<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 7. 함수형 엔드포인트 | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="ch06.html">&larr; Chapter 6. 어노테이션 기반 REST API 구현</a>
    <a href="../index.html">목차</a>
    <a href="ch08.html">Chapter 8. MongoDB 리액티브 데이터 접근 심화 &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-7-router-functions">Chapter 7. 함수형 엔드포인트 (Router Functions)</h1>
<p>앞선 Chapter 6에서는 <code>@RestController</code>와 어노테이션 기반으로 REST API를 구현했다. Spring WebFlux는 또 다른 프로그래밍 모델인 <strong>함수형 엔드포인트</strong>를 제공한다. 이번 장에서는 <code>RouterFunction</code>과 <code>HandlerFunction</code>을 사용하여 동일한 API를 함수형 방식으로 구현하고, 두 방식의 차이를 비교한다.</p>
<hr>
<h2 id="71-handlerfunction-routerfunction">7.1 HandlerFunction과 RouterFunction 이해</h2>
<h3 id="711">7.1.1 함수형 엔드포인트의 핵심 구성 요소</h3>
<p>함수형 엔드포인트는 두 가지 핵심 인터페이스로 구성된다.</p>
<table>
<thead>
<tr>
<th>구성 요소</th>
<th>역할</th>
<th>대응하는 어노테이션 방식</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>HandlerFunction</code></td>
<td>요청을 받아 응답을 생성하는 함수</td>
<td><code>@RequestMapping</code> 메서드 본문</td>
</tr>
<tr>
<td><code>RouterFunction</code></td>
<td>요청을 적절한 HandlerFunction으로 라우팅</td>
<td><code>@RequestMapping</code>, <code>@GetMapping</code> 등</td>
</tr>
<tr>
<td><code>ServerRequest</code></td>
<td>불변(immutable) HTTP 요청 객체</td>
<td>메서드 파라미터 (<code>@RequestBody</code>, <code>@PathVariable</code> 등)</td>
</tr>
<tr>
<td><code>ServerResponse</code></td>
<td>HTTP 응답을 빌더 패턴으로 생성</td>
<td>컨트롤러 반환값</td>
</tr>
</tbody>
</table>
<h3 id="712-handlerfunction">7.1.2 HandlerFunction 인터페이스</h3>
<p><code>HandlerFunction&lt;T extends ServerResponse&gt;</code>는 <code>ServerRequest</code>를 받아 <code>Mono&lt;T&gt;</code>를 반환하는 함수형 인터페이스다.</p>
<pre class="highlight"><code class="language-java">@FunctionalInterface
public interface HandlerFunction&lt;T extends ServerResponse&gt; {
    Mono&lt;T&gt; handle(ServerRequest request);
}</code></pre>
<p>개념적으로 보면 <code>Function&lt;ServerRequest, Mono&lt;ServerResponse&gt;&gt;</code>와 동일하다. 이 단순한 시그니처 덕분에 람다로 간결하게 핸들러를 작성할 수 있다.</p>
<pre class="highlight"><code class="language-java">// 람다로 작성한 간단한 핸들러
HandlerFunction&lt;ServerResponse&gt; helloHandler = request -&gt;
    ServerResponse.ok()
        .contentType(MediaType.TEXT_PLAIN)
        .bodyValue("Hello, WebFlux!");</code></pre>
<h3 id="713-routerfunction">7.1.3 RouterFunction 인터페이스</h3>
<p><code>RouterFunction&lt;T extends ServerResponse&gt;</code>는 요청을 분석하여 적절한 <code>HandlerFunction</code>으로 연결하는 역할을 한다.</p>
<pre class="highlight"><code class="language-java">@FunctionalInterface
public interface RouterFunction&lt;T extends ServerResponse&gt; {
    Mono&lt;HandlerFunction&lt;T&gt;&gt; route(ServerRequest request);
}</code></pre>
<p>직접 구현하기보다는 <code>RouterFunctions.route()</code> 헬퍼 메서드를 사용하여 선언적으로 라우팅을 정의한다.</p>
<h3 id="714-serverrequest-serverresponse">7.1.4 ServerRequest와 ServerResponse</h3>
<p><strong>ServerRequest</strong>는 불변 객체로, HTTP 메서드, URI, 헤더, 쿼리 파라미터, 요청 바디에 접근하는 메서드를 제공한다.</p>
<pre class="highlight"><code class="language-java">// ServerRequest 주요 메서드
request.method();                          // HTTP 메서드
request.uri();                             // 전체 URI
request.path();                            // 경로
request.pathVariable("id");               // 경로 변수
request.queryParam("name");               // 쿼리 파라미터 (Optional)
request.headers();                         // 헤더 접근
request.bodyToMono(Product.class);        // 바디를 Mono로 변환
request.bodyToFlux(Product.class);        // 바디를 Flux로 변환</code></pre>
<p><strong>ServerResponse</strong>는 빌더 패턴으로 HTTP 응답을 구성한다.</p>
<pre class="highlight"><code class="language-java">// 200 OK + JSON 바디
ServerResponse.ok()
    .contentType(MediaType.APPLICATION_JSON)
    .bodyValue(product);

// 201 Created + Location 헤더
ServerResponse.created(URI.create("/api/products/" + id))
    .bodyValue(savedProduct);

// 204 No Content
ServerResponse.noContent().build();

// 404 Not Found
ServerResponse.notFound().build();

// Mono/Flux를 바디로 설정
ServerResponse.ok().body(productMono, Product.class);
ServerResponse.ok().body(productFlux, Product.class);</code></pre>
<hr>
<h2 id="72-routerfunction">7.2 RouterFunction으로 라우팅 정의하기</h2>
<h3 id="721">7.2.1 기본 라우팅 정의</h3>
<p><code>RouterFunctions.route()</code>와 <code>RequestPredicates</code>를 조합하여 라우팅 규칙을 정의한다.</p>
<pre class="highlight"><code class="language-java">import static org.springframework.web.reactive.function.server.RouterFunctions.route;
import static org.springframework.web.reactive.function.server.RequestPredicates.*;

@Configuration
public class ProductRouter {

    @Bean
    public RouterFunction&lt;ServerResponse&gt; productRoutes(ProductHandler handler) {
        return route(GET("/api/products"), handler::getAll)
            .andRoute(GET("/api/products/{id}"), handler::getById)
            .andRoute(POST("/api/products"), handler::create)
            .andRoute(PUT("/api/products/{id}"), handler::update)
            .andRoute(DELETE("/api/products/{id}"), handler::delete);
    }
}</code></pre>
<p><code>RequestPredicates</code>는 요청 조건을 표현하는 유틸리티 클래스다. HTTP 메서드, 경로, 콘텐츠 타입 등 다양한 조건을 조합할 수 있다.</p>
<pre class="highlight"><code class="language-java">// 메서드 + 경로
GET("/api/products")
POST("/api/products")

// 경로만
path("/api/products")

// 콘텐츠 타입 조건 추가
POST("/api/products").and(contentType(MediaType.APPLICATION_JSON))

// Accept 헤더 조건
GET("/api/products").and(accept(MediaType.APPLICATION_JSON))

// 조건 결합
method(HttpMethod.GET).and(path("/api/products")).and(accept(MediaType.APPLICATION_JSON))</code></pre>
<h3 id="722-nest">7.2.2 nest()로 라우팅 그룹화</h3>
<p>공통 경로 접두사나 조건을 공유하는 라우트를 <code>nest()</code>로 그룹화하면 중복을 제거하고 가독성을 높일 수 있다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class ProductRouter {

    @Bean
    public RouterFunction&lt;ServerResponse&gt; productRoutes(ProductHandler handler) {
        return nest(path("/api/products"),
            route(GET(""), handler::getAll)
            .andRoute(GET("/{id}"), handler::getById)
            .andRoute(POST("").and(contentType(MediaType.APPLICATION_JSON)), handler::create)
            .andRoute(PUT("/{id}").and(contentType(MediaType.APPLICATION_JSON)), handler::update)
            .andRoute(DELETE("/{id}"), handler::delete)
        );
    }
}</code></pre>
<p>여러 리소스를 하나의 설정 클래스에서 관리할 수도 있다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class AppRouter {

    @Bean
    public RouterFunction&lt;ServerResponse&gt; routes(
            ProductHandler productHandler,
            CategoryHandler categoryHandler,
            OrderHandler orderHandler) {

        return nest(path("/api"),
            nest(path("/products"),
                route(GET(""), productHandler::getAll)
                .andRoute(GET("/{id}"), productHandler::getById)
                .andRoute(POST(""), productHandler::create)
                .andRoute(PUT("/{id}"), productHandler::update)
                .andRoute(DELETE("/{id}"), productHandler::delete)
            )
            .andNest(path("/categories"),
                route(GET(""), categoryHandler::getAll)
                .andRoute(GET("/{id}"), categoryHandler::getById)
                .andRoute(POST(""), categoryHandler::create)
            )
            .andNest(path("/orders"),
                route(GET(""), orderHandler::getAll)
                .andRoute(POST(""), orderHandler::create)
            )
        );
    }
}</code></pre>
<h3 id="723">7.2.3 필터 적용</h3>
<p><code>RouterFunction</code>에 <code>filter()</code>를 적용하여 요청/응답을 가로채는 공통 로직을 추가할 수 있다. 어노테이션 방식의 <code>WebFilter</code>나 <code>HandlerInterceptor</code>에 대응하는 개념이다.</p>
<pre class="highlight"><code class="language-java">@Bean
public RouterFunction&lt;ServerResponse&gt; productRoutes(ProductHandler handler) {
    return nest(path("/api/products"),
        route(GET(""), handler::getAll)
        .andRoute(GET("/{id}"), handler::getById)
        .andRoute(POST(""), handler::create)
    )
    .filter((request, next) -&gt; {
        long startTime = System.currentTimeMillis();
        log.info("Request: {} {}", request.method(), request.path());

        return next.handle(request)
            .doOnSuccess(response -&gt; {
                long duration = System.currentTimeMillis() - startTime;
                log.info("Response: {} ({}ms)", response.statusCode(), duration);
            });
    });
}</code></pre>
<h3 id="724-before-after">7.2.4 before()와 after()</h3>
<p><code>filter()</code> 외에도 <code>before()</code>와 <code>after()</code>로 요청 전/후 처리를 분리할 수 있다.</p>
<pre class="highlight"><code class="language-java">@Bean
public RouterFunction&lt;ServerResponse&gt; productRoutes(ProductHandler handler) {
    return route(GET("/api/products"), handler::getAll)
        .andRoute(POST("/api/products"), handler::create)
        .before(request -&gt; {
            log.info("[Before] {} {}", request.method(), request.path());
            return request;
        })
        .after((request, response) -&gt; {
            log.info("[After] {} -&gt; {}", request.path(), response.statusCode());
            return response;
        });
}</code></pre>
<hr>
<h2 id="73-handlerfunction">7.3 HandlerFunction 구현</h2>
<h3 id="731-handler">7.3.1 Handler 클래스 구조</h3>
<p>실전에서는 핸들러를 별도의 클래스로 분리하여 관리한다. 어노테이션 방식의 컨트롤러에 대응하는 역할을 한다.</p>
<pre class="highlight"><code class="language-java">@Component
@RequiredArgsConstructor
public class ProductHandler {

    private final ProductService productService;

    /**
     * 전체 상품 조회
     */
    public Mono&lt;ServerResponse&gt; getAll(ServerRequest request) {
        Flux&lt;Product&gt; products = productService.findAll();
        return ServerResponse.ok()
            .contentType(MediaType.APPLICATION_JSON)
            .body(products, Product.class);
    }

    /**
     * 단일 상품 조회
     */
    public Mono&lt;ServerResponse&gt; getById(ServerRequest request) {
        String id = request.pathVariable("id");
        return productService.findById(id)
            .flatMap(product -&gt; ServerResponse.ok()
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(product))
            .switchIfEmpty(ServerResponse.notFound().build());
    }

    /**
     * 상품 생성
     */
    public Mono&lt;ServerResponse&gt; create(ServerRequest request) {
        return request.bodyToMono(Product.class)
            .flatMap(productService::save)
            .flatMap(saved -&gt; ServerResponse
                .created(URI.create("/api/products/" + saved.getId()))
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(saved));
    }

    /**
     * 상품 수정
     */
    public Mono&lt;ServerResponse&gt; update(ServerRequest request) {
        String id = request.pathVariable("id");
        return request.bodyToMono(Product.class)
            .flatMap(product -&gt; productService.update(id, product))
            .flatMap(updated -&gt; ServerResponse.ok()
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(updated))
            .switchIfEmpty(ServerResponse.notFound().build());
    }

    /**
     * 상품 삭제
     */
    public Mono&lt;ServerResponse&gt; delete(ServerRequest request) {
        String id = request.pathVariable("id");
        return productService.deleteById(id)
            .then(ServerResponse.noContent().build());
    }
}</code></pre>
<h3 id="732">7.3.2 도메인 모델과 서비스 계층</h3>
<p>핸들러가 사용하는 도메인 모델과 서비스 계층은 어노테이션 방식과 동일하게 재사용할 수 있다.</p>
<pre class="highlight"><code class="language-java">@Document(collection = "products")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Product {

    @Id
    private String id;
    private String name;
    private String description;
    private BigDecimal price;
    private String category;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}</code></pre>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class ProductService {

    private final ReactiveMongoRepository&lt;Product, String&gt; productRepository;

    public Flux&lt;Product&gt; findAll() { return productRepository.findAll(); }
    public Mono&lt;Product&gt; findById(String id) { return productRepository.findById(id); }

    public Mono&lt;Product&gt; save(Product product) {
        product.setCreatedAt(LocalDateTime.now());
        product.setUpdatedAt(LocalDateTime.now());
        return productRepository.save(product);
    }

    public Mono&lt;Product&gt; update(String id, Product product) {
        return productRepository.findById(id)
            .map(existing -&gt; {
                existing.setName(product.getName());
                existing.setPrice(product.getPrice());
                existing.setCategory(product.getCategory());
                existing.setUpdatedAt(LocalDateTime.now());
                return existing;
            })
            .flatMap(productRepository::save);
    }

    public Mono&lt;Void&gt; deleteById(String id) { return productRepository.deleteById(id); }</code></pre>
<h3 id="733">7.3.3 에러 처리가 포함된 핸들러</h3>
<p>실전에서는 검증 실패, 데이터 없음 등 다양한 에러 상황을 핸들러 내에서 처리해야 한다.</p>
<pre class="highlight"><code class="language-java">@Component
@RequiredArgsConstructor
public class ProductHandler {

    private final ProductService productService;
    private final Validator validator;

    public Mono&lt;ServerResponse&gt; create(ServerRequest request) {
        return request.bodyToMono(Product.class)
            .doOnNext(this::validate)
            .flatMap(productService::save)
            .flatMap(saved -&gt; ServerResponse
                .created(URI.create("/api/products/" + saved.getId()))
                .bodyValue(saved))
            .onErrorResume(ValidationException.class, e -&gt;
                ServerResponse.badRequest()
                    .bodyValue(new ErrorResponse("VALIDATION_ERROR", e.getMessage())))
            .onErrorResume(e -&gt;
                ServerResponse.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .bodyValue(new ErrorResponse("INTERNAL_ERROR", "서버 내부 오류가 발생했습니다.")));
    }

    private void validate(Product product) {
        Errors errors = new BeanPropertyBindingResult(product, "product");
        validator.validate(product, errors);
        if (errors.hasErrors()) {
            String message = errors.getFieldErrors().stream()
                .map(e -&gt; e.getField() + ": " + e.getDefaultMessage())
                .collect(Collectors.joining(", "));
            throw new ValidationException(message);
        }
    }
}</code></pre>
<pre class="highlight"><code class="language-java">@Data
@AllArgsConstructor
public class ErrorResponse {
    private String code;
    private String message;
}</code></pre>
<hr>
<h2 id="74">7.4 요청 파라미터 및 바디 처리</h2>
<h3 id="741-path-variable">7.4.1 경로 변수 (Path Variable)</h3>
<p>경로 패턴에 <code>{변수명}</code>으로 선언하고, <code>ServerRequest.pathVariable()</code>로 추출한다.</p>
<pre class="highlight"><code class="language-java">// Router 정의
route(GET("/api/products/{id}"), handler::getById)

// Handler에서 추출
public Mono&lt;ServerResponse&gt; getById(ServerRequest request) {
    String id = request.pathVariable("id");
    return productService.findById(id)
        .flatMap(product -&gt; ServerResponse.ok().bodyValue(product))
        .switchIfEmpty(ServerResponse.notFound().build());
}</code></pre>
<p>여러 경로 변수를 사용하는 경우도 동일하다.</p>
<pre class="highlight"><code class="language-java">// 중첩 리소스 라우팅
route(GET("/api/categories/{categoryId}/products/{productId}"), handler::getProductInCategory)

// Handler
public Mono&lt;ServerResponse&gt; getProductInCategory(ServerRequest request) {
    String categoryId = request.pathVariable("categoryId");
    String productId = request.pathVariable("productId");
    return productService.findByCategoryAndId(categoryId, productId)
        .flatMap(product -&gt; ServerResponse.ok().bodyValue(product))
        .switchIfEmpty(ServerResponse.notFound().build());
}</code></pre>
<h3 id="742-query-parameter">7.4.2 쿼리 파라미터 (Query Parameter)</h3>
<p><code>ServerRequest.queryParam()</code>은 <code>Optional&lt;String&gt;</code>을 반환한다. <code>queryParams()</code>로 전체 파라미터 맵을 얻을 수도 있다.</p>
<pre class="highlight"><code class="language-java">// GET /api/products?category=electronics&amp;minPrice=10000&amp;page=0&amp;size=20
public Mono&lt;ServerResponse&gt; search(ServerRequest request) {
    Optional&lt;String&gt; category = request.queryParam("category");
    Optional&lt;String&gt; minPrice = request.queryParam("minPrice");
    int page = request.queryParam("page")
        .map(Integer::parseInt)
        .orElse(0);
    int size = request.queryParam("size")
        .map(Integer::parseInt)
        .orElse(20);

    Flux&lt;Product&gt; results = productService.search(
        category.orElse(null),
        minPrice.map(BigDecimal::new).orElse(null),
        PageRequest.of(page, size)
    );

    return ServerResponse.ok()
        .contentType(MediaType.APPLICATION_JSON)
        .body(results, Product.class);
}</code></pre>
<h3 id="743-bodytomono-bodytoflux">7.4.3 요청 바디 처리: bodyToMono / bodyToFlux</h3>
<p>단일 객체는 <code>bodyToMono()</code>, 컬렉션은 <code>bodyToFlux()</code>로 역직렬화한다.</p>
<pre class="highlight"><code class="language-java">// 단일 객체 수신
public Mono&lt;ServerResponse&gt; create(ServerRequest request) {
    return request.bodyToMono(Product.class)
        .flatMap(productService::save)
        .flatMap(saved -&gt; ServerResponse.created(
            URI.create("/api/products/" + saved.getId()))
            .bodyValue(saved));
}

// 여러 객체 일괄 수신
public Mono&lt;ServerResponse&gt; createBatch(ServerRequest request) {
    Flux&lt;Product&gt; products = request.bodyToFlux(Product.class);
    return productService.saveAll(products)
        .collectList()
        .flatMap(savedList -&gt; ServerResponse.ok()
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(savedList));
}</code></pre>
<h3 id="744-parameterizedtypereference">7.4.4 ParameterizedTypeReference 활용</h3>
<p>제네릭 타입을 역직렬화할 때는 <code>ParameterizedTypeReference</code>를 사용한다.</p>
<pre class="highlight"><code class="language-java">// Map&lt;String, Object&gt; 형태의 바디 수신
public Mono&lt;ServerResponse&gt; handleDynamic(ServerRequest request) {
    return request.bodyToMono(new ParameterizedTypeReference&lt;Map&lt;String, Object&gt;&gt;() {})
        .flatMap(body -&gt; {
            String name = (String) body.get("name");
            // 동적 처리
            return ServerResponse.ok().bodyValue(Map.of("received", name));
        });
}</code></pre>
<h3 id="745">7.4.5 헤더 및 쿠키 접근</h3>
<pre class="highlight"><code class="language-java">public Mono&lt;ServerResponse&gt; withHeaders(ServerRequest request) {
    // 헤더 접근
    ServerRequest.Headers headers = request.headers();
    List&lt;MediaType&gt; acceptTypes = headers.accept();
    Optional&lt;String&gt; authHeader = headers.firstHeader("Authorization");
    OptionalLong contentLength = headers.contentLength();

    // 쿠키 접근
    MultiValueMap&lt;String, HttpCookie&gt; cookies = request.cookies();
    HttpCookie sessionCookie = cookies.getFirst("SESSION_ID");

    return ServerResponse.ok()
        .bodyValue(Map.of(
            "accept", acceptTypes.toString(),
            "hasAuth", authHeader.isPresent()
        ));
}</code></pre>
<h3 id="746">7.4.6 멀티파트 파일 업로드</h3>
<p>함수형 엔드포인트에서도 멀티파트 요청을 처리할 수 있다.</p>
<pre class="highlight"><code class="language-java">// Router 정의
route(POST("/api/products/{id}/image")
    .and(contentType(MediaType.MULTIPART_FORM_DATA)), handler::uploadImage)</code></pre>
<pre class="highlight"><code class="language-java">// Handler 구현
public Mono&lt;ServerResponse&gt; uploadImage(ServerRequest request) {
    String productId = request.pathVariable("id");

    return request.multipartData()
        .flatMap(parts -&gt; {
            Part filePart = parts.getFirst("file");
            if (filePart instanceof FilePart fp) {
                String filename = fp.filename();
                Path destination = Path.of("/uploads", productId + "_" + filename);
                return fp.transferTo(destination)
                    .then(productService.updateImagePath(productId, destination.toString()))
                    .flatMap(updated -&gt; ServerResponse.ok().bodyValue(updated));
            }
            return ServerResponse.badRequest()
                .bodyValue(new ErrorResponse("INVALID_FILE", "파일이 전송되지 않았습니다."));
        });
}</code></pre>
<p>여러 파트를 개별 처리할 때는 <code>BodyExtractors.toMultipartData()</code>를 사용하여 텍스트 필드(<code>FormFieldPart</code>)와 파일(<code>FilePart</code>)을 각각 추출할 수 있다.</p>
<hr>
<h2 id="75">7.5 어노테이션 방식과 함수형 방식 비교</h2>
<h3 id="751-api">7.5.1 같은 API를 두 방식으로 구현</h3>
<p>동일한 상품 CRUD API를 어노테이션 방식과 함수형 방식으로 구현하여 비교한다.</p>
<p><strong>어노테이션 방식 (@RestController)</strong></p>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/products")
@RequiredArgsConstructor
public class ProductController {

    private final ProductService productService;

    @GetMapping
    public Flux&lt;Product&gt; getAll() {
        return productService.findAll();
    }

    @GetMapping("/{id}")
    public Mono&lt;ResponseEntity&lt;Product&gt;&gt; getById(@PathVariable String id) {
        return productService.findById(id)
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono&lt;Product&gt; create(@Valid @RequestBody Product product) {
        return productService.save(product);
    }

    @PutMapping("/{id}")
    public Mono&lt;ResponseEntity&lt;Product&gt;&gt; update(
            @PathVariable String id,
            @Valid @RequestBody Product product) {
        return productService.update(id, product)
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public Mono&lt;Void&gt; delete(@PathVariable String id) {
        return productService.deleteById(id);
    }
}</code></pre>
<p><strong>함수형 방식 (RouterFunction + HandlerFunction)</strong></p>
<pre class="highlight"><code class="language-java">// Router
@Configuration
public class ProductRouter {

    @Bean
    public RouterFunction&lt;ServerResponse&gt; productRoutes(ProductHandler handler) {
        return nest(path("/api/products"),
            route(GET(""), handler::getAll)
            .andRoute(GET("/{id}"), handler::getById)
            .andRoute(POST("").and(contentType(MediaType.APPLICATION_JSON)),
                      handler::create)
            .andRoute(PUT("/{id}").and(contentType(MediaType.APPLICATION_JSON)),
                      handler::update)
            .andRoute(DELETE("/{id}"), handler::delete)
        );
    }
}

// Handler
@Component
@RequiredArgsConstructor
public class ProductHandler {

    private final ProductService productService;

    public Mono&lt;ServerResponse&gt; getAll(ServerRequest request) {
        return ServerResponse.ok()
            .contentType(MediaType.APPLICATION_JSON)
            .body(productService.findAll(), Product.class);
    }

    public Mono&lt;ServerResponse&gt; getById(ServerRequest request) {
        String id = request.pathVariable("id");
        return productService.findById(id)
            .flatMap(product -&gt; ServerResponse.ok()
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(product))
            .switchIfEmpty(ServerResponse.notFound().build());
    }

    public Mono&lt;ServerResponse&gt; create(ServerRequest request) {
        return request.bodyToMono(Product.class)
            .flatMap(productService::save)
            .flatMap(saved -&gt; ServerResponse
                .created(URI.create("/api/products/" + saved.getId()))
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(saved));
    }

    public Mono&lt;ServerResponse&gt; update(ServerRequest request) {
        String id = request.pathVariable("id");
        return request.bodyToMono(Product.class)
            .flatMap(product -&gt; productService.update(id, product))
            .flatMap(updated -&gt; ServerResponse.ok()
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(updated))
            .switchIfEmpty(ServerResponse.notFound().build());
    }

    public Mono&lt;ServerResponse&gt; delete(ServerRequest request) {
        String id = request.pathVariable("id");
        return productService.deleteById(id)
            .then(ServerResponse.noContent().build());
    }
}</code></pre>
<h3 id="752">7.5.2 핵심 차이점 분석</h3>
<p>두 방식의 주요 차이를 항목별로 비교한다.</p>
<p><strong>라우팅 정의</strong>: 어노테이션 방식은 라우팅 정보(<code>@GetMapping</code>)와 비즈니스 로직이 한 곳에 위치한다. 함수형 방식은 Router(라우팅 정의)와 Handler(로직)가 물리적으로 분리된다.</p>
<p><strong>파라미터 바인딩</strong>: 어노테이션 방식은 <code>@PathVariable</code>, <code>@RequestBody</code> 등으로 자동 바인딩된다. 함수형 방식은 <code>ServerRequest</code>의 <code>pathVariable()</code>, <code>bodyToMono()</code> 등을 직접 호출한다.</p>
<p><strong>검증 처리</strong>: 어노테이션 방식은 <code>@Valid</code>로 자동 검증된다. 함수형 방식은 <code>Validator</code>를 수동 호출해야 한다.</p>
<h3 id="753">7.5.3 장단점 비교표</h3>
<table>
<thead>
<tr>
<th>비교 항목</th>
<th>어노테이션 방식</th>
<th>함수형 방식</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>진입 장벽</strong></td>
<td>낮음 (Spring MVC 경험 활용)</td>
<td>중간 (함수형 개념 필요)</td>
</tr>
<tr>
<td><strong>코드 간결성</strong></td>
<td>간결 (어노테이션이 많은 것을 대행)</td>
<td>상대적으로 장황</td>
</tr>
<tr>
<td><strong>라우팅-로직 분리</strong></td>
<td>같은 클래스에 혼재</td>
<td>명확히 분리</td>
</tr>
<tr>
<td><strong>파라미터 바인딩</strong></td>
<td>자동 (<code>@PathVariable</code>, <code>@RequestBody</code>)</td>
<td>수동 (<code>pathVariable()</code>, <code>bodyToMono()</code>)</td>
</tr>
<tr>
<td><strong>검증 통합</strong></td>
<td><code>@Valid</code> 자동 적용</td>
<td><code>Validator</code> 수동 호출</td>
</tr>
<tr>
<td><strong>테스트 용이성</strong></td>
<td><code>@WebFluxTest</code> 슬라이스 테스트</td>
<td>순수 함수 단위 테스트 용이</td>
</tr>
<tr>
<td><strong>타입 안전성</strong></td>
<td>런타임 리플렉션 의존</td>
<td>컴파일 타임 검증</td>
</tr>
<tr>
<td><strong>라우팅 유연성</strong></td>
<td>고정된 어노테이션 규칙</td>
<td>프로그래밍 방식으로 동적 라우팅 가능</td>
</tr>
<tr>
<td><strong>필터 적용</strong></td>
<td><code>WebFilter</code> (전역)</td>
<td><code>filter()</code> 메서드로 라우트별 적용 가능</td>
</tr>
<tr>
<td><strong>OpenAPI 문서화</strong></td>
<td>SpringDoc 자동 감지</td>
<td>추가 설정 필요</td>
</tr>
</tbody>
</table>
<h3 id="754">7.5.4 실무 선택 기준</h3>
<p>두 방식은 동일한 <code>DispatcherHandler</code>에서 처리되므로 <strong>같은 애플리케이션에 공존할 수 있다</strong>. 실무에서는 상황에 따라 적절한 방식을 선택하면 된다.</p>
<p><strong>어노테이션 방식이 적합한 경우</strong></p>
<ul>
<li>팀에 Spring MVC 경험자가 많을 때</li>
<li>CRUD 위주의 표준적인 REST API</li>
<li><code>@Valid</code>, <code>@ControllerAdvice</code> 등 Spring의 자동 지원이 필요할 때</li>
<li>Swagger/OpenAPI 문서 자동 생성이 중요할 때</li>
</ul>
<p><strong>함수형 방식이 적합한 경우</strong></p>
<ul>
<li>라우팅 로직이 동적으로 변해야 할 때</li>
<li>라우팅 정의와 비즈니스 로직을 명확히 분리하고 싶을 때</li>
<li>특정 라우트 그룹에만 필터를 적용해야 할 때</li>
<li>경량 마이크로서비스에서 불필요한 어노테이션 처리를 줄이고 싶을 때</li>
<li>함수형 프로그래밍 스타일을 선호하는 팀</li>
</ul>
<p><strong>혼합 사용 예시</strong></p>
<pre class="highlight"><code class="language-java">// 어노테이션 방식 — 일반 CRUD API
@RestController
@RequestMapping("/api/users")
public class UserController {
    // 표준적인 CRUD 엔드포인트
}

// 함수형 방식 — 동적 라우팅이 필요한 특수 API
@Configuration
public class WebhookRouter {

    @Bean
    public RouterFunction&lt;ServerResponse&gt; webhookRoutes(WebhookHandler handler) {
        return nest(path("/api/webhooks"),
            route(POST("/{provider}"), handler::handle)
            .filter((request, next) -&gt; {
                // 웹훅 제공자별 서명 검증
                String provider = request.pathVariable("provider");
                return verifySignature(request, provider)
                    .flatMap(valid -&gt; valid
                        ? next.handle(request)
                        : ServerResponse.status(HttpStatus.UNAUTHORIZED).build());
            })
        );
    }
}</code></pre>
<h3 id="755-openapi">7.5.5 함수형 엔드포인트에서 OpenAPI 문서화</h3>
<p>함수형 방식에서는 SpringDoc이 라우팅 정보를 자동 감지하지 못한다. <code>@RouterOperation</code>으로 API 명세를 수동 추가해야 한다.</p>
<pre class="highlight"><code class="language-java">@Bean
@RouterOperations({
    @RouterOperation(path = "/api/products", method = RequestMethod.GET,
        beanClass = ProductHandler.class, beanMethod = "getAll",
        operation = @Operation(operationId = "getAllProducts",
            summary = "전체 상품 조회")),
    @RouterOperation(path = "/api/products/{id}", method = RequestMethod.GET,
        beanClass = ProductHandler.class, beanMethod = "getById",
        operation = @Operation(operationId = "getProductById",
            summary = "상품 단건 조회",
            parameters = @Parameter(name = "id", in = ParameterIn.PATH, required = true)))
})
public RouterFunction&lt;ServerResponse&gt; productRoutes(ProductHandler handler) {
    return nest(path("/api/products"),
        route(GET(""), handler::getAll)
        .andRoute(GET("/{id}"), handler::getById)
    );
}</code></pre>
<hr>
<h2 id="_1">요약</h2>
<p>이번 장에서 다룬 핵심 내용을 정리한다.</p>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 내용</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>HandlerFunction</strong></td>
<td><code>ServerRequest -&gt; Mono&lt;ServerResponse&gt;</code> 시그니처의 함수형 인터페이스</td>
</tr>
<tr>
<td><strong>RouterFunction</strong></td>
<td><code>route()</code>, <code>nest()</code>로 선언적 라우팅 정의, <code>filter()</code>로 공통 로직 적용</td>
</tr>
<tr>
<td><strong>ServerRequest</strong></td>
<td>불변 요청 객체, <code>pathVariable()</code>, <code>queryParam()</code>, <code>bodyToMono()</code> 등으로 데이터 추출</td>
</tr>
<tr>
<td><strong>ServerResponse</strong></td>
<td>빌더 패턴으로 상태 코드, 헤더, 바디를 설정하여 응답 생성</td>
</tr>
<tr>
<td><strong>멀티파트 처리</strong></td>
<td><code>multipartData()</code>, <code>BodyExtractors.toMultipartData()</code>로 파일 업로드 처리</td>
</tr>
<tr>
<td><strong>어노테이션 vs 함수형</strong></td>
<td>같은 애플리케이션에 공존 가능, 상황에 따라 적합한 방식 선택</td>
</tr>
</tbody>
</table>
<p>다음 장에서는 MongoDB 리액티브 데이터 접근을 심화하여, <code>ReactiveMongoTemplate</code>, 커스텀 쿼리, Aggregation Pipeline, 변경 스트림 등을 다룬다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>