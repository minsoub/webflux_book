<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 6. 어노테이션 기반 REST API 구현 | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="ch05.html">&larr; Chapter 5. 개발 환경 구성</a>
    <a href="../index.html">목차</a>
    <a href="ch07.html">Chapter 7. 함수형 엔드포인트 &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-6-rest-api">Chapter 6. 어노테이션 기반 REST API 구현</h1>
<p>Chapter 5에서 프로젝트 구조와 개발 환경을 갖추었다. 이번 장에서는 본격적으로 도메인 모델을 정의하고, 리포지토리, 서비스, 컨트롤러 계층을 순서대로 구축하여 완전한 CRUD REST API를 완성한다. 모든 계층에서 <code>Mono</code>와 <code>Flux</code>를 반환하며, 요청부터 응답, 데이터베이스 접근까지 논블로킹으로 동작하는 리액티브 파이프라인을 구성한다.</p>
<hr>
<h2 id="61-document">6.1 도메인 모델(Document) 정의</h2>
<h3 id="611">6.1.1 주요 어노테이션 정리</h3>
<p>Spring Data MongoDB는 Java 객체를 MongoDB 도큐먼트에 매핑하기 위한 다양한 어노테이션을 제공한다.</p>
<table>
<thead>
<tr>
<th>어노테이션</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@Document</code></td>
<td>클래스를 MongoDB 컬렉션에 매핑한다. <code>collection</code> 속성으로 컬렉션 이름을 지정한다.</td>
</tr>
<tr>
<td><code>@Id</code></td>
<td>필드를 MongoDB의 <code>_id</code>에 매핑한다. <code>String</code> 타입이면 자동으로 <code>ObjectId</code>가 생성된다.</td>
</tr>
<tr>
<td><code>@Field</code></td>
<td>필드명을 MongoDB 도큐먼트의 키 이름과 다르게 매핑할 때 사용한다.</td>
</tr>
<tr>
<td><code>@Indexed</code></td>
<td>해당 필드에 인덱스를 생성한다. <code>unique</code>, <code>direction</code> 등의 속성을 지원한다.</td>
</tr>
<tr>
<td><code>@CreatedDate</code></td>
<td>도큐먼트 최초 저장 시 자동으로 현재 시각을 기록한다.</td>
</tr>
<tr>
<td><code>@LastModifiedDate</code></td>
<td>도큐먼트 수정 시 자동으로 현재 시각을 갱신한다.</td>
</tr>
<tr>
<td><code>@Version</code></td>
<td>낙관적 잠금(Optimistic Locking)을 위한 버전 필드를 지정한다.</td>
</tr>
<tr>
<td><code>@Transient</code></td>
<td>해당 필드를 MongoDB에 저장하지 않는다.</td>
</tr>
</tbody>
</table>
<h3 id="612-user">6.1.2 User 도메인 모델</h3>
<pre class="highlight"><code class="language-java">package com.example.webfluxdemo.domain;

import lombok.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.annotation.Version;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.mapping.Field;

import java.time.LocalDateTime;

@Document(collection = "users")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Builder
@ToString
public class User {

    @Id
    private String id;

    @Field("name")
    private String name;

    @Indexed(unique = true)
    private String email;

    private String password;

    @Builder.Default
    private String role = "USER";

    @CreatedDate
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;

    @Version
    private Long version;

    public void updateProfile(String name, String email) {
        this.name = name;
        this.email = email;
    }

    public void changePassword(String password) {
        this.password = password;
    }
}</code></pre>
<p><code>@Version</code> 필드를 추가하면 동시 수정 시 <code>OptimisticLockingFailureException</code>이 발생하여 데이터 정합성을 보호한다.</p>
<h3 id="613-post">6.1.3 Post 도메인 모델</h3>
<pre class="highlight"><code class="language-java">package com.example.webfluxdemo.domain;

import lombok.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.mongodb.core.index.CompoundIndex;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Document(collection = "posts")
@CompoundIndex(name = "author_created", def = "{'authorId': 1, 'createdAt': -1}")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Builder
@ToString
public class Post {

    @Id
    private String id;

    private String title;

    private String content;

    @Indexed
    private String authorId;

    @Builder.Default
    private List&lt;String&gt; tags = new ArrayList&lt;&gt;();

    @Builder.Default
    private int viewCount = 0;

    @CreatedDate
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;

    public void update(String title, String content, List&lt;String&gt; tags) {
        this.title = title;
        this.content = content;
        this.tags = tags != null ? tags : this.tags;
    }

    public void incrementViewCount() {
        this.viewCount++;
    }
}</code></pre>
<p><code>@CompoundIndex</code>로 <code>authorId</code> 오름차순 + <code>createdAt</code> 내림차순 복합 인덱스를 생성하여, 특정 작성자의 최신 게시글 조회 쿼리를 최적화한다.</p>
<h3 id="614-auditing">6.1.4 Auditing 설정</h3>
<p><code>@CreatedDate</code>, <code>@LastModifiedDate</code>가 동작하려면 Auditing 기능을 활성화해야 한다.</p>
<pre class="highlight"><code class="language-java">package com.example.webfluxdemo.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.mongodb.config.EnableReactiveMongoAuditing;

@Configuration
@EnableReactiveMongoAuditing
public class MongoConfig {
}</code></pre>
<p>리액티브 환경에서는 반드시 <code>EnableReactiveMongoAuditing</code>을 사용해야 하며, 일반 <code>@EnableMongoAuditing</code>은 동작하지 않는다. 자동 인덱스 생성을 활성화하려면 <code>application.yml</code>에 다음 설정을 추가한다.</p>
<pre class="highlight"><code class="language-yaml">spring:
  data:
    mongodb:
      uri: mongodb://admin:secret1234@localhost:27017/webflux_demo?authSource=admin
      auto-index-creation: true</code></pre>
<blockquote>
<p><strong>주의</strong>: <code>auto-index-creation</code>은 개발 환경에서는 편리하지만, 운영 환경에서는 수동 인덱스 관리를 권장한다. 대규모 컬렉션에서 인덱스 자동 생성은 서비스 시작 시간을 지연시킬 수 있다.</p>
</blockquote>
<hr>
<h2 id="62-reactivemongorepository">6.2 ReactiveMongoRepository 활용</h2>
<h3 id="621-userrepository">6.2.1 UserRepository 정의</h3>
<pre class="highlight"><code class="language-java">public interface UserRepository extends ReactiveMongoRepository&lt;User, String&gt; {

    // 메서드 이름 기반 쿼리 자동 생성
    Mono&lt;User&gt; findByEmail(String email);

    Flux&lt;User&gt; findByName(String name);

    Flux&lt;User&gt; findByRole(String role);

    Mono&lt;Boolean&gt; existsByEmail(String email);

    // @Query: MongoDB JSON 쿼리 직접 작성
    @Query("{ 'name': { $regex: ?0, $options: 'i' } }")
    Flux&lt;User&gt; searchByName(String keyword);

    // 특정 필드만 조회 (fields 속성)
    @Query(value = "{ 'role': ?0 }", fields = "{ 'name': 1, 'email': 1 }")
    Flux&lt;User&gt; findNameAndEmailByRole(String role);
}</code></pre>
<p><code>ReactiveMongoRepository&lt;T, ID&gt;</code>는 <code>ReactiveCrudRepository</code>를 확장하며, 다음 메서드를 기본으로 제공한다.</p>
<table>
<thead>
<tr>
<th>메서드</th>
<th>반환 타입</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>save(T entity)</code></td>
<td><code>Mono&lt;T&gt;</code></td>
<td>삽입 또는 수정</td>
</tr>
<tr>
<td><code>findById(ID id)</code></td>
<td><code>Mono&lt;T&gt;</code></td>
<td>ID로 조회</td>
</tr>
<tr>
<td><code>findAll()</code></td>
<td><code>Flux&lt;T&gt;</code></td>
<td>전체 조회</td>
</tr>
<tr>
<td><code>deleteById(ID id)</code></td>
<td><code>Mono&lt;Void&gt;</code></td>
<td>ID로 삭제</td>
</tr>
<tr>
<td><code>count()</code></td>
<td><code>Mono&lt;Long&gt;</code></td>
<td>전체 개수</td>
</tr>
<tr>
<td><code>existsById(ID id)</code></td>
<td><code>Mono&lt;Boolean&gt;</code></td>
<td>존재 여부 확인</td>
</tr>
</tbody>
</table>
<h3 id="622-postrepository">6.2.2 PostRepository 정의</h3>
<pre class="highlight"><code class="language-java">public interface PostRepository extends ReactiveMongoRepository&lt;Post, String&gt; {

    Flux&lt;Post&gt; findByAuthorId(String authorId);

    Flux&lt;Post&gt; findByTagsContaining(String tag);

    Flux&lt;Post&gt; findByTitleContainingIgnoreCase(String keyword);

    // 페이징: Pageable 파라미터를 전달
    Flux&lt;Post&gt; findByAuthorId(String authorId, Pageable pageable);

    Mono&lt;Long&gt; countByAuthorId(String authorId);

    // 복잡한 쿼리: 제목 또는 내용에 키워드가 포함된 게시글 검색
    @Query("{ $or: [ " +
           "  { 'title': { $regex: ?0, $options: 'i' } }, " +
           "  { 'content': { $regex: ?0, $options: 'i' } } " +
           "] }")
    Flux&lt;Post&gt; searchByKeyword(String keyword);

    // 정렬: 메서드 이름에 OrderBy 포함
    Flux&lt;Post&gt; findByAuthorIdOrderByCreatedAtDesc(String authorId);
}</code></pre>
<h3 id="623">6.2.3 쿼리 메서드 이름 규칙</h3>
<p>Spring Data는 메서드 이름을 파싱하여 쿼리를 자동 생성한다. 주요 키워드:</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>예시</th>
<th>생성 쿼리</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Is</code> / <code>Equals</code></td>
<td><code>findByName(String)</code></td>
<td><code>{ 'name': ?0 }</code></td>
</tr>
<tr>
<td><code>Between</code></td>
<td><code>findByAgeBetween(int, int)</code></td>
<td><code>{ 'age': { $gte: ?0, $lte: ?1 } }</code></td>
</tr>
<tr>
<td><code>Containing</code></td>
<td><code>findByTitleContaining(String)</code></td>
<td><code>{ 'title': { $regex: ?0 } }</code></td>
</tr>
<tr>
<td><code>In</code></td>
<td><code>findByRoleIn(List)</code></td>
<td><code>{ 'role': { $in: ?0 } }</code></td>
</tr>
<tr>
<td><code>OrderBy</code></td>
<td><code>findByAuthorIdOrderByCreatedAtDesc</code></td>
<td>정렬 추가</td>
</tr>
<tr>
<td><code>IgnoreCase</code></td>
<td><code>findByNameIgnoreCase(String)</code></td>
<td>대소문자 무시</td>
</tr>
</tbody>
</table>
<h3 id="624">6.2.4 페이징 처리</h3>
<p>리액티브 환경에서의 페이징은 <code>Pageable</code>을 파라미터로 전달하고, 별도로 총 개수를 조회한다.</p>
<pre class="highlight"><code class="language-java">import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;

// 0번째 페이지, 10개씩, 생성일 내림차순
Pageable pageable = PageRequest.of(0, 10, Sort.by(Sort.Direction.DESC, "createdAt"));

Flux&lt;Post&gt; posts = postRepository.findByAuthorId("user123", pageable);
Mono&lt;Long&gt; totalCount = postRepository.countByAuthorId("user123");</code></pre>
<blockquote>
<p><strong>참고</strong>: Spring Data Reactive에는 <code>Page&lt;T&gt;</code> 반환 타입이 없다. <code>Page</code>는 전체 개수를 동기적으로 계산해야 하므로 리액티브 모델과 맞지 않기 때문이다. 대신 <code>Flux&lt;T&gt;</code>와 <code>Mono&lt;Long&gt;</code>을 조합하여 페이징 정보를 구성한다.</p>
</blockquote>
<hr>
<h2 id="63">6.3 서비스 계층 구현</h2>
<h3 id="631">6.3.1 커스텀 예외 정의</h3>
<p>먼저 서비스 계층에서 사용할 커스텀 예외를 정의한다.</p>
<pre class="highlight"><code class="language-java">@Getter
public class ResourceNotFoundException extends RuntimeException {
    private final String resourceName;
    private final String fieldName;
    private final String fieldValue;

    public ResourceNotFoundException(String resourceName, String fieldName,
                                     String fieldValue) {
        super(String.format("%s not found with %s: '%s'",
                resourceName, fieldName, fieldValue));
        this.resourceName = resourceName;
        this.fieldName = fieldName;
        this.fieldValue = fieldValue;
    }
}

public class DuplicateResourceException extends RuntimeException {
    public DuplicateResourceException(String message) { super(message); }
}</code></pre>
<h3 id="632-userservice">6.3.2 UserService 구현체</h3>
<p>인터페이스에서 <code>Mono&lt;User&gt; createUser(User)</code>, <code>Mono&lt;User&gt; getUserById(String)</code>, <code>Flux&lt;User&gt; getAllUsers()</code> 등의 CRUD 메서드를 정의하고, 구현체를 작성한다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
@Slf4j
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;

    @Override
    public Mono&lt;User&gt; createUser(User user) {
        return userRepository.existsByEmail(user.getEmail())
                .flatMap(exists -&gt; {
                    if (exists) {
                        return Mono.error(new DuplicateResourceException(
                                "Email already exists: " + user.getEmail()));
                    }
                    return userRepository.save(user);
                })
                .doOnSuccess(saved -&gt; log.info("User created: {}", saved.getId()));
    }

    @Override
    public Mono&lt;User&gt; getUserById(String id) {
        return userRepository.findById(id)
                .switchIfEmpty(Mono.error(
                        new ResourceNotFoundException("User", "id", id)));
    }

    @Override
    public Flux&lt;User&gt; getAllUsers() { return userRepository.findAll(); }

    @Override
    public Flux&lt;User&gt; searchUsers(String keyword) {
        return userRepository.searchByName(keyword);
    }

    @Override
    public Mono&lt;User&gt; updateUser(String id, User user) {
        return userRepository.findById(id)
                .switchIfEmpty(Mono.error(
                        new ResourceNotFoundException("User", "id", id)))
                .flatMap(existingUser -&gt; {
                    existingUser.updateProfile(user.getName(), user.getEmail());
                    return userRepository.save(existingUser);
                })
                .doOnSuccess(updated -&gt; log.info("User updated: {}", updated.getId()));
    }

    @Override
    public Mono&lt;Void&gt; deleteUser(String id) {
        return userRepository.findById(id)
                .switchIfEmpty(Mono.error(
                        new ResourceNotFoundException("User", "id", id)))
                .flatMap(userRepository::delete)
                .doOnSuccess(v -&gt; log.info("User deleted: {}", id));
    }
}</code></pre>
<p>핵심 패턴: <code>switchIfEmpty</code>는 리액티브에서 <code>null</code> 검사를 대체하고, <code>flatMap</code>은 비동기 연산을 체이닝하며, <code>doOnSuccess</code>는 로깅 등 사이드 이펙트를 수행한다.</p>
<h3 id="633-postservice">6.3.3 PostService 구현체</h3>
<p><code>PostService</code>도 동일한 패턴을 따른다. 핵심 메서드만 발췌한다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
@Slf4j
public class PostService {

    private final PostRepository postRepository;

    public Mono&lt;Post&gt; createPost(Post post) {
        return postRepository.save(post)
                .doOnSuccess(saved -&gt; log.info("Post created: {}", saved.getId()));
    }

    public Mono&lt;Post&gt; getPostById(String id) {
        return postRepository.findById(id)
                .switchIfEmpty(Mono.error(
                        new ResourceNotFoundException("Post", "id", id)));
    }

    public Flux&lt;Post&gt; getPostsByAuthor(String authorId, int page, int size) {
        PageRequest pageable = PageRequest.of(page, size,
                Sort.by(Sort.Direction.DESC, "createdAt"));
        return postRepository.findByAuthorId(authorId, pageable);
    }

    public Mono&lt;Long&gt; countPostsByAuthor(String authorId) { return postRepository.countByAuthorId(authorId); }

    public Mono&lt;Post&gt; updatePost(String id, Post post) {
        return postRepository.findById(id)
                .switchIfEmpty(Mono.error(
                        new ResourceNotFoundException("Post", "id", id)))
                .flatMap(existing -&gt; {
                    existing.update(post.getTitle(), post.getContent(), post.getTags());
                    return postRepository.save(existing);
                });
    }

    public Mono&lt;Void&gt; deletePost(String id) {
        return postRepository.findById(id)
                .switchIfEmpty(Mono.error(
                        new ResourceNotFoundException("Post", "id", id)))
                .flatMap(postRepository::delete);
    }
}</code></pre>
<hr>
<h2 id="64-restcontroller-crud-api">6.4 @RestController로 CRUD API 만들기</h2>
<h3 id="641-usercontroller">6.4.1 UserController</h3>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono&lt;UserResponse&gt; createUser(@RequestBody CreateUserRequest request) {
        User user = User.builder()
                .name(request.name())
                .email(request.email())
                .password(request.password())
                .build();
        return userService.createUser(user)
                .map(UserResponse::from);
    }

    @GetMapping("/{id}")
    public Mono&lt;ResponseEntity&lt;UserResponse&gt;&gt; getUserById(@PathVariable String id) {
        return userService.getUserById(id)
                .map(UserResponse::from)
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping
    public Flux&lt;UserResponse&gt; getAllUsers() {
        return userService.getAllUsers()
                .map(UserResponse::from);
    }

    @GetMapping("/search")
    public Flux&lt;UserResponse&gt; searchUsers(@RequestParam String keyword) {
        return userService.searchUsers(keyword)
                .map(UserResponse::from);
    }

    @PutMapping("/{id}")
    public Mono&lt;ResponseEntity&lt;UserResponse&gt;&gt; updateUser(
            @PathVariable String id,
            @RequestBody UpdateUserRequest request) {
        User user = User.builder()
                .name(request.name())
                .email(request.email())
                .build();
        return userService.updateUser(id, user)
                .map(UserResponse::from)
                .map(ResponseEntity::ok);
    }

    @DeleteMapping("/{id}")
    public Mono&lt;ResponseEntity&lt;Void&gt;&gt; deleteUser(@PathVariable String id) {
        return userService.deleteUser(id)
                .then(Mono.just(ResponseEntity.noContent().&lt;Void&gt;build()));
    }
}</code></pre>
<p>컨트롤러의 핵심 패턴은 다음과 같다.</p>
<ul>
<li><strong><code>@ResponseStatus</code></strong>: <code>ResponseEntity</code> 없이 상태 코드를 간편하게 지정한다.</li>
<li><strong><code>ResponseEntity</code>를 <code>Mono</code>로 감싸기</strong>: <code>map(ResponseEntity::ok)</code>로 200 응답, <code>defaultIfEmpty(ResponseEntity.notFound().build())</code>로 404를 반환한다.</li>
<li><strong><code>then()</code></strong>: <code>Mono&lt;Void&gt;</code> 완료 후 새로운 값을 발행한다. 삭제 후 204 응답에 활용한다.</li>
</ul>
<h3 id="642-postcontroller">6.4.2 PostController</h3>
<p><code>PostController</code>는 <code>UserController</code>와 동일한 패턴을 따른다. 페이징 조회 부분만 발췌한다.</p>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/posts")
@RequiredArgsConstructor
public class PostController {

    private final PostService postService;

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono&lt;PostResponse&gt; createPost(@RequestBody CreatePostRequest request) {
        Post post = Post.builder()
                .title(request.title())
                .content(request.content())
                .authorId(request.authorId())
                .tags(request.tags())
                .build();
        return postService.createPost(post).map(PostResponse::from);
    }

    @GetMapping("/{id}")
    public Mono&lt;ResponseEntity&lt;PostResponse&gt;&gt; getPostById(@PathVariable String id) {
        return postService.getPostById(id)
                .map(PostResponse::from)
                .map(ResponseEntity::ok);
    }

    @GetMapping("/author/{authorId}")
    public Flux&lt;PostResponse&gt; getPostsByAuthor(
            @PathVariable String authorId,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        return postService.getPostsByAuthor(authorId, page, size)
                .map(PostResponse::from);
    }

    @PutMapping("/{id}")
    public Mono&lt;ResponseEntity&lt;PostResponse&gt;&gt; updatePost(
            @PathVariable String id, @RequestBody UpdatePostRequest request) {
        Post post = Post.builder()
                .title(request.title()).content(request.content())
                .tags(request.tags()).build();
        return postService.updatePost(id, post)
                .map(PostResponse::from).map(ResponseEntity::ok);
    }

    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public Mono&lt;Void&gt; deletePost(@PathVariable String id) {
        return postService.deletePost(id);
    }
}</code></pre>
<h3 id="643-api">6.4.3 완성된 API 엔드포인트 정리</h3>
<table>
<thead>
<tr>
<th>메서드</th>
<th>URI</th>
<th>상태 코드</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>POST</code></td>
<td><code>/api/users</code></td>
<td>201</td>
</tr>
<tr>
<td><code>GET</code></td>
<td><code>/api/users</code>, <code>/api/users/{id}</code>, <code>/api/users/search?keyword=</code></td>
<td>200</td>
</tr>
<tr>
<td><code>PUT</code></td>
<td><code>/api/users/{id}</code></td>
<td>200</td>
</tr>
<tr>
<td><code>DELETE</code></td>
<td><code>/api/users/{id}</code></td>
<td>204</td>
</tr>
<tr>
<td><code>POST</code></td>
<td><code>/api/posts</code></td>
<td>201</td>
</tr>
<tr>
<td><code>GET</code></td>
<td><code>/api/posts</code>, <code>/api/posts/{id}</code>, <code>/api/posts/author/{authorId}?page=&amp;size=</code></td>
<td>200</td>
</tr>
<tr>
<td><code>PUT</code></td>
<td><code>/api/posts/{id}</code></td>
<td>200</td>
</tr>
<tr>
<td><code>DELETE</code></td>
<td><code>/api/posts/{id}</code></td>
<td>204</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="65-dto">6.5 요청/응답 DTO 설계</h2>
<h3 id="651-java-record-dto">6.5.1 Java record를 활용한 DTO</h3>
<p>Java 16부터 도입된 <code>record</code> 클래스는 불변 데이터 캐리어에 적합하다. 생성자, <code>equals()</code>, <code>hashCode()</code>, <code>toString()</code>을 자동으로 생성하므로 DTO로 사용하기에 이상적이다.</p>
<p><strong>User 관련 DTO</strong></p>
<pre class="highlight"><code class="language-java">public record CreateUserRequest(String name, String email, String password) {}

public record UpdateUserRequest(String name, String email) {}

public record UserResponse(
        String id, String name, String email, String role,
        LocalDateTime createdAt, LocalDateTime updatedAt
) {
    // 도메인 -&gt; DTO 변환 정적 팩토리 메서드
    public static UserResponse from(User user) {
        return new UserResponse(user.getId(), user.getName(), user.getEmail(),
                user.getRole(), user.getCreatedAt(), user.getUpdatedAt());
    }
}</code></pre>
<p><strong>Post 관련 DTO</strong></p>
<p>Post DTO도 동일한 패턴이다. <code>PostResponse</code>의 <code>from()</code> 정적 팩토리 메서드만 발췌한다.</p>
<pre class="highlight"><code class="language-java">public record CreatePostRequest(String title, String content,
                                 String authorId, List&lt;String&gt; tags) {}

public record UpdatePostRequest(String title, String content, List&lt;String&gt; tags) {}

public record PostResponse(
        String id, String title, String content, String authorId,
        List&lt;String&gt; tags, int viewCount,
        LocalDateTime createdAt, LocalDateTime updatedAt
) {
    public static PostResponse from(Post post) {
        return new PostResponse(
                post.getId(), post.getTitle(), post.getContent(),
                post.getAuthorId(), post.getTags(), post.getViewCount(),
                post.getCreatedAt(), post.getUpdatedAt());
    }
}</code></pre>
<h3 id="652-dto">6.5.2 DTO 사용의 이점</h3>
<p>도메인 모델을 직접 API 응답으로 노출하지 않고 DTO를 사용하는 이유: (1) <code>password</code>, <code>version</code> 등 내부 필드 노출 방지(<strong>보안</strong>), (2) 도메인 변경이 API 계약에 영향을 주지 않음(<strong>안정성</strong>), (3) 용도별 다른 DTO 제공 가능(<strong>유연성</strong>), (4) Bean Validation 적용 가능(<strong>검증</strong>, Chapter 9에서 상세히 다룬다).</p>
<h3 id="653-dto">6.5.3 페이징 응답 DTO</h3>
<p>페이징 결과를 감싸는 범용 DTO를 만들면 클라이언트에 페이징 메타 정보를 함께 전달할 수 있다.</p>
<pre class="highlight"><code class="language-java">package com.example.webfluxdemo.dto;

import java.util.List;

public record PageResponse&lt;T&gt;(
        List&lt;T&gt; content,
        int page,
        int size,
        long totalElements,
        int totalPages
) {
    public static &lt;T&gt; PageResponse&lt;T&gt; of(List&lt;T&gt; content, int page,
                                          int size, long totalElements) {
        int totalPages = (int) Math.ceil((double) totalElements / size);
        return new PageResponse&lt;&gt;(content, page, size, totalElements, totalPages);
    }
}</code></pre>
<p>컨트롤러에서 페이징 응답을 구성하는 예시:</p>
<pre class="highlight"><code class="language-java">@GetMapping("/author/{authorId}")
public Mono&lt;PageResponse&lt;PostResponse&gt;&gt; getPostsByAuthorPaged(
        @PathVariable String authorId,
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "10") int size) {

    Mono&lt;List&lt;PostResponse&gt;&gt; contentMono = postService
            .getPostsByAuthor(authorId, page, size)
            .map(PostResponse::from)
            .collectList();

    Mono&lt;Long&gt; countMono = postService.countPostsByAuthor(authorId);

    return Mono.zip(contentMono, countMono)
            .map(tuple -&gt; PageResponse.of(tuple.getT1(), page, size, tuple.getT2()));
}</code></pre>
<p><code>Mono.zip</code>으로 콘텐츠 조회와 총 개수 조회를 <strong>동시에</strong> 실행하고, 두 결과를 <code>PageResponse</code>로 조합한다. 리액티브 병렬 처리의 관용적 패턴이다.</p>
<hr>
<h2 id="66-api">6.6 API 테스트</h2>
<p>애플리케이션을 실행한 후, 다양한 도구로 API를 호출하여 동작을 검증한다.</p>
<pre class="highlight"><code class="language-bash"># 애플리케이션 실행
./gradlew bootRun</code></pre>
<h3 id="661-curl">6.6.1 cURL 테스트</h3>
<p><strong>사용자 생성 (POST)</strong></p>
<pre class="highlight"><code class="language-bash">curl -X POST http://localhost:8080/api/users \
  -H "Content-Type: application/json" \
  -d '{
    "name": "홍길동",
    "email": "hong@example.com",
    "password": "securePass123"
  }'</code></pre>
<p>응답 예시:</p>
<pre class="highlight"><code class="language-json">{
  "id": "65f1a2b3c4d5e6f7a8b9c0d1",
  "name": "홍길동",
  "email": "hong@example.com",
  "role": "USER",
  "createdAt": "2025-06-15T10:30:00",
  "updatedAt": "2025-06-15T10:30:00"
}</code></pre>
<p><strong>사용자 조회 (GET)</strong></p>
<pre class="highlight"><code class="language-bash"># 전체 조회
curl http://localhost:8080/api/users

# 단건 조회
curl http://localhost:8080/api/users/65f1a2b3c4d5e6f7a8b9c0d1</code></pre>
<p><strong>수정 / 삭제 / 게시글</strong></p>
<pre class="highlight"><code class="language-bash"># 사용자 수정
curl -X PUT http://localhost:8080/api/users/65f1a2b3c4d5e6f7a8b9c0d1 \
  -H "Content-Type: application/json" \
  -d '{ "name": "홍길동(수정)", "email": "hong-updated@example.com" }'

# 사용자 삭제
curl -X DELETE http://localhost:8080/api/users/65f1a2b3c4d5e6f7a8b9c0d1 -v

# 게시글 생성
curl -X POST http://localhost:8080/api/posts \
  -H "Content-Type: application/json" \
  -d '{ "title": "WebFlux 첫 글", "content": "리액티브 API 구현",
        "authorId": "65f1a2b3c4d5e6f7a8b9c0d1", "tags": ["spring","webflux"] }'

# 게시글 검색
curl "http://localhost:8080/api/posts/search?keyword=WebFlux"

# 작성자별 페이징 조회
curl "http://localhost:8080/api/posts/author/65f1a2b3c4d5e6f7a8b9c0d1?page=0&amp;size=5"</code></pre>
<h3 id="662-httpie">6.6.2 HTTPie 테스트</h3>
<p>HTTPie는 cURL보다 직관적인 문법을 제공하는 HTTP 클라이언트다.</p>
<pre class="highlight"><code class="language-bash"># 사용자 생성 — JSON 필드를 key=value 형식으로 전달
http POST localhost:8080/api/users \
  name="김철수" email="kim@example.com" password="pass1234"

# 조회
http localhost:8080/api/users

# 게시글 생성 — JSON 배열은 := 연산자로 전달
http POST localhost:8080/api/posts \
  title="HTTPie 테스트" content="HTTPie로 API를 테스트합니다." \
  authorId="65f1a2b3c4d5e6f7a8b9c0d1" tags:='["test", "httpie"]'</code></pre>
<blockquote>
<p><strong>팁</strong>: HTTPie에서 <code>=</code>는 문자열, <code>:=</code>는 JSON 리터럴(숫자, 배열, 객체, boolean)을 전달한다.</p>
</blockquote>
<h3 id="663-intellij-http-client">6.6.3 IntelliJ HTTP Client</h3>
<p>IntelliJ IDEA에 내장된 HTTP Client를 사용하면 <code>.http</code> 파일로 요청을 관리할 수 있다. 프로젝트 루트에 <code>.http</code> 파일을 작성한다.</p>
<pre class="highlight"><code class="language-http">### 사용자 생성
POST http://localhost:8080/api/users
Content-Type: application/json

{
  "name": "이영희",
  "email": "lee@example.com",
  "password": "myPassword456"
}

### 전체 사용자 조회
GET http://localhost:8080/api/users

### 사용자 수정
PUT http://localhost:8080/api/users/{{userId}}
Content-Type: application/json

{
  "name": "이영희(수정)",
  "email": "lee-updated@example.com"
}

### 사용자 삭제
DELETE http://localhost:8080/api/users/{{userId}}</code></pre>
<p><code>{{userId}}</code>와 같은 변수는 <code>http-client.env.json</code> 파일에서 환경별로 관리한다. <code>.http</code> 파일을 Git으로 관리하면 팀원과 API 테스트를 공유할 수 있다는 것이 큰 장점이다.</p>
<hr>
<h2 id="6">6장 정리</h2>
<p>이번 장에서 다룬 핵심 내용을 정리한다.</p>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 요약</th>
</tr>
</thead>
<tbody>
<tr>
<td>도메인 모델</td>
<td><code>@Document</code>, <code>@Id</code>, <code>@Indexed</code>, <code>@CompoundIndex</code>로 도큐먼트 매핑. Auditing으로 생성/수정 시각 자동 관리</td>
</tr>
<tr>
<td>리포지토리</td>
<td><code>ReactiveMongoRepository</code>로 기본 CRUD 자동 제공. 쿼리 메서드 이름 규칙, <code>@Query</code>, 페이징 지원</td>
</tr>
<tr>
<td>서비스 계층</td>
<td><code>switchIfEmpty</code>로 존재 여부 검증, <code>flatMap</code>으로 비동기 체이닝, 커스텀 예외로 의미 있는 에러 전달</td>
</tr>
<tr>
<td>컨트롤러</td>
<td><code>@RestController</code>로 CRUD 엔드포인트 구성. <code>ResponseEntity</code>로 상태 코드 제어, <code>Mono</code>/<code>Flux</code> 반환</td>
</tr>
<tr>
<td>DTO 설계</td>
<td>Java <code>record</code>로 불변 DTO 정의. 도메인과 API 계약을 분리하여 보안과 유지보수성 확보</td>
</tr>
<tr>
<td>API 테스트</td>
<td>cURL, HTTPie, IntelliJ HTTP Client로 엔드포인트 검증</td>
</tr>
</tbody>
</table>
<p>다음 Chapter 7에서는 어노테이션 방식 대신 <strong>함수형 엔드포인트(Router Functions)</strong> 를 사용하여 동일한 API를 구현하고, 두 방식의 차이점과 장단점을 비교한다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>