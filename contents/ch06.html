<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 6. 어노테이션 기반 REST API 구현 | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="ch05.html">&larr; Chapter 5. 개발 환경 구성</a>
    <a href="../index.html">목차</a>
    <a href="ch07.html">Chapter 7. 함수형 엔드포인트 &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-6-rest-api">Chapter 6. 어노테이션 기반 REST API 구현</h1>
<p>Chapter 5에서 프로젝트 구조와 개발 환경을 다 갖추었으니, 이제 본격적으로 API를 만들어보자. 먼저 도메인 모델을 정의하고, 리포지토리와 서비스 계층을 거쳐 컨트롤러까지 순서대로 구축하면 완전한 CRUD REST API가 완성된다. 이 과정에서 모든 계층이 <code>Mono</code>와 <code>Flux</code>를 반환하며, 요청에서부터 응답까지 논블로킹으로 동작하는 리액티브 파이프라인을 구성하게 된다.</p>
<hr>
<h2 id="61-document">6.1 도메인 모델(Document) 정의</h2>
<h3 id="611">6.1.1 주요 어노테이션 정리</h3>
<p>Spring Data MongoDB는 Java 객체를 MongoDB 도큐먼트에 매핑할 때 여러 어노테이션을 제공한다. 각각이 어떤 역할을 하는지 살펴보자.</p>
<table>
<thead>
<tr>
<th>어노테이션</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@Document</code></td>
<td>클래스를 MongoDB 컬렉션에 매핑한다. <code>collection</code> 속성으로 컬렉션 이름을 지정한다.</td>
</tr>
<tr>
<td><code>@Id</code></td>
<td>필드를 MongoDB의 <code>_id</code>에 매핑한다. <code>String</code> 타입이면 자동으로 <code>ObjectId</code>가 생성된다.</td>
</tr>
<tr>
<td><code>@Field</code></td>
<td>필드명을 MongoDB 도큐먼트의 키 이름과 다르게 매핑할 때 사용한다.</td>
</tr>
<tr>
<td><code>@Indexed</code></td>
<td>해당 필드에 인덱스를 생성한다. <code>unique</code>, <code>direction</code> 등의 속성을 지원한다.</td>
</tr>
<tr>
<td><code>@CreatedDate</code></td>
<td>도큐먼트 최초 저장 시 자동으로 현재 시각을 기록한다.</td>
</tr>
<tr>
<td><code>@LastModifiedDate</code></td>
<td>도큐먼트 수정 시 자동으로 현재 시각을 갱신한다.</td>
</tr>
<tr>
<td><code>@Version</code></td>
<td>낙관적 잠금(Optimistic Locking)을 위한 버전 필드를 지정한다.</td>
</tr>
<tr>
<td><code>@Transient</code></td>
<td>해당 필드를 MongoDB에 저장하지 않는다.</td>
</tr>
</tbody>
</table>
<h3 id="612-user">6.1.2 User 도메인 모델</h3>
<p>```java
package com.example.webfluxdemo.domain;</p>
<p>import lombok.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.annotation.Version;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.mapping.Field;</p>
<p>import java.time.LocalDateTime;</p>
<p>@Document(collection = "users")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Builder
@ToString
public class User {</p>
<pre><code>@Id
private String id;

@Field("name")
private String name;

@Indexed(unique = true)
private String email;

private String password;

@Builder.Default
private String role = "USER";

@CreatedDate
private LocalDateTime createdAt;

@LastModifiedDate
private LocalDateTime updatedAt;

@Version
private Long version;

public void updateProfile(String name, String email) {
    this.name = name;
    this.email = email;
}

public void changePassword(String password) {
    this.password = password;
}
</code></pre>
<p>}
```</p>
<p><code>@Version</code> 필드를 추가해두면, 여러 요청이 동시에 같은 사용자를 수정할 때 <code>OptimisticLockingFailureException</code>이 발생해서 데이터 정합성을 지켜준다.</p>
<h3 id="613-post">6.1.3 Post 도메인 모델</h3>
<p>```java
package com.example.webfluxdemo.domain;</p>
<p>import lombok.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.mongodb.core.index.CompoundIndex;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;</p>
<p>import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;</p>
<p>@Document(collection = "posts")
@CompoundIndex(name = "author_created", def = "{'authorId': 1, 'createdAt': -1}")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Builder
@ToString
public class Post {</p>
<pre><code>@Id
private String id;

private String title;

private String content;

@Indexed
private String authorId;

@Builder.Default
private List&lt;String&gt; tags = new ArrayList&lt;&gt;();

@Builder.Default
private int viewCount = 0;

@CreatedDate
private LocalDateTime createdAt;

@LastModifiedDate
private LocalDateTime updatedAt;

public void update(String title, String content, List&lt;String&gt; tags) {
    this.title = title;
    this.content = content;
    this.tags = tags != null ? tags : this.tags;
}

public void incrementViewCount() {
    this.viewCount++;
}
</code></pre>
<p>}
```</p>
<p><code>@CompoundIndex</code>로 <code>authorId</code> 오름차순과 <code>createdAt</code> 내림차순의 복합 인덱스를 만들면, 특정 작성자의 최신 게시글을 조회할 때 쿼리가 훨씬 빨라진다.</p>
<h3 id="614-auditing">6.1.4 Auditing 설정</h3>
<p><code>@CreatedDate</code>와 <code>@LastModifiedDate</code>가 실제로 동작하려면, Auditing 기능을 명시적으로 활성화해야 한다.</p>
<p>```java
package com.example.webfluxdemo.config;</p>
<p>import org.springframework.context.annotation.Configuration;
import org.springframework.data.mongodb.config.EnableReactiveMongoAuditing;</p>
<p>@Configuration
@EnableReactiveMongoAuditing
public class MongoConfig {
}
```</p>
<p>리액티브 환경에서는 꼭 <code>EnableReactiveMongoAuditing</code>을 써야 한다는 점을 잊지 말자. 일반적인 <code>@EnableMongoAuditing</code>은 여기서 작동하지 않기 때문이다. 그리고 자동 인덱스 생성을 켜려면 <code>application.yml</code>에 다음을 추가하면 된다.</p>
<p><code>yaml
spring:
  data:
    mongodb:
      uri: mongodb://admin:secret1234@localhost:27017/webflux_demo?authSource=admin
      auto-index-creation: true</code></p>
<blockquote>
<p><strong>주의</strong>: <code>auto-index-creation</code>은 개발 환경에서는 편리하지만, 운영 환경에서는 수동 인덱스 관리를 권장한다. 대규모 컬렉션에서 인덱스 자동 생성은 서비스 시작 시간을 지연시킬 수 있다.</p>
</blockquote>
<hr>
<h2 id="62-reactivemongorepository">6.2 ReactiveMongoRepository 활용</h2>
<p>이제 데이터베이스 접근 계층을 만들어보자. Spring Data가 제공하는 리액티브 리포지토리를 활용하면 기본 CRUD 메서드를 자동으로 얻을 수 있다.</p>
<h3 id="621-userrepository">6.2.1 UserRepository 정의</h3>
<p>```java
public interface UserRepository extends ReactiveMongoRepository<User, String> {</p>
<pre><code>// 메서드 이름 기반 쿼리 자동 생성
Mono&lt;User&gt; findByEmail(String email);

Flux&lt;User&gt; findByName(String name);

Flux&lt;User&gt; findByRole(String role);

Mono&lt;Boolean&gt; existsByEmail(String email);

// @Query: MongoDB JSON 쿼리 직접 작성
@Query("{ 'name': { $regex: ?0, $options: 'i' } }")
Flux&lt;User&gt; searchByName(String keyword);

// 특정 필드만 조회 (fields 속성)
@Query(value = "{ 'role': ?0 }", fields = "{ 'name': 1, 'email': 1 }")
Flux&lt;User&gt; findNameAndEmailByRole(String role);
</code></pre>
<p>}
```</p>
<p><code>ReactiveMongoRepository&lt;T, ID&gt;</code>는 <code>ReactiveCrudRepository</code>를 상속받으므로, 기본적으로 다음과 같은 메서드들을 제공한다.</p>
<table>
<thead>
<tr>
<th>메서드</th>
<th>반환 타입</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>save(T entity)</code></td>
<td><code>Mono&lt;T&gt;</code></td>
<td>삽입 또는 수정</td>
</tr>
<tr>
<td><code>findById(ID id)</code></td>
<td><code>Mono&lt;T&gt;</code></td>
<td>ID로 조회</td>
</tr>
<tr>
<td><code>findAll()</code></td>
<td><code>Flux&lt;T&gt;</code></td>
<td>전체 조회</td>
</tr>
<tr>
<td><code>deleteById(ID id)</code></td>
<td><code>Mono&lt;Void&gt;</code></td>
<td>ID로 삭제</td>
</tr>
<tr>
<td><code>count()</code></td>
<td><code>Mono&lt;Long&gt;</code></td>
<td>전체 개수</td>
</tr>
<tr>
<td><code>existsById(ID id)</code></td>
<td><code>Mono&lt;Boolean&gt;</code></td>
<td>존재 여부 확인</td>
</tr>
</tbody>
</table>
<h3 id="622-postrepository">6.2.2 PostRepository 정의</h3>
<p>```java
public interface PostRepository extends ReactiveMongoRepository<Post, String> {</p>
<pre><code>Flux&lt;Post&gt; findByAuthorId(String authorId);

Flux&lt;Post&gt; findByTagsContaining(String tag);

Flux&lt;Post&gt; findByTitleContainingIgnoreCase(String keyword);

// 페이징: Pageable 파라미터를 전달
Flux&lt;Post&gt; findByAuthorId(String authorId, Pageable pageable);

Mono&lt;Long&gt; countByAuthorId(String authorId);

// 복잡한 쿼리: 제목 또는 내용에 키워드가 포함된 게시글 검색
@Query("{ $or: [ " +
       "  { 'title': { $regex: ?0, $options: 'i' } }, " +
       "  { 'content': { $regex: ?0, $options: 'i' } } " +
       "] }")
Flux&lt;Post&gt; searchByKeyword(String keyword);

// 정렬: 메서드 이름에 OrderBy 포함
Flux&lt;Post&gt; findByAuthorIdOrderByCreatedAtDesc(String authorId);
</code></pre>
<p>}
```</p>
<h3 id="623">6.2.3 쿼리 메서드 이름 규칙</h3>
<p>Spring Data의 매력적인 점 중 하나가 메서드 이름만 보고도 쿼리를 자동으로 만들어준다는 것이다. 주요 키워드들을 정리하면 다음과 같다.</p>
<table>
<thead>
<tr>
<th>키워드</th>
<th>예시</th>
<th>생성 쿼리</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Is</code> / <code>Equals</code></td>
<td><code>findByName(String)</code></td>
<td><code>{ 'name': ?0 }</code></td>
</tr>
<tr>
<td><code>Between</code></td>
<td><code>findByAgeBetween(int, int)</code></td>
<td><code>{ 'age': { $gte: ?0, $lte: ?1 } }</code></td>
</tr>
<tr>
<td><code>Containing</code></td>
<td><code>findByTitleContaining(String)</code></td>
<td><code>{ 'title': { $regex: ?0 } }</code></td>
</tr>
<tr>
<td><code>In</code></td>
<td><code>findByRoleIn(List)</code></td>
<td><code>{ 'role': { $in: ?0 } }</code></td>
</tr>
<tr>
<td><code>OrderBy</code></td>
<td><code>findByAuthorIdOrderByCreatedAtDesc</code></td>
<td>정렬 추가</td>
</tr>
<tr>
<td><code>IgnoreCase</code></td>
<td><code>findByNameIgnoreCase(String)</code></td>
<td>대소문자 무시</td>
</tr>
</tbody>
</table>
<h3 id="624">6.2.4 페이징 처리</h3>
<p>리액티브 환경에서 페이징을 할 때는 약간 다른 접근이 필요하다. <code>Pageable</code>을 전달하되, 총 개수는 별도로 조회해야 한다.</p>
<p>```java
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;</p>
<p>// 0번째 페이지, 10개씩, 생성일 내림차순
Pageable pageable = PageRequest.of(0, 10, Sort.by(Sort.Direction.DESC, "createdAt"));</p>
<p>Flux<Post> posts = postRepository.findByAuthorId("user123", pageable);
Mono<Long> totalCount = postRepository.countByAuthorId("user123");
```</p>
<blockquote>
<p><strong>참고</strong>: Spring Data Reactive에는 <code>Page&lt;T&gt;</code> 반환 타입이 없다. <code>Page</code>는 전체 개수를 동기적으로 계산해야 하므로 리액티브 모델과 맞지 않기 때문이다. 대신 <code>Flux&lt;T&gt;</code>와 <code>Mono&lt;Long&gt;</code>을 조합하여 페이징 정보를 구성한다.</p>
</blockquote>
<hr>
<h2 id="63">6.3 서비스 계층 구현</h2>
<p>서비스 계층은 리포지토리와 컨트롤러 사이에서 비즈니스 로직을 담당한다. 리액티브 패턴을 제대로 이해하는 것이 이 계층에서 가장 중요하다.</p>
<h3 id="631">6.3.1 커스텀 예외 정의</h3>
<p>먼저 서비스에서 사용할 커스텀 예외들을 정의해두자.</p>
<p>```java
@Getter
public class ResourceNotFoundException extends RuntimeException {
    private final String resourceName;
    private final String fieldName;
    private final String fieldValue;</p>
<pre><code>public ResourceNotFoundException(String resourceName, String fieldName,
                                 String fieldValue) {
    super(String.format("%s not found with %s: '%s'",
            resourceName, fieldName, fieldValue));
    this.resourceName = resourceName;
    this.fieldName = fieldName;
    this.fieldValue = fieldValue;
}
</code></pre>
<p>}</p>
<p>public class DuplicateResourceException extends RuntimeException {
    public DuplicateResourceException(String message) { super(message); }
}
```</p>
<h3 id="632-userservice">6.3.2 UserService 구현체</h3>
<p>이제 실제 CRUD 로직을 구현해보자. 인터페이스에서 <code>Mono&lt;User&gt; createUser(User)</code>, <code>Mono&lt;User&gt; getUserById(String)</code>, <code>Flux&lt;User&gt; getAllUsers()</code> 같은 메서드를 선언했다면, 구현체에서는 리액티브 패턴을 활용해서 이를 구현한다.</p>
<p>```java
@Service
@RequiredArgsConstructor
@Slf4j
public class UserServiceImpl implements UserService {</p>
<pre><code>private final UserRepository userRepository;

@Override
public Mono&lt;User&gt; createUser(User user) {
    return userRepository.existsByEmail(user.getEmail())
            .flatMap(exists -&gt; {
                if (exists) {
                    return Mono.error(new DuplicateResourceException(
                            "Email already exists: " + user.getEmail()));
                }
                return userRepository.save(user);
            })
            .doOnSuccess(saved -&gt; log.info("User created: {}", saved.getId()));
}

@Override
public Mono&lt;User&gt; getUserById(String id) {
    return userRepository.findById(id)
            .switchIfEmpty(Mono.error(
                    new ResourceNotFoundException("User", "id", id)));
}

@Override
public Flux&lt;User&gt; getAllUsers() { return userRepository.findAll(); }

@Override
public Flux&lt;User&gt; searchUsers(String keyword) {
    return userRepository.searchByName(keyword);
}

@Override
public Mono&lt;User&gt; updateUser(String id, User user) {
    return userRepository.findById(id)
            .switchIfEmpty(Mono.error(
                    new ResourceNotFoundException("User", "id", id)))
            .flatMap(existingUser -&gt; {
                existingUser.updateProfile(user.getName(), user.getEmail());
                return userRepository.save(existingUser);
            })
            .doOnSuccess(updated -&gt; log.info("User updated: {}", updated.getId()));
}

@Override
public Mono&lt;Void&gt; deleteUser(String id) {
    return userRepository.findById(id)
            .switchIfEmpty(Mono.error(
                    new ResourceNotFoundException("User", "id", id)))
            .flatMap(userRepository::delete)
            .doOnSuccess(v -&gt; log.info("User deleted: {}", id));
}
</code></pre>
<p>}
```</p>
<p>이 코드에서 핵심적으로 봐야 할 패턴들이 있다. <code>switchIfEmpty</code>는 <code>null</code> 검사를 리액티브 방식으로 대체하는 것이고, <code>flatMap</code>은 비동기 작업을 체인처럼 연결해준다. 그리고 <code>doOnSuccess</code>는 로깅처럼 사이드 이펙트를 일으키는 부분이다. 이 세 가지를 조합하면 리액티브하면서도 안전한 서비스 로직을 만들 수 있기 때문이다.</p>
<h3 id="633-postservice">6.3.3 PostService 구현체</h3>
<p><code>PostService</code>도 UserService와 거의 동일한 패턴을 따른다. 여기서는 게시글 관련 핵심 메서드만 보여주겠다.</p>
<p>```java
@Service
@RequiredArgsConstructor
@Slf4j
public class PostService {</p>
<pre><code>private final PostRepository postRepository;

public Mono&lt;Post&gt; createPost(Post post) {
    return postRepository.save(post)
            .doOnSuccess(saved -&gt; log.info("Post created: {}", saved.getId()));
}

public Mono&lt;Post&gt; getPostById(String id) {
    return postRepository.findById(id)
            .switchIfEmpty(Mono.error(
                    new ResourceNotFoundException("Post", "id", id)));
}

public Flux&lt;Post&gt; getPostsByAuthor(String authorId, int page, int size) {
    PageRequest pageable = PageRequest.of(page, size,
            Sort.by(Sort.Direction.DESC, "createdAt"));
    return postRepository.findByAuthorId(authorId, pageable);
}

public Mono&lt;Long&gt; countPostsByAuthor(String authorId) { return postRepository.countByAuthorId(authorId); }

public Mono&lt;Post&gt; updatePost(String id, Post post) {
    return postRepository.findById(id)
            .switchIfEmpty(Mono.error(
                    new ResourceNotFoundException("Post", "id", id)))
            .flatMap(existing -&gt; {
                existing.update(post.getTitle(), post.getContent(), post.getTags());
                return postRepository.save(existing);
            });
}

public Mono&lt;Void&gt; deletePost(String id) {
    return postRepository.findById(id)
            .switchIfEmpty(Mono.error(
                    new ResourceNotFoundException("Post", "id", id)))
            .flatMap(postRepository::delete);
}
</code></pre>
<p>}
```</p>
<hr>
<h2 id="64-restcontroller-crud-api">6.4 @RestController로 CRUD API 만들기</h2>
<p>마지막으로 클라이언트 요청을 받아서 처리하는 컨트롤러를 만든다. 리액티브 컨트롤러는 동기식 방식과 몇 가지 다른 점이 있다.</p>
<h3 id="641-usercontroller">6.4.1 UserController</h3>
<p>```java
@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
public class UserController {</p>
<pre><code>private final UserService userService;

@PostMapping
@ResponseStatus(HttpStatus.CREATED)
public Mono&lt;UserResponse&gt; createUser(@RequestBody CreateUserRequest request) {
    User user = User.builder()
            .name(request.name())
            .email(request.email())
            .password(request.password())
            .build();
    return userService.createUser(user)
            .map(UserResponse::from);
}

@GetMapping("/{id}")
public Mono&lt;ResponseEntity&lt;UserResponse&gt;&gt; getUserById(@PathVariable String id) {
    return userService.getUserById(id)
            .map(UserResponse::from)
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
}

@GetMapping
public Flux&lt;UserResponse&gt; getAllUsers() {
    return userService.getAllUsers()
            .map(UserResponse::from);
}

@GetMapping("/search")
public Flux&lt;UserResponse&gt; searchUsers(@RequestParam String keyword) {
    return userService.searchUsers(keyword)
            .map(UserResponse::from);
}

@PutMapping("/{id}")
public Mono&lt;ResponseEntity&lt;UserResponse&gt;&gt; updateUser(
        @PathVariable String id,
        @RequestBody UpdateUserRequest request) {
    User user = User.builder()
            .name(request.name())
            .email(request.email())
            .build();
    return userService.updateUser(id, user)
            .map(UserResponse::from)
            .map(ResponseEntity::ok);
}

@DeleteMapping("/{id}")
public Mono&lt;ResponseEntity&lt;Void&gt;&gt; deleteUser(@PathVariable String id) {
    return userService.deleteUser(id)
            .then(Mono.just(ResponseEntity.noContent().&lt;Void&gt;build()));
}
</code></pre>
<p>}
```</p>
<p>컨트롤러를 작성할 때 기억해야 할 패턴들이 있다. <code>@ResponseStatus</code>를 쓰면 <code>ResponseEntity</code> 없이 깔끔하게 상태 코드를 지정할 수 있다. 그리고 <code>ResponseEntity</code>를 <code>Mono</code>로 감싸서 <code>map(ResponseEntity::ok)</code>로 200 응답을 만들거나, <code>defaultIfEmpty</code>로 404를 처리하는 것이 관례다. 마지막으로 <code>then()</code>을 사용하면 <code>Mono&lt;Void&gt;</code>가 완료된 후 새로운 값을 내보낼 수 있는데, 삭제 후 204 응답을 줄 때 자주 쓰인다.</p>
<h3 id="642-postcontroller">6.4.2 PostController</h3>
<p><code>PostController</code>도 UserController와 똑같은 패턴으로 작성된다. 여기서는 게시글 엔드포인트 중에서도 페이징 조회 부분을 중심으로 살펴보자.</p>
<p>```java
@RestController
@RequestMapping("/api/posts")
@RequiredArgsConstructor
public class PostController {</p>
<pre><code>private final PostService postService;

@PostMapping
@ResponseStatus(HttpStatus.CREATED)
public Mono&lt;PostResponse&gt; createPost(@RequestBody CreatePostRequest request) {
    Post post = Post.builder()
            .title(request.title())
            .content(request.content())
            .authorId(request.authorId())
            .tags(request.tags())
            .build();
    return postService.createPost(post).map(PostResponse::from);
}

@GetMapping("/{id}")
public Mono&lt;ResponseEntity&lt;PostResponse&gt;&gt; getPostById(@PathVariable String id) {
    return postService.getPostById(id)
            .map(PostResponse::from)
            .map(ResponseEntity::ok);
}

@GetMapping("/author/{authorId}")
public Flux&lt;PostResponse&gt; getPostsByAuthor(
        @PathVariable String authorId,
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "10") int size) {
    return postService.getPostsByAuthor(authorId, page, size)
            .map(PostResponse::from);
}

@PutMapping("/{id}")
public Mono&lt;ResponseEntity&lt;PostResponse&gt;&gt; updatePost(
        @PathVariable String id, @RequestBody UpdatePostRequest request) {
    Post post = Post.builder()
            .title(request.title()).content(request.content())
            .tags(request.tags()).build();
    return postService.updatePost(id, post)
            .map(PostResponse::from).map(ResponseEntity::ok);
}

@DeleteMapping("/{id}")
@ResponseStatus(HttpStatus.NO_CONTENT)
public Mono&lt;Void&gt; deletePost(@PathVariable String id) {
    return postService.deletePost(id);
}
</code></pre>
<p>}
```</p>
<h3 id="643-api">6.4.3 완성된 API 엔드포인트 정리</h3>
<table>
<thead>
<tr>
<th>메서드</th>
<th>URI</th>
<th>상태 코드</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>POST</code></td>
<td><code>/api/users</code></td>
<td>201</td>
</tr>
<tr>
<td><code>GET</code></td>
<td><code>/api/users</code>, <code>/api/users/{id}</code>, <code>/api/users/search?keyword=</code></td>
<td>200</td>
</tr>
<tr>
<td><code>PUT</code></td>
<td><code>/api/users/{id}</code></td>
<td>200</td>
</tr>
<tr>
<td><code>DELETE</code></td>
<td><code>/api/users/{id}</code></td>
<td>204</td>
</tr>
<tr>
<td><code>POST</code></td>
<td><code>/api/posts</code></td>
<td>201</td>
</tr>
<tr>
<td><code>GET</code></td>
<td><code>/api/posts</code>, <code>/api/posts/{id}</code>, <code>/api/posts/author/{authorId}?page=&amp;size=</code></td>
<td>200</td>
</tr>
<tr>
<td><code>PUT</code></td>
<td><code>/api/posts/{id}</code></td>
<td>200</td>
</tr>
<tr>
<td><code>DELETE</code></td>
<td><code>/api/posts/{id}</code></td>
<td>204</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="65-dto">6.5 요청/응답 DTO 설계</h2>
<h3 id="651-java-record-dto">6.5.1 Java record를 활용한 DTO</h3>
<p>Java 16부터 <code>record</code>라는 새로운 클래스 타입이 추가되었는데, 이것은 DTO로 쓰기에 정말 좋다. 불변 데이터를 담는 용도로 설계되었고, 생성자나 <code>equals()</code>, <code>hashCode()</code>, <code>toString()</code> 같은 메서드를 자동으로 만들어주기 때문이다.</p>
<p><strong>User 관련 DTO</strong></p>
<p>```java
public record CreateUserRequest(String name, String email, String password) {}</p>
<p>public record UpdateUserRequest(String name, String email) {}</p>
<p>public record UserResponse(
        String id, String name, String email, String role,
        LocalDateTime createdAt, LocalDateTime updatedAt
) {
    // 도메인 -&gt; DTO 변환 정적 팩토리 메서드
    public static UserResponse from(User user) {
        return new UserResponse(user.getId(), user.getName(), user.getEmail(),
                user.getRole(), user.getCreatedAt(), user.getUpdatedAt());
    }
}
```</p>
<p><strong>Post 관련 DTO</strong></p>
<p>Post DTO도 User와 동일한 방식으로 만들면 된다. 여기서는 <code>PostResponse</code>의 <code>from()</code> 정적 팩토리 메서드만 보여주겠다.</p>
<p>```java
public record CreatePostRequest(String title, String content,
                                 String authorId, List<String> tags) {}</p>
<p>public record UpdatePostRequest(String title, String content, List<String> tags) {}</p>
<p>public record PostResponse(
        String id, String title, String content, String authorId,
        List<String> tags, int viewCount,
        LocalDateTime createdAt, LocalDateTime updatedAt
) {
    public static PostResponse from(Post post) {
        return new PostResponse(
                post.getId(), post.getTitle(), post.getContent(),
                post.getAuthorId(), post.getTags(), post.getViewCount(),
                post.getCreatedAt(), post.getUpdatedAt());
    }
}
```</p>
<h3 id="652-dto">6.5.2 DTO 사용의 이점</h3>
<p>도메인 모델을 그대로 API 응답으로 주지 않고 DTO를 따로 만드는 이유가 있다. 첫째, <code>password</code>나 <code>version</code> 같은 민감한 내부 필드가 노출되는 것을 막을 수 있다는 보안상 이점이다. 둘째, 도메인 모델이 바뀌어도 API 계약이 깨지지 않으므로 안정성이 좋다. 셋째, 용도에 따라 다른 DTO를 제공할 수 있어 유연하다. 그리고 넷째, 나중에 Bean Validation을 적용할 때도 DTO 단계에서 검증하는 것이 깔끔하다. 이런 여러 이유가 조합되어 있기 때문이다.</p>
<h3 id="653-dto">6.5.3 페이징 응답 DTO</h3>
<p>페이징 결과를 감싸는 범용 DTO를 하나 만들어두면, 모든 페이징 응답에서 일관되게 페이징 메타 정보를 클라이언트에 전달할 수 있다.</p>
<p>```java
package com.example.webfluxdemo.dto;</p>
<p>import java.util.List;</p>
<p>public record PageResponse<T>(
        List<T> content,
        int page,
        int size,
        long totalElements,
        int totalPages
) {
    public static <T> PageResponse<T> of(List<T> content, int page,
                                          int size, long totalElements) {
        int totalPages = (int) Math.ceil((double) totalElements / size);
        return new PageResponse&lt;&gt;(content, page, size, totalElements, totalPages);
    }
}
```</p>
<p>컨트롤러에서 페이징 응답을 구성하는 예시:</p>
<p>```java
@GetMapping("/author/{authorId}")
public Mono<PageResponse\<PostResponse>> getPostsByAuthorPaged(
        @PathVariable String authorId,
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "10") int size) {</p>
<pre><code>Mono&lt;List&lt;PostResponse&gt;&gt; contentMono = postService
        .getPostsByAuthor(authorId, page, size)
        .map(PostResponse::from)
        .collectList();

Mono&lt;Long&gt; countMono = postService.countPostsByAuthor(authorId);

return Mono.zip(contentMono, countMono)
        .map(tuple -&gt; PageResponse.of(tuple.getT1(), page, size, tuple.getT2()));
</code></pre>
<p>}
```</p>
<p><code>Mono.zip</code>을 사용하면 콘텐츠 조회와 총 개수 조회를 <strong>동시에</strong> 실행할 수 있고, 나중에 두 결과를 조합해서 <code>PageResponse</code>로 만든다. 이것이 리액티브 환경에서 여러 비동기 작업을 병렬로 처리하는 관용적인 방법이다.</p>
<hr>
<h2 id="66-api">6.6 API 테스트</h2>
<p>API를 제대로 만들었는지 확인하는 가장 좋은 방법은 직접 호출해보는 것이다. 여러 도구를 이용해서 이를 해보자.</p>
<p>```bash</p>
<h1 id="_1">애플리케이션 실행</h1>
<p>./gradlew bootRun
```</p>
<h3 id="661-curl">6.6.1 cURL 테스트</h3>
<p><strong>사용자 생성 (POST)</strong></p>
<p><code>bash
curl -X POST http://localhost:8080/api/users \
  -H "Content-Type: application/json" \
  -d '{
    "name": "홍길동",
    "email": "hong@example.com",
    "password": "securePass123"
  }'</code></p>
<p>응답 예시:</p>
<p><code>json
{
  "id": "65f1a2b3c4d5e6f7a8b9c0d1",
  "name": "홍길동",
  "email": "hong@example.com",
  "role": "USER",
  "createdAt": "2025-06-15T10:30:00",
  "updatedAt": "2025-06-15T10:30:00"
}</code></p>
<p><strong>사용자 조회 (GET)</strong></p>
<p>```bash</p>
<h1 id="_2">전체 조회</h1>
<p>curl http://localhost:8080/api/users</p>
<h1 id="_3">단건 조회</h1>
<p>curl http://localhost:8080/api/users/65f1a2b3c4d5e6f7a8b9c0d1
```</p>
<p><strong>수정 / 삭제 / 게시글</strong></p>
<p>```bash</p>
<h1 id="_4">사용자 수정</h1>
<p>curl -X PUT http://localhost:8080/api/users/65f1a2b3c4d5e6f7a8b9c0d1 \
  -H "Content-Type: application/json" \
  -d '{ "name": "홍길동(수정)", "email": "hong-updated@example.com" }'</p>
<h1 id="_5">사용자 삭제</h1>
<p>curl -X DELETE http://localhost:8080/api/users/65f1a2b3c4d5e6f7a8b9c0d1 -v</p>
<h1 id="_6">게시글 생성</h1>
<p>curl -X POST http://localhost:8080/api/posts \
  -H "Content-Type: application/json" \
  -d '{ "title": "WebFlux 첫 글", "content": "리액티브 API 구현",
        "authorId": "65f1a2b3c4d5e6f7a8b9c0d1", "tags": ["spring","webflux"] }'</p>
<h1 id="_7">게시글 검색</h1>
<p>curl "http://localhost:8080/api/posts/search?keyword=WebFlux"</p>
<h1 id="_8">작성자별 페이징 조회</h1>
<p>curl "http://localhost:8080/api/posts/author/65f1a2b3c4d5e6f7a8b9c0d1?page=0&amp;size=5"
```</p>
<h3 id="662-httpie">6.6.2 HTTPie 테스트</h3>
<p>cURL도 좋지만, HTTPie라는 도구를 쓰면 더 직관적으로 API를 테스트할 수 있다.</p>
<p>```bash</p>
<h1 id="json-keyvalue">사용자 생성 — JSON 필드를 key=value 형식으로 전달</h1>
<p>http POST localhost:8080/api/users \
  name="김철수" email="kim@example.com" password="pass1234"</p>
<h1 id="_9">조회</h1>
<p>http localhost:8080/api/users</p>
<h1 id="json">게시글 생성 — JSON 배열은 := 연산자로 전달</h1>
<p>http POST localhost:8080/api/posts \
  title="HTTPie 테스트" content="HTTPie로 API를 테스트합니다." \
  authorId="65f1a2b3c4d5e6f7a8b9c0d1" tags:='["test", "httpie"]'
```</p>
<blockquote>
<p><strong>팁</strong>: HTTPie에서 <code>=</code>는 문자열, <code>:=</code>는 JSON 리터럴(숫자, 배열, 객체, boolean)을 전달한다.</p>
</blockquote>
<h3 id="663-intellij-http-client">6.6.3 IntelliJ HTTP Client</h3>
<p>IntelliJ IDEA를 쓰는 개발자라면, 내장된 HTTP Client 기능을 활용하는 게 제일 편하다. <code>.http</code> 파일로 모든 API 요청을 관리할 수 있기 때문이다. 프로젝트 루트에 <code>.http</code> 파일을 만들어보자.</p>
<p>```http</p>
<h3 id="_10">사용자 생성</h3>
<p>POST http://localhost:8080/api/users
Content-Type: application/json</p>
<p>{
  "name": "이영희",
  "email": "lee@example.com",
  "password": "myPassword456"
}</p>
<h3 id="_11">전체 사용자 조회</h3>
<p>GET http://localhost:8080/api/users</p>
<h3 id="_12">사용자 수정</h3>
<p>PUT http://localhost:8080/api/users/{{userId}}
Content-Type: application/json</p>
<p>{
  "name": "이영희(수정)",
  "email": "lee-updated@example.com"
}</p>
<h3 id="_13">사용자 삭제</h3>
<p>DELETE http://localhost:8080/api/users/{{userId}}
```</p>
<p><code>{{userId}}</code>처럼 변수화한 부분은 <code>http-client.env.json</code>에서 환경별로 관리한다. 그리고 <code>.http</code> 파일을 Git에 넣어서 관리하면 팀원들과 같은 API 테스트를 공유할 수 있다는 게 정말 큰 장점이다.</p>
<hr>
<h2 id="6">6장 정리</h2>
<p>이번 장에서 배운 것들을 한번 정리해보자.</p>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 요약</th>
</tr>
</thead>
<tbody>
<tr>
<td>도메인 모델</td>
<td><code>@Document</code>, <code>@Id</code>, <code>@Indexed</code>, <code>@CompoundIndex</code>로 도큐먼트 매핑. Auditing으로 생성/수정 시각 자동 관리</td>
</tr>
<tr>
<td>리포지토리</td>
<td><code>ReactiveMongoRepository</code>로 기본 CRUD 자동 제공. 쿼리 메서드 이름 규칙, <code>@Query</code>, 페이징 지원</td>
</tr>
<tr>
<td>서비스 계층</td>
<td><code>switchIfEmpty</code>로 존재 여부 검증, <code>flatMap</code>으로 비동기 체이닝, 커스텀 예외로 의미 있는 에러 전달</td>
</tr>
<tr>
<td>컨트롤러</td>
<td><code>@RestController</code>로 CRUD 엔드포인트 구성. <code>ResponseEntity</code>로 상태 코드 제어, <code>Mono</code>/<code>Flux</code> 반환</td>
</tr>
<tr>
<td>DTO 설계</td>
<td>Java <code>record</code>로 불변 DTO 정의. 도메인과 API 계약을 분리하여 보안과 유지보수성 확보</td>
</tr>
<tr>
<td>API 테스트</td>
<td>cURL, HTTPie, IntelliJ HTTP Client로 엔드포인트 검증</td>
</tr>
</tbody>
</table>
<p>이제 기본적인 REST API를 어노테이션 방식으로 만들어봤다. 다음 Chapter 7에서는 다른 방식으로 <strong>함수형 엔드포인트(Router Functions)</strong> 를 사용해서 똑같은 API를 구현해보고, 어떤 차이가 있는지 비교해볼 예정이다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>