<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 2. Spring WebFlux 개요 | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="ch01.html">&larr; Chapter 1. 리액티브 프로그래밍 소개</a>
    <a href="../index.html">목차</a>
    <a href="ch03.html">Chapter 3. Project Reactor 핵심 &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-2-spring-webflux">Chapter 2. Spring WebFlux 개요</h1>
<p>Spring WebFlux는 Spring Framework 5에서 도입된 리액티브 웹 프레임워크다. 기존 Spring MVC가 서블릿 기반의 동기/블로킹 모델 위에 구축되었다면, WebFlux는 논블로킹 I/O와 리액티브 스트림을 기반으로 설계되었다. 이 장에서는 WebFlux의 전체적인 아키텍처, 내부 동작 원리, 그리고 언제 WebFlux를 선택해야 하는지에 대해 살펴본다.</p>
<hr>
<h2 id="21-spring-mvc-spring-webflux">2.1 Spring MVC와 Spring WebFlux 비교</h2>
<h3 id="211-vs">2.1.1 아키텍처 차이: 서블릿 스택 vs 리액티브 스택</h3>
<p>Spring MVC는 Java Servlet API 위에 구축된다. 클라이언트 요청이 들어오면 서블릿 컨테이너(Tomcat, Jetty 등)가 스레드 풀에서 하나의 스레드를 할당하고, 해당 스레드가 요청의 시작부터 끝까지 전체 처리를 담당한다. 이를 <strong>thread-per-request</strong> 모델이라 한다.</p>
<pre class="highlight"><code>[Spring MVC 스택]
┌─────────────────────┐
│   Servlet Container  │  (Tomcat, Jetty)
│   ┌───────────────┐  │
│   │ DispatcherServlet │
│   │   ┌─────────┐ │  │
│   │   │ Handler  │ │  │
│   │   │ Mapping  │ │  │
│   │   └─────────┘ │  │
│   │   ┌─────────┐ │  │
│   │   │Controller│ │  │
│   │   └─────────┘ │  │
│   └───────────────┘  │
│   Servlet API        │
│   (Blocking I/O)     │
└─────────────────────┘</code></pre>
<p>반면 Spring WebFlux는 리액티브 스택 위에 구축된다. 서블릿 API에 의존하지 않으며, 기본적으로 Netty를 런타임으로 사용한다. 소수의 이벤트 루프 스레드가 다수의 요청을 논블로킹 방식으로 처리한다.</p>
<pre class="highlight"><code>[Spring WebFlux 스택]
┌─────────────────────┐
│   Reactive Runtime   │  (Netty, Undertow)
│   ┌───────────────┐  │
│   │DispatcherHandler│
│   │   ┌─────────┐ │  │
│   │   │ Handler  │ │  │
│   │   │ Mapping  │ │  │
│   │   └─────────┘ │  │
│   │   ┌─────────┐ │  │
│   │   │Controller│ │  │
│   │   │   or     │ │  │
│   │   │RouterFunc│ │  │
│   │   └─────────┘ │  │
│   └───────────────┘  │
│   Reactive Streams   │
│   (Non-Blocking I/O) │
└─────────────────────┘</code></pre>
<h3 id="212">2.1.2 스레드 모델 차이</h3>
<p><strong>Spring MVC</strong>의 스레드 모델은 직관적이다. 동시에 200개의 요청을 처리하려면 최소 200개의 스레드가 필요하다. 각 스레드는 데이터베이스 응답을 기다리는 동안에도 점유된 상태로 남는다.</p>
<pre class="highlight"><code>[Spring MVC - Thread-per-Request]

요청 A ──▶ Thread-1: [수신]──[처리]──[DB 대기...]──[응답]──▶ 완료
요청 B ──▶ Thread-2: [수신]──[처리]──[DB 대기...]──[응답]──▶ 완료
요청 C ──▶ Thread-3: [수신]──[처리]──[DB 대기...]──[응답]──▶ 완료
  ...
요청 N ──▶ Thread-N: (스레드 풀 고갈 → 대기 큐에서 대기)</code></pre>
<p><strong>Spring WebFlux</strong>는 이벤트 루프 기반이다. CPU 코어 수만큼의 소수 스레드(기본적으로 코어 수 x 1)가 모든 요청을 논블로킹으로 처리한다. I/O 대기 시간 동안 스레드가 다른 요청을 처리할 수 있다.</p>
<pre class="highlight"><code>[Spring WebFlux - Event Loop]

EventLoop-1: [요청A 수신]─[요청B 수신]─[요청A DB콜백]─[요청C 수신]─[요청B DB콜백]─...
EventLoop-2: [요청D 수신]─[요청E 수신]─[요청D DB콜백]─[요청F 수신]─[요청E DB콜백]─...</code></pre>
<p><strong>처리량과 지연 시간 비교</strong></p>
<table>
<thead>
<tr>
<th>항목</th>
<th>Spring MVC</th>
<th>Spring WebFlux</th>
</tr>
</thead>
<tbody>
<tr>
<td>동시 연결 수</td>
<td>스레드 풀 크기에 제한 (보통 200~500)</td>
<td>수만 개 이상 동시 연결 가능</td>
</tr>
<tr>
<td>스레드 수</td>
<td>요청 수에 비례</td>
<td>CPU 코어 수에 비례 (고정)</td>
</tr>
<tr>
<td>메모리 사용</td>
<td>스레드당 약 512KB~1MB 스택</td>
<td>적은 스레드로 메모리 효율적</td>
</tr>
<tr>
<td>I/O 바운드 작업</td>
<td>대기 중 스레드 낭비</td>
<td>대기 중 다른 작업 처리</td>
</tr>
<tr>
<td>CPU 바운드 작업</td>
<td>효율적</td>
<td>이점 없음 (오히려 복잡성 증가)</td>
</tr>
<tr>
<td>지연 시간</td>
<td>부하 낮을 때 약간 유리</td>
<td>부하 높을 때 안정적</td>
</tr>
<tr>
<td>최대 처리량</td>
<td>스레드 풀 포화 시 급감</td>
<td>일정하게 유지</td>
</tr>
</tbody>
</table>
<h3 id="213">2.1.3 코드 스타일 비교</h3>
<p>동일한 사용자 조회 API를 두 방식으로 구현하여 비교해보자.</p>
<p><strong>Spring MVC 방식:</strong></p>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping("/{id}")
    public ResponseEntity&lt;User&gt; getUser(@PathVariable String id) {
        User user = userService.findById(id);  // 블로킹 호출
        if (user == null) {
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity.ok(user);
    }

    @GetMapping
    public ResponseEntity&lt;List&lt;User&gt;&gt; getAllUsers() {
        List&lt;User&gt; users = userService.findAll();  // 블로킹 호출
        return ResponseEntity.ok(users);
    }

    @PostMapping
    public ResponseEntity&lt;User&gt; createUser(@RequestBody User user) {
        User saved = userService.save(user);  // 블로킹 호출
        return ResponseEntity
                .created(URI.create("/api/users/" + saved.getId()))
                .body(saved);
    }
}</code></pre>
<p><strong>Spring WebFlux 방식:</strong></p>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping("/{id}")
    public Mono&lt;ResponseEntity&lt;User&gt;&gt; getUser(@PathVariable String id) {
        return userService.findById(id)                    // 논블로킹 호출
                .map(user -&gt; ResponseEntity.ok(user))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping
    public Flux&lt;User&gt; getAllUsers() {
        return userService.findAll();  // 논블로킹, 스트리밍 가능
    }

    @PostMapping
    public Mono&lt;ResponseEntity&lt;User&gt;&gt; createUser(@RequestBody User user) {
        return userService.save(user)                      // 논블로킹 호출
                .map(saved -&gt; ResponseEntity
                        .created(URI.create("/api/users/" + saved.getId()))
                        .body(saved));
    }
}</code></pre>
<p>핵심적인 차이점을 정리하면 다음과 같다.</p>
<table>
<thead>
<tr>
<th>구분</th>
<th>Spring MVC</th>
<th>Spring WebFlux</th>
</tr>
</thead>
<tbody>
<tr>
<td>반환 타입</td>
<td><code>User</code>, <code>List&lt;User&gt;</code></td>
<td><code>Mono&lt;User&gt;</code>, <code>Flux&lt;User&gt;</code></td>
</tr>
<tr>
<td>실행 방식</td>
<td>메서드 호출 시 즉시 실행</td>
<td>구독(subscribe) 시 실행</td>
</tr>
<tr>
<td>데이터 흐름</td>
<td>동기적, 순차적</td>
<td>비동기적, 이벤트 기반</td>
</tr>
<tr>
<td>에러 처리</td>
<td>try-catch</td>
<td><code>onErrorResume</code>, <code>onErrorReturn</code></td>
</tr>
<tr>
<td>기본 서버</td>
<td>Tomcat</td>
<td>Netty</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="22-webflux-netty">2.2 WebFlux의 내부 구조와 Netty</h2>
<h3 id="221-netty">2.2.1 Netty란 무엇인가</h3>
<p>Netty는 JVM 위에서 동작하는 비동기 이벤트 기반 네트워크 프레임워크다. 고성능 프로토콜 서버와 클라이언트를 빠르게 개발할 수 있도록 설계되었으며, HTTP, WebSocket, TCP, UDP 등 다양한 프로토콜을 지원한다.</p>
<p>Spring WebFlux가 Netty를 기본 런타임으로 선택한 이유는 다음과 같다.</p>
<ul>
<li><strong>논블로킹 I/O</strong>: Java NIO 기반으로 소수 스레드로 대량의 동시 연결 처리</li>
<li><strong>이벤트 루프 모델</strong>: 효율적인 리소스 활용과 높은 동시성</li>
<li><strong>검증된 안정성</strong>: Discord, Apple, Netflix 등 대규모 서비스에서 검증</li>
<li><strong>풍부한 프로토콜 지원</strong>: HTTP/1.1, HTTP/2, WebSocket 기본 지원</li>
</ul>
<h3 id="222-event-loop">2.2.2 이벤트 루프(Event Loop) 모델</h3>
<p>Netty의 이벤트 루프는 하나의 스레드가 <strong>셀렉터(Selector)</strong>를 통해 여러 채널(연결)의 I/O 이벤트를 감시하고 처리하는 구조다.</p>
<pre class="highlight"><code>[Netty 이벤트 루프 구조]

                  ┌──────────────────────────────┐
                  │       EventLoopGroup          │
                  │  (Boss Group - 연결 수락)      │
                  │  ┌────────────────────────┐   │
                  │  │ EventLoop (Thread-1)   │   │
                  │  │  → 새 연결 수락(accept)  │   │
                  │  └────────────────────────┘   │
                  └──────────┬───────────────────┘
                             │ 연결을 Worker에 등록
                  ┌──────────▼───────────────────┐
                  │       EventLoopGroup          │
                  │  (Worker Group - I/O 처리)     │
                  │  ┌────────────────────────┐   │
                  │  │ EventLoop-1 (Thread)   │   │
                  │  │  채널 A, D, G 담당      │   │
                  │  └────────────────────────┘   │
                  │  ┌────────────────────────┐   │
                  │  │ EventLoop-2 (Thread)   │   │
                  │  │  채널 B, E, H 담당      │   │
                  │  └────────────────────────┘   │
                  │  ┌────────────────────────┐   │
                  │  │ EventLoop-N (Thread)   │   │
                  │  │  채널 C, F, I 담당      │   │
                  │  └────────────────────────┘   │
                  └──────────────────────────────┘</code></pre>
<p>각 이벤트 루프 스레드는 다음 과정을 무한 반복한다.</p>
<ol>
<li><strong>Selector로 I/O 이벤트 대기</strong>: 등록된 채널 중 읽기/쓰기 가능한 채널이 있는지 확인</li>
<li><strong>이벤트 처리</strong>: 준비된 채널의 데이터를 읽거나 쓰기</li>
<li><strong>태스크 큐 처리</strong>: 예약된 작업(스케줄된 태스크) 실행</li>
</ol>
<p>이 모델의 핵심 규칙은 <strong>하나의 채널은 항상 같은 이벤트 루프에 바인딩</strong>된다는 것이다. 이로 인해 동기화 없이도 스레드 안전성이 보장된다.</p>
<h3 id="223-httphandler-webhandler-dispatcherhandler">2.2.3 HttpHandler, WebHandler, DispatcherHandler 파이프라인</h3>
<p>Spring WebFlux는 내부적으로 계층화된 핸들러 파이프라인을 구성한다.</p>
<pre class="highlight"><code>[요청 처리 파이프라인]

HTTP 요청
   │
   ▼
┌──────────────┐
│  HttpHandler │  ← 서버 API와 리액티브 스트림의 연결점
│  (최하위 계층) │     Netty, Undertow 등 서버별 어댑터 제공
└──────┬───────┘
       ▼
┌──────────────────┐
│  WebHttpHandler  │  ← HttpHandler를 감싸는 데코레이터
│  Build           │     세션, 코덱, 로케일 등 웹 기능 통합
└──────┬───────────┘
       ▼
┌──────────────────┐
│   WebFilter 체인  │  ← 요청/응답을 가로채는 필터 (인증, 로깅 등)
└──────┬───────────┘
       ▼
┌──────────────────┐
│ WebExceptionHandler │  ← 예외 처리
└──────┬───────────┘
       ▼
┌──────────────────┐
│ DispatcherHandler │  ← 핵심 디스패처 (MVC의 DispatcherServlet 역할)
│  ┌─────────────┐ │
│  │HandlerMapping│ │  → 요청 URL을 핸들러에 매핑
│  └──────┬──────┘ │
│  ┌──────▼──────┐ │
│  │HandlerAdapter│ │  → 핸들러 실행
│  └──────┬──────┘ │
│  ┌──────▼──────┐ │
│  │ResultHandler │ │  → 결과를 HTTP 응답으로 변환
│  └─────────────┘ │
└──────────────────┘</code></pre>
<p><strong>HttpHandler</strong>는 가장 낮은 수준의 계약이다. 단일 메서드 <code>handle(ServerHttpRequest, ServerHttpResponse)</code>를 정의하며, Netty, Undertow, Tomcat(서블릿 3.1+) 등의 서버별 어댑터가 이를 구현한다.</p>
<pre class="highlight"><code class="language-java">public interface HttpHandler {
    Mono&lt;Void&gt; handle(ServerHttpRequest request, ServerHttpResponse response);
}</code></pre>
<p><strong>DispatcherHandler</strong>는 Spring MVC의 <code>DispatcherServlet</code>에 해당하는 중앙 디스패처다. 세 단계로 요청을 처리한다.</p>
<pre class="highlight"><code class="language-java">// DispatcherHandler의 핵심 로직 (간략화)
public Mono&lt;Void&gt; handle(ServerWebExchange exchange) {
    return Flux.fromIterable(this.handlerMappings)       // 1. 핸들러 매핑 탐색
            .concatMap(mapping -&gt; mapping.getHandler(exchange))
            .next()
            .flatMap(handler -&gt; invokeHandler(exchange, handler))  // 2. 핸들러 실행
            .flatMap(result -&gt; handleResult(exchange, result));    // 3. 결과 처리
}</code></pre>
<h3 id="224">2.2.4 요청 처리 흐름</h3>
<p>클라이언트의 HTTP 요청이 WebFlux 애플리케이션에 도달하여 응답이 반환되기까지의 전체 흐름을 정리하면 다음과 같다.</p>
<ol>
<li><strong>Netty가 TCP 연결을 수락</strong>하고 HTTP 요청을 파싱한다.</li>
<li><strong>HttpHandler 어댑터</strong>가 Netty의 요청/응답 객체를 <code>ServerHttpRequest</code>, <code>ServerHttpResponse</code>로 변환한다.</li>
<li><strong>WebHttpHandlerBuilder</strong>가 구성한 필터 체인(<code>WebFilter</code>)이 순서대로 실행된다.</li>
<li><strong>DispatcherHandler</strong>가 <code>HandlerMapping</code>을 통해 적절한 핸들러를 찾는다.</li>
<li><code>RequestMappingHandlerMapping</code>: 어노테이션 기반 핸들러</li>
<li><code>RouterFunctionMapping</code>: 함수형 라우터</li>
<li><strong>HandlerAdapter</strong>가 핸들러를 실행하고 <code>Mono&lt;HandlerResult&gt;</code>를 반환한다.</li>
<li><strong>HandlerResultHandler</strong>가 결과를 HTTP 응답으로 변환하여 클라이언트에 전송한다.</li>
</ol>
<p>모든 단계가 <code>Mono</code>와 <code>Flux</code>로 연결되어 있어 전체 파이프라인이 논블로킹으로 동작한다. 어느 한 단계에서도 스레드를 블로킹하지 않는다는 것이 핵심이다.</p>
<hr>
<h2 id="23-io">2.3 논블로킹 I/O의 원리</h2>
<h3 id="231-io-vs-io">2.3.1 블로킹 I/O vs 논블로킹 I/O</h3>
<p><strong>블로킹 I/O</strong>에서는 <code>read()</code> 또는 <code>write()</code> 호출 시 데이터가 준비될 때까지 호출한 스레드가 대기 상태에 들어간다. 스레드는 아무 일도 하지 못하면서 시스템 리소스를 점유한다.</p>
<pre class="highlight"><code class="language-java">// 블로킹 I/O 예시 (java.io)
try (Socket socket = new Socket("example.com", 80);
     InputStream in = socket.getInputStream()) {

    byte[] buffer = new byte[1024];
    int bytesRead = in.read(buffer);  // ← 데이터가 올 때까지 스레드 블로킹
    // 이 줄은 데이터를 읽을 때까지 실행되지 않는다
    processData(buffer, bytesRead);
}</code></pre>
<pre class="highlight"><code>[블로킹 I/O 타임라인]

Thread-1: ──[read() 호출]──────[대기중...]──────[데이터 수신]──[처리]──▶
                               ↑
                         스레드가 아무 일도 못함</code></pre>
<p><strong>논블로킹 I/O</strong>에서는 <code>read()</code> 호출이 즉시 반환된다. 데이터가 아직 없으면 "아직 없다"는 결과를 반환하고, 스레드는 다른 작업을 수행할 수 있다.</p>
<pre class="highlight"><code class="language-java">// 논블로킹 I/O 예시 (java.nio)
SocketChannel channel = SocketChannel.open();
channel.configureBlocking(false);  // 논블로킹 모드 설정
channel.connect(new InetSocketAddress("example.com", 80));

ByteBuffer buffer = ByteBuffer.allocate(1024);
int bytesRead = channel.read(buffer);  // ← 즉시 반환 (데이터 없으면 0 또는 -1)
// 스레드가 블로킹되지 않으므로 바로 다음 줄 실행</code></pre>
<pre class="highlight"><code>[논블로킹 I/O 타임라인]

Thread-1: ──[read()→0]──[다른작업]──[read()→0]──[다른작업]──[read()→데이터]──[처리]──▶
              ↑             ↑           ↑           ↑
         즉시 반환      유용한 작업   즉시 반환    유용한 작업</code></pre>
<h3 id="232-java-nio-selector">2.3.2 Java NIO와 Selector</h3>
<p>Java NIO(New I/O)의 핵심 컴포넌트인 <strong>Selector</strong>는 하나의 스레드가 여러 채널의 I/O 이벤트를 효율적으로 감시할 수 있게 한다. 운영체제의 <code>epoll</code>(Linux), <code>kqueue</code>(macOS) 시스템 콜을 활용한다.</p>
<pre class="highlight"><code class="language-java">// Java NIO Selector 사용 예시
Selector selector = Selector.open();

// 여러 채널을 셀렉터에 등록
ServerSocketChannel serverChannel = ServerSocketChannel.open();
serverChannel.configureBlocking(false);
serverChannel.bind(new InetSocketAddress(8080));
serverChannel.register(selector, SelectionKey.OP_ACCEPT);

while (true) {
    // I/O 이벤트가 있을 때까지 대기 (효율적인 대기)
    selector.select();

    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();
    Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();

    while (iter.hasNext()) {
        SelectionKey key = iter.next();

        if (key.isAcceptable()) {
            // 새 연결 수락
            SocketChannel client = serverChannel.accept();
            client.configureBlocking(false);
            client.register(selector, SelectionKey.OP_READ);
        } else if (key.isReadable()) {
            // 데이터 읽기 가능
            SocketChannel client = (SocketChannel) key.channel();
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            client.read(buffer);
            // 데이터 처리...
        }

        iter.remove();
    }
}</code></pre>
<pre class="highlight"><code>[Selector 동작 원리]

                    ┌───────────────┐
                    │   Selector    │
                    │   (Thread-1)  │
                    └───┬───┬───┬───┘
                        │   │   │
            ┌───────────┘   │   └───────────┐
            ▼               ▼               ▼
       ┌─────────┐   ┌─────────┐   ┌─────────┐
       │Channel A│   │Channel B│   │Channel C│
       │ (READ)  │   │ (WRITE) │   │ (READ)  │
       └─────────┘   └─────────┘   └─────────┘

  하나의 스레드가 select()를 호출하면:
  → 운영체제가 준비된 채널만 알려줌 (예: A와 C)
  → 스레드가 A와 C만 처리 (불필요한 폴링 없음)</code></pre>
<h3 id="233">2.3.3 이벤트 루프의 동작 방식</h3>
<p>Netty의 이벤트 루프는 Java NIO의 Selector를 기반으로 하되, 더 정교한 태스크 스케줄링과 파이프라인 처리를 추가한 것이다.</p>
<p>이벤트 루프의 한 사이클(iteration)은 다음과 같다.</p>
<pre class="highlight"><code>[이벤트 루프 사이클]

┌─────────────────────────────────────────────┐
│                Event Loop                    │
│                                              │
│  1. select()  ─── I/O 이벤트 감지            │
│       │                                      │
│       ▼                                      │
│  2. processSelectedKeys() ─── I/O 처리       │
│       │    (데이터 읽기/쓰기, 연결 수락)       │
│       ▼                                      │
│  3. runAllTasks() ─── 태스크 큐 처리          │
│       │    (사용자가 제출한 작업, 타이머 등)    │
│       │                                      │
│       └──────── 반복 ────────────────────────│
└─────────────────────────────────────────────┘</code></pre>
<p>중요한 원칙: <strong>이벤트 루프 스레드에서 블로킹 작업을 절대 수행하면 안 된다.</strong> 하나의 이벤트 루프가 수천 개의 연결을 담당하므로, 해당 스레드가 블로킹되면 수천 개의 연결이 동시에 지연된다.</p>
<pre class="highlight"><code class="language-java">// 절대 하면 안 되는 코드 (이벤트 루프에서 블로킹)
@GetMapping("/bad-example")
public Mono&lt;String&gt; badExample() {
    Thread.sleep(1000);  // 이벤트 루프 스레드를 1초간 블로킹!
    return Mono.just("이렇게 하면 안 됩니다");
}

// 올바른 코드 (논블로킹)
@GetMapping("/good-example")
public Mono&lt;String&gt; goodExample() {
    return Mono.delay(Duration.ofSeconds(1))  // 논블로킹 대기
            .then(Mono.just("논블로킹으로 1초 후 응답"));
}</code></pre>
<p>블로킹이 불가피한 경우에는 별도의 스케줄러로 작업을 위임해야 한다.</p>
<pre class="highlight"><code class="language-java">// 블로킹이 불가피한 경우 - 별도 스케줄러 사용
@GetMapping("/blocking-needed")
public Mono&lt;String&gt; blockingNeeded() {
    return Mono.fromCallable(() -&gt; {
                // 블로킹 API 호출 (예: 레거시 JDBC)
                return legacyService.queryDatabase();
            })
            .subscribeOn(Schedulers.boundedElastic());  // 블로킹 전용 스레드 풀
}</code></pre>
<hr>
<h2 id="24-webflux">2.4 WebFlux를 선택해야 하는 경우와 그렇지 않은 경우</h2>
<h3 id="241-webflux">2.4.1 WebFlux가 적합한 시나리오</h3>
<p><strong>1. 높은 동시성이 요구되는 I/O 바운드 애플리케이션</strong></p>
<p>마이크로서비스 게이트웨이, API 중개 서비스처럼 다수의 외부 서비스를 호출하고 결과를 조합하는 경우에 WebFlux가 빛을 발한다.</p>
<pre class="highlight"><code class="language-java">// 여러 외부 서비스를 동시에 호출하여 결과 조합
public Mono&lt;DashboardData&gt; getDashboard(String userId) {
    Mono&lt;UserProfile&gt; profile = userService.getProfile(userId);
    Mono&lt;List&lt;Order&gt;&gt; orders = orderService.getOrders(userId);
    Mono&lt;List&lt;Notification&gt;&gt; notifications = notificationService.get(userId);

    return Mono.zip(profile, orders, notifications)
            .map(tuple -&gt; new DashboardData(
                    tuple.getT1(),
                    tuple.getT2(),
                    tuple.getT3()
            ));
    // 세 호출이 동시에 실행되어 전체 응답 시간 단축
}</code></pre>
<p><strong>2. 실시간 스트리밍 애플리케이션</strong></p>
<p>SSE(Server-Sent Events), WebSocket을 활용한 실시간 데이터 스트리밍에 WebFlux의 <code>Flux</code>가 자연스럽게 대응한다.</p>
<pre class="highlight"><code class="language-java">// 실시간 주가 스트리밍
@GetMapping(value = "/stocks/{symbol}/stream",
            produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;StockPrice&gt; streamStockPrice(@PathVariable String symbol) {
    return stockService.getPriceStream(symbol);  // 무한 스트림
}</code></pre>
<p><strong>3. 대량의 동시 연결을 유지해야 하는 경우</strong></p>
<p>채팅 서비스, 알림 시스템처럼 수천~수만 개의 커넥션을 장시간 유지해야 하는 경우, 스레드-퍼-리퀘스트 모델은 메모리 한계에 금방 도달한다.</p>
<p><strong>4. 전체 파이프라인이 리액티브인 경우</strong></p>
<p>데이터베이스(MongoDB Reactive, R2DBC), 메시지 브로커(Reactor Kafka, Reactor RabbitMQ), HTTP 클라이언트(WebClient) 모두 리액티브 드라이버를 사용할 수 있을 때 WebFlux의 이점이 극대화된다.</p>
<h3 id="242-webflux">2.4.2 WebFlux가 부적합한 시나리오</h3>
<p><strong>1. JDBC/JPA(관계형 DB) 블로킹 드라이버를 사용하는 경우</strong></p>
<p>전통적인 JDBC나 Spring Data JPA는 블로킹 API다. WebFlux 위에서 사용하면 이벤트 루프를 블로킹하게 되어 오히려 성능이 저하된다. R2DBC가 대안이지만, JPA의 풍부한 기능(지연 로딩, 캐시 등)을 포기해야 한다.</p>
<p><strong>2. CPU 집약적인 작업이 대부분인 경우</strong></p>
<p>이미지 처리, 복잡한 계산, 암호화 등 CPU를 장시간 사용하는 작업에서는 논블로킹 I/O의 이점이 없다. 오히려 리액티브 프로그래밍의 복잡성만 추가된다.</p>
<p><strong>3. 팀의 리액티브 프로그래밍 경험이 부족한 경우</strong></p>
<p>리액티브 프로그래밍은 학습 곡선이 가파르다. 디버깅이 어렵고, 기존의 명령형 사고방식과 근본적으로 다른 접근이 필요하다. 팀 전체가 충분히 준비되지 않은 상태에서 도입하면 생산성이 크게 떨어질 수 있다.</p>
<p><strong>4. 동시 요청 수가 적은 내부 관리 도구</strong></p>
<p>동시 사용자가 수십 명 수준인 백오피스 시스템에서는 Spring MVC가 충분하며, WebFlux를 도입할 이유가 없다.</p>
<h3 id="243">2.4.3 의사결정 기준</h3>
<p>다음 체크리스트를 통해 WebFlux 도입 여부를 판단할 수 있다.</p>
<pre class="highlight"><code>[WebFlux 도입 의사결정 흐름]

높은 동시성(수천 이상)이 필요한가?
  ├── 아니오 → Spring MVC 사용
  └── 예
       │
       전체 I/O 파이프라인이 논블로킹 가능한가?
       (DB, 메시지 큐, 외부 API 등)
         ├── 아니오 → Spring MVC 사용 (또는 부분적 리액티브)
         └── 예
              │
              팀이 리액티브 프로그래밍에 익숙한가?
                ├── 아니오 → 학습 기간 확보 후 도입 검토
                └── 예 → Spring WebFlux 사용</code></pre>
<hr>
<h2 id="25-webflux">2.5 WebFlux의 두 가지 프로그래밍 모델</h2>
<p>Spring WebFlux는 두 가지 프로그래밍 모델을 제공한다. 어노테이션 기반 모델과 함수형 엔드포인트 모델이다. 두 모델은 동일한 리액티브 런타임 위에서 동작하며, 하나의 애플리케이션 내에서 혼용할 수도 있다.</p>
<h3 id="251">2.5.1 어노테이션 기반 모델</h3>
<p>Spring MVC를 사용해본 개발자에게 가장 친숙한 방식이다. <code>@Controller</code>, <code>@RestController</code>, <code>@RequestMapping</code> 등의 어노테이션을 그대로 사용하되, 반환 타입이 <code>Mono</code>와 <code>Flux</code>로 바뀐다.</p>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/products")
public class ProductController {

    private final ProductService productService;

    public ProductController(ProductService productService) {
        this.productService = productService;
    }

    /**
     * 단일 상품 조회
     */
    @GetMapping("/{id}")
    public Mono&lt;ResponseEntity&lt;Product&gt;&gt; getProduct(@PathVariable String id) {
        return productService.findById(id)
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * 전체 상품 목록 조회
     */
    @GetMapping
    public Flux&lt;Product&gt; getAllProducts(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        return productService.findAll(page, size);
    }

    /**
     * 상품 생성
     */
    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono&lt;Product&gt; createProduct(@Valid @RequestBody Product product) {
        return productService.save(product);
    }

    /**
     * 상품 수정
     */
    @PutMapping("/{id}")
    public Mono&lt;ResponseEntity&lt;Product&gt;&gt; updateProduct(
            @PathVariable String id,
            @Valid @RequestBody Product product) {
        return productService.update(id, product)
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * 상품 삭제
     */
    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public Mono&lt;Void&gt; deleteProduct(@PathVariable String id) {
        return productService.deleteById(id);
    }

    /**
     * 카테고리별 상품 스트리밍 (SSE)
     */
    @GetMapping(value = "/stream/category/{category}",
                produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux&lt;Product&gt; streamByCategory(@PathVariable String category) {
        return productService.findByCategoryStream(category);
    }
}</code></pre>
<p>서비스 계층도 함께 살펴보자.</p>
<pre class="highlight"><code class="language-java">@Service
public class ProductService {

    private final ProductRepository productRepository;

    public ProductService(ProductRepository productRepository) {
        this.productRepository = productRepository;
    }

    public Mono&lt;Product&gt; findById(String id) {
        return productRepository.findById(id);
    }

    public Flux&lt;Product&gt; findAll(int page, int size) {
        return productRepository.findAll()
                .skip((long) page * size)
                .take(size);
    }

    public Mono&lt;Product&gt; save(Product product) {
        product.setCreatedAt(LocalDateTime.now());
        return productRepository.save(product);
    }

    public Mono&lt;Product&gt; update(String id, Product product) {
        return productRepository.findById(id)
                .flatMap(existing -&gt; {
                    existing.setName(product.getName());
                    existing.setPrice(product.getPrice());
                    existing.setUpdatedAt(LocalDateTime.now());
                    return productRepository.save(existing);
                });
    }

    public Mono&lt;Void&gt; deleteById(String id) {
        return productRepository.deleteById(id);
    }

    public Flux&lt;Product&gt; findByCategoryStream(String category) {
        return productRepository.findByCategory(category);
    }
}</code></pre>
<h3 id="252">2.5.2 함수형 엔드포인트 모델</h3>
<p>함수형 모델은 라우팅과 핸들러를 프로그래밍 방식으로 정의한다. <code>RouterFunction</code>이 라우팅 규칙을 정의하고, <code>HandlerFunction</code>이 요청을 처리한다.</p>
<p><strong>핸들러(Handler):</strong></p>
<pre class="highlight"><code class="language-java">@Component
public class ProductHandler {

    private final ProductService productService;

    public ProductHandler(ProductService productService) {
        this.productService = productService;
    }

    /**
     * 단일 상품 조회
     */
    public Mono&lt;ServerResponse&gt; getProduct(ServerRequest request) {
        String id = request.pathVariable("id");
        return productService.findById(id)
                .flatMap(product -&gt; ServerResponse.ok()
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(product))
                .switchIfEmpty(ServerResponse.notFound().build());
    }

    /**
     * 전체 상품 목록 조회
     */
    public Mono&lt;ServerResponse&gt; getAllProducts(ServerRequest request) {
        int page = request.queryParam("page")
                .map(Integer::parseInt).orElse(0);
        int size = request.queryParam("size")
                .map(Integer::parseInt).orElse(20);

        Flux&lt;Product&gt; products = productService.findAll(page, size);
        return ServerResponse.ok()
                .contentType(MediaType.APPLICATION_JSON)
                .body(products, Product.class);
    }

    /**
     * 상품 생성
     */
    public Mono&lt;ServerResponse&gt; createProduct(ServerRequest request) {
        return request.bodyToMono(Product.class)
                .flatMap(productService::save)
                .flatMap(saved -&gt; ServerResponse
                        .created(URI.create("/api/products/" + saved.getId()))
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(saved));
    }

    /**
     * 상품 수정
     */
    public Mono&lt;ServerResponse&gt; updateProduct(ServerRequest request) {
        String id = request.pathVariable("id");
        return request.bodyToMono(Product.class)
                .flatMap(product -&gt; productService.update(id, product))
                .flatMap(updated -&gt; ServerResponse.ok()
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(updated))
                .switchIfEmpty(ServerResponse.notFound().build());
    }

    /**
     * 상품 삭제
     */
    public Mono&lt;ServerResponse&gt; deleteProduct(ServerRequest request) {
        String id = request.pathVariable("id");
        return productService.deleteById(id)
                .then(ServerResponse.noContent().build());
    }
}</code></pre>
<p><strong>라우터(Router):</strong></p>
<pre class="highlight"><code class="language-java">@Configuration
public class ProductRouter {

    @Bean
    public RouterFunction&lt;ServerResponse&gt; productRoutes(ProductHandler handler) {
        return RouterFunctions.route()
                .path("/api/products", builder -&gt; builder
                        .GET("/{id}", handler::getProduct)
                        .GET("", handler::getAllProducts)
                        .POST("", handler::createProduct)
                        .PUT("/{id}", handler::updateProduct)
                        .DELETE("/{id}", handler::deleteProduct)
                )
                .build();
    }
}</code></pre>
<p>여러 도메인의 라우터를 조합할 수도 있다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class AppRouter {

    @Bean
    public RouterFunction&lt;ServerResponse&gt; allRoutes(
            ProductHandler productHandler,
            OrderHandler orderHandler,
            UserHandler userHandler) {

        return RouterFunctions.route()
                .path("/api/products", builder -&gt; builder
                        .GET("/{id}", productHandler::getProduct)
                        .GET("", productHandler::getAllProducts)
                        .POST("", productHandler::createProduct)
                )
                .path("/api/orders", builder -&gt; builder
                        .GET("/{id}", orderHandler::getOrder)
                        .GET("", orderHandler::getAllOrders)
                        .POST("", orderHandler::createOrder)
                )
                .path("/api/users", builder -&gt; builder
                        .GET("/{id}", userHandler::getUser)
                        .POST("", userHandler::createUser)
                )
                .filter((request, next) -&gt; {
                    // 공통 필터: 요청 로깅
                    System.out.println("Request: " + request.method()
                            + " " + request.path());
                    return next.handle(request);
                })
                .build();
    }
}</code></pre>
<h3 id="253">2.5.3 두 모델의 비교와 선택 기준</h3>
<table>
<thead>
<tr>
<th>기준</th>
<th>어노테이션 기반</th>
<th>함수형 엔드포인트</th>
</tr>
</thead>
<tbody>
<tr>
<td>학습 비용</td>
<td>낮음 (MVC 경험 활용)</td>
<td>중간 (새로운 API 학습 필요)</td>
</tr>
<tr>
<td>코드 스타일</td>
<td>선언적 (어노테이션)</td>
<td>프로그래밍 방식 (코드로 라우팅)</td>
</tr>
<tr>
<td>라우팅 유연성</td>
<td>제한적</td>
<td>매우 유연 (조건부 라우팅 등)</td>
</tr>
<tr>
<td>테스트</td>
<td><code>@WebFluxTest</code></td>
<td>순수 단위 테스트 용이</td>
</tr>
<tr>
<td>검증</td>
<td><code>@Valid</code> 자동 적용</td>
<td>수동으로 검증 로직 작성</td>
</tr>
<tr>
<td>IDE 지원</td>
<td>우수 (자동완성, 네비게이션)</td>
<td>보통</td>
</tr>
<tr>
<td>한 파일 응집도</td>
<td>낮음 (라우팅이 분산)</td>
<td>높음 (한 곳에서 라우팅 파악)</td>
</tr>
</tbody>
</table>
<p><strong>어노테이션 기반을 선택하는 경우:</strong></p>
<ul>
<li>기존 Spring MVC 경험이 있는 팀</li>
<li>빠른 개발 속도가 중요한 프로젝트</li>
<li>표준적인 CRUD API를 구현하는 경우</li>
<li>Bean Validation을 적극 활용하는 경우</li>
</ul>
<p><strong>함수형 엔드포인트를 선택하는 경우:</strong></p>
<ul>
<li>라우팅 규칙이 복잡하거나 동적인 경우</li>
<li>경량 마이크로서비스에서 최소한의 프레임워크 의존이 필요한 경우</li>
<li>함수형 프로그래밍 스타일을 선호하는 팀</li>
<li>테스트에서 스프링 컨텍스트 없이 핸들러를 단위 테스트하고 싶은 경우</li>
</ul>
<p>실무에서는 어노테이션 기반 모델이 더 널리 사용된다. Spring MVC에서의 전환 비용이 낮고, 대부분의 팀이 이미 익숙하기 때문이다. 함수형 모델은 특수한 라우팅 요구사항이 있거나, 팀이 함수형 스타일에 익숙한 경우에 선택하면 좋다.</p>
<hr>
<h2 id="_1">정리</h2>
<p>이 장에서 다룬 핵심 내용을 요약하면 다음과 같다.</p>
<ul>
<li><strong>Spring MVC vs WebFlux</strong>: MVC는 서블릿 기반 thread-per-request 모델이고, WebFlux는 이벤트 루프 기반 논블로킹 모델이다. WebFlux는 높은 동시성에서 적은 리소스로 안정적인 처리량을 유지한다.</li>
<li><strong>Netty와 이벤트 루프</strong>: WebFlux의 기본 런타임인 Netty는 이벤트 루프 모델을 통해 소수의 스레드로 수만 개의 동시 연결을 처리한다. 이벤트 루프 스레드를 블로킹하면 안 된다.</li>
<li><strong>논블로킹 I/O</strong>: Java NIO의 Selector를 활용하여 하나의 스레드가 여러 채널의 I/O를 효율적으로 관리한다. 데이터가 준비될 때만 처리하므로 스레드 낭비가 없다.</li>
<li><strong>도입 판단 기준</strong>: 높은 동시성, 리액티브 파이프라인, 팀 역량의 세 조건이 모두 충족될 때 WebFlux를 선택한다.</li>
<li><strong>두 가지 프로그래밍 모델</strong>: 어노테이션 기반은 MVC 경험을 활용할 수 있어 접근성이 높고, 함수형 모델은 라우팅의 유연성과 테스트 용이성에서 장점이 있다.</li>
</ul>
<p>다음 장에서는 WebFlux의 핵심 기반인 <strong>Project Reactor</strong>를 깊이 있게 다룬다. <code>Mono</code>와 <code>Flux</code>의 동작 원리, 주요 연산자, 에러 처리 전략 등을 살펴볼 것이다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>