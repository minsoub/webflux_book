<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 2. Spring WebFlux 개요 | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="ch01.html">&larr; Chapter 1. 리액티브 프로그래밍 소개</a>
    <a href="../index.html">목차</a>
    <a href="ch03.html">Chapter 3. Project Reactor 핵심 &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-2-spring-webflux">Chapter 2. Spring WebFlux 개요</h1>
<p>Spring WebFlux는 Spring Framework 5에서 도입된 리액티브 웹 프레임워크다. 기존 Spring MVC가 서블릿 기반의 동기/블로킹 모델 위에 구축되었다면, WebFlux는 논블로킹 I/O와 리액티브 스트림을 기반으로 완전히 다르게 설계되었다. 이제 WebFlux의 아키텍처를 들여다보고, 내부가 어떻게 움직이는지, 그리고 실제로 이것을 써야 할 때는 언제인지 함께 살펴보자.</p>
<hr>
<h2 id="21-spring-mvc-spring-webflux">2.1 Spring MVC와 Spring WebFlux 비교</h2>
<h3 id="211-vs">2.1.1 아키텍처 차이: 서블릿 스택 vs 리액티브 스택</h3>
<p>Spring MVC는 Java Servlet API 위에 구축되어 있다. 클라이언트의 요청이 들어오면 서블릿 컨테이너(Tomcat, Jetty 등)는 스레드 풀에서 하나의 스레드를 할당하고, 그 스레드가 요청의 처음부터 끝까지 계속 담당하게 된다. 이 방식을 <strong>thread-per-request</strong> 모델이라고 부르는데, 이름 그대로 요청 하나당 스레드 하나씩 배치하는 것이다.</p>
<p><code>[Spring MVC 스택]
┌─────────────────────┐
│   Servlet Container  │  (Tomcat, Jetty)
│   ┌───────────────┐  │
│   │ DispatcherServlet │
│   │   ┌─────────┐ │  │
│   │   │ Handler  │ │  │
│   │   │ Mapping  │ │  │
│   │   └─────────┘ │  │
│   │   ┌─────────┐ │  │
│   │   │Controller│ │  │
│   │   └─────────┘ │  │
│   └───────────────┘  │
│   Servlet API        │
│   (Blocking I/O)     │
└─────────────────────┘</code></p>
<p>반면 Spring WebFlux는 리액티브 스택 위에서 완전히 다르게 구축되어 있다. 서블릿 API에는 의존하지 않으며, 기본 런타임으로 Netty를 사용한다. 핵심은 소수의 이벤트 루프 스레드가 많은 요청들을 논블로킹 방식으로 효율적으로 처리할 수 있다는 점이다.</p>
<p><code>[Spring WebFlux 스택]
┌─────────────────────┐
│   Reactive Runtime   │  (Netty, Undertow)
│   ┌───────────────┐  │
│   │DispatcherHandler│
│   │   ┌─────────┐ │  │
│   │   │ Handler  │ │  │
│   │   │ Mapping  │ │  │
│   │   └─────────┘ │  │
│   │   ┌─────────┐ │  │
│   │   │Controller│ │  │
│   │   │   or     │ │  │
│   │   │RouterFunc│ │  │
│   │   └─────────┘ │  │
│   └───────────────┘  │
│   Reactive Streams   │
│   (Non-Blocking I/O) │
└─────────────────────┘</code></p>
<h3 id="212">2.1.2 스레드 모델 차이</h3>
<p><strong>Spring MVC</strong>의 스레드 모델은 직관적이긴 하지만 자원 측면에서는 비효율적이다. 동시에 200개의 요청을 처리하려면 최소 200개의 스레드를 준비해야 한다. 문제는 각 스레드가 데이터베이스 응답을 기다리는 동안에도 계속 점유되고 있다는 기 때문이다.</p>
<p>```
[Spring MVC - Thread-per-Request]</p>
<p>요청 A ──▶ Thread-1: [수신]──[처리]──[DB 대기...]──[응답]──▶ 완료
요청 B ──▶ Thread-2: [수신]──[처리]──[DB 대기...]──[응답]──▶ 완료
요청 C ──▶ Thread-3: [수신]──[처리]──[DB 대기...]──[응답]──▶ 완료
  ...
요청 N ──▶ Thread-N: (스레드 풀 고갈 → 대기 큐에서 대기)
```</p>
<p><strong>Spring WebFlux</strong>는 이벤트 루프 방식을 채택했기 때문에 상황이 완전히 달라진다. CPU 코어 수 정도의 적은 스레드(기본적으로 코어 수 x 1)가 모든 요청을 논블로킹으로 처리할 수 있다. I/O 대기 시간 동안 해당 스레드가 다른 요청을 처리하면 되기 때문이다.</p>
<p>```
[Spring WebFlux - Event Loop]</p>
<p>EventLoop-1: [요청A 수신]─[요청B 수신]─[요청A DB콜백]─[요청C 수신]─[요청B DB콜백]─...
EventLoop-2: [요청D 수신]─[요청E 수신]─[요청D DB콜백]─[요청F 수신]─[요청E DB콜백]─...
```</p>
<p><strong>처리량과 지연 시간 비교</strong></p>
<table>
<thead>
<tr>
<th>항목</th>
<th>Spring MVC</th>
<th>Spring WebFlux</th>
</tr>
</thead>
<tbody>
<tr>
<td>동시 연결 수</td>
<td>스레드 풀 크기에 제한 (보통 200~500)</td>
<td>수만 개 이상 동시 연결 가능</td>
</tr>
<tr>
<td>스레드 수</td>
<td>요청 수에 비례</td>
<td>CPU 코어 수에 비례 (고정)</td>
</tr>
<tr>
<td>메모리 사용</td>
<td>스레드당 약 512KB~1MB 스택</td>
<td>적은 스레드로 메모리 효율적</td>
</tr>
<tr>
<td>I/O 바운드 작업</td>
<td>대기 중 스레드 낭비</td>
<td>대기 중 다른 작업 처리</td>
</tr>
<tr>
<td>CPU 바운드 작업</td>
<td>효율적</td>
<td>이점 없음 (오히려 복잡성 증가)</td>
</tr>
<tr>
<td>지연 시간</td>
<td>부하 낮을 때 약간 유리</td>
<td>부하 높을 때 안정적</td>
</tr>
<tr>
<td>최대 처리량</td>
<td>스레드 풀 포화 시 급감</td>
<td>일정하게 유지</td>
</tr>
</tbody>
</table>
<h3 id="213">2.1.3 코드 스타일 비교</h3>
<p>이를 직관적으로 이해하기 위해, 사용자를 조회하는 간단한 API를 두 가지 방식으로 구현해서 비교해보면 좋다.</p>
<p><strong>Spring MVC 방식:</strong></p>
<p>```java
@RestController
@RequestMapping("/api/users")
public class UserController {</p>
<pre><code>private final UserService userService;

public UserController(UserService userService) {
    this.userService = userService;
}

@GetMapping("/{id}")
public ResponseEntity&lt;User&gt; getUser(@PathVariable String id) {
    User user = userService.findById(id);  // 블로킹 호출
    if (user == null) {
        return ResponseEntity.notFound().build();
    }
    return ResponseEntity.ok(user);
}

@GetMapping
public ResponseEntity&lt;List&lt;User&gt;&gt; getAllUsers() {
    List&lt;User&gt; users = userService.findAll();  // 블로킹 호출
    return ResponseEntity.ok(users);
}

@PostMapping
public ResponseEntity&lt;User&gt; createUser(@RequestBody User user) {
    User saved = userService.save(user);  // 블로킹 호출
    return ResponseEntity
            .created(URI.create("/api/users/" + saved.getId()))
            .body(saved);
}
</code></pre>
<p>}
```</p>
<p><strong>Spring WebFlux 방식:</strong></p>
<p>```java
@RestController
@RequestMapping("/api/users")
public class UserController {</p>
<pre><code>private final UserService userService;

public UserController(UserService userService) {
    this.userService = userService;
}

@GetMapping("/{id}")
public Mono&lt;ResponseEntity&lt;User&gt;&gt; getUser(@PathVariable String id) {
    return userService.findById(id)                    // 논블로킹 호출
            .map(user -&gt; ResponseEntity.ok(user))
            .defaultIfEmpty(ResponseEntity.notFound().build());
}

@GetMapping
public Flux&lt;User&gt; getAllUsers() {
    return userService.findAll();  // 논블로킹, 스트리밍 가능
}

@PostMapping
public Mono&lt;ResponseEntity&lt;User&gt;&gt; createUser(@RequestBody User user) {
    return userService.save(user)                      // 논블로킹 호출
            .map(saved -&gt; ResponseEntity
                    .created(URI.create("/api/users/" + saved.getId()))
                    .body(saved));
}
</code></pre>
<p>}
```</p>
<p>두 방식의 핵심 차이를 표로 정리해보면 이렇다.</p>
<table>
<thead>
<tr>
<th>구분</th>
<th>Spring MVC</th>
<th>Spring WebFlux</th>
</tr>
</thead>
<tbody>
<tr>
<td>반환 타입</td>
<td><code>User</code>, <code>List&lt;User&gt;</code></td>
<td><code>Mono&lt;User&gt;</code>, <code>Flux&lt;User&gt;</code></td>
</tr>
<tr>
<td>실행 방식</td>
<td>메서드 호출 시 즉시 실행</td>
<td>구독(subscribe) 시 실행</td>
</tr>
<tr>
<td>데이터 흐름</td>
<td>동기적, 순차적</td>
<td>비동기적, 이벤트 기반</td>
</tr>
<tr>
<td>에러 처리</td>
<td>try-catch</td>
<td><code>onErrorResume</code>, <code>onErrorReturn</code></td>
</tr>
<tr>
<td>기본 서버</td>
<td>Tomcat</td>
<td>Netty</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="22-webflux-netty">2.2 WebFlux의 내부 구조와 Netty</h2>
<h3 id="221-netty">2.2.1 Netty란 무엇인가</h3>
<p>Netty는 JVM에서 동작하는 비동기 이벤트 기반 네트워크 프레임워크다. 고성능 프로토콜 서버와 클라이언트를 빠르게 구축할 수 있도록 설계되었으며, HTTP부터 WebSocket, TCP, UDP에 이르기까지 다양한 프로토콜을 모두 지원한다.</p>
<p>Spring WebFlux가 Netty를 기본 런타임으로 선택한 이유는 다음 몇 가지로 요약할 수 있다.</p>
<ul>
<li><strong>논블로킹 I/O</strong>: Java NIO 기반으로 소수 스레드로 대량의 동시 연결 처리</li>
<li><strong>이벤트 루프 모델</strong>: 효율적인 리소스 활용과 높은 동시성</li>
<li><strong>검증된 안정성</strong>: Discord, Apple, Netflix 등 대규모 서비스에서 검증</li>
<li><strong>풍부한 프로토콜 지원</strong>: HTTP/1.1, HTTP/2, WebSocket 기본 지원</li>
</ul>
<h3 id="222-event-loop">2.2.2 이벤트 루프(Event Loop) 모델</h3>
<p>Netty의 이벤트 루프가 정말 핵심인데, 아주 간단히 말하면 하나의 스레드가 <strong>셀렉터(Selector)</strong>라는 도구를 사용해서 여러 채널(연결)의 I/O 이벤트를 감시하고 처리하는 구조다.</p>
<p>```
[Netty 이벤트 루프 구조]</p>
<pre><code>              ┌──────────────────────────────┐
              │       EventLoopGroup          │
              │  (Boss Group - 연결 수락)      │
              │  ┌────────────────────────┐   │
              │  │ EventLoop (Thread-1)   │   │
              │  │  → 새 연결 수락(accept)  │   │
              │  └────────────────────────┘   │
              └──────────┬───────────────────┘
                         │ 연결을 Worker에 등록
              ┌──────────▼───────────────────┐
              │       EventLoopGroup          │
              │  (Worker Group - I/O 처리)     │
              │  ┌────────────────────────┐   │
              │  │ EventLoop-1 (Thread)   │   │
              │  │  채널 A, D, G 담당      │   │
              │  └────────────────────────┘   │
              │  ┌────────────────────────┐   │
              │  │ EventLoop-2 (Thread)   │   │
              │  │  채널 B, E, H 담당      │   │
              │  └────────────────────────┘   │
              │  ┌────────────────────────┐   │
              │  │ EventLoop-N (Thread)   │   │
              │  │  채널 C, F, I 담당      │   │
              │  └────────────────────────┘   │
              └──────────────────────────────┘
</code></pre>
<p>```</p>
<p>각 이벤트 루프 스레드는 다음 세 가지를 계속 반복한다.</p>
<ol>
<li><strong>Selector로 I/O 이벤트 대기</strong>: 등록된 채널 중에 읽거나 쓸 준비가 된 채널이 있는지 확인한다</li>
<li><strong>이벤트 처리</strong>: 준비된 채널에서 데이터를 읽거나 쓴다</li>
<li><strong>태스크 큐 처리</strong>: 예약되어 있던 작업들(스케줄된 태스크)을 실행한다</li>
</ol>
<p>이 모델에서 기억할 핵심 원칙이 하나 있다. <strong>하나의 채널은 항상 같은 이벤트 루프에 연결</strong>된다는 것인데, 덕분에 복잡한 동기화 코드 없이도 스레드 안전성이 자동으로 보장될 수 있다.</p>
<h3 id="223-httphandler-webhandler-dispatcherhandler">2.2.3 HttpHandler, WebHandler, DispatcherHandler 파이프라인</h3>
<p>Spring WebFlux의 내부는 여러 계층의 핸들러들이 마치 우편 처리 시스템처럼 서로 연쇄되어 있다.</p>
<p>```
[요청 처리 파이프라인]</p>
<p>HTTP 요청
   │
   ▼
┌──────────────┐
│  HttpHandler │  ← 서버 API와 리액티브 스트림의 연결점
│  (최하위 계층) │     Netty, Undertow 등 서버별 어댑터 제공
└──────┬───────┘
       ▼
┌──────────────────┐
│  WebHttpHandler  │  ← HttpHandler를 감싸는 데코레이터
│  Build           │     세션, 코덱, 로케일 등 웹 기능 통합
└──────┬───────────┘
       ▼
┌──────────────────┐
│   WebFilter 체인  │  ← 요청/응답을 가로채는 필터 (인증, 로깅 등)
└──────┬───────────┘
       ▼
┌──────────────────┐
│ WebExceptionHandler │  ← 예외 처리
└──────┬───────────┘
       ▼
┌──────────────────┐
│ DispatcherHandler │  ← 핵심 디스패처 (MVC의 DispatcherServlet 역할)
│  ┌─────────────┐ │
│  │HandlerMapping│ │  → 요청 URL을 핸들러에 매핑
│  └──────┬──────┘ │
│  ┌──────▼──────┐ │
│  │HandlerAdapter│ │  → 핸들러 실행
│  └──────┬──────┘ │
│  ┌──────▼──────┐ │
│  │ResultHandler │ │  → 결과를 HTTP 응답으로 변환
│  └─────────────┘ │
└──────────────────┘
```</p>
<p><strong>HttpHandler</strong>는 가장 기본적인 계약(interface)다. 실은 <code>handle(ServerHttpRequest, ServerHttpResponse)</code> 하나의 메서드만 정의하고 있는데, Netty나 Undertow, Tomcat(서블릿 3.1+) 같은 각 서버마다 이를 구현하는 어댑터를 두고 있다.</p>
<p><code>java
public interface HttpHandler {
    Mono&lt;Void&gt; handle(ServerHttpRequest request, ServerHttpResponse response);
}</code></p>
<p><strong>DispatcherHandler</strong>는 Spring MVC의 <code>DispatcherServlet</code>을 리액티브 방식으로 다시 구현한 것이라고 보면 된다. 요청을 세 단계로 나누어 처리한다.</p>
<p><code>java
// DispatcherHandler의 핵심 로직 (간략화)
public Mono&lt;Void&gt; handle(ServerWebExchange exchange) {
    return Flux.fromIterable(this.handlerMappings)       // 1. 핸들러 매핑 탐색
            .concatMap(mapping -&gt; mapping.getHandler(exchange))
            .next()
            .flatMap(handler -&gt; invokeHandler(exchange, handler))  // 2. 핸들러 실행
            .flatMap(result -&gt; handleResult(exchange, result));    // 3. 결과 처리
}</code></p>
<h3 id="224">2.2.4 요청 처리 흐름</h3>
<p>이제 클라이언트의 HTTP 요청이 들어와서 응답이 나갈 때까지 전체 여정을 따라가보자.</p>
<ol>
<li><strong>Netty가 TCP 연결을 수락</strong>한 다음 HTTP 요청을 파싱한다.</li>
<li><strong>HttpHandler 어댑터</strong>가 Netty의 네이티브 객체들을 Spring 표준인 <code>ServerHttpRequest</code>, <code>ServerHttpResponse</code>로 변환해준다.</li>
<li><strong>WebHttpHandlerBuilder</strong>가 구성한 필터 체인(<code>WebFilter</code>)이 순차적으로 실행되어 요청/응답을 가로챈다 (인증, 로깅 등).</li>
<li><strong>DispatcherHandler</strong>가 <code>HandlerMapping</code>을 통해 해당 요청을 처리할 적절한 핸들러를 찾아낸다.</li>
<li><code>RequestMappingHandlerMapping</code>: 어노테이션 기반 핸들러 찾기 (<code>@GetMapping</code> 등)</li>
<li><code>RouterFunctionMapping</code>: 함수형 라우터 찾기</li>
<li><strong>HandlerAdapter</strong>가 찾은 핸들러를 실제로 실행하고 <code>Mono&lt;HandlerResult&gt;</code>를 반환한다.</li>
<li><strong>HandlerResultHandler</strong>가 그 결과를 HTTP 응답으로 변환해서 클라이언트에 전송한다.</li>
</ol>
<p>중요한 것은 모든 단계가 <code>Mono</code>와 <code>Flux</code>로 연쇄되어 있다는 기 때문이다. 덕분에 전체 파이프라인이 논블로킹으로 동작할 수 있다. 어느 단계도 스레드를 블로킹하지 않으면서 처리를 완료한다.</p>
<hr>
<h2 id="23-io">2.3 논블로킹 I/O의 원리</h2>
<h3 id="231-io-vs-io">2.3.1 블로킹 I/O vs 논블로킹 I/O</h3>
<p><strong>블로킹 I/O</strong>는 직관적이지만 비효율적이다. <code>read()</code> 또는 <code>write()</code> 호출 시 데이터가 준비될 때까지 호출한 스레드는 대기 상태에 빠진다. 이 동안 그 스레드는 아무 일도 못하면서 메모리와 스택 공간만 계속 차지한다.</p>
<p>```java
// 블로킹 I/O 예시 (java.io)
try (Socket socket = new Socket("example.com", 80);
     InputStream in = socket.getInputStream()) {</p>
<pre><code>byte[] buffer = new byte[1024];
int bytesRead = in.read(buffer);  // ← 데이터가 올 때까지 스레드 블로킹
// 이 줄은 데이터를 읽을 때까지 실행되지 않는다
processData(buffer, bytesRead);
</code></pre>
<p>}
```</p>
<p>```
[블로킹 I/O 타임라인]</p>
<p>Thread-1: ──[read() 호출]──────[대기중...]──────[데이터 수신]──[처리]──▶
                               ↑
                         스레드가 아무 일도 못함
```</p>
<p><strong>논블로킹 I/O</strong>는 완전히 다르다. <code>read()</code> 호출이 즉시 반환되기 때문에 데이터가 아직 없으면 "아직 없다"는 신호만 받고, 스레드는 바로 다른 일을 할 수 있다.</p>
<p>```java
// 논블로킹 I/O 예시 (java.nio)
SocketChannel channel = SocketChannel.open();
channel.configureBlocking(false);  // 논블로킹 모드 설정
channel.connect(new InetSocketAddress("example.com", 80));
while (!channel.finishConnect()) { /<em> 연결 완료 대기 </em>/ }</p>
<p>ByteBuffer buffer = ByteBuffer.allocate(1024);
int bytesRead = channel.read(buffer);  // ← 즉시 반환 (데이터 없으면 0 또는 -1)
// 스레드가 블로킹되지 않으므로 바로 다음 줄 실행
```</p>
<p>```
[논블로킹 I/O 타임라인]</p>
<p>Thread-1: ──[read()→0]──[다른작업]──[read()→0]──[다른작업]──[read()→데이터]──[처리]──▶
              ↑             ↑           ↑           ↑
         즉시 반환      유용한 작업   즉시 반환    유용한 작업
```</p>
<h3 id="232-java-nio-selector">2.3.2 Java NIO와 Selector</h3>
<p>Java NIO(New I/O)의 핵심은 <strong>Selector</strong>다. 이것이 있으면 하나의 스레드가 여러 채널의 I/O 이벤트를 효율적으로 감시할 수 있다. 내부적으로는 운영체제의 <code>epoll</code>(Linux) 또는 <code>kqueue</code>(macOS) 같은 고효율 시스템 콜을 활용하고 있다.</p>
<p>```java
// Java NIO Selector 사용 예시
Selector selector = Selector.open();</p>
<p>// 여러 채널을 셀렉터에 등록
ServerSocketChannel serverChannel = ServerSocketChannel.open();
serverChannel.configureBlocking(false);
serverChannel.bind(new InetSocketAddress(8080));
serverChannel.register(selector, SelectionKey.OP_ACCEPT);</p>
<p>while (true) {
    // I/O 이벤트가 있을 때까지 대기 (효율적인 대기)
    selector.select();</p>
<pre><code>Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();
Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();

while (iter.hasNext()) {
    SelectionKey key = iter.next();

    if (key.isAcceptable()) {
        // 새 연결 수락
        SocketChannel client = serverChannel.accept();
        client.configureBlocking(false);
        client.register(selector, SelectionKey.OP_READ);
    } else if (key.isReadable()) {
        // 데이터 읽기 가능
        SocketChannel client = (SocketChannel) key.channel();
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        client.read(buffer);
        // 데이터 처리...
    }

    iter.remove();
}
</code></pre>
<p>}
```</p>
<p>```
[Selector 동작 원리]</p>
<pre><code>                ┌───────────────┐
                │   Selector    │
                │   (Thread-1)  │
                └───┬───┬───┬───┘
                    │   │   │
        ┌───────────┘   │   └───────────┐
        ▼               ▼               ▼
   ┌─────────┐   ┌─────────┐   ┌─────────┐
   │Channel A│   │Channel B│   │Channel C│
   │ (READ)  │   │ (WRITE) │   │ (READ)  │
   └─────────┘   └─────────┘   └─────────┘
</code></pre>
<p>하나의 스레드가 select()를 호출하면:
  → 운영체제가 준비된 채널만 알려줌 (예: A와 C)
  → 스레드가 A와 C만 처리 (불필요한 폴링 없음)
```</p>
<h3 id="233">2.3.3 이벤트 루프의 동작 방식</h3>
<p>Netty의 이벤트 루프는 Java NIO의 Selector를 기초로 삼되, 여기에 더 정교한 태스크 스케줄링과 파이프라인 처리를 덧붙인 것이다.</p>
<p>이벤트 루프가 한 바퀴 도는(iteration) 과정을 보면 다음과 같다.</p>
<p>```
[이벤트 루프 사이클]</p>
<p>┌─────────────────────────────────────────────┐
│                Event Loop                    │
│                                              │
│  1. select()  ─── I/O 이벤트 감지            │
│       │                                      │
│       ▼                                      │
│  2. processSelectedKeys() ─── I/O 처리       │
│       │    (데이터 읽기/쓰기, 연결 수락)       │
│       ▼                                      │
│  3. runAllTasks() ─── 태스크 큐 처리          │
│       │    (사용자가 제출한 작업, 타이머 등)    │
│       │                                      │
│       └──────── 반복 ────────────────────────│
└─────────────────────────────────────────────┘
```</p>
<p>여기서 기억해야 할 절대 원칙이 하나 있다. <strong>이벤트 루프 스레드에서는 절대 블로킹 작업을 하면 안 된다는 것이다.</strong> 하나의 이벤트 루프가 수천 개의 연결을 동시에 담당하고 있기 때문에, 그 스레드가 한 번 블로킹되면 수천 개의 연결이 모두 함께 지연되는 끔찍한 일이 벌어진다.</p>
<p>```java
// 절대 하면 안 되는 코드 (이벤트 루프에서 블로킹)
@GetMapping("/bad-example")
public Mono<String> badExample() {
    Thread.sleep(1000);  // 이벤트 루프 스레드를 1초간 블로킹!
    return Mono.just("이렇게 하면 안 됩니다");
}</p>
<p>// 올바른 코드 (논블로킹)
@GetMapping("/good-example")
public Mono<String> goodExample() {
    return Mono.delay(Duration.ofSeconds(1))  // 논블로킹 대기
            .then(Mono.just("논블로킹으로 1초 후 응답"));
}
```</p>
<p>만약 블로킹 작업이 피할 수 없다면, 반드시 별도의 스케줄러로 그 작업을 위임해야 한다.</p>
<p><code>java
// 블로킹이 불가피한 경우 - 별도 스케줄러 사용
@GetMapping("/blocking-needed")
public Mono&lt;String&gt; blockingNeeded() {
    return Mono.fromCallable(() -&gt; {
                // 블로킹 API 호출 (예: 레거시 JDBC)
                return legacyService.queryDatabase();
            })
            .subscribeOn(Schedulers.boundedElastic());  // 블로킹 전용 스레드 풀
}</code></p>
<hr>
<h2 id="24-webflux">2.4 WebFlux를 선택해야 하는 경우와 그렇지 않은 경우</h2>
<h3 id="241-webflux">2.4.1 WebFlux가 적합한 시나리오</h3>
<p><strong>1. 높은 동시성이 요구되는 I/O 바운드 애플리케이션</strong></p>
<p>마이크로서비스 게이트웨이나 API 중개 서비스처럼 여러 외부 서비스를 한꺼번에 호출하고 결과를 조합해야 하는 경우가 대표적이다. 이런 상황에서 WebFlux는 진가를 발휘한다.</p>
<p>```java
// 여러 외부 서비스를 동시에 호출하여 결과 조합
public Mono<DashboardData> getDashboard(String userId) {
    Mono<UserProfile> profile = userService.getProfile(userId);
    Mono<List\<Order>> orders = orderService.getOrders(userId);
    Mono<List\<Notification>> notifications = notificationService.get(userId);</p>
<pre><code>return Mono.zip(profile, orders, notifications)
        .map(tuple -&gt; new DashboardData(
                tuple.getT1(),
                tuple.getT2(),
                tuple.getT3()
        ));
// 세 호출이 동시에 실행되어 전체 응답 시간 단축
</code></pre>
<p>}
```</p>
<p><strong>2. 실시간 스트리밍 애플리케이션</strong></p>
<p>SSE(Server-Sent Events)나 WebSocket 같은 방식으로 실시간 데이터를 스트리밍해야 할 때, WebFlux의 <code>Flux</code>가 자연스럽게 그 역할을 수행할 수 있다.</p>
<p><code>java
// 실시간 주가 스트리밍
@GetMapping(value = "/stocks/{symbol}/stream",
            produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;StockPrice&gt; streamStockPrice(@PathVariable String symbol) {
    return stockService.getPriceStream(symbol);  // 무한 스트림
}</code></p>
<p><strong>3. 대량의 동시 연결을 유지해야 하는 경우</strong></p>
<p>채팅 서비스나 알림 시스템처럼 수천 개에서 수만 개의 커넥션을 오래 유지해야 할 때는 어떨까? thread-per-request 방식은 메모리 한계에 쉽게 도달하기 때문에 WebFlux가 필수다.</p>
<p><strong>4. 전체 파이프라인이 리액티브인 경우</strong></p>
<p>실무에서 자주 보는 패턴인데, 데이터베이스(MongoDB Reactive, R2DBC), 메시지 브로커(Reactor Kafka, Reactor RabbitMQ), HTTP 클라이언트(WebClient) 등 모든 계층에서 리액티브 드라이버를 사용할 수 있을 때만 WebFlux의 이점이 정말로 극대화된다.</p>
<h3 id="242-webflux">2.4.2 WebFlux가 부적합한 시나리오</h3>
<p><strong>1. JDBC/JPA(관계형 DB) 블로킹 드라이버를 사용하는 경우</strong></p>
<p>전통적인 JDBC나 Spring Data JPA는 어쩔 수 없이 블로킹 API다. 이것을 WebFlux 위에서 사용하면 이벤트 루프 스레드를 블로킹하게 되므로 오히려 성능이 나빠진다. R2DBC라는 리액티브 대안이 있기는 하지만, JPA의 편한 기능들(지연 로딩, 캐싱 등)을 모두 포기해야 한다는 트레이드오프가 있다.</p>
<p><strong>2. CPU 집약적인 작업이 대부분인 경우</strong></p>
<p>이미지 처리나 복잡한 수학 계산, 암호화 같은 CPU를 오래 사용하는 작업들에서는 논블로킹 I/O가 별로 도움이 되지 않는다. 오히려 리액티브 프로그래밍의 복잡성만 들어올 뿐이다.</p>
<p><strong>3. 팀의 리액티브 프로그래밍 경험이 부족한 경우</strong></p>
<p>리액티브 프로그래밍의 학습 곡선은 정말 가파르다. 디버깅도 어렵고, 기존의 명령형 사고방식과는 근본적으로 다른 접근이 필요하기 때문이다. 팀 전체가 충분히 준비되지 않은 채로 도입하면 오히려 생산성이 크게 떨어질 수 있다는 게 문제다.</p>
<p><strong>4. 동시 요청 수가 적은 내부 관리 도구</strong></p>
<p>동시 사용자가 수십 명 정도인 백오피스 시스템이라면? Spring MVC만으로 충분하고, WebFlux를 굳이 도입할 필요가 없다.</p>
<h3 id="243">2.4.3 의사결정 기준</h3>
<p>결국 WebFlux를 도입할지 말지는 몇 가지 질문에 답하는 것으로 결정할 수 있다.</p>
<p>```
[WebFlux 도입 의사결정 흐름]</p>
<p>높은 동시성(수천 이상)이 필요한가?
  ├── 아니오 → Spring MVC 사용
  └── 예
       │
       전체 I/O 파이프라인이 논블로킹 가능한가?
       (DB, 메시지 큐, 외부 API 등)
         ├── 아니오 → Spring MVC 사용 (또는 부분적 리액티브)
         └── 예
              │
              팀이 리액티브 프로그래밍에 익숙한가?
                ├── 아니오 → 학습 기간 확보 후 도입 검토
                └── 예 → Spring WebFlux 사용
```</p>
<hr>
<h2 id="25-webflux">2.5 WebFlux의 두 가지 프로그래밍 모델</h2>
<p>Spring WebFlux를 사용할 때 선택할 수 있는 프로그래밍 방식이 두 가지 있다. 어노테이션 기반 모델과 함수형 엔드포인트 모델인데, 둘 다 동일한 리액티브 런타임 위에서 움직인다. 흥미롭게도 한 프로젝트 내에서 두 방식을 섞어 쓸 수도 있다.</p>
<h3 id="251">2.5.1 어노테이션 기반 모델</h3>
<p>Spring MVC를 써본 개발자라면 가장 익숙한 방식이다. <code>@Controller</code>, <code>@RestController</code>, <code>@RequestMapping</code> 같은 어노테이션을 그대로 사용하면서 반환 타입만 <code>Mono</code>와 <code>Flux</code>로 바꾸면 된다.</p>
<p>```java
@RestController
@RequestMapping("/api/products")
public class ProductController {</p>
<pre><code>private final ProductService productService;

public ProductController(ProductService productService) {
    this.productService = productService;
}

/**
 * 단일 상품 조회
 */
@GetMapping("/{id}")
public Mono&lt;ResponseEntity&lt;Product&gt;&gt; getProduct(@PathVariable String id) {
    return productService.findById(id)
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
}

/**
 * 전체 상품 목록 조회
 */
@GetMapping
public Flux&lt;Product&gt; getAllProducts(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "20") int size) {
    return productService.findAll(page, size);
}

/**
 * 상품 생성
 */
@PostMapping
@ResponseStatus(HttpStatus.CREATED)
public Mono&lt;Product&gt; createProduct(@Valid @RequestBody Product product) {
    return productService.save(product);
}

/**
 * 상품 수정
 */
@PutMapping("/{id}")
public Mono&lt;ResponseEntity&lt;Product&gt;&gt; updateProduct(
        @PathVariable String id,
        @Valid @RequestBody Product product) {
    return productService.update(id, product)
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
}

/**
 * 상품 삭제
 */
@DeleteMapping("/{id}")
@ResponseStatus(HttpStatus.NO_CONTENT)
public Mono&lt;Void&gt; deleteProduct(@PathVariable String id) {
    return productService.deleteById(id);
}

/**
 * 카테고리별 상품 스트리밍 (SSE)
 */
@GetMapping(value = "/stream/category/{category}",
            produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;Product&gt; streamByCategory(@PathVariable String category) {
    return productService.findByCategoryStream(category);
}
</code></pre>
<p>}
```</p>
<p>서비스 계층도 어떻게 구성되는지 보면 감이 올 것이다.</p>
<p>```java
@Service
public class ProductService {</p>
<pre><code>private final ProductRepository productRepository;

public ProductService(ProductRepository productRepository) {
    this.productRepository = productRepository;
}

public Mono&lt;Product&gt; findById(String id) {
    return productRepository.findById(id);
}

public Flux&lt;Product&gt; findAll(int page, int size) {
    return productRepository.findAll()
            .skip((long) page * size)
            .take(size);
}

public Mono&lt;Product&gt; save(Product product) {
    product.setCreatedAt(LocalDateTime.now());
    return productRepository.save(product);
}

public Mono&lt;Product&gt; update(String id, Product product) {
    return productRepository.findById(id)
            .flatMap(existing -&gt; {
                existing.setName(product.getName());
                existing.setPrice(product.getPrice());
                existing.setUpdatedAt(LocalDateTime.now());
                return productRepository.save(existing);
            });
}

public Mono&lt;Void&gt; deleteById(String id) {
    return productRepository.deleteById(id);
}

public Flux&lt;Product&gt; findByCategoryStream(String category) {
    return productRepository.findByCategory(category);
}
</code></pre>
<p>}
```</p>
<h3 id="252">2.5.2 함수형 엔드포인트 모델</h3>
<p>함수형 모델은 라우팅과 핸들러를 어노테이션이 아니라 코드로 직접 정의하는 방식이다. <code>RouterFunction</code>이 라우팅 규칙을, <code>HandlerFunction</code>이 요청 처리를 담당한다.</p>
<p><strong>핸들러(Handler):</strong></p>
<p>```java
@Component
public class ProductHandler {</p>
<pre><code>private final ProductService productService;

public ProductHandler(ProductService productService) {
    this.productService = productService;
}

/**
 * 단일 상품 조회
 */
public Mono&lt;ServerResponse&gt; getProduct(ServerRequest request) {
    String id = request.pathVariable("id");
    return productService.findById(id)
            .flatMap(product -&gt; ServerResponse.ok()
                    .contentType(MediaType.APPLICATION_JSON)
                    .bodyValue(product))
            .switchIfEmpty(ServerResponse.notFound().build());
}

/**
 * 전체 상품 목록 조회
 */
public Mono&lt;ServerResponse&gt; getAllProducts(ServerRequest request) {
    int page = request.queryParam("page")
            .map(Integer::parseInt).orElse(0);
    int size = request.queryParam("size")
            .map(Integer::parseInt).orElse(20);

    Flux&lt;Product&gt; products = productService.findAll(page, size);
    return ServerResponse.ok()
            .contentType(MediaType.APPLICATION_JSON)
            .body(products, Product.class);
}

/**
 * 상품 생성
 */
public Mono&lt;ServerResponse&gt; createProduct(ServerRequest request) {
    return request.bodyToMono(Product.class)
            .flatMap(productService::save)
            .flatMap(saved -&gt; ServerResponse
                    .created(URI.create("/api/products/" + saved.getId()))
                    .contentType(MediaType.APPLICATION_JSON)
                    .bodyValue(saved));
}

/**
 * 상품 수정
 */
public Mono&lt;ServerResponse&gt; updateProduct(ServerRequest request) {
    String id = request.pathVariable("id");
    return request.bodyToMono(Product.class)
            .flatMap(product -&gt; productService.update(id, product))
            .flatMap(updated -&gt; ServerResponse.ok()
                    .contentType(MediaType.APPLICATION_JSON)
                    .bodyValue(updated))
            .switchIfEmpty(ServerResponse.notFound().build());
}

/**
 * 상품 삭제
 */
public Mono&lt;ServerResponse&gt; deleteProduct(ServerRequest request) {
    String id = request.pathVariable("id");
    return productService.deleteById(id)
            .then(ServerResponse.noContent().build());
}
</code></pre>
<p>}
```</p>
<p><strong>라우터(Router):</strong></p>
<p>```java
@Configuration
public class ProductRouter {</p>
<pre><code>@Bean
public RouterFunction&lt;ServerResponse&gt; productRoutes(ProductHandler handler) {
    return RouterFunctions.route()
            .path("/api/products", builder -&gt; builder
                    .GET("/{id}", handler::getProduct)
                    .GET("", handler::getAllProducts)
                    .POST("", handler::createProduct)
                    .PUT("/{id}", handler::updateProduct)
                    .DELETE("/{id}", handler::deleteProduct)
            )
            .build();
}
</code></pre>
<p>}
```</p>
<p>여러 도메인의 라우터들을 조합해서 전체 라우팅을 구성할 수도 있다.</p>
<p>```java
@Configuration
public class AppRouter {</p>
<pre><code>@Bean
public RouterFunction&lt;ServerResponse&gt; allRoutes(
        ProductHandler productHandler,
        OrderHandler orderHandler,
        UserHandler userHandler) {

    return RouterFunctions.route()
            .path("/api/products", builder -&gt; builder
                    .GET("/{id}", productHandler::getProduct)
                    .GET("", productHandler::getAllProducts)
                    .POST("", productHandler::createProduct)
            )
            .path("/api/orders", builder -&gt; builder
                    .GET("/{id}", orderHandler::getOrder)
                    .GET("", orderHandler::getAllOrders)
                    .POST("", orderHandler::createOrder)
            )
            .path("/api/users", builder -&gt; builder
                    .GET("/{id}", userHandler::getUser)
                    .POST("", userHandler::createUser)
            )
            .filter((request, next) -&gt; {
                // 공통 필터: 요청 로깅
                System.out.println("Request: " + request.method()
                        + " " + request.path());
                return next.handle(request);
            })
            .build();
}
</code></pre>
<p>}
```</p>
<h3 id="253">2.5.3 두 모델의 비교와 선택 기준</h3>
<table>
<thead>
<tr>
<th>기준</th>
<th>어노테이션 기반</th>
<th>함수형 엔드포인트</th>
</tr>
</thead>
<tbody>
<tr>
<td>학습 비용</td>
<td>낮음 (MVC 경험 활용)</td>
<td>중간 (새로운 API 학습 필요)</td>
</tr>
<tr>
<td>코드 스타일</td>
<td>선언적 (어노테이션)</td>
<td>프로그래밍 방식 (코드로 라우팅)</td>
</tr>
<tr>
<td>라우팅 유연성</td>
<td>제한적</td>
<td>매우 유연 (조건부 라우팅 등)</td>
</tr>
<tr>
<td>테스트</td>
<td><code>@WebFluxTest</code></td>
<td>순수 단위 테스트 용이</td>
</tr>
<tr>
<td>검증</td>
<td><code>@Valid</code> 자동 적용</td>
<td>수동으로 검증 로직 작성</td>
</tr>
<tr>
<td>IDE 지원</td>
<td>우수 (자동완성, 네비게이션)</td>
<td>보통</td>
</tr>
<tr>
<td>한 파일 응집도</td>
<td>낮음 (라우팅이 분산)</td>
<td>높음 (한 곳에서 라우팅 파악)</td>
</tr>
</tbody>
</table>
<p><strong>어노테이션 기반을 선택하는 경우:</strong></p>
<ul>
<li>이미 Spring MVC 경험이 있는 팀</li>
<li>빠른 개발 속도를 중요하게 보는 프로젝트</li>
<li>표준적인 CRUD API만 필요한 경우</li>
<li>Bean Validation을 자주 쓰는 경우</li>
</ul>
<p><strong>함수형 엔드포인트를 선택하는 경우:</strong></p>
<ul>
<li>라우팅 규칙이 복잡하거나 동적으로 바뀌어야 하는 경우</li>
<li>마이크로서비스처럼 최소한의 프레임워크 의존성이 필요한 경우</li>
<li>팀이 함수형 프로그래밍 스타일을 좋아하는 경우</li>
<li>테스트할 때 Spring 컨텍스트 없이 핸들러만 단위 테스트하고 싶은 경우</li>
</ul>
<p>현실적으로 실무에서는 어노테이션 기반 모델이 훨씬 더 광범위하게 쓰인다. Spring MVC에서의 전환 비용이 낮고, 대부분 팀이 이미 익숙하기 때문이다. 함수형 모델은 특별히 라우팅이 복잡한 상황이거나, 팀이 함수형 스타일을 잘 다루는 경우에 고려해볼 만하다.</p>
<hr>
<h2 id="_1">정리</h2>
<p>이 장을 통해 살펴본 핵심 내용들을 정리하면 다음과 같다.</p>
<ul>
<li><strong>Spring MVC vs WebFlux</strong>: MVC는 서블릿 기반의 thread-per-request 모델이고, WebFlux는 이벤트 루프를 기반으로 한 논블로킹 모델이다. 특히 높은 동시성 상황에서 WebFlux가 적은 리소스로 안정적인 처리량을 유지할 수 있다.</li>
<li><strong>Netty와 이벤트 루프</strong>: WebFlux가 기본으로 사용하는 Netty는 이벤트 루프 모델을 통해 소수의 스레드로 수만 개의 동시 연결을 처리해낼 수 있다. 다만 절대로 이벤트 루프 스레드를 블로킹하면 안 된다는 원칙은 철저히 지켜야 한다.</li>
<li><strong>논블로킹 I/O</strong>: Java NIO의 Selector를 활용하면 하나의 스레드가 여러 채널의 I/O를 효율적으로 관리할 수 있다. 데이터가 실제로 준비될 때만 처리하기 때문에 스레드 낭비가 거의 없다.</li>
<li><strong>도입 판단 기준</strong>: 높은 동시성이 필요하고, 리액티브 파이프라인을 구축할 수 있으며, 팀의 역량이 충분한 세 조건이 모두 만족될 때 WebFlux를 선택해야 한다.</li>
<li><strong>두 가지 프로그래밍 모델</strong>: 어노테이션 기반 모델은 Spring MVC 경험을 활용할 수 있어서 접근성이 높고, 함수형 모델은 라우팅의 자유도와 테스트 편의성에서 강점이 있다.</li>
</ul>
<p>다음 장에서는 WebFlux를 작동하게 하는 심장 같은 존재인 <strong>Project Reactor</strong>를 깊이 있게 살펴본다. <code>Mono</code>와 <code>Flux</code>가 어떻게 동작하는지, 주요 연산자들은 무엇인지, 에러를 어떻게 처리해야 하는지 등을 자세히 다룰 것이다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>