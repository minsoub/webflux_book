<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Part 7. 실전 프로젝트 (Ch.21) | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="part6.html">&larr; Part 6. 운영과 배포 (Ch.18-20)</a>
    <a href="../index.html">목차</a>
    <span class="disabled">다음 &rarr;</span>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-21">Chapter 21. 실전 프로젝트: 실시간 게시판 서비스</h1>
<p>지금까지 배운 WebFlux, MongoDB 리액티브, JWT 인증, SSE, 테스트 등의 개념을 하나의 완전한 프로젝트로 통합할 차례다. 이번 장에서는 <strong>실시간 게시판 서비스</strong>를 처음부터 끝까지 구축한다. 회원가입과 JWT 기반 인증, 게시글 CRUD, 댓글 시스템, MongoDB Change Streams를 활용한 실시간 알림, 페이징과 검색, GridFS 파일 업로드, 테스트 작성, Docker Compose 배포까지 실전에서 필요한 전 과정을 다룬다.</p>
<hr>
<h2 id="211">21.1 요구사항 분석 및 설계</h2>
<h3 id="2111">21.1.1 기능 요구사항과 기술 스택</h3>
<table>
<thead>
<tr>
<th>기능 영역</th>
<th>세부 기능</th>
<th>기술</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>사용자 관리</strong></td>
<td>회원가입, 로그인, JWT 토큰 발급</td>
<td>Spring Security + jjwt</td>
</tr>
<tr>
<td><strong>게시글</strong></td>
<td>작성, 조회, 수정, 삭제, 페이징</td>
<td>ReactiveMongoRepository</td>
</tr>
<tr>
<td><strong>댓글</strong></td>
<td>작성, 조회, 삭제</td>
<td>ReactiveMongoTemplate</td>
</tr>
<tr>
<td><strong>실시간 알림</strong></td>
<td>새 댓글 알림</td>
<td>Change Streams + SSE</td>
</tr>
<tr>
<td><strong>검색</strong></td>
<td>제목/본문 키워드 검색</td>
<td>ReactiveMongoTemplate</td>
</tr>
<tr>
<td><strong>파일 업로드</strong></td>
<td>첨부파일 업로드/다운로드</td>
<td>GridFS</td>
</tr>
</tbody>
</table>
<p>전체 스택은 Spring Boot 3.x + WebFlux + MongoDB 7.x(Reactive) + Testcontainers + Docker Compose로 구성한다.</p>
<h3 id="2112">21.1.2 프로젝트 구조</h3>
<pre class="highlight"><code>reactive-board/
├── src/main/java/com/example/board/
│   ├── config/          # MongoConfig, SecurityConfig
│   ├── security/        # JwtTokenProvider, JwtAuthenticationFilter
│   ├── domain/          # User, Post, Comment
│   ├── repository/      # UserRepository, PostRepository, CommentRepository
│   ├── service/         # UserService, PostService, CommentService,
│   │                    # NotificationService, FileService, PostSearchService
│   ├── controller/      # AuthController, PostController, CommentController,
│   │                    # NotificationController, FileController
│   └── dto/             # 요청/응답 DTO 클래스
├── src/main/resources/application.yml
├── Dockerfile
└── docker-compose.yml</code></pre>
<h3 id="2113">21.1.3 시스템 아키텍처</h3>
<pre class="highlight"><code>[클라이언트] → [Netty] → Controller → Service → MongoDB
                                         └── Change Streams → SSE → 클라이언트</code></pre>
<hr>
<h2 id="212-jwt">21.2 사용자 관리 (회원가입, 로그인, JWT)</h2>
<h3 id="2121">21.2.1 의존성 설정</h3>
<pre class="highlight"><code class="language-groovy">dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    implementation 'org.springframework.boot:spring-boot-starter-data-mongodb-reactive'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'io.jsonwebtoken:jjwt-api:0.12.6'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.12.6'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.12.6'
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'io.projectreactor:reactor-test'
    testImplementation 'org.testcontainers:mongodb:1.20.4'
}</code></pre>
<h3 id="2122-user">21.2.2 User 도메인 모델</h3>
<pre class="highlight"><code class="language-java">@Document(collection = "users")
@Data @NoArgsConstructor @AllArgsConstructor @Builder
public class User {
    @Id private String id;
    @Indexed(unique = true) private String email;
    @Indexed(unique = true) private String nickname;
    private String password;
    @Builder.Default private List&lt;String&gt; roles = List.of("ROLE_USER");
    @CreatedDate private LocalDateTime createdAt;
}</code></pre>
<h3 id="2123-jwt">21.2.3 JWT 토큰 제공자</h3>
<pre class="highlight"><code class="language-java">@Component
public class JwtTokenProvider {

    private final SecretKey secretKey;
    private final long accessTokenValidity;

    public JwtTokenProvider(@Value("${jwt.secret}") String secret,
            @Value("${jwt.access-token-validity:3600000}") long validity) {
        this.secretKey = Keys.hmacShaKeyFor(Decoders.BASE64.decode(secret));
        this.accessTokenValidity = validity;
    }

    public String createToken(String userId, String email, List&lt;String&gt; roles) {
        return Jwts.builder().subject(userId)
            .claim("email", email).claim("roles", roles)
            .issuedAt(new Date())
            .expiration(new Date(System.currentTimeMillis() + accessTokenValidity))
            .signWith(secretKey).compact();
    }

    public Claims parseToken(String token) {
        return Jwts.parser().verifyWith(secretKey).build()
            .parseSignedClaims(token).getPayload();
    }

    public boolean validateToken(String token) {
        try { parseToken(token); return true; }
        catch (JwtException | IllegalArgumentException e) { return false; }
    }
}</code></pre>
<h3 id="2124-jwt-security">21.2.4 JWT 인증 필터와 Security 설정</h3>
<p>WebFlux 환경에서는 서블릿 필터 대신 <code>WebFilter</code>를 사용한다. Bearer 토큰을 추출하고, 유효하면 <code>ReactiveSecurityContextHolder</code>에 인증 정보를 설정한다.</p>
<pre class="highlight"><code class="language-java">@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter implements WebFilter {

    private final JwtTokenProvider jwtTokenProvider;

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        String token = extractToken(exchange.getRequest());
        if (token != null &amp;&amp; jwtTokenProvider.validateToken(token)) {
            Claims claims = jwtTokenProvider.parseToken(token);
            List&lt;SimpleGrantedAuthority&gt; authorities =
                claims.get("roles", List.class).stream()
                    .map(r -&gt; new SimpleGrantedAuthority((String) r)).toList();
            var auth = new UsernamePasswordAuthenticationToken(
                claims.getSubject(), null, authorities);
            return chain.filter(exchange)
                .contextWrite(ReactiveSecurityContextHolder.withAuthentication(auth));
        }
        return chain.filter(exchange);
    }

    private String extractToken(ServerHttpRequest request) {
        String bearer = request.getHeaders().getFirst(HttpHeaders.AUTHORIZATION);
        return (bearer != null &amp;&amp; bearer.startsWith("Bearer "))
            ? bearer.substring(7) : null;
    }
}</code></pre>
<p>Security 설정에서는 인증/비인증 엔드포인트를 구분하고, JWT 필터를 등록한다.</p>
<pre class="highlight"><code class="language-java">@Configuration @EnableWebFluxSecurity @RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        return http
            .csrf(ServerHttpSecurity.CsrfSpec::disable)
            .httpBasic(ServerHttpSecurity.HttpBasicSpec::disable)
            .formLogin(ServerHttpSecurity.FormLoginSpec::disable)
            .authorizeExchange(ex -&gt; ex
                .pathMatchers("/api/auth/**").permitAll()
                .pathMatchers(HttpMethod.GET, "/api/posts/**").permitAll()
                .pathMatchers("/api/notifications/**").permitAll()
                .anyExchange().authenticated())
            .addFilterBefore(jwtAuthenticationFilter, SecurityWebFiltersOrder.AUTHENTICATION)
            .build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); }
}</code></pre>
<h3 id="2125">21.2.5 회원가입/로그인 서비스</h3>
<pre class="highlight"><code class="language-java">@Service @RequiredArgsConstructor
public class UserService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtTokenProvider jwtTokenProvider;

    public Mono&lt;UserResponse&gt; signup(SignupRequest request) {
        return userRepository.findByEmail(request.getEmail())
            .flatMap(existing -&gt; Mono.&lt;User&gt;error(
                new DuplicateException("이미 등록된 이메일입니다.")))
            .switchIfEmpty(Mono.defer(() -&gt; userRepository.save(User.builder()
                .email(request.getEmail()).nickname(request.getNickname())
                .password(passwordEncoder.encode(request.getPassword())).build())))
            .map(u -&gt; new UserResponse(u.getId(), u.getEmail(), u.getNickname()));
    }

    public Mono&lt;LoginResponse&gt; login(LoginRequest request) {
        return userRepository.findByEmail(request.getEmail())
            .filter(u -&gt; passwordEncoder.matches(request.getPassword(), u.getPassword()))
            .map(u -&gt; new LoginResponse(
                jwtTokenProvider.createToken(u.getId(), u.getEmail(), u.getRoles()),
                u.getNickname()))
            .switchIfEmpty(Mono.error(
                new AuthenticationException("이메일 또는 비밀번호가 올바르지 않습니다.")));
    }
}</code></pre>
<hr>
<h2 id="213-crud-api">21.3 게시글 CRUD API 구현</h2>
<h3 id="2131-post">21.3.1 Post 도메인 모델</h3>
<pre class="highlight"><code class="language-java">@Document(collection = "posts")
@Data @NoArgsConstructor @AllArgsConstructor @Builder
public class Post {
    @Id private String id;
    @Indexed private String authorId;
    private String authorNickname;
    private String title;
    private String content;
    private List&lt;String&gt; attachmentIds;
    @Builder.Default private int viewCount = 0;
    @Builder.Default private int commentCount = 0;
    @CreatedDate private LocalDateTime createdAt;
    @LastModifiedDate private LocalDateTime updatedAt;
}</code></pre>
<h3 id="2132-postservice">21.3.2 PostService</h3>
<p>조회수 증가는 <code>ReactiveMongoTemplate</code>의 원자적 업데이트를 사용하고, 수정/삭제 시 작성자 권한을 검증한다.</p>
<pre class="highlight"><code class="language-java">@Service @RequiredArgsConstructor
public class PostService {

    private final PostRepository postRepository;
    private final ReactiveMongoTemplate mongoTemplate;

    public Mono&lt;Post&gt; createPost(PostRequest req, String authorId, String nickname) {
        return postRepository.save(Post.builder().authorId(authorId)
            .authorNickname(nickname).title(req.getTitle())
            .content(req.getContent()).build());
    }

    public Mono&lt;Post&gt; getPost(String postId) {
        return postRepository.findById(postId)
            .switchIfEmpty(Mono.error(new NotFoundException("게시글을 찾을 수 없습니다.")))
            .flatMap(post -&gt; mongoTemplate.updateFirst(
                Query.query(Criteria.where("id").is(postId)),
                new Update().inc("viewCount", 1), Post.class)
                .thenReturn(post));
    }

    public Mono&lt;Post&gt; updatePost(String postId, PostRequest req, String authorId) {
        return postRepository.findById(postId)
            .switchIfEmpty(Mono.error(new NotFoundException("게시글을 찾을 수 없습니다.")))
            .filter(p -&gt; p.getAuthorId().equals(authorId))
            .switchIfEmpty(Mono.error(new ForbiddenException("수정 권한이 없습니다.")))
            .flatMap(p -&gt; { p.setTitle(req.getTitle()); p.setContent(req.getContent());
                return postRepository.save(p); });
    }

    public Mono&lt;Void&gt; deletePost(String postId, String authorId) {
        return postRepository.findById(postId)
            .switchIfEmpty(Mono.error(new NotFoundException("게시글을 찾을 수 없습니다.")))
            .filter(p -&gt; p.getAuthorId().equals(authorId))
            .switchIfEmpty(Mono.error(new ForbiddenException("삭제 권한이 없습니다.")))
            .flatMap(postRepository::delete);
    }
}</code></pre>
<h3 id="2133-postcontroller">21.3.3 PostController</h3>
<pre class="highlight"><code class="language-java">@RestController @RequestMapping("/api/posts") @RequiredArgsConstructor
public class PostController {

    private final PostService postService;
    private final PostSearchService postSearchService;
    private final UserRepository userRepository;

    @PostMapping @ResponseStatus(HttpStatus.CREATED)
    public Mono&lt;PostResponse&gt; createPost(@Valid @RequestBody PostRequest request,
            @AuthenticationPrincipal Mono&lt;String&gt; principalId) {
        return principalId.flatMap(uid -&gt; userRepository.findById(uid)
            .flatMap(u -&gt; postService.createPost(request, uid, u.getNickname()))
            .map(PostResponse::from));
    }

    @GetMapping("/{postId}")
    public Mono&lt;PostResponse&gt; getPost(@PathVariable String postId) {
        return postService.getPost(postId).map(PostResponse::from);
    }

    @PutMapping("/{postId}")
    public Mono&lt;PostResponse&gt; updatePost(@PathVariable String postId,
            @Valid @RequestBody PostRequest request,
            @AuthenticationPrincipal Mono&lt;String&gt; principalId) {
        return principalId.flatMap(uid -&gt;
            postService.updatePost(postId, request, uid).map(PostResponse::from));
    }

    @DeleteMapping("/{postId}") @ResponseStatus(HttpStatus.NO_CONTENT)
    public Mono&lt;Void&gt; deletePost(@PathVariable String postId,
            @AuthenticationPrincipal Mono&lt;String&gt; principalId) {
        return principalId.flatMap(uid -&gt; postService.deletePost(postId, uid));
    }

    @GetMapping
    public Mono&lt;PageResponse&lt;PostResponse&gt;&gt; listPosts(
            @RequestParam(defaultValue = "") String keyword,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        return postSearchService.searchPosts(keyword, page, size);
    }
}</code></pre>
<hr>
<h2 id="214-vs">21.4 댓글 시스템 (내장 도큐먼트 vs 참조)</h2>
<h3 id="2141">21.4.1 설계 선택</h3>
<table>
<thead>
<tr>
<th>기준</th>
<th>임베디드(Embedded)</th>
<th>참조(Reference)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>문서 크기</strong></td>
<td>댓글 증가 시 16MB 제한 위험</td>
<td>안정적</td>
</tr>
<tr>
<td><strong>독립 쿼리</strong></td>
<td>댓글만 별도 조회 어려움</td>
<td>페이징/정렬 가능</td>
</tr>
<tr>
<td><strong>Change Stream</strong></td>
<td>활용 제한적</td>
<td>댓글 컬렉션 감시 가능</td>
</tr>
</tbody>
</table>
<p>댓글이 무제한 증가할 수 있고, Change Streams 기반 실시간 알림이 필요하므로 <strong>참조 방식</strong>을 선택한다.</p>
<h3 id="2142-comment">21.4.2 Comment 모델과 서비스</h3>
<pre class="highlight"><code class="language-java">@Document(collection = "comments")
@Data @NoArgsConstructor @AllArgsConstructor @Builder
public class Comment {
    @Id private String id;
    @Indexed private String postId;
    private String authorId;
    private String authorNickname;
    private String content;
    @CreatedDate private LocalDateTime createdAt;
}</code></pre>
<pre class="highlight"><code class="language-java">@Service @RequiredArgsConstructor
public class CommentService {

    private final CommentRepository commentRepository;
    private final PostRepository postRepository;
    private final ReactiveMongoTemplate mongoTemplate;

    public Mono&lt;Comment&gt; addComment(String postId, String content,
                                     String authorId, String authorNickname) {
        return postRepository.findById(postId)
            .switchIfEmpty(Mono.error(new NotFoundException("게시글을 찾을 수 없습니다.")))
            .then(Mono.defer(() -&gt; commentRepository.save(Comment.builder()
                .postId(postId).authorId(authorId)
                .authorNickname(authorNickname).content(content).build())))
            .flatMap(c -&gt; mongoTemplate.updateFirst(
                Query.query(Criteria.where("id").is(postId)),
                new Update().inc("commentCount", 1), Post.class).thenReturn(c));
    }

    public Flux&lt;Comment&gt; getComments(String postId) {
        return commentRepository.findByPostIdOrderByCreatedAtDesc(postId);
    }

    public Mono&lt;Void&gt; deleteComment(String commentId, String userId) {
        return commentRepository.findById(commentId)
            .filter(c -&gt; c.getAuthorId().equals(userId))
            .switchIfEmpty(Mono.error(new ForbiddenException("삭제 권한이 없습니다.")))
            .flatMap(c -&gt; commentRepository.delete(c).then(mongoTemplate.updateFirst(
                Query.query(Criteria.where("id").is(c.getPostId())),
                new Update().inc("commentCount", -1), Post.class).then()));
    }
}</code></pre>
<hr>
<h2 id="215-sse">21.5 실시간 알림 (SSE)</h2>
<p>MongoDB Change Streams로 <code>comments</code> 컬렉션의 insert 이벤트를 감지하고, <code>Sinks.Many</code>를 통해 SSE로 클라이언트에 전송한다.</p>
<pre class="highlight"><code>[댓글 작성] → MongoDB insert → Change Stream 감지 → Sinks.Many → SSE → 클라이언트</code></pre>
<h3 id="2151-notificationservice">21.5.1 NotificationService</h3>
<pre class="highlight"><code class="language-java">@Service @Slf4j
public class NotificationService {

    private final Sinks.Many&lt;NotificationEvent&gt; sink;
    private final Flux&lt;NotificationEvent&gt; notificationFlux;

    public NotificationService(ReactiveMongoTemplate mongoTemplate) {
        this.sink = Sinks.many().multicast().onBackpressureBuffer(256);
        this.notificationFlux = sink.asFlux().share();

        mongoTemplate.changeStream("comments",
                ChangeStreamOptions.builder()
                    .filter(Aggregation.newAggregation(Aggregation.match(
                        Criteria.where("operationType").is("insert"))))
                    .build(), Comment.class)
            .doOnNext(event -&gt; {
                Comment c = event.getBody();
                if (c != null) {
                    sink.tryEmitNext(NotificationEvent.builder()
                        .type("NEW_COMMENT").postId(c.getPostId())
                        .message(c.getAuthorNickname() + "님이 댓글을 작성했습니다.")
                        .createdAt(LocalDateTime.now()).build());
                }
            })
            .doOnError(e -&gt; log.error("Change Stream 오류", e))
            .subscribe();
    }

    public Flux&lt;NotificationEvent&gt; getNotifications(String postId) {
        return notificationFlux.filter(e -&gt; e.getPostId().equals(postId));
    }

    public Flux&lt;NotificationEvent&gt; getAllNotifications() { return notificationFlux; }
}</code></pre>
<h3 id="2152-notificationcontroller">21.5.2 NotificationController</h3>
<pre class="highlight"><code class="language-java">@RestController @RequestMapping("/api/notifications") @RequiredArgsConstructor
public class NotificationController {

    private final NotificationService notificationService;

    @GetMapping(value = "/stream/{postId}", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux&lt;ServerSentEvent&lt;NotificationEvent&gt;&gt; streamByPost(
            @PathVariable String postId) {
        return notificationService.getNotifications(postId)
            .map(e -&gt; ServerSentEvent.&lt;NotificationEvent&gt;builder()
                .id(UUID.randomUUID().toString()).event(e.getType()).data(e).build());
    }

    @GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux&lt;ServerSentEvent&lt;NotificationEvent&gt;&gt; streamAll() {
        return notificationService.getAllNotifications()
            .map(e -&gt; ServerSentEvent.&lt;NotificationEvent&gt;builder()
                .id(UUID.randomUUID().toString()).event(e.getType()).data(e).build());
    }
}</code></pre>
<p>Change Streams는 MongoDB <strong>레플리카 셋(Replica Set)</strong> 모드에서만 동작한다. 21.9절에서 이를 설정한다.</p>
<hr>
<h2 id="216">21.6 페이징과 검색 기능</h2>
<p>리액티브 환경에서는 Spring Data의 <code>Page</code> 객체를 직접 사용할 수 없으므로 커스텀 DTO를 구성한다.</p>
<pre class="highlight"><code class="language-java">@Data @NoArgsConstructor @AllArgsConstructor @Builder
public class PageResponse&lt;T&gt; {
    private List&lt;T&gt; content;
    private int page, size;
    private long totalElements;
    private int totalPages;
    private boolean hasNext;

    public static &lt;T&gt; Mono&lt;PageResponse&lt;T&gt;&gt; of(
            Flux&lt;T&gt; contentFlux, Mono&lt;Long&gt; countMono, int page, int size) {
        return Mono.zip(contentFlux.collectList(), countMono).map(tuple -&gt; {
            long total = tuple.getT2();
            int tp = (int) Math.ceil((double) total / size);
            return PageResponse.&lt;T&gt;builder().content(tuple.getT1())
                .page(page).size(size).totalElements(total)
                .totalPages(tp).hasNext(page &lt; tp - 1).build();
        });
    }
}</code></pre>
<p><code>ReactiveMongoTemplate</code>으로 동적 쿼리, 정렬, 페이징을 처리한다.</p>
<pre class="highlight"><code class="language-java">@Service @RequiredArgsConstructor
public class PostSearchService {

    private final ReactiveMongoTemplate mongoTemplate;

    public Mono&lt;PageResponse&lt;PostResponse&gt;&gt; searchPosts(
            String keyword, int page, int size) {
        Criteria criteria = new Criteria();
        if (keyword != null &amp;&amp; !keyword.isBlank()) {
            criteria.orOperator(Criteria.where("title").regex(keyword, "i"),
                Criteria.where("content").regex(keyword, "i"));
        }
        Query query = Query.query(criteria)
            .with(Sort.by(Sort.Direction.DESC, "createdAt"));
        Flux&lt;PostResponse&gt; content = mongoTemplate
            .find(query.skip((long) page * size).limit(size), Post.class)
            .map(PostResponse::from);
        Mono&lt;Long&gt; count = mongoTemplate.count(Query.query(criteria), Post.class);
        return PageResponse.of(content, count, page, size);
    }
}</code></pre>
<p>검색 성능을 위해 텍스트 인덱스(Text Index)를 추가할 수 있다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class MongoConfig {
    @EventListener(ApplicationReadyEvent.class)
    public void initIndices(ApplicationReadyEvent event) {
        ReactiveMongoTemplate template = event.getApplicationContext()
            .getBean(ReactiveMongoTemplate.class);
        template.indexOps(Post.class).ensureIndex(
            new TextIndexDefinition.TextIndexDefinitionBuilder()
                .onField("title").onField("content").build()).subscribe();
    }
}</code></pre>
<hr>
<h2 id="217-gridfs">21.7 파일 업로드 (GridFS)</h2>
<p>MongoDB GridFS는 파일을 청크(Chunk)로 분할하여 저장한다. 리액티브 환경에서는 <code>ReactiveGridFsTemplate</code>을 사용한다.</p>
<pre class="highlight"><code class="language-java">@Service @RequiredArgsConstructor
public class FileService {

    private final ReactiveGridFsTemplate gridFsTemplate;

    public Mono&lt;String&gt; uploadFile(FilePart filePart) {
        DBObject metadata = new BasicDBObject();
        metadata.put("contentType", filePart.headers().getContentType() != null
            ? filePart.headers().getContentType().toString()
            : MediaType.APPLICATION_OCTET_STREAM_VALUE);
        return gridFsTemplate.store(filePart.content(), filePart.filename(), metadata)
            .map(ObjectId::toString);
    }

    public Mono&lt;GridFsResource&gt; downloadFile(String fileId) {
        return gridFsTemplate.findOne(Query.query(Criteria.where("_id").is(fileId)))
            .flatMap(gridFsTemplate::getResource);
    }

    public Mono&lt;Void&gt; deleteFile(String fileId) {
        return gridFsTemplate.delete(Query.query(Criteria.where("_id").is(fileId))).then();
    }
}</code></pre>
<pre class="highlight"><code class="language-java">@RestController @RequestMapping("/api/files") @RequiredArgsConstructor
public class FileController {

    private final FileService fileService;

    @PostMapping(consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    @ResponseStatus(HttpStatus.CREATED)
    public Mono&lt;Map&lt;String, String&gt;&gt; upload(@RequestPart("file") Mono&lt;FilePart&gt; file) {
        return file.flatMap(fileService::uploadFile).map(id -&gt; Map.of("fileId", id));
    }

    @GetMapping("/{fileId}")
    public Mono&lt;ResponseEntity&lt;Flux&lt;DataBuffer&gt;&gt;&gt; download(@PathVariable String fileId) {
        return fileService.downloadFile(fileId).map(r -&gt; ResponseEntity.ok()
            .header(HttpHeaders.CONTENT_DISPOSITION,
                "attachment; filename=\"" + r.getFilename() + "\"")
            .contentType(MediaType.APPLICATION_OCTET_STREAM)
            .body(r.getDownloadStream()));
    }
}</code></pre>
<p>반환된 <code>fileId</code>를 게시글의 <code>attachmentIds</code>에 저장하면 게시글과 첨부파일을 연결할 수 있다.</p>
<hr>
<h2 id="218">21.8 전체 테스트 작성</h2>
<pre class="highlight"><code class="language-java">@Testcontainers
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public abstract class IntegrationTestBase {

    @Container
    static MongoDBContainer mongo = new MongoDBContainer("mongo:7.0")
        .withCommand("--replSet", "rs0");

    @DynamicPropertySource
    static void mongoProps(DynamicPropertyRegistry registry) {
        registry.add("spring.data.mongodb.uri", mongo::getReplicaSetUrl);
    }

    @Autowired protected WebTestClient webTestClient;
}</code></pre>
<h3 id="2182-postservice">21.8.2 PostService 단위 테스트</h3>
<pre class="highlight"><code class="language-java">@ExtendWith(MockitoExtension.class)
class PostServiceTest {

    @Mock private PostRepository postRepository;
    @Mock private ReactiveMongoTemplate mongoTemplate;
    @InjectMocks private PostService postService;

    @Test @DisplayName("게시글 생성 시 저자 정보가 정확히 설정된다")
    void createPost_setsAuthorInfo() {
        Post saved = Post.builder().id("p1").authorId("u1")
            .authorNickname("홍길동").title("제목").build();
        when(postRepository.save(any(Post.class))).thenReturn(Mono.just(saved));
        StepVerifier.create(postService.createPost(
                new PostRequest("제목", "본문"), "u1", "홍길동"))
            .assertNext(p -&gt; assertThat(p.getAuthorId()).isEqualTo("u1"))
            .verifyComplete();
    }

    @Test @DisplayName("존재하지 않는 게시글 조회 시 NotFoundException")
    void getPost_notFound() {
        when(postRepository.findById("x")).thenReturn(Mono.empty());
        StepVerifier.create(postService.getPost("x"))
            .expectError(NotFoundException.class).verify();
    }

    @Test @DisplayName("작성자가 아닌 사용자의 수정 시 ForbiddenException")
    void updatePost_wrongAuthor() {
        when(postRepository.findById("p1")).thenReturn(
            Mono.just(Post.builder().id("p1").authorId("u1").build()));
        StepVerifier.create(postService.updatePost("p1",
                new PostRequest("수정", "수정"), "u999"))
            .expectError(ForbiddenException.class).verify();
    }
}</code></pre>
<h3 id="2183-postcontroller">21.8.3 PostController 통합 테스트</h3>
<pre class="highlight"><code class="language-java">class PostControllerTest extends IntegrationTestBase {

    @Autowired private UserRepository userRepository;
    @Autowired private PostRepository postRepository;
    @Autowired private JwtTokenProvider jwtTokenProvider;
    private String authToken;

    @BeforeEach
    void setup() {
        User user = User.builder().id("test-user").email("test@example.com")
            .nickname("테스터").password("encoded").build();
        userRepository.save(user).block();
        authToken = jwtTokenProvider.createToken(
            user.getId(), user.getEmail(), user.getRoles());
    }

    @AfterEach
    void cleanup() {
        postRepository.deleteAll().then(userRepository.deleteAll()).block();
    }

    @Test @DisplayName("인증된 사용자가 게시글을 생성하면 201 응답")
    void createPost_returns201() {
        webTestClient.post().uri("/api/posts")
            .header(HttpHeaders.AUTHORIZATION, "Bearer " + authToken)
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(new PostRequest("테스트 제목", "테스트 본문"))
            .exchange()
            .expectStatus().isCreated()
            .expectBody()
            .jsonPath("$.title").isEqualTo("테스트 제목")
            .jsonPath("$.authorNickname").isEqualTo("테스터");
    }

    @Test @DisplayName("인증 없이 게시글 생성 시 401 응답")
    void createPost_unauthenticated() {
        webTestClient.post().uri("/api/posts")
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(new PostRequest("제목", "본문"))
            .exchange().expectStatus().isUnauthorized();
    }

    @Test @DisplayName("게시글 목록 페이징 조회")
    void listPosts_paged() {
        Flux.range(1, 15).flatMap(i -&gt; postRepository.save(Post.builder()
            .title("게시글 " + i).content("본문").authorId("test-user")
            .authorNickname("테스터").build())).blockLast();
        webTestClient.get().uri("/api/posts?page=0&amp;size=10").exchange()
            .expectStatus().isOk().expectBody()
            .jsonPath("$.content.length()").isEqualTo(10)
            .jsonPath("$.totalElements").isEqualTo(15)
            .jsonPath("$.hasNext").isEqualTo(true);
    }
}</code></pre>
<hr>
<h2 id="219-docker-compose">21.9 Docker Compose로 배포</h2>
<h3 id="2191">21.9.1 설정 파일</h3>
<pre class="highlight"><code class="language-yaml"># application.yml
spring:
  data:
    mongodb:
      uri: ${MONGODB_URI:mongodb://localhost:27017/reactive-board?replicaSet=rs0}
jwt:
  secret: ${JWT_SECRET:Y2xhdWRlLXdlYmZsdXgtYm9vay1zZWNyZXQta2V5LWZvci1qd3QtdG9rZW4=}
  access-token-validity: 3600000</code></pre>
<pre class="highlight"><code class="language-dockerfile">FROM eclipse-temurin:21-jre-alpine
WORKDIR /app
COPY build/libs/reactive-board-0.0.1-SNAPSHOT.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]</code></pre>
<p>MongoDB를 레플리카 셋으로 구성해야 Change Streams가 동작한다.</p>
<pre class="highlight"><code class="language-yaml"># docker-compose.yml
version: '3.8'
services:
  mongodb:
    image: mongo:7.0
    ports: ["27017:27017"]
    volumes: [mongo-data:/data/db]
    command: ["--replSet", "rs0", "--bind_ip_all"]
    healthcheck:
      test: &gt;
        mongosh --eval "try { rs.status().ok }
        catch(e) { rs.initiate({_id:'rs0',members:[{_id:0,host:'mongodb:27017'}]}).ok }"
      interval: 10s
      start_period: 30s
  app:
    build: .
    ports: ["8080:8080"]
    environment:
      MONGODB_URI: mongodb://mongodb:27017/reactive-board?replicaSet=rs0&amp;directConnection=true
      JWT_SECRET: Y2xhdWRlLXdlYmZsdXgtYm9vay1zZWNyZXQta2V5LWZvci1qd3QtdG9rZW4=
    depends_on:
      mongodb: { condition: service_healthy }
volumes:
  mongo-data:</code></pre>
<h3 id="2192-api">21.9.2 빌드 및 API 동작 확인</h3>
<pre class="highlight"><code class="language-bash">./gradlew clean build &amp;&amp; docker compose up --build -d

# 회원가입 → 로그인 → 토큰 획득
curl -X POST http://localhost:8080/api/auth/signup -H "Content-Type: application/json" \
  -d '{"email":"user@example.com","nickname":"홍길동","password":"pass123"}'
TOKEN=$(curl -s -X POST http://localhost:8080/api/auth/login -H "Content-Type: application/json" \
  -d '{"email":"user@example.com","password":"pass123"}' | jq -r '.token')

# 게시글 작성 / SSE 구독 / 파일 업로드
curl -X POST http://localhost:8080/api/posts -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" -d '{"title":"첫 게시글","content":"WebFlux 게시판"}'
curl -N http://localhost:8080/api/notifications/stream   # 별도 터미널에서 SSE 구독
curl -X POST http://localhost:8080/api/files -H "Authorization: Bearer $TOKEN" -F "file=@./sample.png"</code></pre>
<h3 id="2193">21.9.3 전체 요청 흐름</h3>
<pre class="highlight"><code>[사용자 A] POST /api/posts → JWT 검증 → MongoDB insert → 201 Created
[사용자 B] GET /api/notifications/stream (SSE 연결 유지)
[사용자 C] POST /api/posts/{id}/comments → MongoDB insert → Change Stream → SSE 알림 전송</code></pre>
<hr>
<p>이번 장에서 구축한 실시간 게시판 서비스는 Part 1부터 Part 6까지 다룬 핵심 개념을 모두 통합한 결과물이다. Reactor 기반의 논블로킹 처리, MongoDB 리액티브 드라이버, JWT 인증, SSE 실시간 통신, GridFS 파일 관리, StepVerifier와 WebTestClient를 활용한 테스트, Docker Compose 배포까지 전 과정을 실전 코드로 경험했다. 다음 장에서는 이 프로젝트를 확장하여 실시간 채팅 서비스를 구축하며 WebSocket과 고급 메시징 패턴을 다룬다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>