<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 14. WebClient | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="ch13.html">&larr; Chapter 13. WebSocket</a>
    <a href="../index.html">목차</a>
    <a href="ch15.html">Chapter 15. R2DBC와의 통합 &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-14-webclient-http">Chapter 14. WebClient: 리액티브 HTTP 클라이언트</h1>
<p>Spring WebFlux 애플리케이션에서 외부 서비스와 통신해야 할 때, 전통적인 <code>RestTemplate</code> 대신 <code>WebClient</code>를 사용한다. <code>WebClient</code>는 Spring 5에서 도입된 <strong>논블로킹 리액티브 HTTP 클라이언트</strong>로, 이번 장에서는 설정과 기본 사용법부터 에러 핸들링, 재시도, 타임아웃, 외부 API 동시 호출, 필터까지 실전에서 필요한 모든 내용을 다룬다.</p>
<hr>
<h2 id="141-webclient">14.1 WebClient 설정과 기본 사용법</h2>
<h3 id="1411-webclient">14.1.1 WebClient란?</h3>
<p><code>WebClient</code>는 Spring WebFlux 모듈에 포함된 논블로킹 HTTP 클라이언트다. 내부적으로 Reactor Netty의 <code>HttpClient</code>를 사용하며, 리액티브 스트림 기반으로 요청과 응답을 처리한다.</p>
<table>
<thead>
<tr>
<th>특성</th>
<th>RestTemplate</th>
<th>WebClient</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>블로킹 여부</strong></td>
<td>블로킹</td>
<td>논블로킹</td>
</tr>
<tr>
<td><strong>반환 타입</strong></td>
<td>직접 객체 반환</td>
<td><code>Mono&lt;T&gt;</code>, <code>Flux&lt;T&gt;</code></td>
</tr>
<tr>
<td><strong>스트리밍</strong></td>
<td>미지원</td>
<td>SSE, 스트리밍 응답 지원</td>
</tr>
<tr>
<td><strong>유지 상태</strong></td>
<td>Spring 6에서 deprecated</td>
<td>현재 권장 방식</td>
</tr>
</tbody>
</table>
<h3 id="1412-webclient">14.1.2 WebClient 생성과 빈 설정</h3>
<p><code>WebClient</code>는 <code>create()</code>, <code>create(baseUrl)</code>, <code>builder()</code> 세 가지 방식으로 생성한다. 실전에서는 <code>builder()</code>를 사용하여 빈으로 등록하는 것이 일반적이다. 여러 외부 서비스를 호출하는 경우, 서비스별로 별도의 빈을 정의한다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class WebClientConfig {

    @Bean("userServiceClient")
    public WebClient userServiceClient() {
        return WebClient.builder()
            .baseUrl("https://user-service.example.com")
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .build();
    }

    @Bean("orderServiceClient")
    public WebClient orderServiceClient() {
        return WebClient.builder()
            .baseUrl("https://order-service.example.com")
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .build();
    }
}</code></pre>
<h3 id="1413">14.1.3 커넥션 풀 설정</h3>
<p>운영 환경에서는 Reactor Netty의 커넥션 풀을 명시적으로 설정하는 것이 바람직하다.</p>
<pre class="highlight"><code class="language-java">@Bean
public WebClient webClient() {
    ConnectionProvider provider = ConnectionProvider.builder("custom-pool")
        .maxConnections(500)                           // 최대 커넥션 수
        .maxIdleTime(Duration.ofSeconds(20))            // 유휴 커넥션 유지 시간
        .maxLifeTime(Duration.ofSeconds(60))            // 커넥션 최대 수명
        .pendingAcquireTimeout(Duration.ofSeconds(60))  // 커넥션 대기 타임아웃
        .evictInBackground(Duration.ofSeconds(120))     // 백그라운드 정리 주기
        .build();

    HttpClient httpClient = HttpClient.create(provider)
        .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)
        .compress(true);

    return WebClient.builder()
        .baseUrl("https://api.example.com")
        .clientConnector(new ReactorClientHttpConnector(httpClient))
        .build();
}</code></pre>
<h3 id="1414-codec">14.1.4 코덱(Codec) 설정</h3>
<p>대용량 응답 처리나 커스텀 직렬화가 필요한 경우 코덱을 설정한다. <code>maxInMemorySize</code>는 응답 본문의 메모리 버퍼 최대 크기(기본 256KB)이며, 대용량 JSON 응답 시 <code>DataBufferLimitException</code>이 발생하면 이 값을 늘린다.</p>
<pre class="highlight"><code class="language-java">@Bean
public WebClient webClient() {
    return WebClient.builder()
        .codecs(configurer -&gt; {
            configurer.defaultCodecs().maxInMemorySize(10 * 1024 * 1024); // 10MB

            ObjectMapper mapper = new ObjectMapper();
            mapper.registerModule(new JavaTimeModule());
            mapper.setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);
            configurer.defaultCodecs().jackson2JsonEncoder(
                new Jackson2JsonEncoder(mapper, MediaType.APPLICATION_JSON));
            configurer.defaultCodecs().jackson2JsonDecoder(
                new Jackson2JsonDecoder(mapper, MediaType.APPLICATION_JSON));
        })
        .build();
}</code></pre>
<hr>
<h2 id="142-get-post-put-delete">14.2 요청/응답 처리 (GET, POST, PUT, DELETE)</h2>
<h3 id="1421-get">14.2.1 GET 요청</h3>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class ProductClientService {

    private final WebClient webClient;

    // 단일 객체 조회
    public Mono&lt;Product&gt; getProduct(String id) {
        return webClient.get()
            .uri("/api/products/{id}", id)
            .retrieve()
            .bodyToMono(Product.class);
    }

    // 목록 조회
    public Flux&lt;Product&gt; getAllProducts() {
        return webClient.get()
            .uri("/api/products")
            .retrieve()
            .bodyToFlux(Product.class);
    }

    // 쿼리 파라미터 사용
    public Flux&lt;Product&gt; searchProducts(String keyword, int page, int size) {
        return webClient.get()
            .uri(uriBuilder -&gt; uriBuilder
                .path("/api/products/search")
                .queryParam("keyword", keyword)
                .queryParam("page", page)
                .queryParam("size", size)
                .build())
            .retrieve()
            .bodyToFlux(Product.class);
    }
}</code></pre>
<h3 id="1422-post">14.2.2 POST 요청</h3>
<pre class="highlight"><code class="language-java">// JSON 본문 전송 (bodyValue: 준비된 객체)
public Mono&lt;Product&gt; createProduct(ProductRequest request) {
    return webClient.post().uri("/api/products")
        .bodyValue(request).retrieve().bodyToMono(Product.class);
}

// Mono 본문 전송 (body: Publisher 타입)
public Mono&lt;Product&gt; createProductReactive(Mono&lt;ProductRequest&gt; request) {
    return webClient.post().uri("/api/products")
        .body(request, ProductRequest.class).retrieve().bodyToMono(Product.class);
}

// 폼 데이터 전송
public Mono&lt;String&gt; submitForm(String username, String password) {
    return webClient.post().uri("/api/auth/login")
        .contentType(MediaType.APPLICATION_FORM_URLENCODED)
        .body(BodyInserters.fromFormData("username", username)
            .with("password", password))
        .retrieve().bodyToMono(String.class);
}</code></pre>
<h3 id="1423-put-delete">14.2.3 PUT과 DELETE 요청</h3>
<pre class="highlight"><code class="language-java">public Mono&lt;Product&gt; updateProduct(String id, ProductRequest request) {
    return webClient.put()
        .uri("/api/products/{id}", id)
        .bodyValue(request)
        .retrieve()
        .bodyToMono(Product.class);
}

public Mono&lt;Void&gt; deleteProduct(String id) {
    return webClient.delete()
        .uri("/api/products/{id}", id)
        .retrieve()
        .bodyToMono(Void.class);
}</code></pre>
<h3 id="1424-retrieve-vs-exchangetomono">14.2.4 retrieve() vs exchangeToMono()</h3>
<p><code>retrieve()</code>는 간결하게 응답 본문만 추출하며 4xx/5xx에 자동 예외를 던진다. <code>exchangeToMono()</code>는 상태 코드, 헤더 등 전체 응답 정보에 접근할 수 있다.</p>
<pre class="highlight"><code class="language-java">public Mono&lt;Product&gt; getProductWithStatus(String id) {
    return webClient.get()
        .uri("/api/products/{id}", id)
        .exchangeToMono(response -&gt; {
            if (response.statusCode().is2xxSuccessful()) {
                return response.bodyToMono(Product.class);
            } else if (response.statusCode() == HttpStatus.NOT_FOUND) {
                return Mono.empty();
            } else {
                return response.createError();
            }
        });
}</code></pre>
<blockquote>
<p><strong>주의</strong>: 이전 버전의 <code>exchange()</code> 메서드는 deprecated되었다. 리소스 누수 위험이 있으므로, 반드시 <code>exchangeToMono()</code> 또는 <code>exchangeToFlux()</code>를 사용한다.</p>
</blockquote>
<p>응답 헤더와 상태 코드가 모두 필요하면 <code>toEntity()</code>를 사용한다.</p>
<pre class="highlight"><code class="language-java">public Mono&lt;ResponseEntity&lt;Product&gt;&gt; getProductWithHeaders(String id) {
    return webClient.get()
        .uri("/api/products/{id}", id)
        .retrieve()
        .toEntity(Product.class);
}</code></pre>
<h3 id="1425">14.2.5 스트리밍 응답 처리</h3>
<p>SSE 스트림이나 NDJSON 스트림을 구독할 수 있다.</p>
<pre class="highlight"><code class="language-java">// SSE 스트림
public Flux&lt;ServerSentEvent&lt;String&gt;&gt; subscribeToEvents() {
    return webClient.get().uri("/api/events/stream")
        .accept(MediaType.TEXT_EVENT_STREAM).retrieve()
        .bodyToFlux(new ParameterizedTypeReference&lt;ServerSentEvent&lt;String&gt;&gt;() {});
}

// NDJSON 스트림
public Flux&lt;Product&gt; streamProducts() {
    return webClient.get().uri("/api/products/stream")
        .accept(MediaType.APPLICATION_NDJSON).retrieve()
        .bodyToFlux(Product.class);
}</code></pre>
<hr>
<h2 id="143">14.3 에러 핸들링과 재시도 전략</h2>
<h3 id="1431-onstatus">14.3.1 onStatus()를 활용한 상태 코드별 처리</h3>
<p><code>retrieve()</code>는 4xx/5xx에 자동으로 <code>WebClientResponseException</code>을 발생시킨다. <code>onStatus()</code>로 커스텀 처리를 정의한다.</p>
<pre class="highlight"><code class="language-java">public Mono&lt;Product&gt; getProduct(String id) {
    return webClient.get()
        .uri("/api/products/{id}", id)
        .retrieve()
        .onStatus(HttpStatusCode::is4xxClientError, response -&gt; {
            if (response.statusCode() == HttpStatus.NOT_FOUND) {
                return Mono.error(
                    new ProductNotFoundException("상품을 찾을 수 없습니다: " + id));
            }
            return response.bodyToMono(ErrorResponse.class)
                .flatMap(error -&gt; Mono.error(
                    new InvalidRequestException(error.getMessage())));
        })
        .onStatus(HttpStatusCode::is5xxServerError, response -&gt;
            response.bodyToMono(String.class)
                .flatMap(body -&gt; Mono.error(
                    new ExternalServiceException("서버 에러: " + body)))
        )
        .bodyToMono(Product.class);
}</code></pre>
<h3 id="1432-retrywhen-retrybackoff">14.3.2 retryWhen()과 Retry.backoff()</h3>
<p><code>retry(n)</code>은 즉시 재시도하므로 과부하를 유발한다. 운영 환경에서는 <code>Retry.backoff()</code>로 지수 백오프를 사용한다.</p>
<pre class="highlight"><code class="language-java">public Mono&lt;Product&gt; getProductWithBackoff(String id) {
    return webClient.get()
        .uri("/api/products/{id}", id)
        .retrieve()
        .bodyToMono(Product.class)
        .retryWhen(Retry.backoff(3, Duration.ofSeconds(1))
            .maxBackoff(Duration.ofSeconds(10))
            .jitter(0.5)
            .filter(ex -&gt; ex instanceof WebClientResponseException.ServiceUnavailable
                       || ex instanceof ConnectException)
            .doBeforeRetry(signal -&gt; log.warn(
                "재시도 #{} - 원인: {}",
                signal.totalRetries() + 1,
                signal.failure().getMessage()))
            .onRetryExhaustedThrow((spec, signal) -&gt;
                new ExternalServiceException(
                    "재시도 횟수 초과: " + signal.failure().getMessage(),
                    signal.failure()))
        );
}</code></pre>
<table>
<thead>
<tr>
<th>재시도 횟수</th>
<th>최소 대기 시간</th>
<th>jitter=0.5 적용 시 범위</th>
</tr>
</thead>
<tbody>
<tr>
<td>1회차</td>
<td>1초</td>
<td>0.5초 ~ 1.5초</td>
</tr>
<tr>
<td>2회차</td>
<td>2초</td>
<td>1초 ~ 3초</td>
</tr>
<tr>
<td>3회차</td>
<td>4초</td>
<td>2초 ~ 6초</td>
</tr>
</tbody>
</table>
<p><code>jitter</code>는 여러 클라이언트가 동시에 재시도하여 부하가 집중되는 "thundering herd" 문제를 방지한다.</p>
<h3 id="1433">14.3.3 서킷 브레이커 패턴</h3>
<p>외부 서비스가 장시간 장애 상태일 때, Resilience4j로 서킷 브레이커를 적용한다.</p>
<pre class="highlight"><code class="language-groovy">dependencies {
    implementation 'io.github.resilience4j:resilience4j-spring-boot3:2.2.0'
    implementation 'io.github.resilience4j:resilience4j-reactor:2.2.0'
}</code></pre>
<pre class="highlight"><code class="language-yaml">resilience4j:
  circuitbreaker:
    instances:
      productService:
        sliding-window-size: 10
        failure-rate-threshold: 50
        wait-duration-in-open-state: 30s
        permitted-number-of-calls-in-half-open-state: 3</code></pre>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class ProductClientService {

    private final WebClient webClient;
    private final CircuitBreakerRegistry circuitBreakerRegistry;

    public Mono&lt;Product&gt; getProduct(String id) {
        CircuitBreaker cb = circuitBreakerRegistry.circuitBreaker("productService");

        return webClient.get()
            .uri("/api/products/{id}", id)
            .retrieve()
            .bodyToMono(Product.class)
            .transformDeferred(CircuitBreakerOperator.of(cb))
            .onErrorResume(CallNotPermittedException.class, ex -&gt; {
                log.warn("서킷 브레이커 OPEN - 폴백 실행");
                return Mono.just(Product.fallback(id));
            })
            .retryWhen(Retry.backoff(2, Duration.ofMillis(500))
                .filter(ex -&gt; !(ex instanceof CallNotPermittedException)));
    }
}</code></pre>
<table>
<thead>
<tr>
<th>상태</th>
<th>동작</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CLOSED</strong></td>
<td>정상 상태. 모든 요청 전달, 실패율 모니터링</td>
</tr>
<tr>
<td><strong>OPEN</strong></td>
<td>차단 상태. 즉시 폴백 실행. 대기 시간 후 HALF_OPEN 전환</td>
</tr>
<tr>
<td><strong>HALF_OPEN</strong></td>
<td>일부 요청만 허용하여 복구 확인. 성공하면 CLOSED, 실패하면 OPEN</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="144">14.4 타임아웃 설정</h2>
<p>외부 서비스 호출 시 타임아웃은 필수다. 없으면 외부 장애가 자신의 애플리케이션까지 전파된다.</p>
<h3 id="1441">14.4.1 계층별 타임아웃</h3>
<pre class="highlight"><code class="language-java">HttpClient httpClient = HttpClient.create()
    // 1. 커넥션 타임아웃: TCP 연결 수립
    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 3000)
    // 2. 응답 타임아웃: 첫 응답 바이트 수신까지
    .responseTimeout(Duration.ofSeconds(5))
    // 3. 읽기/쓰기 타임아웃: 데이터 전송 중 무응답
    .doOnConnected(conn -&gt; conn
        .addHandlerLast(new ReadTimeoutHandler(10, TimeUnit.SECONDS))
        .addHandlerLast(new WriteTimeoutHandler(10, TimeUnit.SECONDS)));

WebClient webClient = WebClient.builder()
    .clientConnector(new ReactorClientHttpConnector(httpClient))
    .build();</code></pre>
<h3 id="1442-reactor-timeout">14.4.2 Reactor timeout() 연산자</h3>
<p>리액티브 체인 수준에서 재시도 포함 전체 시간을 제한한다.</p>
<pre class="highlight"><code class="language-java">public Mono&lt;Product&gt; getProduct(String id) {
    return webClient.get()
        .uri("/api/products/{id}", id)
        .retrieve()
        .bodyToMono(Product.class)
        .retryWhen(Retry.backoff(3, Duration.ofSeconds(1)))
        .timeout(Duration.ofSeconds(15))
        .onErrorResume(TimeoutException.class, ex -&gt;
            Mono.error(new ExternalServiceException("응답 시간 초과")));
}</code></pre>
<h3 id="1443">14.4.3 타임아웃 종합 정리</h3>
<table>
<thead>
<tr>
<th>타임아웃</th>
<th>적용 계층</th>
<th>대상</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>커넥션 타임아웃</strong></td>
<td>TCP</td>
<td>서버와 TCP 연결 수립</td>
</tr>
<tr>
<td><strong>응답 타임아웃</strong></td>
<td>HTTP</td>
<td>첫 응답 바이트 수신까지</td>
</tr>
<tr>
<td><strong>읽기 타임아웃</strong></td>
<td>TCP</td>
<td>데이터 읽기 중 무응답</td>
</tr>
<tr>
<td><strong>쓰기 타임아웃</strong></td>
<td>TCP</td>
<td>데이터 쓰기 중 무응답</td>
</tr>
<tr>
<td><strong>Reactor timeout()</strong></td>
<td>리액티브</td>
<td>전체 리액티브 체인 완료</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="145-api">14.5 외부 API 연동 실전 예제</h2>
<h3 id="1451-rest-api">14.5.1 REST API 호출 서비스</h3>
<p>외부 날씨 API를 호출하는 실전 예제다. 에러 처리, 재시도, 타임아웃을 모두 적용한다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Service
public class WeatherClientService {

    private final WebClient webClient;

    public WeatherClientService(WebClient.Builder builder,
                                @Value("${weather.api.key}") String apiKey) {
        this.webClient = builder
            .baseUrl("https://api.openweathermap.org/data/2.5")
            .defaultUriVariables(Map.of("appid", apiKey)).build();
    }

    public Mono&lt;WeatherResponse&gt; getCurrentWeather(String city) {
        return webClient.get()
            .uri(uriBuilder -&gt; uriBuilder.path("/weather")
                .queryParam("q", city).queryParam("appid", "{appid}")
                .queryParam("units", "metric").build())
            .retrieve()
            .onStatus(HttpStatusCode::is4xxClientError, response -&gt;
                response.statusCode() == HttpStatus.NOT_FOUND
                    ? Mono.error(new CityNotFoundException("도시를 찾을 수 없습니다: " + city))
                    : response.createException())
            .bodyToMono(WeatherResponse.class)
            .retryWhen(Retry.backoff(2, Duration.ofSeconds(1))
                .filter(ex -&gt; ex instanceof WebClientResponseException.ServiceUnavailable))
            .timeout(Duration.ofSeconds(10));
    }
}</code></pre>
<h3 id="1452-api-zip">14.5.2 여러 API 동시 호출 (zip)</h3>
<p><code>Mono.zip()</code>으로 독립적인 여러 API를 병렬 실행하고 결과를 조합한다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class DashboardService {

    private final UserClientService userClient;
    private final OrderClientService orderClient;
    private final WeatherClientService weatherClient;

    public Mono&lt;DashboardResponse&gt; getDashboard(String userId) {
        Mono&lt;UserProfile&gt; userMono = userClient.getProfile(userId);
        Mono&lt;List&lt;Order&gt;&gt; ordersMono = orderClient.getRecentOrders(userId).collectList();
        Mono&lt;WeatherResponse&gt; weatherMono = weatherClient.getCurrentWeather("Seoul");

        return Mono.zip(userMono, ordersMono, weatherMono)
            .map(tuple -&gt; DashboardResponse.builder()
                .user(tuple.getT1())
                .recentOrders(tuple.getT2())
                .weather(tuple.getT3())
                .build());
    }
}</code></pre>
<p>세 API 호출은 <strong>동시에</strong> 실행되므로, 가장 느린 호출 기준으로만 대기한다.</p>
<h3 id="1453-api-merge">14.5.3 여러 API 결과 병합 (merge)</h3>
<p><code>Flux.merge()</code>는 여러 소스의 결과를 도착 순서대로 합친다.</p>
<pre class="highlight"><code class="language-java">public Flux&lt;PriceQuote&gt; getPriceQuotes(String productId) {
    Flux&lt;PriceQuote&gt; a = webClient.get()
        .uri("https://supplier-a.com/api/price/{id}", productId)
        .retrieve().bodyToMono(PriceQuote.class).flux();
    Flux&lt;PriceQuote&gt; b = webClient.get()
        .uri("https://supplier-b.com/api/price/{id}", productId)
        .retrieve().bodyToMono(PriceQuote.class).flux();

    return Flux.merge(a, b)
        .timeout(Duration.ofSeconds(5))
        .onErrorResume(ex -&gt; Flux.empty());
}</code></pre>
<h3 id="1454-api-flatmap">14.5.4 순차 API 호출 (flatMap 체이닝)</h3>
<p>하나의 API 결과를 다음 API의 입력으로 사용하는 경우 <code>flatMap</code>으로 체이닝한다.</p>
<pre class="highlight"><code class="language-java">// 1. 사용자 조회 → 2. 주문 생성 → 3. 결제 처리
public Mono&lt;PaymentResult&gt; processOrder(String userId, OrderRequest orderRequest) {
    return webClient.get()
        .uri("/api/users/{id}", userId)
        .retrieve()
        .bodyToMono(UserProfile.class)
        .flatMap(user -&gt; {
            orderRequest.setShippingAddress(user.getAddress());
            return webClient.post()
                .uri("/api/orders")
                .bodyValue(orderRequest)
                .retrieve()
                .bodyToMono(OrderResponse.class);
        })
        .flatMap(order -&gt; webClient.post()
            .uri("/api/payments")
            .bodyValue(new PaymentRequest(order.getId(), order.getTotalAmount()))
            .retrieve()
            .bodyToMono(PaymentResult.class));
}</code></pre>
<h3 id="1455-fallback">14.5.5 폴백(Fallback) 패턴</h3>
<p>외부 API 실패 시 대체 데이터를 반환한다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Service
@RequiredArgsConstructor
public class ProductService {

    private final WebClient webClient;
    private final ProductRepository productRepository;

    public Mono&lt;Product&gt; getProduct(String id) {
        return webClient.get()
            .uri("/api/products/{id}", id)
            .retrieve().bodyToMono(Product.class)
            .timeout(Duration.ofSeconds(3))
            .onErrorResume(ex -&gt; {
                log.warn("외부 API 실패, 로컬 DB 폴백: {}", ex.getMessage());
                return productRepository.findById(id);
            });
    }

    // 다단계 폴백: 캐시 → 외부 API → 기본값
    public Mono&lt;ExchangeRate&gt; getExchangeRate(String currency) {
        return getFromCache(currency)
            .switchIfEmpty(getFromExternalApi(currency)
                .doOnNext(rate -&gt; saveToCache(currency, rate)))
            .switchIfEmpty(Mono.just(ExchangeRate.defaultRate(currency)))
            .onErrorReturn(ExchangeRate.defaultRate(currency));
    }
}</code></pre>
<h3 id="1456-api">14.5.6 페이지네이션 API 전체 조회</h3>
<p><code>expand()</code> 연산자로 재귀적으로 다음 페이지를 호출하며, <code>Mono.empty()</code> 반환 시 재귀가 종료된다.</p>
<pre class="highlight"><code class="language-java">public Flux&lt;Product&gt; getAllProductsPaginated() {
    return fetchPage(0)
        .expand(page -&gt; page.hasNext() ? fetchPage(page.getPage() + 1) : Mono.empty())
        .flatMapIterable(PageResponse::getContent);
}

private Mono&lt;PageResponse&lt;Product&gt;&gt; fetchPage(int page) {
    return webClient.get()
        .uri(uriBuilder -&gt; uriBuilder.path("/api/products")
            .queryParam("page", page).queryParam("size", 100).build())
        .retrieve()
        .bodyToMono(new ParameterizedTypeReference&lt;PageResponse&lt;Product&gt;&gt;() {});
}</code></pre>
<hr>
<h2 id="146-webclient">14.6 WebClient 필터와 인터셉터</h2>
<h3 id="1461-exchangefilterfunction">14.6.1 ExchangeFilterFunction과 로깅 필터</h3>
<p><code>ExchangeFilterFunction</code>은 <code>WebClient</code>의 요청/응답 파이프라인에 횡단 관심사를 추가하는 메커니즘이다. <code>WebClient.builder().filter()</code>로 등록하며, 여러 필터를 등록하면 등록 순서대로 체이닝된다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
public class WebClientFilters {

    public static ExchangeFilterFunction logRequestResponse() {
        return (request, next) -&gt; {
            long startTime = System.currentTimeMillis();
            log.info("&gt;&gt;&gt; {} {}", request.method(), request.url());

            return next.exchange(request)
                .doOnNext(response -&gt; {
                    long duration = System.currentTimeMillis() - startTime;
                    log.info("&lt;&lt;&lt; {} {} - {}ms",
                        response.statusCode(), request.url(), duration);
                });
        };
    }
}</code></pre>
<h3 id="1462">14.6.2 인증 필터</h3>
<p>정적 API 키 필터와 동적 토큰 갱신 필터를 구현한다.</p>
<pre class="highlight"><code class="language-java">public static ExchangeFilterFunction apiKeyAuth(String apiKey) {
    return (request, next) -&gt; {
        ClientRequest filtered = ClientRequest.from(request)
            .header("X-API-Key", apiKey).build();
        return next.exchange(filtered);
    };
}</code></pre>
<pre class="highlight"><code class="language-java">@Component
@RequiredArgsConstructor
public class DynamicAuthFilter {

    private final TokenService tokenService;

    public ExchangeFilterFunction authFilter() {
        return (request, next) -&gt;
            tokenService.getValidToken()
                .flatMap(token -&gt; {
                    ClientRequest filtered = ClientRequest.from(request)
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                        .build();
                    return next.exchange(filtered);
                });
    }
}</code></pre>
<pre class="highlight"><code class="language-java">@Service
public class TokenService {

    private final WebClient authClient;
    private final AtomicReference&lt;TokenInfo&gt; cachedToken = new AtomicReference&lt;&gt;();

    public TokenService(WebClient.Builder builder) {
        this.authClient = builder.baseUrl("https://auth.example.com").build();
    }

    public Mono&lt;String&gt; getValidToken() {
        TokenInfo current = cachedToken.get();
        if (current != null &amp;&amp; !current.isExpired()) {
            return Mono.just(current.getAccessToken());
        }
        return authClient.post().uri("/oauth/token")
            .contentType(MediaType.APPLICATION_FORM_URLENCODED)
            .body(BodyInserters.fromFormData("grant_type", "client_credentials")
                .with("client_id", "my-client").with("client_secret", "my-secret"))
            .retrieve().bodyToMono(TokenInfo.class)
            .doOnNext(cachedToken::set).map(TokenInfo::getAccessToken);
    }
}</code></pre>
<h3 id="1463-id">14.6.3 에러 처리 필터와 요청 ID 전파 필터</h3>
<pre class="highlight"><code class="language-java">public static ExchangeFilterFunction errorHandlingFilter() {
    return (request, next) -&gt; next.exchange(request)
        .flatMap(response -&gt; {
            if (response.statusCode().is5xxServerError()) {
                return response.bodyToMono(String.class)
                    .flatMap(body -&gt; Mono.error(new ExternalServiceException(
                        "서버 에러 [" + request.method() + " " + request.url() + "]: " + body)));
            }
            return Mono.just(response);
        });
}

public static ExchangeFilterFunction traceIdFilter() {
    return (request, next) -&gt; {
        String traceId = Optional.ofNullable(MDC.get("traceId"))
            .orElse(UUID.randomUUID().toString().substring(0, 8));
        ClientRequest filtered = ClientRequest.from(request)
            .header("X-Trace-Id", traceId).build();
        return next.exchange(filtered);
    };
}</code></pre>
<h3 id="1464">14.6.4 필터 조합과 적용</h3>
<p>여러 필터를 조합하여 적용하는 전체 예제다.</p>
<pre class="highlight"><code class="language-java">@Configuration
@RequiredArgsConstructor
public class WebClientConfig {

    private final DynamicAuthFilter dynamicAuthFilter;
    @Value("${external.api.base-url}") private String baseUrl;

    @Bean
    public WebClient webClient() {
        HttpClient httpClient = HttpClient.create()
            .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)
            .responseTimeout(Duration.ofSeconds(10))
            .doOnConnected(conn -&gt; conn
                .addHandlerLast(new ReadTimeoutHandler(10, TimeUnit.SECONDS))
                .addHandlerLast(new WriteTimeoutHandler(10, TimeUnit.SECONDS)));

        return WebClient.builder()
            .baseUrl(baseUrl)
            .clientConnector(new ReactorClientHttpConnector(httpClient))
            .codecs(c -&gt; c.defaultCodecs().maxInMemorySize(5 * 1024 * 1024))
            .filter(WebClientFilters.traceIdFilter())       // 1. 추적
            .filter(dynamicAuthFilter.authFilter())          // 2. 인증
            .filter(WebClientFilters.logRequestResponse())   // 3. 로깅
            .filter(WebClientFilters.errorHandlingFilter())  // 4. 에러 처리
            .build();
    }
}</code></pre>
<p>필터 등록 순서가 곧 실행 순서다. 권장 순서는 추적 -&gt; 인증 -&gt; 로깅 -&gt; 에러 처리 순이다.</p>
<h3 id="1465-webclient">14.6.5 테스트에서의 WebClient 모킹</h3>
<p><code>MockWebServer</code>로 외부 API를 모킹하여 테스트한다.</p>
<pre class="highlight"><code class="language-groovy">testImplementation 'com.squareup.okhttp3:mockwebserver:4.12.0'</code></pre>
<pre class="highlight"><code class="language-java">class ProductClientServiceTest {

    private MockWebServer mockWebServer;
    private ProductClientService service;

    @BeforeEach
    void setUp() throws IOException {
        mockWebServer = new MockWebServer();
        mockWebServer.start();
        service = new ProductClientService(
            WebClient.builder().baseUrl(mockWebServer.url("/").toString()).build());
    }

    @AfterEach
    void tearDown() throws IOException { mockWebServer.shutdown(); }

    @Test
    void getProduct_성공() {
        mockWebServer.enqueue(new MockResponse()
            .setBody("{\"id\":\"123\",\"name\":\"테스트 상품\",\"price\":10000}")
            .addHeader("Content-Type", "application/json"));

        StepVerifier.create(service.getProduct("123"))
            .assertNext(p -&gt; assertThat(p.getName()).isEqualTo("테스트 상품"))
            .verifyComplete();
    }

    @Test
    void getProduct_재시도_후_성공() {
        // 처음 두 번은 503, 세 번째는 성공
        mockWebServer.enqueue(new MockResponse().setResponseCode(503));
        mockWebServer.enqueue(new MockResponse().setResponseCode(503));
        mockWebServer.enqueue(new MockResponse()
            .setBody("{\"id\":\"123\",\"name\":\"상품\",\"price\":5000}")
            .addHeader("Content-Type", "application/json"));

        StepVerifier.create(service.getProductWithBackoff("123"))
            .assertNext(p -&gt; assertThat(p.getId()).isEqualTo("123"))
            .verifyComplete();
        assertThat(mockWebServer.getRequestCount()).isEqualTo(3);
    }
}</code></pre>
<hr>
<h2 id="_1">요약</h2>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 내용</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>WebClient 설정</strong></td>
<td><code>WebClient.builder()</code>로 빈 생성, 커넥션 풀(<code>ConnectionProvider</code>), 코덱(<code>maxInMemorySize</code>, Jackson) 설정</td>
</tr>
<tr>
<td><strong>요청/응답 처리</strong></td>
<td>GET/POST/PUT/DELETE, <code>retrieve()</code> vs <code>exchangeToMono()</code>, <code>bodyToMono</code>/<code>bodyToFlux</code>, 스트리밍</td>
</tr>
<tr>
<td><strong>에러 핸들링</strong></td>
<td><code>onStatus()</code>로 상태 코드별 처리, <code>onErrorResume()</code>으로 폴백, 서킷 브레이커로 장애 전파 차단</td>
</tr>
<tr>
<td><strong>재시도 전략</strong></td>
<td><code>Retry.backoff()</code>로 지수 백오프, <code>jitter</code>로 부하 분산, <code>filter()</code>로 재시도 대상 예외 선별</td>
</tr>
<tr>
<td><strong>타임아웃</strong></td>
<td>커넥션/읽기/쓰기/응답 타임아웃 계층별 설정, Reactor <code>timeout()</code>으로 전체 체인 시간 제한</td>
</tr>
<tr>
<td><strong>외부 API 연동</strong></td>
<td><code>Mono.zip()</code>으로 병렬 호출, <code>Flux.merge()</code>로 결과 병합, 폴백 패턴, 페이지네이션 순회</td>
</tr>
<tr>
<td><strong>필터</strong></td>
<td><code>ExchangeFilterFunction</code>으로 로깅/인증/에러 처리/추적 필터 구현, 필터 체이닝 순서</td>
</tr>
</tbody>
</table>
<p>다음 장에서는 R2DBC를 활용하여 관계형 데이터베이스를 리액티브 방식으로 접근하고, MongoDB와 함께 멀티 데이터소스를 구성하는 방법을 다룬다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>