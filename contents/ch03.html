<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 3. Project Reactor 핵심 | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="ch02.html">&larr; Chapter 2. Spring WebFlux 개요</a>
    <a href="../index.html">목차</a>
    <a href="ch04.html">Chapter 4. MongoDB 소개 &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-3-project-reactor">Chapter 3. Project Reactor 핵심</h1>
<p>Project Reactor는 Spring WebFlux의 리액티브 프로그래밍 기반이다. 이 장에서는 Reactor의 두 가지 핵심 타입인 <code>Mono</code>와 <code>Flux</code>를 깊이 있게 다루고, 실전에서 빈번하게 사용하는 연산자, 에러 처리, 스케줄러, 그리고 디버깅 기법까지 체계적으로 살펴본다.</p>
<hr>
<h2 id="31-mono-flux">3.1 Mono와 Flux 이해하기</h2>
<h3 id="311-mono-01">3.1.1 Mono: 0..1개의 요소</h3>
<p><code>Mono&lt;T&gt;</code>는 <strong>최대 1개의 요소</strong>를 발행하는 Publisher이다. 데이터베이스에서 단일 레코드를 조회하거나, HTTP 요청의 응답 하나를 반환할 때 주로 사용한다.</p>
<pre class="highlight"><code class="language-java">// 값이 있는 Mono
Mono&lt;String&gt; mono = Mono.just("Hello Reactor");

// 빈 Mono (값 없이 완료)
Mono&lt;String&gt; empty = Mono.empty();

// 에러를 발행하는 Mono
Mono&lt;String&gt; error = Mono.error(new RuntimeException("오류 발생"));</code></pre>
<h3 id="312-flux-0n">3.1.2 Flux: 0..N개의 요소</h3>
<p><code>Flux&lt;T&gt;</code>는 <strong>0개에서 N개까지의 요소</strong>를 발행하는 Publisher이다. 컬렉션 데이터를 스트리밍하거나, 실시간 이벤트를 연속적으로 전달할 때 사용한다.</p>
<pre class="highlight"><code class="language-java">// 여러 값을 가진 Flux
Flux&lt;String&gt; flux = Flux.just("Spring", "WebFlux", "Reactor");

// 리스트에서 Flux 생성
List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);
Flux&lt;Integer&gt; fromList = Flux.fromIterable(numbers);

// 범위로 생성
Flux&lt;Integer&gt; range = Flux.range(1, 10); // 1부터 10까지</code></pre>
<h3 id="313">3.1.3 다양한 생성 방법</h3>
<pre class="highlight"><code class="language-java">// defer: 구독 시점에 Mono/Flux를 생성 (Lazy 평가)
Mono&lt;Long&gt; deferred = Mono.defer(() -&gt; Mono.just(System.currentTimeMillis()));

// fromCallable: Callable로부터 Mono 생성
Mono&lt;String&gt; fromCallable = Mono.fromCallable(() -&gt; {
    // 블로킹 작업도 래핑 가능
    return someBlockingMethod();
});

// create: 프로그래밍 방식으로 Flux 생성 (비동기 브릿지)
Flux&lt;String&gt; created = Flux.create(sink -&gt; {
    sink.next("첫 번째");
    sink.next("두 번째");
    sink.next("세 번째");
    sink.complete();
});

// generate: 동기적으로 하나씩 값을 생성
Flux&lt;Integer&gt; generated = Flux.generate(
    () -&gt; 0,                        // 초기 상태
    (state, sink) -&gt; {
        sink.next(state);
        if (state == 9) sink.complete();
        return state + 1;           // 다음 상태
    }
);

// interval: 일정 간격으로 값 발행 (0부터 증가하는 Long)
Flux&lt;Long&gt; interval = Flux.interval(Duration.ofSeconds(1));</code></pre>
<h3 id="314-subscribe">3.1.4 구독(subscribe)의 의미와 동작</h3>
<p>Reactor에서 가장 핵심적인 개념은 <strong>"아무것도 구독하지 않으면 아무 일도 일어나지 않는다"</strong> 는 것이다. <code>Mono</code>와 <code>Flux</code>는 선언적 파이프라인일 뿐, <code>subscribe()</code>를 호출해야 실제 데이터 흐름이 시작된다.</p>
<pre class="highlight"><code class="language-java">Flux&lt;Integer&gt; pipeline = Flux.range(1, 5)
    .map(i -&gt; i * 2)
    .filter(i -&gt; i &gt; 4);

// subscribe()를 호출하지 않으면 위 코드는 아무 것도 실행하지 않는다.

// 기본 구독
pipeline.subscribe();

// 값 소비자 지정
pipeline.subscribe(
    value -&gt; System.out.println("값: " + value)
);

// 값, 에러, 완료 핸들러 지정
pipeline.subscribe(
    value -&gt; System.out.println("값: " + value),
    error -&gt; System.err.println("에러: " + error.getMessage()),
    () -&gt; System.out.println("완료!")
);
</code></pre>
<blockquote>
<p><strong>주의</strong>: Spring WebFlux에서는 프레임워크가 자동으로 구독을 처리한다. 컨트롤러에서 <code>Mono</code>나 <code>Flux</code>를 반환하면 WebFlux가 내부적으로 <code>subscribe()</code>를 호출하므로, 직접 <code>subscribe()</code>를 호출할 필요가 없다. 오히려 직접 호출하면 예기치 않은 동작이 발생할 수 있다.</p>
</blockquote>
<hr>
<h2 id="32-reactor">3.2 Reactor의 주요 연산자</h2>
<h3 id="321">3.2.1 변환 연산자</h3>
<h4 id="map">map: 동기 변환</h4>
<p>각 요소를 동기적으로 1:1 변환한다.</p>
<pre class="highlight"><code class="language-java">Flux&lt;String&gt; upperCase = Flux.just("spring", "webflux", "reactor")
    .map(String::toUpperCase);
// 결과: "SPRING", "WEBFLUX", "REACTOR"</code></pre>
<h4 id="flatmap-x">flatMap: 비동기 변환 (순서 보장 X)</h4>
<p>각 요소를 <code>Publisher</code>로 변환하고 결과를 병합한다. <strong>순서가 보장되지 않으며</strong>, 동시에 여러 내부 Publisher를 구독한다.</p>
<pre class="highlight"><code class="language-java">Flux&lt;User&gt; users = Flux.just(1L, 2L, 3L)
    .flatMap(id -&gt; userRepository.findById(id));
// 결과 순서: id=2 응답이 먼저 올 수 있음</code></pre>
<h4 id="flatmapsequential">flatMapSequential: 비동기 변환 (순서 보장)</h4>
<p><code>flatMap</code>과 동일하게 동시 실행하되, <strong>원래 순서를 보장</strong>한다.</p>
<pre class="highlight"><code class="language-java">Flux&lt;User&gt; users = Flux.just(1L, 2L, 3L)
    .flatMapSequential(id -&gt; userRepository.findById(id));
// 결과 순서: id=1, id=2, id=3 순서 보장</code></pre>
<h4 id="concatmap">concatMap: 순차 비동기 변환</h4>
<p>각 요소를 순차적으로 처리한다. 이전 요소의 처리가 완료된 후 다음 요소를 처리하므로 <strong>순서가 보장</strong>되지만, <code>flatMapSequential</code>보다 느리다.</p>
<pre class="highlight"><code class="language-java">Flux&lt;User&gt; users = Flux.just(1L, 2L, 3L)
    .concatMap(id -&gt; userRepository.findById(id));
// id=1 조회 완료 -&gt; id=2 조회 시작 -&gt; id=2 완료 -&gt; id=3 조회 시작</code></pre>
<h4 id="flatmap-vs-flatmapsequential-vs-concatmap">flatMap vs flatMapSequential vs concatMap 비교</h4>
<table>
<thead>
<tr>
<th>연산자</th>
<th>동시 실행</th>
<th>순서 보장</th>
<th>사용 시기</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>flatMap</code></td>
<td>O</td>
<td>X</td>
<td>순서 무관, 최대 처리량 필요</td>
</tr>
<tr>
<td><code>flatMapSequential</code></td>
<td>O</td>
<td>O</td>
<td>동시 실행 + 순서 보장</td>
</tr>
<tr>
<td><code>concatMap</code></td>
<td>X</td>
<td>O</td>
<td>순차 처리 필수</td>
</tr>
</tbody>
</table>
<h3 id="322">3.2.2 필터링 연산자</h3>
<pre class="highlight"><code class="language-java">Flux&lt;Integer&gt; numbers = Flux.range(1, 20);

// filter: 조건에 맞는 요소만 통과
Flux&lt;Integer&gt; evenNumbers = numbers.filter(n -&gt; n % 2 == 0);
// 결과: 2, 4, 6, 8, 10, 12, 14, 16, 18, 20

// take: 처음 N개만 가져오기
Flux&lt;Integer&gt; firstThree = numbers.take(3);
// 결과: 1, 2, 3

// skip: 처음 N개 건너뛰기
Flux&lt;Integer&gt; skipped = numbers.skip(17);
// 결과: 18, 19, 20

// distinct: 중복 제거
Flux&lt;String&gt; unique = Flux.just("A", "B", "A", "C", "B")
    .distinct();
// 결과: "A", "B", "C"

// distinctUntilChanged: 연속 중복 제거
Flux&lt;String&gt; changed = Flux.just("A", "A", "B", "B", "A")
    .distinctUntilChanged();
// 결과: "A", "B", "A"</code></pre>
<h3 id="323">3.2.3 결합 연산자</h3>
<h4 id="zip-publisher">zip: 각 Publisher의 요소를 쌍으로 결합</h4>
<pre class="highlight"><code class="language-java">Mono&lt;String&gt; name = Mono.just("홍길동");
Mono&lt;Integer&gt; age = Mono.just(30);

Mono&lt;String&gt; combined = Mono.zip(name, age)
    .map(tuple -&gt; tuple.getT1() + "님은 " + tuple.getT2() + "세입니다.");
// 결과: "홍길동님은 30세입니다."

// Flux에서의 zip
Flux&lt;String&gt; names = Flux.just("Alice", "Bob", "Charlie");
Flux&lt;Integer&gt; scores = Flux.just(95, 87, 92);

Flux&lt;String&gt; results = Flux.zip(names, scores)
    .map(tuple -&gt; tuple.getT1() + ": " + tuple.getT2() + "점");
// 결과: "Alice: 95점", "Bob: 87점", "Charlie: 92점"</code></pre>
<h4 id="merge-publisher">merge: 여러 Publisher를 인터리빙 방식으로 병합</h4>
<p>요소가 발행되는 즉시 하류로 전달한다. 순서는 도착 순이다.</p>
<pre class="highlight"><code class="language-java">Flux&lt;String&gt; fast = Flux.interval(Duration.ofMillis(100))
    .map(i -&gt; "FAST-" + i).take(3);
Flux&lt;String&gt; slow = Flux.interval(Duration.ofMillis(200))
    .map(i -&gt; "SLOW-" + i).take(3);

Flux&lt;String&gt; merged = Flux.merge(fast, slow);
// 도착 순서대로 병합: FAST-0, FAST-1, SLOW-0, FAST-2, SLOW-1, SLOW-2</code></pre>
<h4 id="concat">concat: 순서를 유지하며 병합</h4>
<p>첫 번째 Publisher가 완료된 후 두 번째 Publisher를 구독한다.</p>
<pre class="highlight"><code class="language-java">Flux&lt;String&gt; first = Flux.just("1", "2", "3");
Flux&lt;String&gt; second = Flux.just("A", "B", "C");

Flux&lt;String&gt; concatenated = Flux.concat(first, second);
// 결과: "1", "2", "3", "A", "B", "C" (항상 이 순서)</code></pre>
<h4 id="combinelatest-publisher">combineLatest: 각 Publisher의 최신 값 결합</h4>
<p>어느 한 Publisher에서 새 값이 발행되면, 다른 Publisher의 최신 값과 결합한다.</p>
<pre class="highlight"><code class="language-java">Flux&lt;String&gt; letters = Flux.just("A", "B", "C")
    .delayElements(Duration.ofMillis(100));
Flux&lt;Integer&gt; numbers = Flux.just(1, 2, 3)
    .delayElements(Duration.ofMillis(150));

Flux&lt;String&gt; combined = Flux.combineLatest(
    letters, numbers,
    (letter, number) -&gt; letter + number
);
// 최신 값끼리 결합: A1, B1, B2, C2, C3 (타이밍에 따라 다를 수 있음)</code></pre>
<h3 id="324">3.2.4 집계 연산자</h3>
<pre class="highlight"><code class="language-java">Flux&lt;Integer&gt; numbers = Flux.just(3, 1, 4, 1, 5, 9, 2, 6);

// reduce: 모든 요소를 하나로 축약
Mono&lt;Integer&gt; sum = numbers.reduce(0, Integer::sum);
// 결과: 31

// count: 요소 개수
Mono&lt;Long&gt; count = numbers.count();
// 결과: 8

// collectList: 모든 요소를 List로 수집
Mono&lt;List&lt;Integer&gt;&gt; list = numbers.collectList();
// 결과: [3, 1, 4, 1, 5, 9, 2, 6]

// collectMap: 요소를 Map으로 수집
Flux&lt;User&gt; users = userRepository.findAll();
Mono&lt;Map&lt;String, User&gt;&gt; userMap = users
    .collectMap(User::getId, user -&gt; user);
</code></pre>
<h3 id="325">3.2.5 유용한 유틸리티 연산자</h3>
<pre class="highlight"><code class="language-java">// switchIfEmpty: 빈 결과일 때 대체 Publisher 사용
Mono&lt;User&gt; user = userRepository.findById(id)
    .switchIfEmpty(Mono.error(
        new NotFoundException("사용자를 찾을 수 없습니다: " + id)
    ));

// defaultIfEmpty: 빈 결과일 때 기본값 사용
Mono&lt;String&gt; config = configRepository.findByKey("timeout")
    .defaultIfEmpty("30");

// doOnNext, doOnError, doOnComplete: 부수 효과 (사이드 이펙트)
Flux&lt;User&gt; usersWithLog = userRepository.findAll()
    .doOnNext(u -&gt; log.info("조회된 사용자: {}", u.getName()))
    .doOnError(e -&gt; log.error("조회 실패", e))
    .doOnComplete(() -&gt; log.info("전체 사용자 조회 완료"));

// timeout: 지정 시간 내에 값이 없으면 에러
Mono&lt;User&gt; userWithTimeout = userRepository.findById(id)
    .timeout(Duration.ofSeconds(5));</code></pre>
<hr>
<h2 id="33">3.3 에러 처리 전략</h2>
<p>리액티브 스트림에서 에러가 발생하면 스트림이 종료된다. Reactor는 다양한 에러 처리 연산자를 제공하여 우아한 에러 복구를 가능하게 한다.</p>
<h3 id="331-onerrorreturn">3.3.1 onErrorReturn: 기본값으로 대체</h3>
<p>에러 발생 시 지정한 기본값을 반환하고 스트림을 정상 완료한다.</p>
<pre class="highlight"><code class="language-java">Mono&lt;String&gt; result = externalApi.getData()
    .onErrorReturn("기본값");

// 특정 예외 타입에만 적용
Mono&lt;String&gt; result2 = externalApi.getData()
    .onErrorReturn(TimeoutException.class, "시간 초과 - 기본값 사용");</code></pre>
<h3 id="332-onerrorresume-publisher">3.3.2 onErrorResume: 대체 Publisher로 전환</h3>
<p>에러 발생 시 다른 Publisher로 전환한다. 폴백(fallback) 로직을 구현할 때 유용하다.</p>
<pre class="highlight"><code class="language-java">Mono&lt;User&gt; user = primaryDb.findById(id)
    .onErrorResume(e -&gt; {
        log.warn("Primary DB 실패, Secondary DB로 전환", e);
        return secondaryDb.findById(id);
    });

// 에러 타입별 분기 처리
Mono&lt;String&gt; data = externalService.call()
    .onErrorResume(TimeoutException.class, e -&gt; cachedService.getCached())
    .onErrorResume(ServiceUnavailableException.class, e -&gt; Mono.just("서비스 점검 중"));</code></pre>
<h3 id="333-onerrormap">3.3.3 onErrorMap: 에러를 다른 에러로 변환</h3>
<p>예외를 도메인에 맞는 다른 예외로 변환한다.</p>
<pre class="highlight"><code class="language-java">Mono&lt;User&gt; user = userRepository.findById(id)
    .switchIfEmpty(Mono.error(new UserNotFoundException(id)))
    .onErrorMap(DataAccessException.class, e -&gt;
        new ServiceException("데이터 접근 오류", e)
    );</code></pre>
<h3 id="334-doonerror">3.3.4 doOnError: 에러 발생 시 부수 효과</h3>
<p>스트림 자체를 변경하지 않고 로깅 등의 부수 효과를 실행한다.</p>
<pre class="highlight"><code class="language-java">Mono&lt;User&gt; user = userRepository.findById(id)
    .doOnError(e -&gt; {
        log.error("사용자 조회 중 에러 발생. id={}", id, e);
        metrics.incrementErrorCount("user.findById");
    })
    .onErrorResume(e -&gt; Mono.empty());</code></pre>
<h3 id="335-retry">3.3.5 retry: 단순 재시도</h3>
<p>에러 발생 시 지정한 횟수만큼 재구독한다.</p>
<pre class="highlight"><code class="language-java">Mono&lt;String&gt; result = externalApi.call()
    .retry(3); // 최대 3회 재시도</code></pre>
<h3 id="336-retrywhen">3.3.6 retryWhen: 고급 재시도 전략</h3>
<p><code>Retry</code> 스펙을 사용하여 세밀한 재시도 정책을 구현한다.</p>
<pre class="highlight"><code class="language-java">import reactor.util.retry.Retry;

Mono&lt;String&gt; result = externalApi.call()
    .retryWhen(Retry.backoff(3, Duration.ofSeconds(1))
        .maxBackoff(Duration.ofSeconds(10))
        .jitter(0.5)
        .filter(throwable -&gt; throwable instanceof ServiceUnavailableException)
        .onRetryExhaustedThrow((retryBackoffSpec, retrySignal) -&gt;
            new ServiceException(
                "재시도 횟수 초과. 마지막 에러: " + retrySignal.failure().getMessage(),
                retrySignal.failure()
            )
        )
    );</code></pre>
<h3 id="337">3.3.7 실전 에러 처리 패턴</h3>
<p>다음은 실제 서비스 계층에서 사용하는 종합 에러 처리 패턴이다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class UserService {

    private final ReactiveMongoTemplate mongoTemplate;
    private final UserCacheService cacheService;
    private static final Logger log = LoggerFactory.getLogger(UserService.class);

    public Mono&lt;User&gt; findUserById(String id) {
        return cacheService.getCachedUser(id)            // 1. 캐시 조회
            .switchIfEmpty(
                mongoTemplate.findById(id, User.class)   // 2. DB 조회
                    .doOnNext(user -&gt;
                        cacheService.cacheUser(user)      // 3. 캐시 저장
                            .subscribe()
                    )
            )
            .switchIfEmpty(
                Mono.error(new UserNotFoundException(id)) // 4. 없으면 예외
            )
            .timeout(Duration.ofSeconds(5))               // 5. 타임아웃
            .doOnError(TimeoutException.class, e -&gt;
                log.warn("사용자 조회 타임아웃. id={}", id)
            )
            .onErrorMap(TimeoutException.class, e -&gt;
                new ServiceException("사용자 조회 시간 초과", e)
            )
            .retryWhen(Retry.backoff(2, Duration.ofMillis(500))
                .filter(e -&gt; e instanceof DataAccessException)
            );
    }

    public Flux&lt;User&gt; searchUsers(String keyword) {
        Query query = new Query(
            Criteria.where("name").regex(keyword, "i")
        );

        return mongoTemplate.find(query, User.class)
            .onErrorResume(e -&gt; {
                log.error("사용자 검색 실패. keyword={}", keyword, e);
                return Flux.empty();
            });
    }
}</code></pre>
<hr>
<h2 id="34-scheduler">3.4 스케줄러(Scheduler)와 스레드 모델</h2>
<p>Reactor는 기본적으로 <strong>호출자 스레드</strong>에서 동작한다. 스케줄러를 사용하면 작업을 실행할 스레드를 제어할 수 있다.</p>
<h3 id="341">3.4.1 주요 스케줄러 종류</h3>
<table>
<thead>
<tr>
<th>스케줄러</th>
<th>설명</th>
<th>스레드 수</th>
<th>사용 시기</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Schedulers.parallel()</code></td>
<td>CPU 집약적 작업</td>
<td>CPU 코어 수</td>
<td>계산, 변환 작업</td>
</tr>
<tr>
<td><code>Schedulers.boundedElastic()</code></td>
<td>블로킹 I/O 래핑</td>
<td>최대 10 * CPU 코어</td>
<td>블로킹 코드 감싸기</td>
</tr>
<tr>
<td><code>Schedulers.single()</code></td>
<td>단일 재사용 스레드</td>
<td>1</td>
<td>순차 실행 보장</td>
</tr>
<tr>
<td><code>Schedulers.immediate()</code></td>
<td>현재 스레드</td>
<td>-</td>
<td>테스트, 디폴트</td>
</tr>
<tr>
<td><code>Schedulers.fromExecutorService()</code></td>
<td>커스텀 스레드 풀</td>
<td>사용자 지정</td>
<td>특수한 요구사항</td>
</tr>
</tbody>
</table>
<h3 id="342-publishon-vs-subscribeon">3.4.2 publishOn vs subscribeOn</h3>
<p>두 연산자는 이름이 비슷하지만 동작 방식이 완전히 다르다.</p>
<h4 id="publishon">publishOn: 하류 연산자의 실행 스레드를 변경</h4>
<p><code>publishOn</code> 이후의 연산자들이 지정한 스케줄러에서 실행된다. 파이프라인 중간에 스레드를 전환할 때 사용한다.</p>
<pre class="highlight"><code class="language-java">Flux.range(1, 5)
    .map(i -&gt; {
        log.info("[map1] {} - {}", i, Thread.currentThread().getName());
        return i * 10;
    })
    .publishOn(Schedulers.parallel())   // 여기서부터 parallel 스레드
    .map(i -&gt; {
        log.info("[map2] {} - {}", i, Thread.currentThread().getName());
        return i + 1;
    })
    .subscribe(i -&gt;
        log.info("[subscribe] {} - {}", i, Thread.currentThread().getName())
    );

// map1은 main 스레드, publishOn 이후 map2와 subscribe는 parallel-1 스레드에서 실행</code></pre>
<h4 id="subscribeon">subscribeOn: 전체 구독 체인의 실행 스레드를 변경</h4>
<p>소스의 구독(데이터 발행) 시점부터의 스레드를 변경한다. <strong>위치에 관계없이</strong> 소스 발행 스레드에 영향을 미친다.</p>
<pre class="highlight"><code class="language-java">Mono.fromCallable(() -&gt; {
        log.info("[callable] {}", Thread.currentThread().getName());
        return blockingIoOperation();
    })
    .subscribeOn(Schedulers.boundedElastic())  // 소스가 boundedElastic에서 실행
    .map(result -&gt; processResult(result))
    .subscribe();
// callable, map, subscribe 모두 boundedElastic-1 스레드에서 실행</code></pre>
<h4 id="publishon-subscribeon">publishOn과 subscribeOn 함께 사용</h4>
<pre class="highlight"><code class="language-java">Flux.range(1, 3)
    .subscribeOn(Schedulers.single())          // 소스: single 스레드
    .map(i -&gt; {
        log.info("[map1] {}", Thread.currentThread().getName()); // single-1
        return "값-" + i;
    })
    .publishOn(Schedulers.parallel())          // 이후: parallel 스레드
    .map(s -&gt; {
        log.info("[map2] {}", Thread.currentThread().getName()); // parallel-1
        return s.toUpperCase();
    })
    .subscribe();</code></pre>
<h3 id="343">3.4.3 블로킹 코드를 감싸는 방법</h3>
<p>리액티브 파이프라인 안에서 블로킹 코드를 직접 호출하면 이벤트 루프 스레드를 점유하여 전체 시스템 처리량이 급격히 떨어진다. 불가피하게 블로킹 코드를 사용해야 할 때는 반드시 <code>boundedElastic</code> 스케줄러로 격리해야 한다.</p>
<pre class="highlight"><code class="language-java">@Service
public class LegacyIntegrationService {

    private final LegacyBlockingClient legacyClient;

    // 잘못된 방법 - 이벤트 루프 스레드를 블로킹
    public Mono&lt;String&gt; wrongWay() {
        return Mono.just(legacyClient.blockingCall()); // 절대 이렇게 하지 말 것!
    }

    // 올바른 방법 - boundedElastic에서 블로킹 실행
    public Mono&lt;String&gt; correctWay() {
        return Mono.fromCallable(() -&gt; legacyClient.blockingCall())
            .subscribeOn(Schedulers.boundedElastic());
    }

    // 여러 블로킹 호출을 병렬로 실행
    public Mono&lt;AggregatedResult&gt; parallelBlockingCalls() {
        Mono&lt;String&gt; call1 = Mono.fromCallable(() -&gt; legacyClient.callServiceA())
            .subscribeOn(Schedulers.boundedElastic());

        Mono&lt;String&gt; call2 = Mono.fromCallable(() -&gt; legacyClient.callServiceB())
            .subscribeOn(Schedulers.boundedElastic());

        return Mono.zip(call1, call2)
            .map(tuple -&gt; new AggregatedResult(tuple.getT1(), tuple.getT2()));
    }
}</code></pre>
<blockquote>
<p><strong>Tip</strong>: 프로젝트에 <code>BlockHound</code> 라이브러리를 추가하면 이벤트 루프 스레드에서 블로킹 호출이 발생할 때 즉시 탐지할 수 있다. 19장에서 자세히 다룬다.</p>
</blockquote>
<hr>
<h2 id="35-cold-vs-hot-publisher">3.5 Cold vs Hot Publisher</h2>
<h3 id="351-cold-publisher">3.5.1 Cold Publisher</h3>
<p>Cold Publisher는 <strong>구독할 때마다 데이터를 처음부터 새로 발행</strong>한다. 대부분의 Reactor 연산자는 Cold Publisher를 생성한다.</p>
<pre class="highlight"><code class="language-java">Flux&lt;Long&gt; coldFlux = Flux.defer(() -&gt; {
    log.info("새로운 데이터 소스 생성");
    return Flux.just(System.currentTimeMillis());
});

// 구독자 1: 자신만의 데이터를 받음
coldFlux.subscribe(v -&gt; log.info("구독자1: {}", v));

Thread.sleep(100);

// 구독자 2: 별도의 새로운 데이터를 받음 (다른 타임스탬프)
coldFlux.subscribe(v -&gt; log.info("구독자2: {}", v));

// 각 구독자가 서로 다른 타임스탬프를 받음 (매번 새로 생성)</code></pre>
<h3 id="352-hot-publisher">3.5.2 Hot Publisher</h3>
<p>Hot Publisher는 <strong>구독 여부와 관계없이 데이터를 발행</strong>하며, 구독자들은 구독 이후의 데이터만 받는다.</p>
<pre class="highlight"><code class="language-java">// ConnectableFlux로 Hot Publisher 만들기
Flux&lt;Long&gt; hotFlux = Flux.interval(Duration.ofSeconds(1))
    .publish()
    .autoConnect(2); // 2명이 구독하면 자동 시작

// 구독자 1
hotFlux.subscribe(v -&gt; log.info("구독자1: {}", v));

Thread.sleep(1500);

// 구독자 2가 연결되면 발행 시작, 구독자2는 중간부터 수신
hotFlux.subscribe(v -&gt; log.info("구독자2: {}", v));</code></pre>
<h3 id="353-sinks-hot-publisher">3.5.3 Sinks를 활용한 Hot Publisher 생성</h3>
<p><code>Sinks</code>는 Reactor 3.4부터 도입된 프로그래밍 방식의 신호 발행 도구이다. 기존의 <code>Processor</code> 를 대체하며 스레드 안전성을 보장한다.</p>
<pre class="highlight"><code class="language-java">// Sinks.Many: 여러 값을 여러 구독자에게 발행
Sinks.Many&lt;String&gt; sink = Sinks.many().multicast().onBackpressureBuffer();

Flux&lt;String&gt; hotFlux = sink.asFlux();

// 구독자 등록
hotFlux.subscribe(v -&gt; log.info("구독자1: {}", v));
hotFlux.subscribe(v -&gt; log.info("구독자2: {}", v));

// 값 발행
sink.tryEmitNext("메시지 1");
sink.tryEmitNext("메시지 2");
sink.tryEmitComplete();

// 두 구독자 모두 "메시지 1", "메시지 2"를 수신</code></pre>
<pre class="highlight"><code class="language-java">// Sinks.Many의 다양한 스펙
Sinks.Many&lt;String&gt; unicast   = Sinks.many().unicast().onBackpressureBuffer();   // 구독자 1명
Sinks.Many&lt;String&gt; multicast = Sinks.many().multicast().onBackpressureBuffer(); // 여러 구독자
Sinks.Many&lt;String&gt; replay    = Sinks.many().replay().limit(5); // 최근 5개 재생</code></pre>
<p><strong>실전 예제 - 이벤트 버스 구현</strong>:</p>
<pre class="highlight"><code class="language-java">@Component
public class EventBus {

    private final Sinks.Many&lt;DomainEvent&gt; sink =
        Sinks.many().multicast().onBackpressureBuffer();

    public void publish(DomainEvent event) {
        sink.tryEmitNext(event);
    }

    public Flux&lt;DomainEvent&gt; subscribe() {
        return sink.asFlux();
    }

    public &lt;T extends DomainEvent&gt; Flux&lt;T&gt; subscribe(Class&lt;T&gt; eventType) {
        return sink.asFlux()
            .filter(eventType::isInstance)
            .cast(eventType);
    }
}</code></pre>
<h3 id="354-share-cache">3.5.4 share()와 cache()</h3>
<h4 id="share-cold-publisher-hot-publisher">share(): Cold Publisher를 Hot Publisher로 변환</h4>
<pre class="highlight"><code class="language-java">Flux&lt;Long&gt; shared = Flux.interval(Duration.ofSeconds(1))
    .doOnSubscribe(s -&gt; log.info("구독 시작"))
    .share(); // 첫 구독자가 구독할 때 시작, 모든 구독자가 해제되면 중지

shared.subscribe(v -&gt; log.info("구독자1: {}", v));

Thread.sleep(2500);

// 구독자2는 중간부터 받음
shared.subscribe(v -&gt; log.info("구독자2: {}", v));</code></pre>
<h4 id="cache">cache(): 결과를 캐싱</h4>
<pre class="highlight"><code class="language-java">// 한 번 실행된 결과를 캐싱하여 이후 구독자에게 재사용
Mono&lt;Config&gt; config = loadConfigFromDb()
    .cache(Duration.ofMinutes(10)); // 10분간 캐시

// 첫 번째 호출: DB 조회 실행
config.subscribe(c -&gt; log.info("설정1: {}", c));

// 두 번째 호출: 캐시된 값 반환 (DB 조회 없음)
config.subscribe(c -&gt; log.info("설정2: {}", c));

// Flux에서도 사용 가능
Flux&lt;Product&gt; products = productRepository.findAll()
    .cache(Duration.ofMinutes(5)); // 전체 시퀀스를 캐시</code></pre>
<hr>
<h2 id="36-reactor">3.6 Reactor 디버깅 기법</h2>
<p>리액티브 코드의 디버깅은 명령형 코드보다 까다롭다. 비동기 스택 트레이스가 연산자 체인의 원래 위치를 보여주지 않기 때문이다. Reactor는 이를 돕는 도구를 제공한다.</p>
<h3 id="361-log">3.6.1 log(): 리액티브 신호 로깅</h3>
<p><code>log()</code> 연산자는 구독, 요청, 발행, 완료, 에러 등 모든 리액티브 신호를 로깅한다.</p>
<pre class="highlight"><code class="language-java">Flux.range(1, 5)
    .log("NumberFlux")    // 카테고리 이름 지정 가능
    .map(i -&gt; i * 2)
    .log("DoubledFlux")
    .subscribe();

// 출력: onSubscribe, request, onNext, onComplete 등 모든 신호 로깅

// 특정 신호만 로깅
Flux.range(1, 5)
    .log("MyFlux", Level.INFO, SignalType.ON_NEXT, SignalType.ON_ERROR)
    .subscribe();</code></pre>
<h3 id="362-checkpoint">3.6.2 checkpoint(): 에러 추적 지점 설정</h3>
<p><code>checkpoint()</code>는 에러 발생 시 연산자 체인의 어느 지점에서 문제가 발생했는지 추적할 수 있게 한다.</p>
<pre class="highlight"><code class="language-java">Flux&lt;Integer&gt; flux = Flux.just(1, 2, 0, 4)
    .map(i -&gt; 100 / i)
    .checkpoint("나눗셈 연산 후")        // 이 지점에 체크포인트 설정
    .map(i -&gt; i + 10)
    .checkpoint("덧셈 연산 후");

flux.subscribe(
    v -&gt; log.info("값: {}", v),
    e -&gt; log.error("에러 발생", e)
);

// 에러 메시지에 체크포인트 정보 포함:
// Assembly trace from producer [reactor.core.publisher.FluxMap],
// described as [나눗셈 연산 후]</code></pre>
<pre class="highlight"><code class="language-java">// 상세 스택 트레이스 포함 (비용이 더 들지만 디버깅에 유용)
.checkpoint("상세 체크포인트", true)</code></pre>
<h3 id="363-hooksonoperatordebug">3.6.3 Hooks.onOperatorDebug(): 글로벌 디버그 모드</h3>
<p>모든 연산자에 대해 어셈블리(조립) 시점의 스택 트레이스를 자동 캡처한다. <strong>성능 오버헤드가 크므로 개발 환경에서만 사용</strong>해야 한다.</p>
<pre class="highlight"><code class="language-java">@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        // 개발 환경에서만 활성화
        if (isDevProfile()) {
            Hooks.onOperatorDebug();
        }
        SpringApplication.run(Application.class, args);
    }
}</code></pre>
<p>활성화하면 에러 발생 시 연산자가 조립된 소스 코드 위치(클래스명, 줄 번호)를 스택 트레이스에 포함시켜 준다.</p>
<h3 id="364-reactordebugagent">3.6.4 ReactorDebugAgent: 프로덕션 친화적 디버깅</h3>
<p><code>Hooks.onOperatorDebug()</code>의 성능 문제를 해결한 대안이다. Java Agent 방식으로 바이트코드를 변환하여, 런타임 오버헤드 없이 디버그 정보를 제공한다.</p>
<p><strong>의존성 추가</strong>:</p>
<pre class="highlight"><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
    &lt;artifactId&gt;reactor-tools&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<p><strong>활성화</strong>:</p>
<pre class="highlight"><code class="language-java">@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        ReactorDebugAgent.init();               // JVM 시작 시 한 번 호출
        ReactorDebugAgent.processExistingClasses(); // 이미 로드된 클래스 처리
        SpringApplication.run(Application.class, args);
    }
}</code></pre>
<h3 id="365">3.6.5 디버깅 실전 전략 정리</h3>
<table>
<thead>
<tr>
<th>방법</th>
<th>성능 영향</th>
<th>사용 환경</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>log()</code></td>
<td>낮음</td>
<td>모든 환경</td>
<td>특정 지점의 신호 확인</td>
</tr>
<tr>
<td><code>checkpoint()</code></td>
<td>낮음</td>
<td>모든 환경</td>
<td>특정 지점에 디버그 마커 설정</td>
</tr>
<tr>
<td><code>Hooks.onOperatorDebug()</code></td>
<td><strong>높음</strong></td>
<td>개발 환경만</td>
<td>모든 연산자의 스택 트레이스 캡처</td>
</tr>
<tr>
<td><code>ReactorDebugAgent</code></td>
<td>낮음</td>
<td>모든 환경</td>
<td>바이트코드 변환 기반 디버깅</td>
</tr>
</tbody>
</table>
<p><strong>권장 디버깅 워크플로우</strong>:</p>
<pre class="highlight"><code class="language-java">// 1단계: log()로 신호 흐름 확인
userRepository.findById(id)
    .log("findById")
    .flatMap(user -&gt; orderRepository.findByUserId(user.getId()))
    .log("findOrders")
    .subscribe();

// 2단계: 문제 지점에 checkpoint() 추가
userRepository.findById(id)
    .checkpoint("사용자 조회")
    .flatMap(user -&gt; orderRepository.findByUserId(user.getId()))
    .checkpoint("주문 목록 조회")
    .subscribe();

// 3단계: 그래도 찾기 어려우면 ReactorDebugAgent 활성화</code></pre>
<hr>
<h2 id="_1">요약</h2>
<p>이 장에서 다룬 Project Reactor의 핵심 개념을 정리하면 다음과 같다.</p>
<ul>
<li><strong>Mono와 Flux</strong>는 리액티브 스트림의 기본 구성 요소다. Mono는 0..1개, Flux는 0..N개의 요소를 비동기적으로 발행한다.</li>
<li><strong>연산자</strong>를 조합하여 선언적으로 데이터 처리 파이프라인을 구성한다. <code>flatMap</code>과 <code>concatMap</code>의 차이처럼, 각 연산자의 동작 특성을 이해하는 것이 중요하다.</li>
<li><strong>에러 처리</strong>는 <code>onErrorReturn</code>, <code>onErrorResume</code>, <code>retry</code> 등을 활용하여 우아하게 복구할 수 있다. 특히 <code>retryWhen</code>과 <code>Retry.backoff()</code>를 조합하면 실전에서 필요한 재시도 전략을 구현할 수 있다.</li>
<li><strong>스케줄러</strong>를 통해 작업의 실행 스레드를 제어한다. <code>publishOn</code>은 하류의 스레드를 전환하고, <code>subscribeOn</code>은 소스의 스레드를 전환한다. 블로킹 코드는 반드시 <code>boundedElastic</code>으로 격리해야 한다.</li>
<li><strong>Cold vs Hot Publisher</strong> 개념을 이해하면 데이터 공유와 멀티캐스트 시나리오를 올바르게 구현할 수 있다. <code>Sinks</code>는 프로그래밍 방식으로 Hot Publisher를 생성하는 현대적 도구이다.</li>
<li><strong>디버깅</strong>은 <code>log()</code>, <code>checkpoint()</code>로 시작하고, 필요 시 <code>ReactorDebugAgent</code>를 활용한다.</li>
</ul>
<p>다음 장에서는 MongoDB의 기본 개념과 리액티브 드라이버에 대해 알아본다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>