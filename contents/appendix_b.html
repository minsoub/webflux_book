<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>부록 B. MongoDB 쿼리 연산자 정리 | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="appendix_a.html">&larr; 부록 A. Reactor 주요 연산자 레퍼런스</a>
    <a href="../index.html">목차</a>
    <a href="appendix_c.html">부록 C. 자주 발생하는 문제와 해결 방법 (FAQ) &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="b-mongodb">부록 B. MongoDB 쿼리 연산자 정리</h1>
<p>이 부록에서는 MongoDB의 주요 쿼리 연산자를 카테고리별로 정리하고, 각 연산자에 대해 MongoDB 네이티브 쿼리와 Spring Data MongoDB(Criteria API)로 변환한 Java 코드를 함께 제공한다.</p>
<hr>
<h2 id="b1">B.1 비교 연산자</h2>
<table>
<thead>
<tr>
<th>연산자</th>
<th>설명</th>
<th>MongoDB 쿼리 예제</th>
<th>Spring Data Criteria</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$eq</code></td>
<td>값이 같음</td>
<td><code>{ status: { $eq: "active" } }</code></td>
<td><code>Criteria.where("status").is("active")</code></td>
</tr>
<tr>
<td><code>$ne</code></td>
<td>값이 같지 않음</td>
<td><code>{ status: { $ne: "inactive" } }</code></td>
<td><code>Criteria.where("status").ne("inactive")</code></td>
</tr>
<tr>
<td><code>$gt</code></td>
<td>초과</td>
<td><code>{ age: { $gt: 25 } }</code></td>
<td><code>Criteria.where("age").gt(25)</code></td>
</tr>
<tr>
<td><code>$gte</code></td>
<td>이상</td>
<td><code>{ age: { $gte: 18 } }</code></td>
<td><code>Criteria.where("age").gte(18)</code></td>
</tr>
<tr>
<td><code>$lt</code></td>
<td>미만</td>
<td><code>{ age: { $lt: 65 } }</code></td>
<td><code>Criteria.where("age").lt(65)</code></td>
</tr>
<tr>
<td><code>$lte</code></td>
<td>이하</td>
<td><code>{ age: { $lte: 65 } }</code></td>
<td><code>Criteria.where("age").lte(65)</code></td>
</tr>
<tr>
<td><code>$in</code></td>
<td>배열 내 값과 일치</td>
<td><code>{ status: { $in: ["active", "pending"] } }</code></td>
<td><code>Criteria.where("status").in("active", "pending")</code></td>
</tr>
<tr>
<td><code>$nin</code></td>
<td>배열 내 어떤 값과도 불일치</td>
<td><code>{ role: { $nin: ["admin"] } }</code></td>
<td><code>Criteria.where("role").nin("admin")</code></td>
</tr>
</tbody>
</table>
<p><strong>범위 조건 결합 예제:</strong></p>
<pre class="highlight"><code class="language-javascript">// MongoDB: 나이가 18 이상 65 이하
db.users.find({ age: { $gte: 18, $lte: 65 } })</code></pre>
<pre class="highlight"><code class="language-java">// Spring Data MongoDB
Criteria criteria = Criteria.where("age").gte(18).lte(65);
reactiveMongoTemplate.find(Query.query(criteria), User.class);</code></pre>
<hr>
<h2 id="b2">B.2 논리 연산자</h2>
<table>
<thead>
<tr>
<th>연산자</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$and</code></td>
<td>모든 조건을 만족하는 도큐먼트를 선택</td>
</tr>
<tr>
<td><code>$or</code></td>
<td>하나 이상의 조건을 만족하는 도큐먼트를 선택</td>
</tr>
<tr>
<td><code>$not</code></td>
<td>조건을 만족하지 않는 도큐먼트를 선택</td>
</tr>
<tr>
<td><code>$nor</code></td>
<td>모든 조건을 만족하지 않는 도큐먼트를 선택</td>
</tr>
</tbody>
</table>
<pre class="highlight"><code class="language-javascript">// $and: status가 "active"이고 age가 18 이상
db.users.find({ $and: [{ status: "active" }, { age: { $gte: 18 } }] })
// $or: role이 "admin"이거나 age가 30 이상
db.users.find({ $or: [{ role: "admin" }, { age: { $gte: 30 } }] })
// $nor: status가 "active"도 아니고 role이 "admin"도 아닌 도큐먼트
db.users.find({ $nor: [{ status: "active" }, { role: "admin" }] })</code></pre>
<pre class="highlight"><code class="language-java">// $and — Criteria 체이닝으로 AND 조건이 된다
Criteria and = Criteria.where("status").is("active").and("age").gte(18);
// $or
Criteria or = new Criteria().orOperator(
    Criteria.where("role").is("admin"),
    Criteria.where("age").gte(30));
// $not
Criteria not = Criteria.where("age").not().gt(25);
// $nor
Criteria nor = new Criteria().norOperator(
    Criteria.where("status").is("active"),
    Criteria.where("role").is("admin"));</code></pre>
<hr>
<h2 id="b3">B.3 요소 연산자</h2>
<table>
<thead>
<tr>
<th>연산자</th>
<th>설명</th>
<th>MongoDB 쿼리 예제</th>
<th>Spring Data Criteria</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$exists</code></td>
<td>필드 존재 여부 확인</td>
<td><code>{ email: { $exists: true } }</code></td>
<td><code>Criteria.where("email").exists(true)</code></td>
</tr>
<tr>
<td><code>$type</code></td>
<td>필드의 BSON 타입 확인</td>
<td><code>{ age: { $type: "int" } }</code></td>
<td><code>Criteria.where("age").type(Type.INT32)</code></td>
</tr>
</tbody>
</table>
<hr>
<h2 id="b4">B.4 배열 연산자</h2>
<table>
<thead>
<tr>
<th>연산자</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$all</code></td>
<td>배열이 지정된 모든 요소를 포함</td>
</tr>
<tr>
<td><code>$elemMatch</code></td>
<td>배열 내 요소가 모든 조건을 만족</td>
</tr>
<tr>
<td><code>$size</code></td>
<td>배열 크기가 일치</td>
</tr>
</tbody>
</table>
<pre class="highlight"><code class="language-javascript">// $all: tags에 "mongodb"와 "reactive" 모두 포함
db.articles.find({ tags: { $all: ["mongodb", "reactive"] } })
// $elemMatch: scores 중 80~90 사이 요소가 존재
db.students.find({ scores: { $elemMatch: { $gte: 80, $lte: 90 } } })
// $size: tags 길이가 정확히 3
db.articles.find({ tags: { $size: 3 } })</code></pre>
<pre class="highlight"><code class="language-java">Criteria all = Criteria.where("tags").all("mongodb", "reactive");
Criteria elem = Criteria.where("scores").elemMatch(new Criteria().gte(80).lte(90));
Criteria size = Criteria.where("tags").size(3);</code></pre>
<hr>
<h2 id="b5">B.5 정규식 연산자</h2>
<pre class="highlight"><code class="language-javascript">// name이 "Kim"으로 시작 (대소문자 무시)
db.users.find({ name: { $regex: "^Kim", $options: "i" } })
// email이 "@example.com"으로 끝남
db.users.find({ email: { $regex: "@example\\.com$" } })</code></pre>
<pre class="highlight"><code class="language-java">Criteria regex1 = Criteria.where("name").regex("^Kim", "i");
Criteria regex2 = Criteria.where("email").regex("@example\\.com$");
reactiveMongoTemplate.find(Query.query(regex1), User.class);</code></pre>
<hr>
<h2 id="b6">B.6 업데이트 연산자</h2>
<table>
<thead>
<tr>
<th>연산자</th>
<th>설명</th>
<th>Update API</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$set</code></td>
<td>필드 값 설정</td>
<td><code>new Update().set("field", value)</code></td>
</tr>
<tr>
<td><code>$unset</code></td>
<td>필드 제거</td>
<td><code>new Update().unset("field")</code></td>
</tr>
<tr>
<td><code>$inc</code></td>
<td>값 증감</td>
<td><code>new Update().inc("field", 1)</code></td>
</tr>
<tr>
<td><code>$push</code></td>
<td>배열에 요소 추가</td>
<td><code>new Update().push("field", value)</code></td>
</tr>
<tr>
<td><code>$pull</code></td>
<td>배열에서 요소 제거</td>
<td><code>new Update().pull("field", value)</code></td>
</tr>
<tr>
<td><code>$addToSet</code></td>
<td>중복 없이 배열에 추가</td>
<td><code>new Update().addToSet("field", value)</code></td>
</tr>
</tbody>
</table>
<h3 id="set-unset-inc">$set / $unset / $inc</h3>
<pre class="highlight"><code class="language-javascript">db.users.updateOne({ _id: ObjectId("...") },
  { $set: { status: "inactive" }, $inc: { loginCount: 1 }, $unset: { temp: "" } })</code></pre>
<pre class="highlight"><code class="language-java">Query query = Query.query(Criteria.where("id").is(userId));
Update update = new Update()
    .set("status", "inactive")
    .inc("loginCount", 1)
    .unset("temp");
reactiveMongoTemplate.updateFirst(query, update, User.class);</code></pre>
<h3 id="push-pull-addtoset">$push / $pull / $addToSet</h3>
<pre class="highlight"><code class="language-javascript">db.articles.updateOne({ _id: ObjectId("...") }, { $push: { tags: "webflux" } })
db.articles.updateOne({ _id: ObjectId("...") }, { $pull: { tags: "deprecated" } })
db.articles.updateOne({ _id: ObjectId("...") }, { $addToSet: { tags: "reactive" } })</code></pre>
<pre class="highlight"><code class="language-java">Query query = Query.query(Criteria.where("id").is(articleId));
reactiveMongoTemplate.updateFirst(query, new Update().push("tags", "webflux"), Article.class);
reactiveMongoTemplate.updateFirst(query, new Update().pull("tags", "deprecated"), Article.class);
reactiveMongoTemplate.updateFirst(query, new Update().addToSet("tags", "reactive"), Article.class);</code></pre>
<hr>
<h2 id="b7-aggregation-pipeline">B.7 Aggregation Pipeline 스테이지</h2>
<table>
<thead>
<tr>
<th>스테이지</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$match</code></td>
<td>조건 필터링</td>
</tr>
<tr>
<td><code>$group</code></td>
<td>그룹화 및 집계</td>
</tr>
<tr>
<td><code>$project</code></td>
<td>출력 필드 지정</td>
</tr>
<tr>
<td><code>$sort</code></td>
<td>정렬</td>
</tr>
<tr>
<td><code>$limit</code></td>
<td>결과 수 제한</td>
</tr>
<tr>
<td><code>$skip</code></td>
<td>도큐먼트 건너뛰기</td>
</tr>
<tr>
<td><code>$unwind</code></td>
<td>배열을 개별 도큐먼트로 분해</td>
</tr>
<tr>
<td><code>$lookup</code></td>
<td>다른 컬렉션과 조인</td>
</tr>
</tbody>
</table>
<h3 id="match-group">$match / $group</h3>
<pre class="highlight"><code class="language-javascript">db.orders.aggregate([
  { $match: { status: "completed" } },
  { $group: { _id: "$category", count: { $sum: 1 }, total: { $sum: "$amount" } } }
])</code></pre>
<pre class="highlight"><code class="language-java">Aggregation agg = Aggregation.newAggregation(
    Aggregation.match(Criteria.where("status").is("completed")),
    Aggregation.group("category").count().as("count").sum("amount").as("total")
);
reactiveMongoTemplate.aggregate(agg, "orders", Document.class);</code></pre>
<h3 id="project-sort-limit-skip">$project / $sort / $limit / $skip</h3>
<pre class="highlight"><code class="language-javascript">db.articles.aggregate([
  { $project: { title: 1, author: 1, _id: 0 } },
  { $sort: { createdAt: -1 } },
  { $skip: 20 },
  { $limit: 10 }
])</code></pre>
<pre class="highlight"><code class="language-java">Aggregation agg = Aggregation.newAggregation(
    Aggregation.project("title", "author").andExclude("_id"),
    Aggregation.sort(Sort.Direction.DESC, "createdAt"),
    Aggregation.skip(20),
    Aggregation.limit(10)
);
reactiveMongoTemplate.aggregate(agg, "articles", Article.class);</code></pre>
<h3 id="unwind">$unwind</h3>
<pre class="highlight"><code class="language-javascript">// tags 배열을 분해하여 태그별 빈도 집계
db.articles.aggregate([
  { $unwind: "$tags" },
  { $group: { _id: "$tags", count: { $sum: 1 } } },
  { $sort: { count: -1 } }
])</code></pre>
<pre class="highlight"><code class="language-java">Aggregation agg = Aggregation.newAggregation(
    Aggregation.unwind("tags"),
    Aggregation.group("tags").count().as("count"),
    Aggregation.sort(Sort.Direction.DESC, "count")
);
reactiveMongoTemplate.aggregate(agg, "articles", Document.class);</code></pre>
<h3 id="lookup">$lookup</h3>
<pre class="highlight"><code class="language-javascript">db.orders.aggregate([
  { $lookup: { from: "products", localField: "productId",
               foreignField: "_id", as: "productDetails" } }
])</code></pre>
<pre class="highlight"><code class="language-java">Aggregation agg = Aggregation.newAggregation(
    Aggregation.lookup("products", "productId", "_id", "productDetails")
);
reactiveMongoTemplate.aggregate(agg, "orders", Document.class);</code></pre>
<h3 id="_1">파이프라인 조합 예제</h3>
<p>카테고리별 매출 상위 5개를 조회하는 실전 파이프라인이다.</p>
<pre class="highlight"><code class="language-java">Aggregation agg = Aggregation.newAggregation(
    Aggregation.match(Criteria.where("status").is("completed")),
    Aggregation.group("category")
        .sum("amount").as("totalRevenue")
        .count().as("orderCount"),
    Aggregation.sort(Sort.Direction.DESC, "totalRevenue"),
    Aggregation.limit(5),
    Aggregation.project()
        .and("_id").as("category")
        .andInclude("totalRevenue", "orderCount")
        .andExclude("_id")
);
Flux&lt;Document&gt; results = reactiveMongoTemplate.aggregate(agg, "orders", Document.class);</code></pre>
<hr>
<h2 id="b8">B.8 인덱스</h2>
<table>
<thead>
<tr>
<th>인덱스 유형</th>
<th>설명</th>
<th>생성 예제</th>
</tr>
</thead>
<tbody>
<tr>
<td>단일 필드</td>
<td>하나의 필드에 대한 기본 인덱스</td>
<td><code>db.users.createIndex({ email: 1 })</code></td>
</tr>
<tr>
<td>복합</td>
<td>두 개 이상의 필드를 결합</td>
<td><code>db.orders.createIndex({ userId: 1, createdAt: -1 })</code></td>
</tr>
<tr>
<td>유니크</td>
<td>중복 값을 허용하지 않음</td>
<td><code>db.users.createIndex({ email: 1 }, { unique: true })</code></td>
</tr>
<tr>
<td>텍스트</td>
<td>전문 검색 지원 (컬렉션당 1개)</td>
<td><code>db.articles.createIndex({ content: "text" })</code></td>
</tr>
<tr>
<td>TTL</td>
<td>일정 시간 후 도큐먼트 자동 삭제</td>
<td><code>db.sessions.createIndex({ createdAt: 1 }, { expireAfterSeconds: 3600 })</code></td>
</tr>
</tbody>
</table>
<h3 id="_2">단일 필드 / 유니크 인덱스</h3>
<pre class="highlight"><code class="language-java">@Document(collection = "users")
public class User {
    @Indexed(unique = true)
    private String email;

    @Indexed(direction = IndexDirection.DESCENDING)
    private LocalDateTime createdAt;
}
// 프로그래밍 방식
reactiveMongoTemplate.indexOps("users")
    .ensureIndex(new Index().on("email", Sort.Direction.ASC).unique())
    .subscribe();</code></pre>
<h3 id="_3">복합 인덱스</h3>
<pre class="highlight"><code class="language-java">@Document(collection = "orders")
@CompoundIndex(name = "user_date_idx", def = "{'userId': 1, 'createdAt': -1}")
public class Order {
    private String userId;
    private LocalDateTime createdAt;
}</code></pre>
<h3 id="_4">텍스트 인덱스</h3>
<pre class="highlight"><code class="language-java">@Document(collection = "articles")
public class Article {
    @TextIndexed(weight = 10)
    private String title;
    @TextIndexed(weight = 5)
    private String content;
}
// 텍스트 검색 쿼리
TextCriteria textCriteria = TextCriteria.forDefaultLanguage().matching("reactive webflux");
Query query = TextQuery.queryText(textCriteria).sortByScore();
reactiveMongoTemplate.find(query, Article.class);</code></pre>
<h3 id="ttl">TTL 인덱스</h3>
<pre class="highlight"><code class="language-java">@Document(collection = "sessions")
public class Session {
    @Indexed(expireAfterSeconds = 3600)
    private LocalDateTime createdAt;
}
// 프로그래밍 방식
reactiveMongoTemplate.indexOps("sessions")
    .ensureIndex(new Index().on("createdAt", Sort.Direction.ASC)
        .expire(3600, TimeUnit.SECONDS))
    .subscribe();</code></pre>
<hr>
<h2 id="b9">B.9 자주 사용하는 패턴</h2>
<h3 id="_5">페이징 처리</h3>
<pre class="highlight"><code class="language-java">Query query = Query.query(Criteria.where("status").is("active"))
    .with(Sort.by(Sort.Direction.DESC, "createdAt"))
    .skip(page * size).limit(size);
reactiveMongoTemplate.find(query, Article.class);</code></pre>
<h3 id="upsert">Upsert (존재하면 수정, 없으면 삽입)</h3>
<pre class="highlight"><code class="language-java">Query query = Query.query(Criteria.where("userId").is(userId).and("date").is(today));
Update update = new Update()
    .set("lastAccess", LocalDateTime.now())
    .inc("visitCount", 1)
    .setOnInsert("createdAt", LocalDateTime.now());
reactiveMongoTemplate.upsert(query, update, UserActivity.class);</code></pre>
<h3 id="_6">동적 쿼리 생성</h3>
<pre class="highlight"><code class="language-java">public Flux&lt;Product&gt; search(String keyword, Double minPrice,
                            Double maxPrice, List&lt;String&gt; categories) {
    List&lt;Criteria&gt; conditions = new ArrayList&lt;&gt;();
    if (keyword != null) conditions.add(Criteria.where("name").regex(keyword, "i"));
    if (minPrice != null) conditions.add(Criteria.where("price").gte(minPrice));
    if (maxPrice != null) conditions.add(Criteria.where("price").lte(maxPrice));
    if (categories != null &amp;&amp; !categories.isEmpty())
        conditions.add(Criteria.where("category").in(categories));

    Criteria criteria = new Criteria();
    if (!conditions.isEmpty())
        criteria.andOperator(conditions.toArray(new Criteria[0]));

    return reactiveMongoTemplate.find(Query.query(criteria), Product.class);
}</code></pre>
<hr>
<blockquote>
<p><strong>참고</strong>: MongoDB 연산자의 전체 목록은 <a href="https://www.mongodb.com/docs/manual/reference/operator/">MongoDB 공식 문서</a>에서, Spring Data MongoDB의 Criteria API 상세 내용은 <a href="https://docs.spring.io/spring-data/mongodb/reference/">Spring Data MongoDB 레퍼런스</a>에서 확인할 수 있다.</p>
</blockquote>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>