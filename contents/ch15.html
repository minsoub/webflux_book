<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 15. R2DBC와의 통합 | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="ch14.html">&larr; Chapter 14. WebClient</a>
    <a href="../index.html">목차</a>
    <a href="ch16.html">Chapter 16. 리액티브 테스트 전략 &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-15-r2dbc">Chapter 15. R2DBC와의 통합 (보너스)</h1>
<p>지금까지 이 책에서는 MongoDB를 중심으로 리액티브 데이터 접근을 다루었다. 하지만 실무에서는 관계형 데이터베이스(RDBMS)와 함께 사용해야 하는 상황이 빈번하다. 예를 들어 사용자 인증과 결제 정보는 PostgreSQL에, 상품 카탈로그와 리뷰는 MongoDB에 저장하는 아키텍처가 대표적이다. 이번 장에서는 리액티브 환경에서 관계형 DB에 접근하기 위한 <strong>R2DBC(Reactive Relational Database Connectivity)</strong>를 소개하고, MongoDB와 R2DBC를 동시에 사용하는 <strong>멀티 데이터소스</strong> 구성 방법을 실전 예제와 함께 다룬다.</p>
<hr>
<h2 id="151-r2dbc">15.1 R2DBC란?</h2>
<h3 id="1511-r2dbc">15.1.1 R2DBC 소개</h3>
<p>R2DBC는 <strong>Reactive Relational Database Connectivity</strong>의 약자로, 관계형 데이터베이스에 대한 비동기/논블로킹 접근을 제공하는 SPI(Service Provider Interface) 명세다. 전통적인 JDBC가 블로킹 I/O 기반으로 설계된 반면, R2DBC는 Reactive Streams 표준을 기반으로 처음부터 논블로킹으로 설계되었다.</p>
<table>
<thead>
<tr>
<th>원칙</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>완전한 논블로킹</strong></td>
<td>데이터베이스 연결, 쿼리 실행, 결과 처리 모든 과정이 논블로킹</td>
</tr>
<tr>
<td><strong>Reactive Streams 기반</strong></td>
<td><code>Publisher</code>, <code>Subscriber</code> 패턴을 사용하여 배압(Backpressure) 지원</td>
</tr>
<tr>
<td><strong>SPI 명세</strong></td>
<td>드라이버 제공자가 구현하는 인터페이스 규격</td>
</tr>
<tr>
<td><strong>SQL 중심</strong></td>
<td>ORM이 아닌 SQL 기반 접근 (Spring Data R2DBC가 리포지토리 추상화 제공)</td>
</tr>
</tbody>
</table>
<h3 id="1512-jdbc-vs-r2dbc">15.1.2 JDBC vs R2DBC</h3>
<table>
<thead>
<tr>
<th>구분</th>
<th>JDBC</th>
<th>R2DBC</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>I/O 모델</strong></td>
<td>블로킹</td>
<td>논블로킹</td>
</tr>
<tr>
<td><strong>스레드 모델</strong></td>
<td>요청당 스레드 점유</td>
<td>이벤트 루프 기반</td>
</tr>
<tr>
<td><strong>반환 타입</strong></td>
<td><code>ResultSet</code>, <code>List&lt;T&gt;</code></td>
<td><code>Mono&lt;T&gt;</code>, <code>Flux&lt;T&gt;</code></td>
</tr>
<tr>
<td><strong>배압 지원</strong></td>
<td>없음</td>
<td>Reactive Streams 기반 지원</td>
</tr>
<tr>
<td><strong>트랜잭션</strong></td>
<td><code>ThreadLocal</code> 기반</td>
<td>Reactor Context 기반</td>
</tr>
<tr>
<td><strong>커넥션 풀</strong></td>
<td>HikariCP 등</td>
<td><code>r2dbc-pool</code></td>
</tr>
<tr>
<td><strong>Spring 통합</strong></td>
<td>Spring Data JPA</td>
<td>Spring Data R2DBC</td>
</tr>
</tbody>
</table>
<p>JDBC 기반의 <code>JdbcTemplate</code>이나 JPA를 WebFlux 환경에서 사용하면 이벤트 루프 스레드가 블로킹되어 전체 애플리케이션의 처리량이 급격히 저하된다. R2DBC는 이 문제를 근본적으로 해결한다.</p>
<pre class="highlight"><code>[JDBC + WebFlux]
이벤트 루프 스레드 → DB 쿼리 실행(블로킹) → 스레드 대기 → 처리량 저하

[R2DBC + WebFlux]
이벤트 루프 스레드 → DB 쿼리 요청(논블로킹) → 다른 요청 처리 → 결과 도착 시 콜백</code></pre>
<h3 id="1513">15.1.3 지원 데이터베이스와 의존성 설정</h3>
<p>R2DBC는 SPI 명세이므로, 각 데이터베이스 벤더 또는 커뮤니티가 드라이버를 제공한다.</p>
<table>
<thead>
<tr>
<th>데이터베이스</th>
<th>Maven/Gradle Artifact</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>PostgreSQL</strong></td>
<td><code>org.postgresql:r2dbc-postgresql</code></td>
</tr>
<tr>
<td><strong>MySQL</strong></td>
<td><code>io.asyncer:r2dbc-mysql</code></td>
</tr>
<tr>
<td><strong>MariaDB</strong></td>
<td><code>org.mariadb:r2dbc-mariadb</code></td>
</tr>
<tr>
<td><strong>H2</strong></td>
<td><code>io.r2dbc:r2dbc-h2</code></td>
</tr>
<tr>
<td><strong>Oracle</strong></td>
<td><code>com.oracle.database.r2dbc:oracle-r2dbc</code></td>
</tr>
</tbody>
</table>
<p>이 장에서는 가장 널리 사용되는 <strong>PostgreSQL</strong>을 기준으로 설명한다. <code>build.gradle</code>에 R2DBC 관련 의존성을 추가한다.</p>
<pre class="highlight"><code class="language-groovy">dependencies {
    // 기존 의존성
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    implementation 'org.springframework.boot:spring-boot-starter-data-mongodb-reactive'

    // R2DBC 의존성 추가
    implementation 'org.springframework.boot:spring-boot-starter-data-r2dbc'
    implementation 'org.postgresql:r2dbc-postgresql'

    // Flyway (스키마 마이그레이션) - R2DBC에서는 JDBC 드라이버도 필요
    implementation 'org.flywaydb:flyway-core'
    implementation 'org.flywaydb:flyway-database-postgresql'
    runtimeOnly 'org.postgresql:postgresql'

    testImplementation 'io.r2dbc:r2dbc-h2'
}</code></pre>
<blockquote>
<p><strong>참고</strong>: Flyway 같은 스키마 마이그레이션 도구는 아직 R2DBC를 직접 지원하지 않으므로, 마이그레이션 실행 시에만 JDBC 드라이버가 필요하다. Spring Boot는 시작 시 JDBC 드라이버로 마이그레이션을 수행한 후, 런타임에는 R2DBC 드라이버를 사용한다.</p>
</blockquote>
<h3 id="1514-spring-data-r2dbc">15.1.4 Spring Data R2DBC의 핵심 구성 요소</h3>
<table>
<thead>
<tr>
<th>구성 요소</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ReactiveCrudRepository</code></td>
<td>기본 CRUD 연산을 제공하는 리포지토리 인터페이스</td>
</tr>
<tr>
<td><code>R2dbcEntityTemplate</code></td>
<td><code>ReactiveMongoTemplate</code>에 대응하는 저수준 템플릿</td>
</tr>
<tr>
<td><code>@Table</code>, <code>@Id</code>, <code>@Column</code></td>
<td>엔티티 매핑 어노테이션 (<code>@Entity</code>는 사용하지 않음)</td>
</tr>
<tr>
<td><code>DatabaseClient</code></td>
<td>SQL을 직접 작성하여 실행하는 저수준 클라이언트</td>
</tr>
<tr>
<td><code>R2dbcTransactionManager</code></td>
<td>리액티브 트랜잭션 관리자</td>
</tr>
</tbody>
</table>
<p>MongoDB의 <code>ReactiveMongoRepository</code>를 사용해본 개발자라면 R2DBC 리포지토리도 거의 동일한 방식으로 사용할 수 있다.</p>
<pre class="highlight"><code class="language-java">// MongoDB 리포지토리 (이미 익숙한 패턴)
public interface ProductRepository
        extends ReactiveMongoRepository&lt;Product, String&gt; {
    Flux&lt;Product&gt; findByCategory(String category);
}

// R2DBC 리포지토리 (거의 동일한 패턴)
public interface PaymentRepository
        extends ReactiveCrudRepository&lt;Payment, Long&gt; {
    Flux&lt;Payment&gt; findByUserId(Long userId);
}</code></pre>
<hr>
<h2 id="152-mongodb-r2dbc-db">15.2 MongoDB + R2DBC(관계형 DB) 멀티 데이터소스 구성</h2>
<h3 id="1521">15.2.1 아키텍처 설계</h3>
<p>멀티 데이터소스 아키텍처에서 각 데이터베이스의 역할을 명확히 나누는 것이 중요하다.</p>
<pre class="highlight"><code>┌─────────────────────────────────────────────────┐
│                   Spring WebFlux                 │
│                                                  │
│  ┌──────────────┐         ┌──────────────────┐  │
│  │  R2DBC Layer │         │  MongoDB Layer   │  │
│  │ - 사용자     │         │ - 상품 카탈로그  │  │
│  │ - 주문/결제  │         │ - 상품 리뷰      │  │
│  │ - 재고       │         │ - 활동 로그      │  │
│  └──────┬───────┘         └────────┬─────────┘  │
└─────────┼──────────────────────────┼─────────────┘
          │                          │
    ┌─────▼─────┐             ┌──────▼──────┐
    │ PostgreSQL │             │   MongoDB   │
    └───────────┘             └─────────────┘</code></pre>
<table>
<thead>
<tr>
<th>PostgreSQL (R2DBC)</th>
<th>MongoDB</th>
</tr>
</thead>
<tbody>
<tr>
<td>강한 일관성, ACID 트랜잭션 필수</td>
<td>유연한 스키마, 비정형 데이터</td>
</tr>
<tr>
<td>복잡한 조인이 필요한 데이터</td>
<td>높은 쓰기 처리량이 필요한 데이터</td>
</tr>
<tr>
<td>예: 사용자, 주문, 결제, 재고</td>
<td>예: 상품 카탈로그, 리뷰, 로그</td>
</tr>
</tbody>
</table>
<h3 id="1522-applicationyml">15.2.2 application.yml 두 데이터소스 설정</h3>
<pre class="highlight"><code class="language-yaml">spring:
  # MongoDB 설정
  data:
    mongodb:
      uri: mongodb://localhost:27017/shopdb
      auto-index-creation: true

  # R2DBC (PostgreSQL) 설정
  r2dbc:
    url: r2dbc:postgresql://localhost:5432/shopdb
    username: shopuser
    password: ${DB_PASSWORD:shoppass}
    pool:
      initial-size: 5
      max-size: 20
      max-idle-time: 30m

  # Flyway (JDBC 기반 마이그레이션)
  flyway:
    enabled: true
    url: jdbc:postgresql://localhost:5432/shopdb
    user: shopuser
    password: ${DB_PASSWORD:shoppass}
    locations: classpath:db/migration</code></pre>
<h3 id="1523-flyway">15.2.3 Flyway 스키마 마이그레이션</h3>
<p>R2DBC는 관계형 DB를 사용하므로 테이블 스키마를 사전에 정의해야 한다. <code>src/main/resources/db/migration/V1__init.sql</code> 파일을 작성한다.</p>
<pre class="highlight"><code class="language-sql">CREATE TABLE users (
    id          BIGSERIAL PRIMARY KEY,
    username    VARCHAR(50)  NOT NULL UNIQUE,
    email       VARCHAR(100) NOT NULL UNIQUE,
    password    VARCHAR(255) NOT NULL,
    role        VARCHAR(20)  NOT NULL DEFAULT 'USER',
    created_at  TIMESTAMP    NOT NULL DEFAULT NOW()
);

CREATE TABLE orders (
    id              BIGSERIAL PRIMARY KEY,
    user_id         BIGINT       NOT NULL REFERENCES users(id),
    order_number    VARCHAR(30)  NOT NULL UNIQUE,
    status          VARCHAR(20)  NOT NULL DEFAULT 'PENDING',
    total_amount    DECIMAL(12,2) NOT NULL,
    shipping_address TEXT,
    created_at      TIMESTAMP    NOT NULL DEFAULT NOW()
);

CREATE TABLE order_items (
    id          BIGSERIAL PRIMARY KEY,
    order_id    BIGINT       NOT NULL REFERENCES orders(id),
    product_id  VARCHAR(50)  NOT NULL,  -- MongoDB ObjectId 참조
    product_name VARCHAR(200) NOT NULL,
    quantity    INT          NOT NULL,
    unit_price  DECIMAL(10,2) NOT NULL,
    subtotal    DECIMAL(12,2) NOT NULL
);

CREATE TABLE payments (
    id              BIGSERIAL PRIMARY KEY,
    order_id        BIGINT       NOT NULL REFERENCES orders(id),
    payment_method  VARCHAR(30)  NOT NULL,
    amount          DECIMAL(12,2) NOT NULL,
    status          VARCHAR(20)  NOT NULL DEFAULT 'PENDING',
    transaction_id  VARCHAR(100),
    created_at      TIMESTAMP    NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_order_items_order_id ON order_items(order_id);</code></pre>
<h3 id="1524-mongodbr2dbc">15.2.4 MongoDB/R2DBC 설정 클래스</h3>
<p>두 데이터소스의 리포지토리 스캔 경로를 분리한다.</p>
<pre class="highlight"><code class="language-java">@Configuration
@EnableR2dbcRepositories(basePackages = "com.example.shop.repository.r2dbc")
public class R2dbcConfig extends AbstractR2dbcConfiguration {

    @Value("${spring.r2dbc.url}")
    private String url;

    @Value("${spring.r2dbc.username}")
    private String username;

    @Value("${spring.r2dbc.password}")
    private String password;

    @Override
    @Bean
    public ConnectionFactory connectionFactory() {
        return ConnectionFactories.get(ConnectionFactoryOptions.builder()
            .from(ConnectionFactoryOptions.parse(url))
            .option(ConnectionFactoryOptions.USER, username)
            .option(ConnectionFactoryOptions.PASSWORD, password)
            .build());
    }

    @Bean
    public ReactiveTransactionManager transactionManager(
            ConnectionFactory connectionFactory) {
        return new R2dbcTransactionManager(connectionFactory);
    }
}</code></pre>
<pre class="highlight"><code class="language-java">@Configuration
@EnableReactiveMongoRepositories(
    basePackages = "com.example.shop.repository.mongo"
)
public class MongoConfig extends AbstractReactiveMongoConfiguration {

    @Value("${spring.data.mongodb.uri}")
    private String mongoUri;

    @Override
    protected String getDatabaseName() {
        return "shopdb";
    }

    @Override
    @Bean
    public MongoClient reactiveMongoClient() {
        return MongoClients.create(mongoUri);
    }

    @Bean
    public ReactiveMongoTransactionManager mongoTransactionManager(
            ReactiveMongoDatabaseFactory dbFactory) {
        return new ReactiveMongoTransactionManager(dbFactory);
    }
}</code></pre>
<h3 id="1525">15.2.5 패키지 구조</h3>
<p>멀티 데이터소스를 사용할 때 패키지 구조를 명확히 분리하는 것이 유지보수에 유리하다.</p>
<pre class="highlight"><code>com.example.shop
├── config
│   ├── R2dbcConfig.java
│   └── MongoConfig.java
├── domain
│   ├── rdb                         # R2DBC 엔티티
│   │   ├── UserEntity.java
│   │   ├── OrderEntity.java
│   │   └── OrderItemEntity.java
│   └── mongo                       # MongoDB 도큐먼트
│       ├── Product.java
│       └── Review.java
├── repository
│   ├── r2dbc                       # R2DBC 리포지토리
│   │   ├── UserRepository.java
│   │   └── OrderRepository.java
│   └── mongo                       # MongoDB 리포지토리
│       ├── ProductRepository.java
│       └── ReviewRepository.java
├── service
└── controller</code></pre>
<h3 id="1526">15.2.6 엔티티와 도큐먼트 정의</h3>
<p>R2DBC 엔티티는 <code>@Table</code>, <code>@Id</code>, <code>@Column</code> 어노테이션을 사용한다.</p>
<pre class="highlight"><code class="language-java">@Table("orders")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OrderEntity {

    @Id
    private Long id;

    @Column("user_id")
    private Long userId;

    @Column("order_number")
    private String orderNumber;

    private String status;

    @Column("total_amount")
    private BigDecimal totalAmount;

    @Column("shipping_address")
    private String shippingAddress;

    @Column("created_at")
    private LocalDateTime createdAt;
}</code></pre>
<p>MongoDB 도큐먼트는 유연한 스키마의 장점을 활용한다.</p>
<pre class="highlight"><code class="language-java">@Document(collection = "products")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Product {

    @Id
    private String id;
    private String name;
    private String description;
    private String category;
    private BigDecimal price;
    private int stockQuantity;
    private List&lt;String&gt; tags;
    private Map&lt;String, String&gt; attributes;  // 유연한 속성
    private LocalDateTime createdAt;
}</code></pre>
<h3 id="1527">15.2.7 각 리포지토리</h3>
<p>두 데이터소스의 리포지토리를 패키지별로 분리하여 정의한다.</p>
<pre class="highlight"><code class="language-java">// R2DBC 리포지토리 (com.example.shop.repository.r2dbc)
public interface OrderRepository extends ReactiveCrudRepository&lt;OrderEntity, Long&gt; {
    Flux&lt;OrderEntity&gt; findByUserIdOrderByCreatedAtDesc(Long userId);
    Mono&lt;OrderEntity&gt; findByOrderNumber(String orderNumber);
}

public interface OrderItemRepository
        extends ReactiveCrudRepository&lt;OrderItemEntity, Long&gt; {
    Flux&lt;OrderItemEntity&gt; findByOrderId(Long orderId);
}</code></pre>
<pre class="highlight"><code class="language-java">// MongoDB 리포지토리 (com.example.shop.repository.mongo)
public interface ProductRepository
        extends ReactiveMongoRepository&lt;Product, String&gt; {
    Flux&lt;Product&gt; findByCategory(String category);

    @Query("{ 'price': { '$gte': ?0, '$lte': ?1 } }")
    Flux&lt;Product&gt; findByPriceRange(BigDecimal minPrice, BigDecimal maxPrice);
}

public interface ReviewRepository
        extends ReactiveMongoRepository&lt;Review, String&gt; {
    Flux&lt;Review&gt; findByProductIdOrderByCreatedAtDesc(String productId);
    Mono&lt;Long&gt; countByProductId(String productId);
}</code></pre>
<hr>
<h2 id="153">15.3 리액티브 환경에서 여러 데이터소스 조합하기</h2>
<h3 id="1531">15.3.1 데이터 조합 패턴</h3>
<p>두 데이터소스의 데이터를 조합할 때 Reactor의 연산자를 활용한다.</p>
<p><strong>패턴 1: 순차 조합 (flatMap)</strong> -- 한쪽 결과를 기반으로 다른 데이터소스를 조회한다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class OrderQueryService {

    private final OrderRepository orderRepository;         // R2DBC
    private final OrderItemRepository orderItemRepository; // R2DBC
    private final ProductRepository productRepository;     // MongoDB

    public Mono&lt;OrderDetailResponse&gt; getOrderDetail(Long orderId) {
        return orderRepository.findById(orderId)
            .switchIfEmpty(Mono.error(
                new NotFoundException("주문을 찾을 수 없습니다: " + orderId)))
            .flatMap(order -&gt; orderItemRepository.findByOrderId(orderId)
                .flatMap(item -&gt; productRepository.findById(item.getProductId())
                    .map(product -&gt; OrderItemDetail.builder()
                        .productName(product.getName())
                        .category(product.getCategory())
                        .quantity(item.getQuantity())
                        .unitPrice(item.getUnitPrice())
                        .build()))
                .collectList()
                .map(items -&gt; OrderDetailResponse.builder()
                    .orderId(order.getId())
                    .orderNumber(order.getOrderNumber())
                    .status(order.getStatus())
                    .totalAmount(order.getTotalAmount())
                    .items(items)
                    .createdAt(order.getCreatedAt())
                    .build()));
    }
}</code></pre>
<p><strong>패턴 2: 병렬 조합 (zip)</strong> -- 서로 독립적인 데이터를 병렬로 조회하여 조합한다.</p>
<pre class="highlight"><code class="language-java">public Mono&lt;ProductPageResponse&gt; getProductPage(String productId) {
    Mono&lt;Product&gt; productMono = productRepository.findById(productId)
        .switchIfEmpty(Mono.error(
            new NotFoundException("상품을 찾을 수 없습니다: " + productId)));

    Mono&lt;List&lt;Review&gt;&gt; reviewsMono = reviewRepository
        .findByProductIdOrderByCreatedAtDesc(productId)
        .collectList();

    Mono&lt;Long&gt; reviewCountMono = reviewRepository.countByProductId(productId);

    return Mono.zip(productMono, reviewsMono, reviewCountMono)
        .map(tuple -&gt; ProductPageResponse.builder()
            .product(tuple.getT1())
            .reviews(tuple.getT2())
            .totalReviews(tuple.getT3())
            .build());
}</code></pre>
<h3 id="1532">15.3.2 트랜잭션 주의사항</h3>
<p>멀티 데이터소스 환경에서 트랜잭션은 가장 까다로운 부분이다.</p>
<p><strong>원칙 1: 각 데이터소스의 트랜잭션은 독립적이다</strong></p>
<pre class="highlight"><code class="language-java">// 이 코드는 PostgreSQL 트랜잭션만 보장한다.
// MongoDB 저장이 실패해도 PostgreSQL 변경은 롤백되지 않는다!
@Transactional  // R2dbcTransactionManager가 기본으로 동작
public Mono&lt;Order&gt; createOrder(OrderRequest request) {
    return orderRepository.save(orderEntity)           // PostgreSQL - 트랜잭션 O
        .flatMap(order -&gt;
            productRepository.save(updatedProduct)     // MongoDB - 트랜잭션 X
                .thenReturn(order));
}</code></pre>
<p><strong>원칙 2: 트랜잭션 매니저를 명시적으로 지정한다</strong></p>
<pre class="highlight"><code class="language-java">// PostgreSQL 트랜잭션 사용
@Transactional("transactionManager")
public Mono&lt;OrderEntity&gt; saveOrder(OrderEntity order) {
    return orderRepository.save(order);
}

// MongoDB 트랜잭션 사용
@Transactional("mongoTransactionManager")
public Mono&lt;Product&gt; updateProduct(Product product) {
    return productRepository.save(product);
}</code></pre>
<p><strong>원칙 3: 보상 트랜잭션(Saga) 패턴을 활용한다</strong></p>
<p>두 데이터소스에 걸친 작업에서 일관성을 보장하려면 Saga 패턴을 적용한다. 한쪽이 실패하면 이미 성공한 다른 쪽의 변경을 보상(되돌리기)하는 방식이다.</p>
<h3 id="1533-saga">15.3.3 실전 예제: 주문 시스템 (Saga 패턴)</h3>
<p>재고 차감(MongoDB) -&gt; 주문 생성(PostgreSQL) -&gt; 결제 처리(PostgreSQL) 순서로 진행하며, 각 단계 실패 시 이전 단계를 보상하는 서비스를 구현한다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
@Slf4j
public class OrderSagaService {

    private final OrderRepository orderRepository;
    private final OrderItemRepository orderItemRepository;
    private final ProductRepository productRepository;
    private final PaymentRepository paymentRepository;

    /**
     * 보상 트랜잭션 패턴:
     * 1. 재고 차감 (MongoDB) -&gt; 실패 시 즉시 에러
     * 2. 주문 생성 (PostgreSQL) -&gt; 실패 시 재고 복원
     * 3. 결제 처리 (PostgreSQL) -&gt; 실패 시 주문 취소 + 재고 복원
     */
    public Mono&lt;OrderResult&gt; placeOrder(Long userId, OrderRequest request) {
        return decreaseStock(request.getItems())
            .then(createOrderInDb(userId, request))
            .flatMap(order -&gt; processPayment(order, request)
                .thenReturn(order)
                .onErrorResume(paymentError -&gt; {
                    log.error("결제 실패, 보상 시작", paymentError);
                    return cancelOrder(order)
                        .then(restoreStock(request.getItems()))
                        .then(Mono.error(new PaymentException(
                            "결제 처리에 실패했습니다.", paymentError)));
                }))
            .onErrorResume(orderError -&gt; {
                if (!(orderError instanceof PaymentException)) {
                    log.error("주문 생성 실패, 재고 복원", orderError);
                    return restoreStock(request.getItems())
                        .then(Mono.error(new OrderException(
                            "주문 생성에 실패했습니다.", orderError)));
                }
                return Mono.error(orderError);
            })
            .map(order -&gt; OrderResult.builder()
                .orderId(order.getId())
                .orderNumber(order.getOrderNumber())
                .status("COMPLETED")
                .build());
    }

    private Mono&lt;Void&gt; decreaseStock(List&lt;OrderItemRequest&gt; items) {
        return Flux.fromIterable(items)
            .flatMap(item -&gt; productRepository.findById(item.getProductId())
                .switchIfEmpty(Mono.error(new NotFoundException(
                    "상품을 찾을 수 없습니다: " + item.getProductId())))
                .flatMap(product -&gt; {
                    if (product.getStockQuantity() &lt; item.getQuantity()) {
                        return Mono.error(new InsufficientStockException(
                            product.getName() + " 재고가 부족합니다."));
                    }
                    product.setStockQuantity(
                        product.getStockQuantity() - item.getQuantity());
                    return productRepository.save(product);
                }))
            .then();
    }

    private Mono&lt;Void&gt; restoreStock(List&lt;OrderItemRequest&gt; items) {
        return Flux.fromIterable(items)
            .flatMap(item -&gt; productRepository.findById(item.getProductId())
                .flatMap(product -&gt; {
                    product.setStockQuantity(
                        product.getStockQuantity() + item.getQuantity());
                    return productRepository.save(product);
                }))
            .then();
    }

    private Mono&lt;OrderEntity&gt; createOrderInDb(Long userId, OrderRequest request) {
        OrderEntity order = OrderEntity.builder()
            .userId(userId)
            .orderNumber("ORD-" + System.currentTimeMillis())
            .status("PENDING")
            .totalAmount(request.calculateTotalAmount())
            .shippingAddress(request.getShippingAddress())
            .createdAt(LocalDateTime.now())
            .build();

        return orderRepository.save(order)
            .flatMap(savedOrder -&gt; {
                List&lt;OrderItemEntity&gt; orderItems = request.getItems().stream()
                    .map(item -&gt; OrderItemEntity.builder()
                        .orderId(savedOrder.getId())
                        .productId(item.getProductId())
                        .productName(item.getProductName())
                        .quantity(item.getQuantity())
                        .unitPrice(item.getUnitPrice())
                        .subtotal(item.getUnitPrice()
                            .multiply(BigDecimal.valueOf(item.getQuantity())))
                        .build())
                    .toList();
                return orderItemRepository.saveAll(orderItems)
                    .then(Mono.just(savedOrder));
            });
    }

    private Mono&lt;Void&gt; processPayment(OrderEntity order, OrderRequest request) {
        PaymentEntity payment = PaymentEntity.builder()
            .orderId(order.getId())
            .paymentMethod(request.getPaymentMethod())
            .amount(order.getTotalAmount())
            .status("COMPLETED")
            .transactionId("TXN-" + UUID.randomUUID())
            .createdAt(LocalDateTime.now())
            .build();
        return paymentRepository.save(payment).then();
    }

    private Mono&lt;Void&gt; cancelOrder(OrderEntity order) {
        order.setStatus("CANCELLED");
        return orderRepository.save(order).then();
    }
}</code></pre>
<h3 id="1534">15.3.4 컨트롤러 구현</h3>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/orders")
@RequiredArgsConstructor
public class OrderController {

    private final OrderSagaService orderSagaService;
    private final OrderQueryService orderQueryService;

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono&lt;OrderResult&gt; placeOrder(
            @AuthenticationPrincipal Mono&lt;UserDetails&gt; principal,
            @Valid @RequestBody OrderRequest request) {
        return principal.flatMap(user -&gt; {
            Long userId = Long.parseLong(user.getUsername());
            return orderSagaService.placeOrder(userId, request);
        });
    }

    @GetMapping("/{orderId}")
    public Mono&lt;OrderDetailResponse&gt; getOrderDetail(@PathVariable Long orderId) {
        return orderQueryService.getOrderDetail(orderId);
    }

    @GetMapping("/my")
    public Flux&lt;OrderSummaryResponse&gt; getMyOrders(
            @AuthenticationPrincipal Mono&lt;UserDetails&gt; principal) {
        return principal.flatMapMany(user -&gt; {
            Long userId = Long.parseLong(user.getUsername());
            return orderQueryService.getUserOrders(userId);
        });
    }
}</code></pre>
<h3 id="1535-databaseclient">15.3.5 DatabaseClient를 활용한 복잡한 쿼리</h3>
<p>Spring Data R2DBC의 메서드 이름 기반 쿼리로 부족할 때, <code>DatabaseClient</code>로 SQL을 직접 작성한다.</p>
<pre class="highlight"><code class="language-java">@Repository
@RequiredArgsConstructor
public class OrderCustomRepository {

    private final DatabaseClient databaseClient;

    public Flux&lt;SalesStatistics&gt; getSalesStatistics(
            LocalDateTime from, LocalDateTime to) {
        String sql = """
            SELECT DATE(o.created_at) AS sale_date,
                   COUNT(o.id) AS order_count,
                   SUM(o.total_amount) AS total_sales
            FROM orders o
            WHERE o.status = 'COMPLETED'
              AND o.created_at BETWEEN :from AND :to
            GROUP BY DATE(o.created_at)
            ORDER BY sale_date DESC
            """;

        return databaseClient.sql(sql)
            .bind("from", from)
            .bind("to", to)
            .map((row, metadata) -&gt; SalesStatistics.builder()
                .saleDate(row.get("sale_date", LocalDate.class))
                .orderCount(row.get("order_count", Long.class))
                .totalSales(row.get("total_sales", BigDecimal.class))
                .build())
            .all();
    }
}</code></pre>
<h3 id="1536">15.3.6 두 데이터소스 통계 조합</h3>
<p>PostgreSQL의 주문 통계와 MongoDB의 상품 상세 정보를 조합하는 대시보드 서비스다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class DashboardService {

    private final OrderCustomRepository orderCustomRepository;
    private final ProductRepository productRepository;
    private final ReviewRepository reviewRepository;

    public Flux&lt;PopularProductDashboard&gt; getPopularProductDashboard(int limit) {
        return orderCustomRepository.getPopularProducts(limit)
            .flatMap(stats -&gt; {
                Mono&lt;Product&gt; productMono = productRepository
                    .findById(stats.getProductId())
                    .defaultIfEmpty(Product.builder()
                        .id(stats.getProductId())
                        .name(stats.getProductName())
                        .category("UNKNOWN").build());

                Mono&lt;Double&gt; avgRatingMono = reviewRepository
                    .findByProductIdOrderByCreatedAtDesc(stats.getProductId())
                    .map(Review::getRating)
                    .collectList()
                    .map(ratings -&gt; ratings.stream()
                        .mapToInt(Integer::intValue).average().orElse(0.0));

                return Mono.zip(productMono, avgRatingMono)
                    .map(tuple -&gt; PopularProductDashboard.builder()
                        .productId(stats.getProductId())
                        .productName(stats.getProductName())
                        .category(tuple.getT1().getCategory())
                        .totalQuantitySold(stats.getTotalQuantity())
                        .averageRating(tuple.getT2())
                        .build());
            });
    }
}</code></pre>
<h3 id="1537">15.3.7 멀티 데이터소스 환경의 베스트 프랙티스</h3>
<p><strong>1. 데이터 비정규화로 정합성 관리</strong></p>
<pre class="highlight"><code class="language-java">// 올바른 패턴: 주문 시점의 상품 정보를 비정규화하여 저장
@Table("order_items")
public class OrderItemEntity {
    private String productId;     // MongoDB ObjectId 참조
    private String productName;   // 비정규화 (주문 시점 상품명)
    private BigDecimal unitPrice; // 비정규화 (주문 시점 가격)
}</code></pre>
<p><strong>2. 에러 처리 통합</strong></p>
<pre class="highlight"><code class="language-java">@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(DataIntegrityViolationException.class)
    @ResponseStatus(HttpStatus.CONFLICT)
    public Mono&lt;ErrorResponse&gt; handleDataIntegrity(
            DataIntegrityViolationException ex) {
        return Mono.just(ErrorResponse.of("DATA_CONFLICT",
            "데이터 무결성 위반이 발생했습니다."));
    }

    @ExceptionHandler(DuplicateKeyException.class)
    @ResponseStatus(HttpStatus.CONFLICT)
    public Mono&lt;ErrorResponse&gt; handleDuplicateKey(DuplicateKeyException ex) {
        return Mono.just(ErrorResponse.of("DUPLICATE_KEY",
            "중복된 데이터가 존재합니다."));
    }
}</code></pre>
<p><strong>3. 헬스 체크 통합</strong></p>
<pre class="highlight"><code class="language-java">@Component
@RequiredArgsConstructor
public class MultiDataSourceHealthIndicator
        implements ReactiveHealthIndicator {

    private final ConnectionFactory connectionFactory;
    private final ReactiveMongoTemplate mongoTemplate;

    @Override
    public Mono&lt;Health&gt; health() {
        Mono&lt;String&gt; r2dbcHealth = Mono.from(connectionFactory.create())
            .flatMap(conn -&gt; Mono.from(conn.createStatement("SELECT 1")
                .execute())
                .flatMap(result -&gt; Mono.from(result.map((row, meta) -&gt; "UP")))
                .doFinally(signal -&gt; conn.close()))
            .onErrorReturn("DOWN");

        Mono&lt;String&gt; mongoHealth = mongoTemplate.executeCommand("{ ping: 1 }")
            .map(doc -&gt; "UP")
            .onErrorReturn("DOWN");

        return Mono.zip(r2dbcHealth, mongoHealth)
            .map(tuple -&gt; {
                boolean allUp = "UP".equals(tuple.getT1())
                             &amp;&amp; "UP".equals(tuple.getT2());
                return (allUp ? Health.up() : Health.down())
                    .withDetail("postgresql", tuple.getT1())
                    .withDetail("mongodb", tuple.getT2())
                    .build();
            });
    }
}</code></pre>
<h3 id="1538">15.3.8 주의사항 정리</h3>
<table>
<thead>
<tr>
<th>함정</th>
<th>대응 방법</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>분산 트랜잭션 불가</strong>: <code>@Transactional</code> 하나로 두 DB를 묶을 수 없음</td>
<td>Saga 패턴, 보상 트랜잭션</td>
</tr>
<tr>
<td><strong>참조 무결성 부재</strong>: 두 DB 간 외래 키 제약 없음</td>
<td>비정규화, 방어적 코딩, 정기 정합성 검증 배치</td>
</tr>
<tr>
<td><strong>트랜잭션 매니저 충돌</strong>: 기본 <code>@Transactional</code>이 어느 매니저를 쓸지 모호</td>
<td><code>@Transactional("매니저명")</code> 명시</td>
</tr>
<tr>
<td><strong>N+1 쿼리</strong>: 두 데이터소스 조합 시 반복 조회 발생</td>
<td><code>collectList()</code> 후 일괄 조회, 캐싱</td>
</tr>
<tr>
<td><strong>에러 타입 혼재</strong>: R2DBC와 MongoDB가 다른 예외 체계 사용</td>
<td>통합 예외 핸들러, 비즈니스 예외로 래핑</td>
</tr>
<tr>
<td><strong>스키마 관리</strong>: R2DBC는 DDL 자동 생성 미지원</td>
<td>Flyway 또는 Liquibase 사용</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="_1">요약</h2>
<p>이번 장에서는 리액티브 환경에서 관계형 데이터베이스에 접근하기 위한 R2DBC를 소개하고, MongoDB와 함께 사용하는 멀티 데이터소스 아키텍처를 다루었다.</p>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 내용</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>R2DBC 소개</strong></td>
<td>JDBC의 리액티브 대안, Reactive Streams 기반 논블로킹 DB 접근</td>
</tr>
<tr>
<td><strong>JDBC vs R2DBC</strong></td>
<td>블로킹 vs 논블로킹, ThreadLocal vs Reactor Context 기반 트랜잭션</td>
</tr>
<tr>
<td><strong>멀티 데이터소스 구성</strong></td>
<td>패키지 분리, 설정 클래스 분리, 리포지토리 스캔 경로 분리</td>
</tr>
<tr>
<td><strong>데이터 조합</strong></td>
<td><code>flatMap</code>(순차), <code>zip</code>(병렬)을 활용한 조합 패턴</td>
</tr>
<tr>
<td><strong>트랜잭션 관리</strong></td>
<td>분산 트랜잭션 불가, Saga 패턴과 보상 트랜잭션으로 대응</td>
</tr>
<tr>
<td><strong>실전 예제</strong></td>
<td>주문 시스템 -- 재고 차감(MongoDB) + 주문 생성(PostgreSQL) + 결제 처리</td>
</tr>
</tbody>
</table>
<p>R2DBC는 WebFlux 기반 애플리케이션에서 관계형 데이터베이스를 사용할 때 유일한 리액티브 선택지다. MongoDB와 함께 사용하면 각 데이터베이스의 장점을 최대한 활용할 수 있지만, 분산 트랜잭션과 데이터 정합성에 대한 신중한 설계가 필요하다.</p>
<p>다음 장에서는 리액티브 테스트 전략을 다루며, StepVerifier와 WebTestClient를 활용한 테스트 작성법을 살펴본다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>