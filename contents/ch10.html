<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 10. WebFlux 필터와 인터셉터 | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="ch09.html">&larr; Chapter 9. 데이터 검증과 예외 처리</a>
    <a href="../index.html">목차</a>
    <a href="ch11.html">Chapter 11. 리액티브 보안 &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-10-webflux">Chapter 10. WebFlux 필터와 인터셉터</h1>
<p>Chapter 9에서 데이터 검증과 예외 처리를 다루었다. 이번 장에서는 요청과 응답의 <strong>횡단 관심사(cross-cutting concerns)</strong>를 처리하는 필터와 인터셉터를 살펴본다. Spring MVC의 <code>Filter</code>와 <code>HandlerInterceptor</code>에 대응하는 WebFlux의 <code>WebFilter</code>와 <code>HandlerFilterFunction</code>을 구현하고, 로깅, CORS, 속도 제한까지 실전에서 자주 사용하는 패턴을 모두 다룬다.</p>
<hr>
<h2 id="101-webfilter">10.1 WebFilter 구현</h2>
<h3 id="1011-webfilter">10.1.1 WebFilter 인터페이스 이해</h3>
<p><code>WebFilter</code>는 Spring WebFlux에서 모든 HTTP 요청에 대해 공통 로직을 실행할 수 있는 서블릿 필터 대응 인터페이스다. 어노테이션 기반 컨트롤러와 함수형 엔드포인트 모두에 적용된다.</p>
<pre class="highlight"><code class="language-java">public interface WebFilter {
    Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain);
}</code></pre>
<table>
<thead>
<tr>
<th>파라미터</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ServerWebExchange</code></td>
<td>HTTP 요청(<code>ServerHttpRequest</code>)과 응답(<code>ServerHttpResponse</code>)을 모두 담고 있는 컨텍스트 객체</td>
</tr>
<tr>
<td><code>WebFilterChain</code></td>
<td>다음 필터 또는 핸들러로 요청을 전달하는 체인</td>
</tr>
</tbody>
</table>
<p>핵심 원리는 <strong>필터 체인</strong> 패턴이다. 각 필터는 <code>chain.filter(exchange)</code>를 호출하여 다음 단계로 요청을 넘기고, 반환값인 <code>Mono&lt;Void&gt;</code>에 연산자를 체이닝하여 응답 후처리를 수행한다.</p>
<pre class="highlight"><code>[클라이언트] → [WebFilter 1] → [WebFilter 2] → ... → [핸들러]
                                                         ↓
[클라이언트] ← [WebFilter 1] ← [WebFilter 2] ← ... ← [응답]</code></pre>
<h3 id="1012">10.1.2 요청 전후 처리 필터</h3>
<p><code>@Component</code>로 등록하면 스프링이 자동으로 필터 체인에 추가한다. <code>chain.filter()</code> 호출 전후로 코드를 배치하여 요청과 응답 양쪽을 처리할 수 있다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Component
public class RequestTimingFilter implements WebFilter {

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        // === 전처리 ===
        long startTime = System.currentTimeMillis();
        String method = exchange.getRequest().getMethod().name();
        String path = exchange.getRequest().getURI().getPath();

        log.info("&gt;&gt;&gt; 요청 시작: {} {}", method, path);

        return chain.filter(exchange)
            // === 후처리 ===
            .doFinally(signalType -&gt; {
                long duration = System.currentTimeMillis() - startTime;
                log.info("&lt;&lt;&lt; 요청 완료: {} {} - {}ms [{}]",
                    method, path, duration, signalType);
            });
    }
}</code></pre>
<blockquote>
<p><strong>주의</strong>: <code>then(Mono.fromRunnable(...))</code>은 정상 완료 시에만 실행된다. 에러를 포함한 모든 경우를 처리하려면 위 예시처럼 <code>doFinally</code>를 사용해야 한다.</p>
</blockquote>
<h3 id="1013-order">10.1.3 @Order로 필터 실행 순서 지정</h3>
<p>여러 WebFilter가 등록된 경우 <code>@Order</code> 어노테이션으로 실행 순서를 제어한다. 값이 작을수록 먼저 실행된다.</p>
<pre class="highlight"><code class="language-java">@Component
@Order(1)
public class SecurityCheckFilter implements WebFilter { /* 보안 검사 */ }

@Component
@Order(2)
public class LoggingFilter implements WebFilter { /* 로깅 */ }

@Component
@Order(3)
public class MetricsFilter implements WebFilter { /* 메트릭 수집 */ }</code></pre>
<p><code>Ordered</code> 인터페이스를 구현하는 방법도 있다.</p>
<pre class="highlight"><code class="language-java">@Component
public class HighPriorityFilter implements WebFilter, Ordered {
    @Override
    public int getOrder() { return Ordered.HIGHEST_PRECEDENCE; }

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        return chain.filter(exchange);
    }
}</code></pre>
<h3 id="1014">10.1.4 조건부 필터 적용과 요청 차단</h3>
<p>WebFilter는 기본적으로 <strong>모든 요청</strong>에 적용된다. 특정 경로에만 필터를 적용하려면 내부에서 경로를 확인하고, 요청을 차단하려면 <code>chain.filter()</code>를 호출하지 않고 응답을 즉시 완료한다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Component
@Order(1)
public class ApiKeyFilter implements WebFilter {

    private static final String API_KEY_HEADER = "X-API-Key";
    private static final String VALID_API_KEY = "my-secret-api-key";

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        String path = exchange.getRequest().getURI().getPath();

        // /api/** 경로에만 필터 적용
        if (!path.startsWith("/api/")) {
            return chain.filter(exchange);
        }

        String apiKey = exchange.getRequest().getHeaders().getFirst(API_KEY_HEADER);
        if (VALID_API_KEY.equals(apiKey)) {
            return chain.filter(exchange);
        }

        // 요청 차단: chain.filter()를 호출하지 않고 응답 완료
        log.warn("유효하지 않은 API Key 요청: {}", path);
        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
        return exchange.getResponse().setComplete();
    }
}</code></pre>
<h3 id="1015-attribute">10.1.5 요청 속성(Attribute) 전달</h3>
<p>필터에서 설정한 데이터를 다운스트림 핸들러로 전달할 때 <code>ServerWebExchange</code>의 속성을 활용한다.</p>
<pre class="highlight"><code class="language-java">@Component
@Order(0)
public class RequestContextFilter implements WebFilter {
    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        String requestId = UUID.randomUUID().toString().substring(0, 8);
        exchange.getAttributes().put("requestId", requestId);
        exchange.getResponse().getHeaders().add("X-Request-Id", requestId);
        return chain.filter(exchange);
    }
}

// 컨트롤러에서 속성 사용
@GetMapping("/api/products")
public Mono&lt;ResponseEntity&lt;List&lt;Product&gt;&gt;&gt; getProducts(ServerWebExchange exchange) {
    String requestId = exchange.getAttribute("requestId");
    log.info("[{}] 상품 목록 조회 요청", requestId);
    // ...
}</code></pre>
<hr>
<h2 id="102-handlerfilterfunction">10.2 HandlerFilterFunction 활용</h2>
<h3 id="1021-webfilter-handlerfilterfunction">10.2.1 WebFilter와 HandlerFilterFunction 비교</h3>
<p><code>HandlerFilterFunction</code>은 <strong>함수형 엔드포인트(RouterFunction)</strong> 전용 필터다.</p>
<pre class="highlight"><code class="language-java">@FunctionalInterface
public interface HandlerFilterFunction&lt;T extends ServerResponse, R extends ServerResponse&gt; {
    Mono&lt;R&gt; filter(ServerRequest request, HandlerFunction&lt;T&gt; next);
}</code></pre>
<table>
<thead>
<tr>
<th>항목</th>
<th>WebFilter</th>
<th>HandlerFilterFunction</th>
</tr>
</thead>
<tbody>
<tr>
<td>적용 대상</td>
<td>모든 요청 (어노테이션 + 함수형)</td>
<td>함수형 엔드포인트만</td>
</tr>
<tr>
<td>적용 범위</td>
<td>글로벌</td>
<td>특정 RouterFunction</td>
</tr>
<tr>
<td>접근 객체</td>
<td><code>ServerWebExchange</code></td>
<td><code>ServerRequest</code> / <code>ServerResponse</code></td>
</tr>
<tr>
<td>등록 방법</td>
<td><code>@Component</code> 자동 등록</td>
<td><code>RouterFunction.filter()</code></td>
</tr>
</tbody>
</table>
<h3 id="1022">10.2.2 기본 사용법</h3>
<p><code>RouterFunction</code>의 <code>filter()</code> 메서드에 람다로 필터를 전달한다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class ProductRouter {
    @Bean
    public RouterFunction&lt;ServerResponse&gt; productRoutes(ProductHandler handler) {
        return nest(path("/api/products"),
            route(GET(""), handler::getAll)
            .andRoute(POST(""), handler::create)
            .andRoute(PUT("/{id}"), handler::update)
            .andRoute(DELETE("/{id}"), handler::delete)
        )
        .filter((request, next) -&gt; {
            log.info("Product API 요청: {} {}", request.method(), request.path());
            return next.handle(request);
        });
    }
}</code></pre>
<h3 id="1023">10.2.3 인증 필터 구현</h3>
<p>실제 프로젝트에서 자주 사용하는 인증 필터를 <code>HandlerFilterFunction</code>으로 구현한다.</p>
<pre class="highlight"><code class="language-java">public class AuthFilterFunction
        implements HandlerFilterFunction&lt;ServerResponse, ServerResponse&gt; {

    private final TokenValidator tokenValidator;

    public AuthFilterFunction(TokenValidator tokenValidator) {
        this.tokenValidator = tokenValidator;
    }

    @Override
    public Mono&lt;ServerResponse&gt; filter(ServerRequest request,
                                       HandlerFunction&lt;ServerResponse&gt; next) {
        String authHeader = request.headers().firstHeader("Authorization");

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            return ServerResponse.status(HttpStatus.UNAUTHORIZED)
                .bodyValue(Map.of("error", "Authorization 헤더가 필요합니다."));
        }

        String token = authHeader.substring(7);

        return tokenValidator.validate(token)
            .flatMap(userId -&gt; {
                ServerRequest modifiedRequest = ServerRequest.from(request)
                    .attribute("userId", userId)
                    .build();
                return next.handle(modifiedRequest);
            })
            .onErrorResume(InvalidTokenException.class, e -&gt;
                ServerResponse.status(HttpStatus.UNAUTHORIZED)
                    .bodyValue(Map.of("error", e.getMessage()))
            );
    }
}</code></pre>
<p>라우터에서 공개 API와 보호된 API를 분리하여 인증 필터를 선택적으로 적용한다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class AppRouter {

    private final TokenValidator tokenValidator;

    public AppRouter(TokenValidator tokenValidator) {
        this.tokenValidator = tokenValidator;
    }

    @Bean
    public RouterFunction&lt;ServerResponse&gt; routes(
            ProductHandler productHandler, AuthHandler authHandler) {

        // 인증 불필요: 공개 API
        RouterFunction&lt;ServerResponse&gt; publicRoutes = route(
            POST("/api/auth/login"), authHandler::login
        ).andRoute(
            POST("/api/auth/register"), authHandler::register
        );

        // 인증 필요: 보호된 API
        RouterFunction&lt;ServerResponse&gt; protectedRoutes = nest(path("/api/products"),
            route(GET(""), productHandler::getAll)
            .andRoute(POST(""), productHandler::create)
            .andRoute(DELETE("/{id}"), productHandler::delete)
        ).filter(new AuthFilterFunction(tokenValidator));

        return publicRoutes.and(protectedRoutes);
    }
}</code></pre>
<h3 id="1024">10.2.4 역할 기반 접근 제어 필터</h3>
<p>인증 필터를 확장하여 역할(Role) 기반 인가 필터도 구현할 수 있다. 여러 필터를 체이닝하면 인증 -&gt; 인가 순서로 적용된다.</p>
<pre class="highlight"><code class="language-java">public class RoleFilterFunction
        implements HandlerFilterFunction&lt;ServerResponse, ServerResponse&gt; {

    private final Set&lt;String&gt; allowedRoles;

    public RoleFilterFunction(String... roles) {
        this.allowedRoles = Set.of(roles);
    }

    @Override
    public Mono&lt;ServerResponse&gt; filter(ServerRequest request,
                                       HandlerFunction&lt;ServerResponse&gt; next) {
        String userRole = request.attribute("userRole")
            .map(Object::toString).orElse("");

        if (allowedRoles.contains(userRole)) {
            return next.handle(request);
        }
        return ServerResponse.status(HttpStatus.FORBIDDEN)
            .bodyValue(Map.of("error", "접근 권한이 없습니다."));
    }
}

// 관리자 전용 API에 인증 + 역할 필터 체이닝
RouterFunction&lt;ServerResponse&gt; adminRoutes = nest(path("/api/admin"),
    route(GET("/users"), adminHandler::getAllUsers)
    .andRoute(DELETE("/users/{id}"), adminHandler::deleteUser)
)
.filter(new AuthFilterFunction(tokenValidator))
.filter(new RoleFilterFunction("ADMIN"));</code></pre>
<hr>
<h2 id="103">10.3 요청/응답 로깅</h2>
<h3 id="1031">10.3.1 요청 로깅 필터</h3>
<p>운영 환경에서 요청 정보를 체계적으로 기록하는 로깅 필터를 구현한다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
public class RequestLoggingFilter implements WebFilter {

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String requestId = UUID.randomUUID().toString().substring(0, 8);
        String method = request.getMethod().name();
        String path = request.getURI().getPath();
        String clientIp = extractClientIp(request);

        log.info("[{}] &gt;&gt;&gt; {} {} ip={}", requestId, method, path, clientIp);

        long startTime = System.nanoTime();
        exchange.getResponse().getHeaders().add("X-Request-Id", requestId);
        exchange.getAttributes().put("requestId", requestId);

        return chain.filter(exchange)
            .doFinally(signalType -&gt; {
                long durationMs = (System.nanoTime() - startTime) / 1_000_000;
                HttpStatusCode status = exchange.getResponse().getStatusCode();
                log.info("[{}] &lt;&lt;&lt; {} {} -&gt; {} ({}ms)",
                    requestId, method, path, status, durationMs);
            });
    }

    private String extractClientIp(ServerHttpRequest request) {
        String xff = request.getHeaders().getFirst("X-Forwarded-For");
        if (xff != null &amp;&amp; !xff.isEmpty()) {
            return xff.split(",")[0].trim();
        }
        return Optional.ofNullable(request.getRemoteAddress())
            .map(addr -&gt; addr.getAddress().getHostAddress())
            .orElse("unknown");
    }
}</code></pre>
<h3 id="1032-serverhttpresponsedecorator">10.3.2 응답 바디 로깅 (ServerHttpResponseDecorator)</h3>
<p>응답 바디는 스트림 형태이므로 직접 읽을 수 없다. <code>ServerHttpResponseDecorator</code>로 <code>writeWith</code>를 오버라이드하여 쓰기 시점에 바이트를 가로채 기록한다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Component
@Order(Ordered.HIGHEST_PRECEDENCE + 1)
public class ResponseBodyLoggingFilter implements WebFilter {

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        if (!log.isDebugEnabled()) return chain.filter(exchange);

        String requestId = exchange.getAttribute("requestId");
        ServerHttpResponse original = exchange.getResponse();

        ServerHttpResponseDecorator decorated = new ServerHttpResponseDecorator(original) {
            @Override
            public Mono&lt;Void&gt; writeWith(Publisher&lt;? extends DataBuffer&gt; body) {
                if (body instanceof Flux&lt;? extends DataBuffer&gt; fluxBody) {
                    return super.writeWith(fluxBody.buffer().map(dataBuffers -&gt; {
                        DataBuffer joined = original.bufferFactory().join(dataBuffers);
                        byte[] content = new byte[joined.readableByteCount()];
                        joined.read(content);
                        DataBufferUtils.release(joined);
                        log.debug("[{}] 응답 바디: {}", requestId,
                            new String(content, StandardCharsets.UTF_8));
                        return original.bufferFactory().wrap(content);
                    }));
                }
                return super.writeWith(body);
            }
        };
        return chain.filter(exchange.mutate().response(decorated).build());
    }
}</code></pre>
<blockquote>
<p><strong>주의</strong>: 응답 바디 로깅은 메모리와 성능에 영향을 미친다. 반드시 디버그 레벨에서만 활성화하고, 대용량 응답에서는 크기 제한 로직을 추가해야 한다.</p>
</blockquote>
<h3 id="1033-id-reactor-context">10.3.3 요청 추적 ID와 Reactor Context</h3>
<p>리액티브 환경에서는 스레드가 수시로 전환되므로 기존 <code>MDC</code>가 정상 작동하지 않는다. Reactor의 <strong>Context</strong>를 활용하여 추적 ID를 전파한다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
public class TraceIdFilter implements WebFilter {

    private static final String TRACE_ID_KEY = "traceId";

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        String traceId = Optional.ofNullable(
                exchange.getRequest().getHeaders().getFirst("X-Trace-Id")
            ).orElse(UUID.randomUUID().toString());

        exchange.getResponse().getHeaders().add("X-Trace-Id", traceId);

        return chain.filter(exchange)
            .contextWrite(Context.of(TRACE_ID_KEY, traceId));
    }
}</code></pre>
<p>서비스 계층에서 Context의 추적 ID를 활용한다.</p>
<pre class="highlight"><code class="language-java">@Service
@Slf4j
public class ProductService {
    public Mono&lt;Product&gt; findById(String id) {
        return Mono.deferContextual(ctx -&gt; {
            String traceId = ctx.getOrDefault("traceId", "N/A");
            log.info("[{}] 상품 조회: id={}", traceId, id);
            return productRepository.findById(id);
        });
    }
}</code></pre>
<p>Spring Boot 3.x에서는 Micrometer <strong>Context Propagation</strong>을 사용하면 MDC 자동 전파를 구성할 수 있다.</p>
<pre class="highlight"><code class="language-yaml">spring:
  reactor:
    context-propagation: auto</code></pre>
<hr>
<h2 id="104-cors">10.4 CORS 설정</h2>
<h3 id="1041-cors">10.4.1 CORS 개요</h3>
<p>브라우저는 <strong>동일 출처 정책(Same-Origin Policy)</strong>을 적용한다. 프런트엔드(<code>http://localhost:3000</code>)에서 백엔드(<code>http://localhost:8080</code>)를 호출하면 출처가 다르므로 CORS 에러가 발생한다. 서버에서 적절한 CORS 헤더를 응답에 포함해야 한다.</p>
<table>
<thead>
<tr>
<th>CORS 헤더</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Access-Control-Allow-Origin</code></td>
<td>허용할 출처</td>
</tr>
<tr>
<td><code>Access-Control-Allow-Methods</code></td>
<td>허용할 HTTP 메서드</td>
</tr>
<tr>
<td><code>Access-Control-Allow-Headers</code></td>
<td>허용할 요청 헤더</td>
</tr>
<tr>
<td><code>Access-Control-Allow-Credentials</code></td>
<td>쿠키/인증 정보 포함 허용 여부</td>
</tr>
<tr>
<td><code>Access-Control-Max-Age</code></td>
<td>Preflight 요청 캐시 시간(초)</td>
</tr>
</tbody>
</table>
<h3 id="1042-webfluxconfigurer">10.4.2 WebFluxConfigurer를 이용한 글로벌 설정</h3>
<p>가장 권장되는 방법으로, 모든 엔드포인트에 일괄 적용된다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class CorsConfig implements WebFluxConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
            .allowedOrigins("http://localhost:3000", "https://myapp.example.com")
            .allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS")
            .allowedHeaders("*")
            .exposedHeaders("X-Request-Id", "X-Trace-Id")
            .allowCredentials(true)
            .maxAge(3600);
    }
}</code></pre>
<h3 id="1043-crossorigin">10.4.3 @CrossOrigin 어노테이션</h3>
<p>컨트롤러 또는 개별 메서드 레벨에서 세밀하게 CORS를 설정할 수 있다. 클래스 레벨과 메서드 레벨 설정이 동시에 존재하면 <strong>병합</strong>된다.</p>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/products")
@CrossOrigin(origins = "http://localhost:3000", maxAge = 3600)
public class ProductController {

    @CrossOrigin(origins = "https://partner.example.com")
    @GetMapping("/{id}")
    public Mono&lt;Product&gt; getById(@PathVariable String id) {
        return productService.findById(id);
    }
}</code></pre>
<h3 id="1044-corswebfilter">10.4.4 CorsWebFilter (프로그래밍 방식)</h3>
<p>함수형 엔드포인트에는 <code>@CrossOrigin</code>을 사용할 수 없다. <code>CorsWebFilter</code>를 빈으로 등록하면 어노테이션 기반과 함수형 모두에 적용된다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class CorsFilterConfig {

    @Bean
    public CorsWebFilter corsWebFilter() {
        CorsConfiguration config = new CorsConfiguration();
        config.addAllowedOrigin("http://localhost:3000");
        config.addAllowedOrigin("https://myapp.example.com");
        config.addAllowedMethod("*");
        config.addAllowedHeader("*");
        config.addExposedHeader("X-Request-Id");
        config.setAllowCredentials(true);
        config.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/api/**", config);
        return new CorsWebFilter(source);
    }
}</code></pre>
<h3 id="1045-cors">10.4.5 환경별 CORS 설정</h3>
<p>개발과 운영 환경마다 허용 출처가 다른 경우 <code>application.yml</code> 프로파일과 <code>@Value</code>를 조합한다.</p>
<pre class="highlight"><code class="language-yaml"># application.yml             → app.cors.allowed-origins: "http://localhost:3000"
# application-prod.yml        → app.cors.allowed-origins: "https://myapp.example.com"</code></pre>
<pre class="highlight"><code class="language-java">@Configuration
public class CorsConfig implements WebFluxConfigurer {

    @Value("${app.cors.allowed-origins}")
    private String[] allowedOrigins;

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
            .allowedOrigins(allowedOrigins)
            .allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH")
            .allowedHeaders("*")
            .allowCredentials(true)
            .maxAge(3600);
    }
}</code></pre>
<hr>
<h2 id="105-rate-limiting">10.5 요청 속도 제한(Rate Limiting)</h2>
<h3 id="1051">10.5.1 토큰 버킷 알고리즘</h3>
<p>가장 널리 사용되는 속도 제한 알고리즘이다.</p>
<ol>
<li><strong>버킷</strong>에 토큰이 일정 속도로 채워진다.</li>
<li>요청이 들어오면 버킷에서 토큰 1개를 소비한다.</li>
<li>토큰이 없으면 요청을 거부한다(429 Too Many Requests).</li>
<li>버킷 크기가 고정되어 순간적인 버스트(burst)를 일정 수준까지 허용한다.</li>
</ol>
<pre class="highlight"><code>[토큰 생성기] ---(초당 10개)---&gt; [버킷 (최대 20개)]
                                       ↓
                                 요청 -&gt; 토큰 1개 소비
                                 토큰 부족 -&gt; 429 응답</code></pre>
<h3 id="1052-bucket4j">10.5.2 Bucket4j 의존성</h3>
<p><strong>Bucket4j</strong>는 토큰 버킷 알고리즘의 Java 구현체로, 스레드 안전하며 성능이 뛰어나다. <code>build.gradle.kts</code>에 의존성을 추가한다: <code>implementation("com.bucket4j:bucket4j-core:8.10.1")</code></p>
<h3 id="1053-ip">10.5.3 IP 기반 속도 제한 필터</h3>
<p>클라이언트 IP별로 독립적인 버킷을 관리하는 필터를 구현한다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Component
public class RateLimitFilter implements WebFilter {

    private final Map&lt;String, Bucket&gt; bucketCache = new ConcurrentHashMap&lt;&gt;();

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        String path = exchange.getRequest().getURI().getPath();
        if (!path.startsWith("/api/")) {
            return chain.filter(exchange);
        }

        String clientIp = extractClientIp(exchange);
        Bucket bucket = bucketCache.computeIfAbsent(clientIp, this::createBucket);
        ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);

        if (probe.isConsumed()) {
            exchange.getResponse().getHeaders()
                .add("X-RateLimit-Remaining",
                    String.valueOf(probe.getRemainingTokens()));
            return chain.filter(exchange);
        }

        // 속도 제한 초과 -&gt; 429 응답
        long waitSeconds = probe.getNanosToWaitForRefill() / 1_000_000_000;
        log.warn("속도 제한 초과: IP={}, 재시도까지 {}초", clientIp, waitSeconds);

        exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
        exchange.getResponse().getHeaders().setContentType(MediaType.APPLICATION_JSON);
        exchange.getResponse().getHeaders().add("Retry-After", String.valueOf(waitSeconds));

        String errorBody = """
            {
              "error": "TOO_MANY_REQUESTS",
              "message": "요청 속도 제한을 초과했습니다.",
              "retryAfterSeconds": %d
            }
            """.formatted(waitSeconds);

        return exchange.getResponse().writeWith(
            Mono.just(exchange.getResponse().bufferFactory()
                .wrap(errorBody.getBytes()))
        );
    }

    private Bucket createBucket(String key) {
        Bandwidth limit = Bandwidth.classic(
            10,                                      // 버킷 용량 (버스트)
            Refill.greedy(60, Duration.ofMinutes(1)) // 분당 60개 보충
        );
        return Bucket.builder().addLimit(limit).build();
    }

    private String extractClientIp(ServerWebExchange exchange) {
        String xff = exchange.getRequest().getHeaders().getFirst("X-Forwarded-For");
        if (xff != null &amp;&amp; !xff.isEmpty()) return xff.split(",")[0].trim();
        return Optional.ofNullable(exchange.getRequest().getRemoteAddress())
            .map(addr -&gt; addr.getAddress().getHostAddress()).orElse("unknown");
    }
}</code></pre>
<h3 id="1054">10.5.4 사용자 등급별 차등 속도 제한</h3>
<p>인증된 사용자별로 등급(plan)에 따라 다른 제한을 적용한다. 핵심은 <code>Plan</code> enum으로 등급별 정책을 정의하고, 사용자 ID와 등급을 조합한 키로 버킷을 관리하는 것이다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Component
@Order(10)  // 인증 필터 이후에 실행
public class UserRateLimitFilter implements WebFilter {

    private final Map&lt;String, Bucket&gt; bucketCache = new ConcurrentHashMap&lt;&gt;();

    enum Plan {
        FREE(20, Duration.ofMinutes(1)),       // 무료: 분당 20건
        BASIC(100, Duration.ofMinutes(1)),      // 기본: 분당 100건
        PREMIUM(1000, Duration.ofMinutes(1));   // 프리미엄: 분당 1000건

        final int capacity;
        final Duration period;
        Plan(int capacity, Duration period) {
            this.capacity = capacity;
            this.period = period;
        }
    }

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        String userId = exchange.getAttribute("userId");
        if (userId == null || !exchange.getRequest().getURI()
                .getPath().startsWith("/api/")) {
            return chain.filter(exchange);
        }

        String userPlan = exchange.getAttribute("userPlan");
        Plan plan = resolvePlan(userPlan);
        Bucket bucket = bucketCache.computeIfAbsent(
            userId + ":" + plan.name(), k -&gt; createBucket(plan));

        ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);

        // 남은 호출 횟수를 헤더로 전달
        exchange.getResponse().getHeaders()
            .add("X-RateLimit-Limit", String.valueOf(plan.capacity));
        exchange.getResponse().getHeaders()
            .add("X-RateLimit-Remaining", String.valueOf(probe.getRemainingTokens()));

        if (probe.isConsumed()) return chain.filter(exchange);

        // 429 응답 (IP 기반 필터와 동일한 패턴)
        exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
        String body = """
            {"error":"TOO_MANY_REQUESTS","plan":"%s","limit":%d}
            """.formatted(plan.name(), plan.capacity);
        return exchange.getResponse().writeWith(
            Mono.just(exchange.getResponse().bufferFactory().wrap(body.getBytes())));
    }

    private Plan resolvePlan(String planStr) {
        try { return Plan.valueOf(planStr.toUpperCase()); }
        catch (Exception e) { return Plan.FREE; }
    }

    private Bucket createBucket(Plan plan) {
        return Bucket.builder().addLimit(Bandwidth.classic(
            plan.capacity, Refill.greedy(plan.capacity, plan.period))).build();
    }
}</code></pre>
<h3 id="1055">10.5.5 엔드포인트별 차등 속도 제한</h3>
<p>로그인 API처럼 브루트포스 공격에 취약한 엔드포인트에는 <code>HandlerFilterFunction</code>으로 더 엄격한 제한을 적용한다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class RateLimitConfig {

    @Bean
    public RouterFunction&lt;ServerResponse&gt; rateLimitedAuthRoutes(AuthHandler handler) {
        return route(POST("/api/auth/login"), handler::login)
            .filter(createRateLimitFilter(5, Duration.ofMinutes(1)))   // 분당 5회
            .andRoute(POST("/api/auth/register"), handler::register)
            .filter(createRateLimitFilter(3, Duration.ofHours(1)));    // 시간당 3회
    }

    private HandlerFilterFunction&lt;ServerResponse, ServerResponse&gt;
            createRateLimitFilter(int capacity, Duration period) {
        Map&lt;String, Bucket&gt; buckets = new ConcurrentHashMap&lt;&gt;();
        return (request, next) -&gt; {
            String ip = request.remoteAddress()
                .map(a -&gt; a.getAddress().getHostAddress()).orElse("unknown");
            Bucket bucket = buckets.computeIfAbsent(ip, k -&gt;
                Bucket.builder().addLimit(
                    Bandwidth.classic(capacity, Refill.greedy(capacity, period))
                ).build());

            if (bucket.tryConsume(1)) return next.handle(request);

            return ServerResponse.status(HttpStatus.TOO_MANY_REQUESTS)
                .bodyValue(Map.of("error", "요청이 너무 많습니다."));
        };
    }
}</code></pre>
<h3 id="1056">10.5.6 버킷 캐시 메모리 관리</h3>
<p><code>ConcurrentHashMap</code>에 IP별 버킷이 무한히 쌓이면 메모리 누수가 발생한다. Caffeine 캐시를 사용하면 자동 만료를 쉽게 구현할 수 있다.</p>
<pre class="highlight"><code class="language-kotlin">dependencies {
    implementation("com.github.ben-manes.caffeine:caffeine:3.1.8")
}</code></pre>
<pre class="highlight"><code class="language-java">private final Cache&lt;String, Bucket&gt; bucketCache = Caffeine.newBuilder()
    .maximumSize(100_000)
    .expireAfterAccess(Duration.ofMinutes(10))
    .build();

// 사용: bucketCache.get(clientIp, this::createBucket)</code></pre>
<hr>
<h2 id="106">10.6 정리</h2>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 기술</th>
<th>적용 범위</th>
</tr>
</thead>
<tbody>
<tr>
<td>WebFilter</td>
<td><code>WebFilter</code> 인터페이스, <code>@Order</code></td>
<td>모든 요청 (글로벌)</td>
</tr>
<tr>
<td>HandlerFilterFunction</td>
<td><code>RouterFunction.filter()</code></td>
<td>함수형 엔드포인트 (선택적)</td>
</tr>
<tr>
<td>요청/응답 로깅</td>
<td><code>ServerHttpResponseDecorator</code>, Reactor Context</td>
<td>전역 로깅, 추적 ID</td>
</tr>
<tr>
<td>CORS</td>
<td><code>WebFluxConfigurer</code>, <code>@CrossOrigin</code>, <code>CorsWebFilter</code></td>
<td>API 전체 또는 개별 엔드포인트</td>
</tr>
<tr>
<td>속도 제한</td>
<td>Bucket4j, 토큰 버킷 알고리즘</td>
<td>IP별, 사용자별, 엔드포인트별</td>
</tr>
</tbody>
</table>
<p><strong>설계 원칙</strong>:
- <strong>글로벌 관심사</strong>(로깅, 추적 ID, CORS)에는 <code>WebFilter</code>를 사용한다.
- <strong>특정 API 그룹에만 적용할 로직</strong>(인증, 인가, 속도 제한)에는 <code>HandlerFilterFunction</code>을 사용한다.
- 필터 순서(<code>@Order</code>)는 명시적으로 관리하여 의도하지 않은 동작을 방지한다.
- 응답 바디 로깅처럼 성능에 영향을 주는 필터는 조건부로 활성화한다.</p>
<p>다음 Chapter 11에서는 <strong>Spring Security WebFlux</strong>를 활용하여 본격적인 인증과 인가를 구현한다. 이번 장에서 직접 구현한 인증 필터가 Spring Security의 <code>SecurityWebFilterChain</code>으로 어떻게 대체되고 확장되는지 비교해 볼 것이다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>