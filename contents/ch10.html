<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 10. WebFlux 필터와 인터셉터 | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="ch09.html">&larr; Chapter 9. 데이터 검증과 예외 처리</a>
    <a href="../index.html">목차</a>
    <a href="ch11.html">Chapter 11. 리액티브 보안 &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-10-webflux">Chapter 10. WebFlux 필터와 인터셉터</h1>
<p>지난 장에서 데이터 검증과 예외 처리를 다루었으니, 이제 요청과 응답 양쪽에 걸친 <strong>횡단 관심사(cross-cutting concerns)</strong>를 효율적으로 처리할 차례다. Spring MVC 개발자라면 <code>Filter</code>와 <code>HandlerInterceptor</code>에 익숙할 텐데, WebFlux에서는 <code>WebFilter</code>와 <code>HandlerFilterFunction</code>이라는 리액티브 방식의 도구를 제공한다. 이 장에서는 이 두 가지를 구현하는 방법부터 시작해서, 로깅, CORS, 속도 제한 같은 실무에서 정말 자주 마주치는 패턴들까지 차근차근 살펴보겠다.</p>
<hr>
<h2 id="101-webfilter">10.1 WebFilter 구현</h2>
<h3 id="1011-webfilter">10.1.1 WebFilter 인터페이스 이해</h3>
<p><code>WebFilter</code>는 Spring WebFlux의 핵심 확장점으로, 모든 HTTP 요청을 가로챌 수 있는 게이트웨이 역할을 한다. 어노테이션 기반 컨트롤러든 함수형 엔드포인트든 동일하게 적용되기 때문에 매우 강력하다.</p>
<pre class="highlight"><code class="language-java">public interface WebFilter {
    Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain);
}</code></pre>
<table>
<thead>
<tr>
<th>파라미터</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ServerWebExchange</code></td>
<td>HTTP 요청(<code>ServerHttpRequest</code>)과 응답(<code>ServerHttpResponse</code>)을 모두 담고 있는 컨텍스트 객체</td>
</tr>
<tr>
<td><code>WebFilterChain</code></td>
<td>다음 필터 또는 핸들러로 요청을 전달하는 체인</td>
</tr>
</tbody>
</table>
<p>동작 방식은 <strong>필터 체인</strong> 패턴을 따른다. 각 필터가 <code>chain.filter(exchange)</code>를 호출하면 다음 필터로 요청이 전달되고, 그 반환값인 <code>Mono&lt;Void&gt;</code>에 리액티브 연산자를 붙여서 응답 처리를 할 수 있다.</p>
<pre class="highlight"><code>[클라이언트] → [WebFilter 1] → [WebFilter 2] → ... → [핸들러]
                                                         ↓
[클라이언트] ← [WebFilter 1] ← [WebFilter 2] ← ... ← [응답]</code></pre>
<h3 id="1012">10.1.2 요청 전후 처리 필터</h3>
<p>가장 기본적인 패턴부터 보자. <code>@Component</code>로 등록하면 스프링이 알아서 필터 체인에 추가해주는데, <code>chain.filter()</code> 호출 전후에 코드를 끼워 넣으면 요청과 응답을 동시에 처리할 수 있다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Component
public class RequestTimingFilter implements WebFilter {

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        // === 전처리 ===
        long startTime = System.currentTimeMillis();
        String method = exchange.getRequest().getMethod().name();
        String path = exchange.getRequest().getURI().getPath();

        log.info("&gt;&gt;&gt; 요청 시작: {} {}", method, path);

        return chain.filter(exchange)
            // === 후처리 ===
            .doFinally(signalType -&gt; {
                long duration = System.currentTimeMillis() - startTime;
                log.info("&lt;&lt;&lt; 요청 완료: {} {} - {}ms [{}]",
                    method, path, duration, signalType);
            });
    }
}</code></pre>
<blockquote>
<p><strong>주의</strong>: <code>then(Mono.fromRunnable(...))</code>은 정상 완료 시에만 실행된다. 에러를 포함한 모든 경우를 처리하려면 위 예시처럼 <code>doFinally</code>를 사용해야 한다.</p>
</blockquote>
<h3 id="1013-order">10.1.3 @Order로 필터 실행 순서 지정</h3>
<p>웹 애플리케이션이 복잡해지면 보안 검사, 로깅, 메트릭 수집 등 여러 필터를 체인 형태로 등록하게 되는데, 이때 실행 순서가 중요하다. <code>@Order</code> 어노테이션으로 간단히 제어할 수 있으며, 숫자가 작을수록 먼저 실행된다.</p>
<pre class="highlight"><code class="language-java">@Component
@Order(1)
public class SecurityCheckFilter implements WebFilter { /* 보안 검사 */ }

@Component
@Order(2)
public class LoggingFilter implements WebFilter { /* 로깅 */ }

@Component
@Order(3)
public class MetricsFilter implements WebFilter { /* 메트릭 수집 */ }</code></pre>
<p><code>Ordered</code> 인터페이스를 구현하는 방법도 있다.</p>
<pre class="highlight"><code class="language-java">@Component
public class HighPriorityFilter implements WebFilter, Ordered {
    @Override
    public int getOrder() { return Ordered.HIGHEST_PRECEDENCE; }

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        return chain.filter(exchange);
    }
}</code></pre>
<h3 id="1014">10.1.4 조건부 필터 적용과 요청 차단</h3>
<p>실무에서는 모든 요청에 필터를 적용할 필요는 없다. 특정 경로(예: <code>/api/**</code>)에만 필터를 작동시키려면 내부에서 경로를 확인하고 조건부로 동작하면 된다. 필자의 경험상, API 인증 같은 필터는 공개 엔드포인트를 거르는 것이 성능에 도움이 된다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Component
@Order(1)
public class ApiKeyFilter implements WebFilter {

    private static final String API_KEY_HEADER = "X-API-Key";
    private static final String VALID_API_KEY = "my-secret-api-key";

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        String path = exchange.getRequest().getURI().getPath();

        // /api/** 경로에만 필터 적용
        if (!path.startsWith("/api/")) {
            return chain.filter(exchange);
        }

        String apiKey = exchange.getRequest().getHeaders().getFirst(API_KEY_HEADER);
        if (VALID_API_KEY.equals(apiKey)) {
            return chain.filter(exchange);
        }

        // 요청 차단: chain.filter()를 호출하지 않고 응답 완료
        log.warn("유효하지 않은 API Key 요청: {}", path);
        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
        return exchange.getResponse().setComplete();
    }
}</code></pre>
<h3 id="1015-attribute">10.1.5 요청 속성(Attribute) 전달</h3>
<p>필터 단계에서 수집한 정보(예: 요청 ID, 사용자 정보)를 컨트롤러까지 전달해야 할 때가 있다. <code>ServerWebExchange</code>의 속성 맵을 활용하면 간단하게 해결된다.</p>
<pre class="highlight"><code class="language-java">@Component
@Order(0)
public class RequestContextFilter implements WebFilter {
    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        String requestId = UUID.randomUUID().toString().substring(0, 8);
        exchange.getAttributes().put("requestId", requestId);
        exchange.getResponse().getHeaders().add("X-Request-Id", requestId);
        return chain.filter(exchange);
    }
}

// 컨트롤러에서 속성 사용
@GetMapping("/api/products")
public Mono&lt;ResponseEntity&lt;List&lt;Product&gt;&gt;&gt; getProducts(ServerWebExchange exchange) {
    String requestId = exchange.getAttribute("requestId");
    log.info("[{}] 상품 목록 조회 요청", requestId);
    // ...
}</code></pre>
<hr>
<h2 id="102-handlerfilterfunction">10.2 HandlerFilterFunction 활용</h2>
<h3 id="1021-webfilter-handlerfilterfunction">10.2.1 WebFilter와 HandlerFilterFunction 비교</h3>
<p>WebFilter는 글로벌하게 모든 요청을 잡지만, <code>HandlerFilterFunction</code>은 다르다. 함수형 엔드포인트(RouterFunction) 기반 API에 특화된 필터로, 더 세밀한 제어가 가능하다.</p>
<pre class="highlight"><code class="language-java">@FunctionalInterface
public interface HandlerFilterFunction&lt;T extends ServerResponse, R extends ServerResponse&gt; {
    Mono&lt;R&gt; filter(ServerRequest request, HandlerFunction&lt;T&gt; next);
}</code></pre>
<table>
<thead>
<tr>
<th>항목</th>
<th>WebFilter</th>
<th>HandlerFilterFunction</th>
</tr>
</thead>
<tbody>
<tr>
<td>적용 대상</td>
<td>모든 요청 (어노테이션 + 함수형)</td>
<td>함수형 엔드포인트만</td>
</tr>
<tr>
<td>적용 범위</td>
<td>글로벌</td>
<td>특정 RouterFunction</td>
</tr>
<tr>
<td>접근 객체</td>
<td><code>ServerWebExchange</code></td>
<td><code>ServerRequest</code> / <code>ServerResponse</code></td>
</tr>
<tr>
<td>등록 방법</td>
<td><code>@Component</code> 자동 등록</td>
<td><code>RouterFunction.filter()</code></td>
</tr>
</tbody>
</table>
<h3 id="1022">10.2.2 기본 사용법</h3>
<p>가장 간단한 형태부터 보자. <code>RouterFunction</code>의 <code>filter()</code> 메서드에 람다식으로 필터 로직을 끼워 넣으면 된다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class ProductRouter {
    @Bean
    public RouterFunction&lt;ServerResponse&gt; productRoutes(ProductHandler handler) {
        return nest(path("/api/products"),
            route(GET(""), handler::getAll)
            .andRoute(POST(""), handler::create)
            .andRoute(PUT("/{id}"), handler::update)
            .andRoute(DELETE("/{id}"), handler::delete)
        )
        .filter((request, next) -&gt; {
            log.info("Product API 요청: {} {}", request.method(), request.path());
            return next.handle(request);
        });
    }
}</code></pre>
<h3 id="1023">10.2.3 인증 필터 구현</h3>
<p>이제 실제로 쓸 만한 예제를 봐보자. JWT 토큰 검증 같은 인증 필터를 <code>HandlerFilterFunction</code>으로 구현하는 패턴이다.</p>
<pre class="highlight"><code class="language-java">public class AuthFilterFunction
        implements HandlerFilterFunction&lt;ServerResponse, ServerResponse&gt; {

    private final TokenValidator tokenValidator;

    public AuthFilterFunction(TokenValidator tokenValidator) {
        this.tokenValidator = tokenValidator;
    }

    @Override
    public Mono&lt;ServerResponse&gt; filter(ServerRequest request,
                                       HandlerFunction&lt;ServerResponse&gt; next) {
        String authHeader = request.headers().firstHeader("Authorization");

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            return ServerResponse.status(HttpStatus.UNAUTHORIZED)
                .bodyValue(Map.of("error", "Authorization 헤더가 필요합니다."));
        }

        String token = authHeader.substring(7);

        return tokenValidator.validate(token)
            .flatMap(userId -&gt; {
                ServerRequest modifiedRequest = ServerRequest.from(request)
                    .attribute("userId", userId)
                    .build();
                return next.handle(modifiedRequest);
            })
            .onErrorResume(InvalidTokenException.class, e -&gt;
                ServerResponse.status(HttpStatus.UNAUTHORIZED)
                    .bodyValue(Map.of("error", e.getMessage()))
            );
    }
}</code></pre>
<p>핵심은 라우터 정의 단계에서 공개 API와 보호 API를 명확히 분리하는 것이다. 그러면 필터를 선택적으로 적용할 수 있어서 불필요한 오버헤드를 피할 수 있다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class AppRouter {

    private final TokenValidator tokenValidator;

    public AppRouter(TokenValidator tokenValidator) {
        this.tokenValidator = tokenValidator;
    }

    @Bean
    public RouterFunction&lt;ServerResponse&gt; routes(
            ProductHandler productHandler, AuthHandler authHandler) {

        // 인증 불필요: 공개 API
        RouterFunction&lt;ServerResponse&gt; publicRoutes = route(
            POST("/api/auth/login"), authHandler::login
        ).andRoute(
            POST("/api/auth/register"), authHandler::register
        );

        // 인증 필요: 보호된 API
        RouterFunction&lt;ServerResponse&gt; protectedRoutes = nest(path("/api/products"),
            route(GET(""), productHandler::getAll)
            .andRoute(POST(""), productHandler::create)
            .andRoute(DELETE("/{id}"), productHandler::delete)
        ).filter(new AuthFilterFunction(tokenValidator));

        return publicRoutes.and(protectedRoutes);
    }
}</code></pre>
<h3 id="1024">10.2.4 역할 기반 접근 제어 필터</h3>
<p>인증 필터만으로 부족하면 역할(Role) 기반 인가를 추가하면 된다. 필터를 여러 개 체이닝하면 인증(Authentication) 이후 인가(Authorization)가 순차적으로 실행되므로, 보안을 이중으로 확보할 수 있다.</p>
<pre class="highlight"><code class="language-java">public class RoleFilterFunction
        implements HandlerFilterFunction&lt;ServerResponse, ServerResponse&gt; {

    private final Set&lt;String&gt; allowedRoles;

    public RoleFilterFunction(String... roles) {
        this.allowedRoles = Set.of(roles);
    }

    @Override
    public Mono&lt;ServerResponse&gt; filter(ServerRequest request,
                                       HandlerFunction&lt;ServerResponse&gt; next) {
        String userRole = request.attribute("userRole")
            .map(Object::toString).orElse("");

        if (allowedRoles.contains(userRole)) {
            return next.handle(request);
        }
        return ServerResponse.status(HttpStatus.FORBIDDEN)
            .bodyValue(Map.of("error", "접근 권한이 없습니다."));
    }
}

// 관리자 전용 API에 인증 + 역할 필터 체이닝
RouterFunction&lt;ServerResponse&gt; adminRoutes = nest(path("/api/admin"),
    route(GET("/users"), adminHandler::getAllUsers)
    .andRoute(DELETE("/users/{id}"), adminHandler::deleteUser)
)
.filter(new AuthFilterFunction(tokenValidator))
.filter(new RoleFilterFunction("ADMIN"));</code></pre>
<hr>
<h2 id="103">10.3 요청/응답 로깅</h2>
<h3 id="1031">10.3.1 요청 로깅 필터</h3>
<p>프로덕션 환경에서는 요청의 생명주기를 추적해야 한다. 요청이 들어오는 순간부터 응답을 내보낼 때까지의 모든 정보를 체계적으로 기록해 놓으면, 나중에 문제 분석이 훨씬 수월하다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
public class RequestLoggingFilter implements WebFilter {

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String requestId = UUID.randomUUID().toString().substring(0, 8);
        String method = request.getMethod().name();
        String path = request.getURI().getPath();
        String clientIp = extractClientIp(request);

        log.info("[{}] &gt;&gt;&gt; {} {} ip={}", requestId, method, path, clientIp);

        long startTime = System.nanoTime();
        exchange.getResponse().getHeaders().add("X-Request-Id", requestId);
        exchange.getAttributes().put("requestId", requestId);

        return chain.filter(exchange)
            .doFinally(signalType -&gt; {
                long durationMs = (System.nanoTime() - startTime) / 1_000_000;
                HttpStatusCode status = exchange.getResponse().getStatusCode();
                log.info("[{}] &lt;&lt;&lt; {} {} -&gt; {} ({}ms)",
                    requestId, method, path, status, durationMs);
            });
    }

    private String extractClientIp(ServerHttpRequest request) {
        String xff = request.getHeaders().getFirst("X-Forwarded-For");
        if (xff != null &amp;&amp; !xff.isEmpty()) {
            return xff.split(",")[0].trim();
        }
        return Optional.ofNullable(request.getRemoteAddress())
            .map(addr -&gt; addr.getAddress().getHostAddress())
            .orElse("unknown");
    }
}</code></pre>
<h3 id="1032-serverhttpresponsedecorator">10.3.2 응답 바디 로깅 (ServerHttpResponseDecorator)</h3>
<p>요청만 기록해서는 부족할 때가 많다. 응답 내용도 알고 싶다면? 문제는 응답 바디가 스트림 형태라서 직접 읽을 수 없다는 점이다. <code>ServerHttpResponseDecorator</code>로 감싸면 쓰기 시점에 바이트를 가로챌 수 있다. 필자의 경험상, 디버깅할 때 이 기법이 정말 유용하다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Component
@Order(Ordered.HIGHEST_PRECEDENCE + 1)
public class ResponseBodyLoggingFilter implements WebFilter {

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        if (!log.isDebugEnabled()) return chain.filter(exchange);

        String requestId = exchange.getAttribute("requestId");
        ServerHttpResponse original = exchange.getResponse();

        ServerHttpResponseDecorator decorated = new ServerHttpResponseDecorator(original) {
            @Override
            public Mono&lt;Void&gt; writeWith(Publisher&lt;? extends DataBuffer&gt; body) {
                if (body instanceof Flux&lt;? extends DataBuffer&gt; fluxBody) {
                    return super.writeWith(fluxBody.buffer().map(dataBuffers -&gt; {
                        DataBuffer joined = original.bufferFactory().join(dataBuffers);
                        byte[] content = new byte[joined.readableByteCount()];
                        joined.read(content);
                        DataBufferUtils.release(joined);
                        log.debug("[{}] 응답 바디: {}", requestId,
                            new String(content, StandardCharsets.UTF_8));
                        return original.bufferFactory().wrap(content);
                    }));
                }
                return super.writeWith(body);
            }
        };
        return chain.filter(exchange.mutate().response(decorated).build());
    }
}</code></pre>
<blockquote>
<p><strong>주의</strong>: 응답 바디 로깅은 메모리와 성능에 영향을 미친다. 반드시 디버그 레벨에서만 활성화하고, 대용량 응답에서는 크기 제한 로직을 추가해야 한다.</p>
</blockquote>
<h3 id="1033-id-reactor-context">10.3.3 요청 추적 ID와 Reactor Context</h3>
<p>여기서 한 가지 까다로운 문제가 발생한다. 리액티브 애플리케이션에서는 스레드가 계속 바뀌기 때문에, 기존의 ThreadLocal 기반 <code>MDC(Mapped Diagnostic Context)</code>가 제대로 작동하지 않는다는 것이다. 대신 Reactor의 <strong>Context</strong>를 활용하면 요청 추적 ID를 전체 리액티브 체인에 걸쳐 전파할 수 있다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
public class TraceIdFilter implements WebFilter {

    private static final String TRACE_ID_KEY = "traceId";

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        String traceId = Optional.ofNullable(
                exchange.getRequest().getHeaders().getFirst("X-Trace-Id")
            ).orElse(UUID.randomUUID().toString());

        exchange.getResponse().getHeaders().add("X-Trace-Id", traceId);

        return chain.filter(exchange)
            .contextWrite(Context.of(TRACE_ID_KEY, traceId));
    }
}</code></pre>
<p>서비스 계층에서 Context의 추적 ID를 활용한다.</p>
<pre class="highlight"><code class="language-java">@Service
@Slf4j
public class ProductService {
    public Mono&lt;Product&gt; findById(String id) {
        return Mono.deferContextual(ctx -&gt; {
            String traceId = ctx.getOrDefault("traceId", "N/A");
            log.info("[{}] 상품 조회: id={}", traceId, id);
            return productRepository.findById(id);
        });
    }
}</code></pre>
<p>Spring Boot 3.x에서는 Micrometer <strong>Context Propagation</strong>을 사용하면 MDC 자동 전파를 구성할 수 있다.</p>
<pre class="highlight"><code class="language-yaml">spring:
  reactor:
    context-propagation: auto</code></pre>
<hr>
<h2 id="104-cors">10.4 CORS 설정</h2>
<h3 id="1041-cors">10.4.1 CORS 개요</h3>
<p>모던 웹 개발에서는 프론트엔드와 백엔드가 분리되어 있는 경우가 대부분이다. 브라우저의 보안 정책인 <strong>동일 출처 정책(Same-Origin Policy)</strong> 때문에, 다른 도메인(또는 포트)의 서버를 호출할 때 특별한 허가가 필요하다. 흔한 예로, 프런트엔드가 <code>http://localhost:3000</code>에서 백엔드 <code>http://localhost:8080</code>을 호출하면 CORS 에러가 발생한다. 서버가 이를 허용한다는 신호를 보내려면 응답에 적절한 헤더를 포함해야 한다.</p>
<table>
<thead>
<tr>
<th>CORS 헤더</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Access-Control-Allow-Origin</code></td>
<td>허용할 출처</td>
</tr>
<tr>
<td><code>Access-Control-Allow-Methods</code></td>
<td>허용할 HTTP 메서드</td>
</tr>
<tr>
<td><code>Access-Control-Allow-Headers</code></td>
<td>허용할 요청 헤더</td>
</tr>
<tr>
<td><code>Access-Control-Allow-Credentials</code></td>
<td>쿠키/인증 정보 포함 허용 여부</td>
</tr>
<tr>
<td><code>Access-Control-Max-Age</code></td>
<td>Preflight 요청 캐시 시간(초)</td>
</tr>
</tbody>
</table>
<h3 id="1042-webfluxconfigurer">10.4.2 WebFluxConfigurer를 이용한 글로벌 설정</h3>
<p>CORS를 설정하는 방법은 여러 가지인데, 가장 깔끔한 것은 <code>WebFluxConfigurer</code> 인터페이스를 구현하는 방식이다. 모든 엔드포인트에 일괄 적용되므로 관리가 편하다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class CorsConfig implements WebFluxConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
            .allowedOrigins("http://localhost:3000", "https://myapp.example.com")
            .allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS")
            .allowedHeaders("*")
            .exposedHeaders("X-Request-Id", "X-Trace-Id")
            .allowCredentials(true)
            .maxAge(3600);
    }
}</code></pre>
<h3 id="1043-crossorigin">10.4.3 @CrossOrigin 어노테이션</h3>
<p>전체 설정 대신 특정 컨트롤러나 메서드에만 CORS를 적용하고 싶으면 <code>@CrossOrigin</code>을 사용하면 된다. 클래스 레벨과 메서드 레벨에서 동시에 설정하면 둘이 <strong>병합</strong>되니 주의하자.</p>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/products")
@CrossOrigin(origins = "http://localhost:3000", maxAge = 3600)
public class ProductController {

    @CrossOrigin(origins = "https://partner.example.com")
    @GetMapping("/{id}")
    public Mono&lt;Product&gt; getById(@PathVariable String id) {
        return productService.findById(id);
    }
}</code></pre>
<h3 id="1044-corswebfilter">10.4.4 CorsWebFilter (프로그래밍 방식)</h3>
<p>함수형 엔드포인트를 사용하면 <code>@CrossOrigin</code> 어노테이션을 붙일 수 없다는 게 단점이다. 이 경우 <code>CorsWebFilter</code>를 빈으로 등록해서 프로그래매틱하게 설정하면, 어노테이션 기반과 함수형 모두 커버할 수 있다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class CorsFilterConfig {

    @Bean
    public CorsWebFilter corsWebFilter() {
        CorsConfiguration config = new CorsConfiguration();
        config.addAllowedOrigin("http://localhost:3000");
        config.addAllowedOrigin("https://myapp.example.com");
        config.addAllowedMethod("*");
        config.addAllowedHeader("*");
        config.addExposedHeader("X-Request-Id");
        config.setAllowCredentials(true);
        config.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/api/**", config);
        return new CorsWebFilter(source);
    }
}</code></pre>
<h3 id="1045-cors">10.4.5 환경별 CORS 설정</h3>
<p>실제로는 개발 환경에서는 어떤 출처든 허용하고, 프로덕션에서는 특정 도메인만 허용하는 식으로 환경별로 다르게 설정해야 한다. <code>application.yml</code> 프로파일을 활용하면 간단히 해결된다.</p>
<pre class="highlight"><code class="language-yaml"># application.yml             → app.cors.allowed-origins: "http://localhost:3000"
# application-prod.yml        → app.cors.allowed-origins: "https://myapp.example.com"</code></pre>
<pre class="highlight"><code class="language-java">@Configuration
public class CorsConfig implements WebFluxConfigurer {

    @Value("${app.cors.allowed-origins}")
    private String[] allowedOrigins;

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
            .allowedOrigins(allowedOrigins)
            .allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH")
            .allowedHeaders("*")
            .allowCredentials(true)
            .maxAge(3600);
    }
}</code></pre>
<hr>
<h2 id="105-rate-limiting">10.5 요청 속도 제한(Rate Limiting)</h2>
<h3 id="1051">10.5.1 토큰 버킷 알고리즘</h3>
<p>만약 API를 공개한다면, 악의적인 사용자나 실수로 인한 과다 요청에 대비해야 한다. 이때 속도 제한(Rate Limiting)은 필수 기능이다. 여러 알고리즘이 있지만, 가장 널리 사용되는 건 토큰 버킷 알고리즘이다.</p>
<ol>
<li><strong>버킷</strong>에 토큰이 일정 속도로 채워진다.</li>
<li>요청이 들어오면 버킷에서 토큰 1개를 소비한다.</li>
<li>토큰이 없으면 요청을 거부한다(429 Too Many Requests).</li>
<li>버킷 크기가 고정되어 순간적인 버스트(burst)를 일정 수준까지 허용한다.</li>
</ol>
<pre class="highlight"><code>[토큰 생성기] ---(초당 10개)---&gt; [버킷 (최대 20개)]
                                       ↓
                                 요청 -&gt; 토큰 1개 소비
                                 토큰 부족 -&gt; 429 응답</code></pre>
<h3 id="1052-bucket4j">10.5.2 Bucket4j 의존성</h3>
<p>알고리즘을 직접 구현할 수도 있지만, <strong>Bucket4j</strong> 라이브러리를 사용하면 편하다. 토큰 버킷 알고리즘을 스레드 안전하게 구현했고, 성능도 검증되었다. <code>build.gradle.kts</code>에 의존성을 추가하자: <code>implementation("com.bucket4j:bucket4j-core:8.10.1")</code></p>
<h3 id="1053-ip">10.5.3 IP 기반 속도 제한 필터</h3>
<p>가장 기본적인 구현은 클라이언트 IP를 기준으로 각각 독립적인 버킷을 유지하는 것이다. 필자의 경험상, 공개 API에는 이 정도면 충분하다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Component
public class RateLimitFilter implements WebFilter {

    private final Map&lt;String, Bucket&gt; bucketCache = new ConcurrentHashMap&lt;&gt;();

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        String path = exchange.getRequest().getURI().getPath();
        if (!path.startsWith("/api/")) {
            return chain.filter(exchange);
        }

        String clientIp = extractClientIp(exchange);
        Bucket bucket = bucketCache.computeIfAbsent(clientIp, this::createBucket);
        ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);

        if (probe.isConsumed()) {
            exchange.getResponse().getHeaders()
                .add("X-RateLimit-Remaining",
                    String.valueOf(probe.getRemainingTokens()));
            return chain.filter(exchange);
        }

        // 속도 제한 초과 -&gt; 429 응답
        long waitSeconds = probe.getNanosToWaitForRefill() / 1_000_000_000;
        log.warn("속도 제한 초과: IP={}, 재시도까지 {}초", clientIp, waitSeconds);

        exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
        exchange.getResponse().getHeaders().setContentType(MediaType.APPLICATION_JSON);
        exchange.getResponse().getHeaders().add("Retry-After", String.valueOf(waitSeconds));

        String errorBody = """
            {
              "error": "TOO_MANY_REQUESTS",
              "message": "요청 속도 제한을 초과했습니다.",
              "retryAfterSeconds": %d
            }
            """.formatted(waitSeconds);

        return exchange.getResponse().writeWith(
            Mono.just(exchange.getResponse().bufferFactory()
                .wrap(errorBody.getBytes()))
        );
    }

    private Bucket createBucket(String key) {
        Bandwidth limit = Bandwidth.builder()
            .capacity(10)                                      // 버킷 용량 (버스트)
            .refillGreedy(60, Duration.ofMinutes(1))           // 분당 60개 보충
            .build();
        return Bucket.builder().addLimit(limit).build();
    }

    private String extractClientIp(ServerWebExchange exchange) {
        String xff = exchange.getRequest().getHeaders().getFirst("X-Forwarded-For");
        if (xff != null &amp;&amp; !xff.isEmpty()) return xff.split(",")[0].trim();
        return Optional.ofNullable(exchange.getRequest().getRemoteAddress())
            .map(addr -&gt; addr.getAddress().getHostAddress()).orElse("unknown");
    }
}</code></pre>
<h3 id="1054">10.5.4 사용자 등급별 차등 속도 제한</h3>
<p>IP 기반만으로는 부족하면, 인증된 사용자별로 다른 할당량을 줄 수 있다. 무료 사용자는 분당 20건, 프리미엄은 1000건 같은 식으로 계층화할 수 있다. <code>Plan</code> enum으로 정책을 정의하고, 사용자 ID와 등급을 조합한 키로 버킷을 관리하는 게 핵심이다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Component
@Order(10)  // 인증 필터 이후에 실행
public class UserRateLimitFilter implements WebFilter {

    private final Map&lt;String, Bucket&gt; bucketCache = new ConcurrentHashMap&lt;&gt;();

    enum Plan {
        FREE(20, Duration.ofMinutes(1)),       // 무료: 분당 20건
        BASIC(100, Duration.ofMinutes(1)),      // 기본: 분당 100건
        PREMIUM(1000, Duration.ofMinutes(1));   // 프리미엄: 분당 1000건

        final int capacity;
        final Duration period;
        Plan(int capacity, Duration period) {
            this.capacity = capacity;
            this.period = period;
        }
    }

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        String userId = exchange.getAttribute("userId");
        if (userId == null || !exchange.getRequest().getURI()
                .getPath().startsWith("/api/")) {
            return chain.filter(exchange);
        }

        String userPlan = exchange.getAttribute("userPlan");
        Plan plan = resolvePlan(userPlan);
        Bucket bucket = bucketCache.computeIfAbsent(
            userId + ":" + plan.name(), k -&gt; createBucket(plan));

        ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);

        // 남은 호출 횟수를 헤더로 전달
        exchange.getResponse().getHeaders()
            .add("X-RateLimit-Limit", String.valueOf(plan.capacity));
        exchange.getResponse().getHeaders()
            .add("X-RateLimit-Remaining", String.valueOf(probe.getRemainingTokens()));

        if (probe.isConsumed()) return chain.filter(exchange);

        // 429 응답 (IP 기반 필터와 동일한 패턴)
        exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
        String body = """
            {"error":"TOO_MANY_REQUESTS","plan":"%s","limit":%d}
            """.formatted(plan.name(), plan.capacity);
        return exchange.getResponse().writeWith(
            Mono.just(exchange.getResponse().bufferFactory().wrap(body.getBytes())));
    }

    private Plan resolvePlan(String planStr) {
        try { return Plan.valueOf(planStr.toUpperCase()); }
        catch (Exception e) { return Plan.FREE; }
    }

    private Bucket createBucket(Plan plan) {
        return Bucket.builder().addLimit(Bandwidth.builder()
            .capacity(plan.capacity).refillGreedy(plan.capacity, plan.period)
            .build()).build();
    }
}</code></pre>
<h3 id="1055">10.5.5 엔드포인트별 차등 속도 제한</h3>
<p>로그인 API나 비밀번호 재설정 같은 민감한 엔드포인트는 각별한 주의가 필요하다. 이런 곳에는 <code>HandlerFilterFunction</code>으로 훨씬 더 엄격한 제한을 개별 적용할 수 있다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class RateLimitConfig {

    @Bean
    public RouterFunction&lt;ServerResponse&gt; rateLimitedAuthRoutes(AuthHandler handler) {
        RouterFunction&lt;ServerResponse&gt; loginRoute = route(POST("/api/auth/login"), handler::login)
            .filter(createRateLimitFilter(5, Duration.ofMinutes(1)));   // 분당 5회
        RouterFunction&lt;ServerResponse&gt; registerRoute = route(POST("/api/auth/register"), handler::register)
            .filter(createRateLimitFilter(3, Duration.ofHours(1)));    // 시간당 3회
        return loginRoute.and(registerRoute);
    }

    private HandlerFilterFunction&lt;ServerResponse, ServerResponse&gt;
            createRateLimitFilter(int capacity, Duration period) {
        Map&lt;String, Bucket&gt; buckets = new ConcurrentHashMap&lt;&gt;();
        return (request, next) -&gt; {
            String ip = request.remoteAddress()
                .map(a -&gt; a.getAddress().getHostAddress()).orElse("unknown");
            Bucket bucket = buckets.computeIfAbsent(ip, k -&gt;
                Bucket.builder().addLimit(
                    Bandwidth.builder().capacity(capacity).refillGreedy(capacity, period).build()
                ).build());

            if (bucket.tryConsume(1)) return next.handle(request);

            return ServerResponse.status(HttpStatus.TOO_MANY_REQUESTS)
                .bodyValue(Map.of("error", "요청이 너무 많습니다."));
        };
    }
}</code></pre>
<h3 id="1056">10.5.6 버킷 캐시 메모리 관리</h3>
<p>여기서 놓치기 쉬운 점이 있다. <code>ConcurrentHashMap</code>에 IP별 버킷이 계속 쌓이면 언젠가는 메모리를 다 써버린다. 실제 운영 환경에서 이 문제를 겪었던 개발자는 Caffeine 캐시로 자동 만료를 구현하는 방법을 안다.</p>
<pre class="highlight"><code class="language-kotlin">dependencies {
    implementation("com.github.ben-manes.caffeine:caffeine:3.1.8")
}</code></pre>
<pre class="highlight"><code class="language-java">private final Cache&lt;String, Bucket&gt; bucketCache = Caffeine.newBuilder()
    .maximumSize(100_000)
    .expireAfterAccess(Duration.ofMinutes(10))
    .build();

// 사용: bucketCache.get(clientIp, this::createBucket)</code></pre>
<hr>
<h2 id="106">10.6 정리</h2>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 기술</th>
<th>적용 범위</th>
</tr>
</thead>
<tbody>
<tr>
<td>WebFilter</td>
<td><code>WebFilter</code> 인터페이스, <code>@Order</code></td>
<td>모든 요청 (글로벌)</td>
</tr>
<tr>
<td>HandlerFilterFunction</td>
<td><code>RouterFunction.filter()</code></td>
<td>함수형 엔드포인트 (선택적)</td>
</tr>
<tr>
<td>요청/응답 로깅</td>
<td><code>ServerHttpResponseDecorator</code>, Reactor Context</td>
<td>전역 로깅, 추적 ID</td>
</tr>
<tr>
<td>CORS</td>
<td><code>WebFluxConfigurer</code>, <code>@CrossOrigin</code>, <code>CorsWebFilter</code></td>
<td>API 전체 또는 개별 엔드포인트</td>
</tr>
<tr>
<td>속도 제한</td>
<td>Bucket4j, 토큰 버킷 알고리즘</td>
<td>IP별, 사용자별, 엔드포인트별</td>
</tr>
</tbody>
</table>
<p><strong>실무에서 자주 적용되는 설계 원칙</strong>은 다음과 같다:
- <strong>글로벌 관심사</strong>(로깅, 추적 ID, CORS)는 <code>WebFilter</code>로 모든 곳에 적용한다.
- <strong>특정 API 그룹에만 필요한 로직</strong>(인증, 인가, 특정 엔드포인트의 속도 제한)은 <code>HandlerFilterFunction</code>으로 선택적으로 적용한다.
- 필터 실행 순서(<code>@Order</code>)는 반드시 명시적으로 설정해서 예기치 않은 동작을 미리 차단한다.
- 응답 바디 로깅처럼 오버헤드가 큰 필터는 디버그 모드에서만 켜거나, 트래픽이 많은 시간대에는 비활성화하는 식으로 조건부 활성화를 고려한다.</p>
<p>이제 필터를 통한 기초적인 횡단 관심사 처리를 익혔으니, 다음 Chapter 11에서는 <strong>Spring Security WebFlux</strong>로 한 단계 업그레이드된 인증과 인가 시스템을 만들어보자. 이번 장에서 직접 구현한 인증 필터가 Spring Security의 강력한 <code>SecurityWebFilterChain</code>으로 어떻게 진화하는지 보게 될 것이다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>