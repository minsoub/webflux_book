<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 13. WebSocket | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="ch12.html">&larr; Chapter 12. Server-Sent Events (SSE)</a>
    <a href="../index.html">목차</a>
    <a href="ch14.html">Chapter 14. WebClient &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-13-websocket">Chapter 13. WebSocket</h1>
<p>채팅, 게임, 실시간 대시보드 같은 애플리케이션들을 만들다 보면 HTTP의 요청-응답 모델만으로는 부족함을 느끼게 된다. 사용자가 메시지를 보낼 때까지 기다렸다가 응답하는 방식으로는, 서버가 즉시 클라이언트에게 데이터를 보낼 수 없기 때문이다. 이런 상황에서 WebSocket이 빛을 발한다. 한 번 연결을 수립하면 양쪽이 자유롭게 메시지를 주고받을 수 있고, Spring WebFlux는 리액티브 스트림 기반의 WebSocket 지원을 기본으로 제공한다.</p>
<p>이 장에서는 WebSocket이 어떻게 동작하는지 먼저 살펴보고, WebFlux에서 핸들러를 구현한 후 실제 채팅 애플리케이션을 만들어볼 것이다. 마지막으로 프로덕션 환경에 필요한 세션 관리 전략까지 다룰 예정이다.</p>
<hr>
<h2 id="131-websocket">13.1 WebSocket 프로토콜 이해</h2>
<h3 id="1311-websocket">13.1.1 WebSocket이란?</h3>
<p>WebSocket은 RFC 6455로 표준화된 프로토콜인데, 단순하게 말하면 TCP 연결 위에서 클라이언트와 서버가 <strong>전이중(Full-Duplex) 양방향 통신</strong>을 할 수 있게 해준다. HTTP는 클라이언트의 요청을 기다렸다가 응답하는 방식이지만, WebSocket은 연결이 한 번 수립되면 양쪽 모두 언제든 메시지를 보낼 수 있다. 이 차이가 실시간 애플리케이션 개발에서 정말 중요하다.</p>
<table>
<thead>
<tr>
<th>특징</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>양방향 통신</strong></td>
<td>클라이언트와 서버 모두 독립적으로 메시지를 전송할 수 있다</td>
</tr>
<tr>
<td><strong>지속 연결</strong></td>
<td>한 번 연결이 수립되면 명시적으로 종료할 때까지 유지된다</td>
</tr>
<tr>
<td><strong>낮은 오버헤드</strong></td>
<td>HTTP 헤더 없이 최소 2바이트의 프레임 헤더로 메시지를 교환한다</td>
</tr>
<tr>
<td><strong>실시간성</strong></td>
<td>폴링 없이 서버에서 즉시 클라이언트로 데이터를 전송할 수 있다</td>
</tr>
</tbody>
</table>
<h3 id="1312-http">13.1.2 HTTP 핸드셰이크</h3>
<p>흥미롭게도, WebSocket 연결은 일반 HTTP 요청으로 시작된다. 프로토콜을 업그레이드하는 과정을 거치는 것이다.</p>
<p><strong>클라이언트 요청:</strong></p>
<p><code>GET /ws/chat HTTP/1.1
Host: localhost:8080
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13</code></p>
<p><strong>서버 응답:</strong></p>
<p><code>HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</code></p>
<p>구체적으로는 이렇게 진행된다:</p>
<ol>
<li>클라이언트가 <code>Upgrade: websocket</code> 헤더를 포함한 HTTP GET 요청을 보낸다</li>
<li>서버는 <code>Sec-WebSocket-Key</code>에 매직 GUID(<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>)를 붙여서 SHA-1 해시를 만들고, 그 결과를 <code>Sec-WebSocket-Accept</code>에 담아 응답한다</li>
<li>서버가 <code>101 Switching Protocols</code>를 반환하면, TCP 연결은 살아있되 프로토콜만 WebSocket으로 바뀐다</li>
<li>이제부터 양쪽은 WebSocket 프레임 형식으로 메시지를 교환한다</li>
</ol>
<h3 id="1313">13.1.3 프레임 구조</h3>
<p>연결이 수립되면 이제 프레임(Frame) 단위로 데이터를 주고받는다. 각 프레임은 그 의도를 나타내는 Opcode를 가지고 있다.</p>
<table>
<thead>
<tr>
<th>Opcode</th>
<th>의미</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x1</code></td>
<td>텍스트 프레임 (UTF-8)</td>
</tr>
<tr>
<td><code>0x2</code></td>
<td>바이너리 프레임</td>
</tr>
<tr>
<td><code>0x8</code></td>
<td>연결 종료 (Close)</td>
</tr>
<tr>
<td><code>0x9</code></td>
<td>Ping</td>
</tr>
<tr>
<td><code>0xA</code></td>
<td>Pong</td>
</tr>
</tbody>
</table>
<p>실제로 개발할 때는 이런 저수준의 세부사항까지 신경 쓸 일은 거의 없다. 다만 알아두면 좋은 것은, 텍스트 프레임은 채팅 메시지 같은 문자열을 보낼 때, 바이너리 프레임은 이미지나 파일 같은 데이터를 보낼 때 사용된다는 점이다. 각 프레임은 내부적으로 마지막 프레임 여부, 페이로드 길이, 실제 데이터 등으로 구성된다.</p>
<h3 id="1314-websocket-vs-sse-vs-long-polling">13.1.4 WebSocket vs SSE vs Long Polling 비교</h3>
<table>
<thead>
<tr>
<th>특성</th>
<th>WebSocket</th>
<th>SSE</th>
<th>Long Polling</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>통신 방향</strong></td>
<td>양방향 (Full-Duplex)</td>
<td>단방향 (서버-&gt;클라이언트)</td>
<td>단방향</td>
</tr>
<tr>
<td><strong>프로토콜</strong></td>
<td>ws:// / wss://</td>
<td>HTTP</td>
<td>HTTP</td>
</tr>
<tr>
<td><strong>오버헤드</strong></td>
<td>매우 낮음 (2-14바이트)</td>
<td>낮음</td>
<td>높음 (매번 HTTP 헤더)</td>
</tr>
<tr>
<td><strong>자동 재연결</strong></td>
<td>직접 구현 필요</td>
<td>EventSource 자동 지원</td>
<td>직접 구현 필요</td>
</tr>
<tr>
<td><strong>바이너리 전송</strong></td>
<td>지원</td>
<td>미지원</td>
<td>미지원</td>
</tr>
</tbody>
</table>
<p>Chapter 12에서 다룬 SSE는 서버에서 클라이언트로 일방적으로 보내는 스트리밍에는 제격이다. 하지만 채팅처럼 양쪽 모두 메시지를 보내야 한다면 WebSocket이 필요하다. 필자의 경험상, 실시간 알림처럼 서버의 푸시만 필요한 경우 SSE를 쓰면 구현이 훨씬 간단하지만, 사용자 상호작용이 있는 경우 WebSocket을 선택하게 된다.</p>
<hr>
<h2 id="132-webflux-websocket">13.2 WebFlux에서 WebSocket 핸들러 구현</h2>
<h3 id="1321">13.2.1 의존성 설정</h3>
<p>좋은 소식은 Spring WebFlux에 WebSocket 지원이 이미 포함되어 있다는 것이다. 별도로 추가할 게 없다.</p>
<p><code>groovy
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    implementation 'org.springframework.boot:spring-boot-starter-data-mongodb-reactive'
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
}</code></p>
<h3 id="1322-websockethandler">13.2.2 WebSocketHandler 인터페이스</h3>
<p>Spring WebFlux에서 WebSocket을 다루는 핵심은 <code>WebSocketHandler</code> 인터페이스다.</p>
<p><code>java
public interface WebSocketHandler {
    Mono&lt;Void&gt; handle(WebSocketSession session);
}</code></p>
<p><code>handle()</code> 메서드가 연결이 수립되면 호출되고, 이 메서드가 반환하는 <code>Mono&lt;Void&gt;</code>가 완료되면 연결이 끝난다. <code>WebSocketSession</code> 객체는 <code>receive()</code>로 들어오는 메시지 스트림을 얻고, <code>send()</code>로 메시지를 보낸다.</p>
<p>이해를 돕기 위해 간단한 에코 핸들러를 만들어보자.</p>
<p>```java
@Component
@Slf4j
public class EchoWebSocketHandler implements WebSocketHandler {</p>
<pre><code>@Override
public Mono&lt;Void&gt; handle(WebSocketSession session) {
    log.info("WebSocket 연결 수립: sessionId={}", session.getId());

    Flux&lt;WebSocketMessage&gt; output = session.receive()
        .map(message -&gt; {
            String payload = message.getPayloadAsText();
            log.info("수신 메시지: {}", payload);
            return session.textMessage("Echo: " + payload);
        });

    return session.send(output)
        .doFinally(signal -&gt;
            log.info("WebSocket 연결 종료: sessionId={}", session.getId()));
}
</code></pre>
<p>}
```</p>
<h3 id="1323-handlermapping">13.2.3 HandlerMapping 설정</h3>
<p>이제 이 핸들러를 특정 URL 경로에 연결해야 한다. <code>HandlerMapping</code>과 <code>WebSocketHandlerAdapter</code>를 설정하면 된다.</p>
<p>```java
@Configuration
public class WebSocketConfig {</p>
<pre><code>@Bean
public HandlerMapping webSocketHandlerMapping(EchoWebSocketHandler echoHandler) {
    Map&lt;String, WebSocketHandler&gt; handlerMap = Map.of("/ws/echo", echoHandler);

    SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
    mapping.setUrlMap(handlerMap);
    mapping.setOrder(Ordered.HIGHEST_PRECEDENCE);
    return mapping;
}

@Bean
public WebSocketHandlerAdapter webSocketHandlerAdapter() {
    return new WebSocketHandlerAdapter();
}
</code></pre>
<p>}
```</p>
<p><code>order</code>를 <code>Ordered.HIGHEST_PRECEDENCE</code>로 설정하여 다른 핸들러 매핑보다 먼저 WebSocket 요청을 처리한다.</p>
<h3 id="1324">13.2.4 메시지 송수신 패턴</h3>
<p>실제 구현할 때는 상황에 따라 다른 패턴을 쓴다. 기본적으로 세 가지를 생각해볼 수 있다.</p>
<p><strong>패턴 1: 수신 전용</strong> — 클라이언트에서 오는 메시지를 받아서 처리하기만 한다</p>
<p><code>java
public Mono&lt;Void&gt; handle(WebSocketSession session) {
    return session.receive()
        .doOnNext(msg -&gt; log.info("수신: {}", msg.getPayloadAsText()))
        .then();
}</code></p>
<p><strong>패턴 2: 송신 전용</strong> — 서버에서 클라이언트로 계속 데이터를 보낸다</p>
<p><code>java
public Mono&lt;Void&gt; handle(WebSocketSession session) {
    Flux&lt;WebSocketMessage&gt; output = Flux.interval(Duration.ofSeconds(1))
        .map(tick -&gt; session.textMessage("서버 시간: " + LocalDateTime.now()));
    return session.send(output);
}</code></p>
<p><strong>패턴 3: 양방향</strong> — 수신과 송신을 동시에 처리한다</p>
<p>```java
public Mono<Void> handle(WebSocketSession session) {
    Mono<Void> input = session.receive()
        .doOnNext(msg -&gt; processMessage(msg.getPayloadAsText()))
        .then();</p>
<pre><code>Mono&lt;Void&gt; output = session.send(
    externalEventSource().map(event -&gt; session.textMessage(event)));

return Mono.zip(input, output).then();
</code></pre>
<p>}
```</p>
<h3 id="1325-json">13.2.5 JSON 메시지 처리</h3>
<p>실무에서는 평문보다는 JSON 형식의 메시지를 주고받는다. 구조가 명확해서 다루기 훨씬 편하기 때문이다.</p>
<p><code>java
@Data @Builder @NoArgsConstructor @AllArgsConstructor
public class ChatMessage {
    private String type;       // MESSAGE, JOIN, LEAVE
    private String roomId;
    private String sender;
    private String content;
    private LocalDateTime timestamp;
}</code></p>
<p>```java
@Component
@RequiredArgsConstructor @Slf4j
public class JsonWebSocketHandler implements WebSocketHandler {</p>
<pre><code>private final ObjectMapper objectMapper;

@Override
public Mono&lt;Void&gt; handle(WebSocketSession session) {
    Flux&lt;WebSocketMessage&gt; output = session.receive()
        .map(WebSocketMessage::getPayloadAsText)
        .flatMap(payload -&gt; {
            try {
                ChatMessage msg = objectMapper.readValue(payload, ChatMessage.class);
                msg.setTimestamp(LocalDateTime.now());
                return Mono.just(session.textMessage(
                    objectMapper.writeValueAsString(msg)));
            } catch (JsonProcessingException e) {
                log.error("JSON 파싱 오류: {}", e.getMessage());
                return Mono.empty();
            }
        });
    return session.send(output);
}
</code></pre>
<p>}
```</p>
<p>브라우저의 JavaScript로 동작을 테스트하면 다음과 같이 한다.</p>
<p><code>javascript
const ws = new WebSocket('ws://localhost:8080/ws/echo');
ws.onopen = () =&gt; ws.send('Hello WebSocket!');
ws.onmessage = (event) =&gt; console.log('수신:', event.data);
ws.onclose = (event) =&gt; console.log('종료:', event.code);</code></p>
<hr>
<h2 id="133">13.3 실시간 채팅 애플리케이션 구축</h2>
<p>이제 WebSocket의 진정한 가치가 나오는 부분이다. WebSocket과 MongoDB를 결합해서 여러 채팅방을 지원하는 실시간 채팅 애플리케이션을 만들어보자.</p>
<h3 id="1331">13.3.1 도메인 모델과 리포지토리</h3>
<p><code>java
@Document(collection = "chat_rooms")
@Data @Builder @NoArgsConstructor @AllArgsConstructor
public class ChatRoom {
    @Id private String id;
    private String name;
    private String description;
    private String createdBy;
    private Set&lt;String&gt; participants;
    private LocalDateTime createdAt;
}</code></p>
<p>```java
@Document(collection = "chat_messages")
@Data @Builder @NoArgsConstructor @AllArgsConstructor
public class ChatMessageDocument {
    @Id private String id;
    @Indexed private String roomId;
    private String sender;
    private String content;
    private MessageType type;
    private LocalDateTime timestamp;</p>
<pre><code>public enum MessageType { MESSAGE, JOIN, LEAVE, SYSTEM }
</code></pre>
<p>}
```</p>
<p>```java
public interface ChatRoomRepository extends ReactiveMongoRepository<ChatRoom, String> {
    Flux<ChatRoom> findByParticipantsContaining(String username);
}</p>
<p>public interface ChatMessageRepository
        extends ReactiveMongoRepository<ChatMessageDocument, String> {
    Flux<ChatMessageDocument> findByRoomIdOrderByTimestampDesc(
        String roomId, Pageable pageable);
    Flux<ChatMessageDocument> findByRoomIdAndTimestampAfterOrderByTimestampAsc(
        String roomId, LocalDateTime after);
}
```</p>
<h3 id="1332">13.3.2 채팅방 관리 서비스</h3>
<p>```java
@Service
@RequiredArgsConstructor
public class ChatRoomService {</p>
<pre><code>private final ChatRoomRepository chatRoomRepository;

public Mono&lt;ChatRoom&gt; createRoom(String name, String description,
                                  String createdBy) {
    ChatRoom room = ChatRoom.builder()
        .name(name).description(description).createdBy(createdBy)
        .participants(new HashSet&lt;&gt;(Set.of(createdBy)))
        .createdAt(LocalDateTime.now()).build();
    return chatRoomRepository.save(room);
}

public Flux&lt;ChatRoom&gt; getAllRooms() {
    return chatRoomRepository.findAll();
}

public Mono&lt;ChatRoom&gt; joinRoom(String roomId, String username) {
    return chatRoomRepository.findById(roomId)
        .flatMap(room -&gt; {
            room.getParticipants().add(username);
            return chatRoomRepository.save(room);
        });
}

public Mono&lt;ChatRoom&gt; leaveRoom(String roomId, String username) {
    return chatRoomRepository.findById(roomId)
        .flatMap(room -&gt; {
            room.getParticipants().remove(username);
            return chatRoomRepository.save(room);
        });
}
</code></pre>
<p>}
```</p>
<h3 id="1333">13.3.3 메시지 브로드캐스팅</h3>
<p>이제 핵심 부분이다. 한 사용자가 메시지를 보내면 같은 채팅방의 모든 다른 사용자들에게 전달해야 한다. Reactor의 <code>Sinks</code>라는 기능을 사용하면 이를 깔끔하게 구현할 수 있다. 한쪽에서 메시지를 발행하면 여러 세션이 이를 구독하는 구조인데, 필자의 경험상 채팅처럼 다대다 통신이 필요한 경우 <code>Sinks</code>가 정말 유용하다.</p>
<p>```java
@Service
@Slf4j
public class ChatMessageBroker {</p>
<pre><code>private final Map&lt;String, Sinks.Many&lt;ChatMessageDocument&gt;&gt; roomSinks =
    new ConcurrentHashMap&lt;&gt;();

public Sinks.Many&lt;ChatMessageDocument&gt; getRoomSink(String roomId) {
    return roomSinks.computeIfAbsent(roomId,
        id -&gt; Sinks.many().multicast().onBackpressureBuffer(256));
}

public void publish(String roomId, ChatMessageDocument message) {
    Sinks.EmitResult result = getRoomSink(roomId).tryEmitNext(message);
    if (result.isFailure()) {
        log.warn("메시지 발행 실패: roomId={}, result={}", roomId, result);
    }
}

public Flux&lt;ChatMessageDocument&gt; subscribe(String roomId) {
    return getRoomSink(roomId).asFlux();
}

public void removeRoom(String roomId) {
    Sinks.Many&lt;ChatMessageDocument&gt; removed = roomSinks.remove(roomId);
    if (removed != null) removed.tryEmitComplete();
}
</code></pre>
<p>}
```</p>
<p><code>Sinks.many().multicast().onBackpressureBuffer(256)</code>는 여러 구독자에게 동시에 메시지를 전달하는 Hot Publisher를 만든다. 만약 어떤 클라이언트가 느려서 메시지를 처리하지 못하면, 최대 256개까지 버퍼에 보관했다가 추후에 보낸다. 이렇게 하면 느린 클라이언트 때문에 빠른 클라이언트까지 영향을 받지 않는다.</p>
<h3 id="1334">13.3.4 채팅 메시지 서비스</h3>
<p>메시지를 저장하고 브로드캐스팅하는 로직을 한 곳에 모으자.</p>
<p>```java
@Service
@RequiredArgsConstructor @Slf4j
public class ChatMessageService {</p>
<pre><code>private final ChatMessageRepository chatMessageRepository;
private final ChatMessageBroker messageBroker;

public Mono&lt;ChatMessageDocument&gt; saveAndBroadcast(ChatMessageDocument message) {
    message.setTimestamp(LocalDateTime.now());
    return chatMessageRepository.save(message)
        .doOnSuccess(saved -&gt; messageBroker.publish(saved.getRoomId(), saved));
}

public Flux&lt;ChatMessageDocument&gt; getRecentMessages(String roomId, int limit) {
    return chatMessageRepository.findByRoomIdOrderByTimestampDesc(
        roomId, PageRequest.of(0, limit));
}

public Flux&lt;ChatMessageDocument&gt; getMessagesSince(
        String roomId, LocalDateTime since) {
    return chatMessageRepository
        .findByRoomIdAndTimestampAfterOrderByTimestampAsc(roomId, since);
}
</code></pre>
<p>}
```</p>
<h3 id="1335-websocket">13.3.5 채팅 WebSocket 핸들러</h3>
<p>지금까지 만든 서비스들을 모두 조합해서 실제 채팅을 처리할 WebSocket 핸들러를 만든다.</p>
<p>```java
@Component
@RequiredArgsConstructor @Slf4j
public class ChatWebSocketHandler implements WebSocketHandler {</p>
<pre><code>private final ChatMessageService chatMessageService;
private final ChatMessageBroker messageBroker;
private final ObjectMapper objectMapper;

@Override
public Mono&lt;Void&gt; handle(WebSocketSession session) {
    URI uri = session.getHandshakeInfo().getUri();
    Map&lt;String, String&gt; params = parseQueryParams(uri);
    String roomId = params.get("roomId");
    String username = params.get("username");

    if (roomId == null || username == null) {
        return session.close(CloseStatus.POLICY_VIOLATION);
    }

    log.info("채팅 연결: roomId={}, username={}", roomId, username);

    // 입장 알림
    Mono&lt;Void&gt; joinNotification = createSystemMessage(
        roomId, username + "님이 입장했습니다.",
        ChatMessageDocument.MessageType.JOIN);

    // 수신: 클라이언트 메시지를 저장 및 브로드캐스트
    Mono&lt;Void&gt; input = session.receive()
        .flatMap(msg -&gt; handleIncoming(msg.getPayloadAsText(), roomId, username))
        .doFinally(signal -&gt; createSystemMessage(roomId,
            username + "님이 퇴장했습니다.",
            ChatMessageDocument.MessageType.LEAVE).subscribe())
        .then();

    // 송신: 채팅방 브로드캐스트 스트림 구독
    Flux&lt;WebSocketMessage&gt; output = messageBroker.subscribe(roomId)
        .mapNotNull(chatMsg -&gt; toWebSocketMessage(session, chatMsg));

    return joinNotification
        .then(Mono.zip(input, session.send(output)).then());
}

private Mono&lt;ChatMessageDocument&gt; handleIncoming(
        String payload, String roomId, String sender) {
    try {
        ChatMessage incoming = objectMapper.readValue(payload, ChatMessage.class);
        ChatMessageDocument doc = ChatMessageDocument.builder()
            .roomId(roomId).sender(sender).content(incoming.getContent())
            .type(ChatMessageDocument.MessageType.MESSAGE).build();
        return chatMessageService.saveAndBroadcast(doc);
    } catch (JsonProcessingException e) {
        log.error("메시지 파싱 오류: {}", e.getMessage());
        return Mono.empty();
    }
}

private Mono&lt;Void&gt; createSystemMessage(String roomId, String content,
                                        ChatMessageDocument.MessageType type) {
    ChatMessageDocument msg = ChatMessageDocument.builder()
        .roomId(roomId).sender("SYSTEM").content(content).type(type).build();
    return chatMessageService.saveAndBroadcast(msg).then();
}

private WebSocketMessage toWebSocketMessage(
        WebSocketSession session, ChatMessageDocument msg) {
    try {
        return session.textMessage(objectMapper.writeValueAsString(msg));
    } catch (JsonProcessingException e) {
        return null;
    }
}

private Map&lt;String, String&gt; parseQueryParams(URI uri) {
    Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
    String query = uri.getQuery();
    if (query == null) return params;
    for (String param : query.split("&amp;")) {
        String[] pair = param.split("=", 2);
        if (pair.length == 2) params.put(pair[0], pair[1]);
    }
    return params;
}
</code></pre>
<p>}
```</p>
<p>WebSocket 라우팅에 등록한다.</p>
<p>```java
@Configuration
public class WebSocketConfig {
    @Bean
    public HandlerMapping webSocketHandlerMapping(ChatWebSocketHandler chatHandler) {
        SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
        mapping.setUrlMap(Map.of("/ws/chat", chatHandler));
        mapping.setOrder(Ordered.HIGHEST_PRECEDENCE);
        return mapping;
    }</p>
<pre><code>@Bean
public WebSocketHandlerAdapter webSocketHandlerAdapter() {
    return new WebSocketHandlerAdapter();
}
</code></pre>
<p>}
```</p>
<h3 id="1336-rest-api">13.3.6 채팅방 REST API</h3>
<p>WebSocket 연결이 시작되기 전에 채팅방을 만들고 관리해야 한다. 이를 위한 REST API를 준비하자.</p>
<p>```java
@RestController
@RequestMapping("/api/chat/rooms")
@RequiredArgsConstructor
public class ChatRoomController {</p>
<pre><code>private final ChatRoomService chatRoomService;
private final ChatMessageService chatMessageService;

@PostMapping
@ResponseStatus(HttpStatus.CREATED)
public Mono&lt;ChatRoom&gt; createRoom(@RequestBody CreateRoomRequest request) {
    return chatRoomService.createRoom(
        request.getName(), request.getDescription(), request.getCreatedBy());
}

@GetMapping
public Flux&lt;ChatRoom&gt; getAllRooms() {
    return chatRoomService.getAllRooms();
}

@GetMapping("/{roomId}/messages")
public Flux&lt;ChatMessageDocument&gt; getRecentMessages(
        @PathVariable String roomId,
        @RequestParam(defaultValue = "50") int limit) {
    return chatMessageService.getRecentMessages(roomId, limit);
}

@PostMapping("/{roomId}/join")
public Mono&lt;ChatRoom&gt; joinRoom(@PathVariable String roomId,
                                @RequestParam String username) {
    return chatRoomService.joinRoom(roomId, username);
}
</code></pre>
<p>}
```</p>
<h3 id="1337">13.3.7 이전 메시지 로드</h3>
<p>채팅에서 중요한 부분 중 하나는 사용자가 입장했을 때 기존 메시지를 보여주는 것이다. 이를 하는 방법은 크게 두 가지가 있다.</p>
<p><strong>전략 1: REST API를 통한 초기 로드</strong> — WebSocket 연결을 맺기 전에 REST API로 최근 메시지를 미리 가져온다</p>
<p><code>``javascript
async function joinChatRoom(roomId, username) {
    const res = await fetch(</code>/api/chat/rooms/${roomId}/messages?limit=50`);
    const history = await res.json();
    history.reverse().forEach(msg =&gt; displayMessage(msg));</p>
<pre><code>const ws = new WebSocket(
    `ws://localhost:8080/ws/chat?roomId=${roomId}&amp;username=${username}`);
ws.onmessage = (e) =&gt; displayMessage(JSON.parse(e.data));
</code></pre>
<p>}
```</p>
<p><strong>전략 2: WebSocket 내 히스토리 전송</strong> — 연결 직후 과거 메시지를 먼저 보낸 다음, 실시간 메시지로 전환한다</p>
<p>```java
Flux<WebSocketMessage> history = chatMessageService.getRecentMessages(roomId, 50)
    .mapNotNull(msg -&gt; toWebSocketMessage(session, msg));
Flux<WebSocketMessage> live = messageBroker.subscribe(roomId)
    .mapNotNull(msg -&gt; toWebSocketMessage(session, msg));</p>
<p>Flux<WebSocketMessage> output = history.concatWith(live);
```</p>
<p>일반적으로는 전략 1이 더 간단하고, 과거 메시지와 실시간 메시지 사이에 누락될 위험도 적다. 필자의 경험상 프로덕션 환경에서는 전략 1을 쓰는 것이 더 안정적이다.</p>
<h3 id="1338-mongodb">13.3.8 MongoDB 인덱스 설정</h3>
<p>채팅방별로 시간 순서대로 메시지를 자주 조회하므로, 성능을 위해 복합 인덱스를 만들어두자.</p>
<p>```java
@Configuration
@RequiredArgsConstructor
public class MongoIndexConfig {
    private final ReactiveMongoTemplate mongoTemplate;</p>
<pre><code>@PostConstruct
public void initIndexes() {
    mongoTemplate.indexOps(ChatMessageDocument.class)
        .ensureIndex(new Index()
            .on("roomId", Sort.Direction.ASC)
            .on("timestamp", Sort.Direction.DESC))
        .subscribe();
}
</code></pre>
<p>}
```</p>
<hr>
<h2 id="134-websocket">13.4 WebSocket 세션 관리</h2>
<h3 id="1341">13.4.1 세션 라이프사이클</h3>
<p>WebSocket 세션도 생명주기가 있다: <code>CONNECTING -&gt; OPEN -&gt; CLOSING -&gt; CLOSED</code>. 여러 세션을 추적하고 필요할 때 제어하려면 세션을 중앙에서 관리해야 한다.</p>
<p>```java
@Component @Slf4j
public class WebSocketSessionRegistry {</p>
<pre><code>private final Map&lt;String, Map&lt;String, WebSocketSession&gt;&gt; roomSessions =
    new ConcurrentHashMap&lt;&gt;();
private final Map&lt;String, String&gt; sessionUserMap = new ConcurrentHashMap&lt;&gt;();

public void register(String roomId, String username, WebSocketSession session) {
    roomSessions.computeIfAbsent(roomId, k -&gt; new ConcurrentHashMap&lt;&gt;())
        .put(session.getId(), session);
    sessionUserMap.put(session.getId(), username);
    log.info("세션 등록: roomId={}, username={}, 현재 인원={}",
        roomId, username, getSessionCount(roomId));
}

public void unregister(String roomId, WebSocketSession session) {
    Map&lt;String, WebSocketSession&gt; sessions = roomSessions.get(roomId);
    if (sessions != null) {
        sessions.remove(session.getId());
        if (sessions.isEmpty()) roomSessions.remove(roomId);
    }
    sessionUserMap.remove(session.getId());
}

public int getSessionCount(String roomId) {
    Map&lt;String, WebSocketSession&gt; s = roomSessions.get(roomId);
    return s != null ? s.size() : 0;
}

public Set&lt;String&gt; getOnlineUsers(String roomId) {
    Map&lt;String, WebSocketSession&gt; sessions = roomSessions.get(roomId);
    if (sessions == null) return Collections.emptySet();
    return sessions.keySet().stream()
        .map(sessionUserMap::get).filter(Objects::nonNull)
        .collect(Collectors.toSet());
}

public Map&lt;String, WebSocketSession&gt; getSessions(String roomId) {
    return roomSessions.getOrDefault(roomId, new ConcurrentHashMap&lt;&gt;());
}

public String getUsername(String sessionId) {
    return sessionUserMap.getOrDefault(sessionId, "unknown");
}

public Map&lt;String, WebSocketSession&gt; getAllSessions() {
    Map&lt;String, WebSocketSession&gt; all = new ConcurrentHashMap&lt;&gt;();
    roomSessions.values().forEach(all::putAll);
    return all;
}
</code></pre>
<p>}
```</p>
<p>ChatWebSocketHandler에 이를 통합하면, 연결 시점에 <code>register()</code>를 호출하고, 연결이 끝나는 시점인 <code>doFinally()</code>에서 <code>unregister()</code>를 호출하는 식으로 세션 생명주기를 관리한다.</p>
<h3 id="1342-pingpong">13.4.2 Ping/Pong 하트비트</h3>
<p>네트워크가 불안정하거나 오랫동안 아무 메시지도 없으면, 프록시나 방화벽이 유휴 연결을 끊어버릴 수 있다. 이를 방지하려면 주기적으로 Ping/Pong을 주고받으면서 연결이 살아있음을 알린다.</p>
<p><strong>서버 측 Ping 스케줄러:</strong></p>
<p>```java
@Component
@RequiredArgsConstructor @Slf4j
public class WebSocketPingScheduler {</p>
<pre><code>private final WebSocketSessionRegistry sessionRegistry;

@Scheduled(fixedRate = 30000)
public void sendPing() {
    sessionRegistry.getAllSessions().forEach((sessionId, session) -&gt; {
        if (session.isOpen()) {
            session.send(Mono.just(session.pingMessage(factory -&gt;
                factory.wrap("ping".getBytes(StandardCharsets.UTF_8)))))
                .subscribe(null, error -&gt;
                    log.warn("Ping 실패: sessionId={}", sessionId));
        }
    });
}
</code></pre>
<p>}
```</p>
<p><code>@EnableScheduling</code>을 메인 애플리케이션에 추가해야 한다.</p>
<p><strong>애플리케이션 레벨 하트비트:</strong></p>
<p>그런데 프록시나 방화벽이 WebSocket 프레임을 제대로 지원하지 않는 경우도 있다. 이런 상황에서는 애플리케이션 레벨에서 직접 하트비트를 처리해야 한다.</p>
<p>```java
// 수신 시 하트비트 필터링
Mono<Void> input = session.receive()
    .filter(msg -&gt; !"HEARTBEAT".equals(msg.getPayloadAsText()))
    .flatMap(msg -&gt; handleIncoming(msg.getPayloadAsText(), roomId, username))
    .then();</p>
<p>// 송신 시 하트비트와 실시간 메시지 병합
Flux<WebSocketMessage> heartbeat = Flux.interval(Duration.ofSeconds(25))
    .map(tick -&gt; session.textMessage("HEARTBEAT"));
Flux<WebSocketMessage> output = Flux.merge(
    messageBroker.subscribe(roomId).mapNotNull(m -&gt; toWebSocketMessage(session, m)),
    heartbeat);
```</p>
<h3 id="1343">13.4.3 재연결 처리</h3>
<p>결국 네트워크는 끊긴다. 이를 대비한 자동 재연결 메커니즘은 필수다. 클라이언트와 서버 양쪽에서 대비해야 한다.</p>
<p><strong>클라이언트 재연결 (지수 백오프):</strong></p>
<p>```javascript
class ReconnectingWebSocket {
    constructor(url, options = {}) {
        this.url = url;
        this.maxRetries = options.maxRetries || 10;
        this.retryDelay = options.retryDelay || 1000;
        this.maxRetryDelay = options.maxRetryDelay || 30000;
        this.retryCount = 0;
        this.lastMessageTimestamp = null;
        this.connect();
    }</p>
<pre><code>connect() {
    let connectUrl = this.url;
    if (this.lastMessageTimestamp) {
        const sep = connectUrl.includes('?') ? '&amp;' : '?';
        connectUrl += `${sep}since=${this.lastMessageTimestamp}`;
    }
    this.ws = new WebSocket(connectUrl);

    this.ws.onopen = () =&gt; { this.retryCount = 0; };
    this.ws.onmessage = (e) =&gt; {
        if (e.data === 'HEARTBEAT') return;
        const msg = JSON.parse(e.data);
        this.lastMessageTimestamp = msg.timestamp;
        this.onMessage?.(msg);
    };
    this.ws.onclose = (e) =&gt; {
        if (e.code !== 1000 &amp;&amp; this.retryCount &lt; this.maxRetries) {
            const delay = Math.min(
                this.retryDelay * Math.pow(2, this.retryCount),
                this.maxRetryDelay);
            setTimeout(() =&gt; { this.retryCount++; this.connect(); }, delay);
        }
    };
}

send(data) {
    if (this.ws?.readyState === WebSocket.OPEN)
        this.ws.send(typeof data === 'string' ? data : JSON.stringify(data));
}

close() { this.maxRetries = 0; this.ws?.close(1000); }
</code></pre>
<p>}
```</p>
<p><strong>서버 측 메시지 복구:</strong></p>
<p>클라이언트가 재연결할 때 타임스탬프를 전달하면, 그 이후의 메시지들을 모두 전송해줄 수 있다.</p>
<p>```java
@Override
public Mono<Void> handle(WebSocketSession session) {
    // ... 파라미터 추출 ...
    String sinceParam = params.get("since");</p>
<pre><code>// 재연결 시 놓친 메시지 복구
Flux&lt;WebSocketMessage&gt; missedMessages = Flux.empty();
if (sinceParam != null) {
    LocalDateTime since = LocalDateTime.parse(sinceParam);
    missedMessages = chatMessageService.getMessagesSince(roomId, since)
        .mapNotNull(msg -&gt; toWebSocketMessage(session, msg));
}

Flux&lt;WebSocketMessage&gt; liveMessages = messageBroker.subscribe(roomId)
    .mapNotNull(msg -&gt; toWebSocketMessage(session, msg));

// 놓친 메시지 먼저 전송 후 실시간 스트림 전환
Flux&lt;WebSocketMessage&gt; output = missedMessages.concatWith(liveMessages);

Mono&lt;Void&gt; input = session.receive()
    .filter(msg -&gt; !"HEARTBEAT".equals(msg.getPayloadAsText()))
    .flatMap(msg -&gt; handleIncoming(msg.getPayloadAsText(), roomId, username))
    .doFinally(signal -&gt; sessionRegistry.unregister(roomId, session))
    .then();

return Mono.zip(input, session.send(output)).then();
</code></pre>
<p>}
```</p>
<h3 id="1344">13.4.4 연결 종료와 보안</h3>
<p>WebSocket 연결을 닫을 때는 <code>CloseStatus</code> 코드로 종료 사유를 알린다. 주요 코드들이다.</p>
<table>
<thead>
<tr>
<th>코드</th>
<th>의미</th>
</tr>
</thead>
<tbody>
<tr>
<td>1000</td>
<td>정상 종료</td>
</tr>
<tr>
<td>1001</td>
<td>서버 종료 또는 페이지 이동</td>
</tr>
<tr>
<td>1008</td>
<td>정책 위반</td>
</tr>
<tr>
<td>1011</td>
<td>서버 내부 오류</td>
</tr>
<tr>
<td>4000+</td>
<td>애플리케이션 정의 코드</td>
</tr>
</tbody>
</table>
<p>예를 들어, 부정행위를 하는 사용자를 강제로 퇴장시키려면 이렇게 할 수 있다.</p>
<p><code>java
public Mono&lt;Void&gt; disconnectUser(String roomId, String targetUsername) {
    return Flux.fromIterable(sessionRegistry.getSessions(roomId).entrySet())
        .filter(e -&gt; targetUsername.equals(sessionRegistry.getUsername(e.getKey())))
        .flatMap(e -&gt; e.getValue()
            .close(new CloseStatus(4001, "관리자에 의해 종료")))
        .then();
}</code></p>
<p>WebSocket 엔드포인트도 당연히 인증이 필요하다. WebSocket 핸드셰이크가 사실 HTTP 요청이므로, Spring Security를 그냥 적용할 수 있다. 다만 JWT 토큰 같은 걸 어떻게 전달할지는 생각해야 한다. 일반적으로는 쿼리 파라미터나 첫 번째 메시지에 담아서 보낸다.</p>
<p><code>java
@Bean
public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
    return http
        .authorizeExchange(ex -&gt; ex
            .pathMatchers("/ws/**").authenticated()
            .pathMatchers("/api/auth/**").permitAll()
            .anyExchange().authenticated())
        .csrf(csrf -&gt; csrf.disable())
        .build();
}</code></p>
<p><code>java
// 핸들러 내부에서 JWT 검증
String token = params.get("token");
if (token == null || !jwtTokenProvider.validateToken(token)) {
    return session.close(new CloseStatus(4401, "인증 실패"));
}
String username = jwtTokenProvider.getUsernameFromToken(token);</code></p>
<p><code>javascript
// 클라이언트에서 토큰 전달
const token = localStorage.getItem('accessToken');
const ws = new WebSocket(
    `ws://localhost:8080/ws/chat?roomId=${roomId}&amp;username=${user}&amp;token=${token}`);</code></p>
<blockquote>
<p><strong>주의</strong>: URL 쿼리 파라미터로 토큰을 전달하면 로그에 그대로 남을 수 있다. 서버 로그, 브라우저 히스토리, 프록시 로그 등 여러 곳에 보인다는 뜻이다. 필자의 경험상 프로덕션에서는 쿠키를 쓰거나, WebSocket 연결 직후 첫 번째 메시지로 토큰을 보내는 것이 더 안전하다.</p>
</blockquote>
<hr>
<h2 id="_1">요약</h2>
<p>이 장에서 배운 내용을 정리해보면:</p>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 내용</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>WebSocket 프로토콜</strong></td>
<td>HTTP 핸드셰이크로 시작해서 프레임으로 양방향 통신, SSE나 Long Polling과는 다른 특성</td>
</tr>
<tr>
<td><strong>WebSocket 핸들러</strong></td>
<td><code>WebSocketHandler</code> 인터페이스로 연결 관리, URL 매핑, 수신/송신/양방향 처리</td>
</tr>
<tr>
<td><strong>실시간 채팅</strong></td>
<td><code>Sinks.Many</code>로 메시지 브로드캐스팅, MongoDB에 저장, 과거 메시지 로드</td>
</tr>
<tr>
<td><strong>세션 관리</strong></td>
<td>세션 추적, 하트비트로 연결 유지, 재연결 시 메시지 복구, 보안</td>
</tr>
</tbody>
</table>
<p>WebSocket은 정말로 강력한 도구다. 실시간 양방향 통신이 필요한 거의 모든 상황에서 유용하다. Spring WebFlux의 리액티브 지원과 Reactor의 <code>Sinks</code>를 잘 조합하면, 수많은 동시 연결을 안정적으로 처리하는 애플리케이션을 만들 수 있다. 다음 장에서는 다시 클라이언트 입장으로 돌아가서, WebClient로 외부 API를 리액티브하게 호출하는 방법을 다룬다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>