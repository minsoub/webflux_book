<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 1. 리액티브 프로그래밍 소개 | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <span class="disabled">&larr; 이전</span>
    <a href="../index.html">목차</a>
    <a href="ch02.html">Chapter 2. Spring WebFlux 개요 &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-1">Chapter 1. 리액티브 프로그래밍 소개</h1>
<p>현대 소프트웨어 시스템이 직면한 현실을 생각해 보자. 수백만 사용자의 동시 요청을 처리하고, 밀리초 단위의 응답 시간을 보장하며, 24/7 무중단 운영을 해야 한다는 것은 정말 과도한 요구사항처럼 들린다. 그런데 이미 우리는 그런 시스템들이 존재한다는 것을 알고 있다. 전통적인 명령형 프로그래밍 모델만으로는 이런 요구사항을 충족하기 어렵다는 것도 경험상 알 수 있기 때문이다. 이 장에서는 리액티브 프로그래밍의 핵심 개념을 살펴보면서, Spring WebFlux가 왜 이 패러다임을 선택했는지 그 이유를 함께 이해해 보자.</p>
<hr>
<h2 id="11">1.1 리액티브 프로그래밍이란?</h2>
<h3 id="111">1.1.1 정의와 핵심 원칙</h3>
<p>리액티브 프로그래밍(Reactive Programming)은 <strong>데이터 스트림과 변화의 전파</strong>에 초점을 맞춘 프로그래밍 패러다임인데, 이 둘의 차이를 한 문장으로 표현하면 쉽게 이해할 수 있다. 기존의 명령형 프로그래밍이 "이 값을 가져와서 이렇게 처리하라"라고 지시하는 방식이라면, 리액티브 프로그래밍은 "데이터가 흘러오면 이렇게 반응하라"라고 선언하는 방식이기 때문이다.</p>
<p>스프레드시트를 떠올려 보자. 셀 A1에 10, B1에 20이 있고, C1에 <code>=A1+B1</code>이라는 수식을 넣으면 C1은 30이 된다. 이후 A1의 값을 50으로 바꾸면 C1은 자동으로 70으로 갱신된다. 이것이 리액티브 프로그래밍의 본질이다. C1은 A1과 B1의 <strong>변화에 반응</strong>한다.</p>
<p>이러한 패러다임의 핵심 원칙을 정리하면 대략 이렇게 된다.</p>
<ul>
<li><strong>비동기 데이터 스트림</strong>: 모든 데이터를 시간에 따라 흐르는 스트림으로 모델링하기 때문에 순간 모든 데이터가 메모리에 있을 필요가 없다.</li>
<li><strong>변화의 전파</strong>: 상류(upstream)의 변화가 하류(downstream)로 자동 전파되므로 중간에 신경 쓸 필요가 줄어든다.</li>
<li><strong>선언적 구성</strong>: 데이터를 어떻게(how) 처리할지가 아니라, 무엇을(what) 할지 선언하는 방식으로 더 간결한 코드가 된다.</li>
<li><strong>논블로킹 실행</strong>: 스레드를 차단하지 않고 비동기적으로 작업을 수행할 수 있어 리소스를 훨씬 효율적으로 쓸 수 있다.</li>
</ul>
<h3 id="112-reactive-manifesto">1.1.2 리액티브 선언문 (Reactive Manifesto)</h3>
<p>2014년에 발표된 리액티브 선언문이 있는데, 여기서는 리액티브 시스템이 갖추어야 할 네 가지 속성을 명확히 정의하고 있다.</p>
<table>
<thead>
<tr>
<th>속성</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>응답성(Responsive)</strong></td>
<td>시스템이 가능한 한 즉각적으로 응답한다. 응답성은 사용자 경험의 핵심이다.</td>
</tr>
<tr>
<td><strong>탄력성(Resilient)</strong></td>
<td>장애가 발생해도 시스템이 응답성을 유지한다. 장애는 각 컴포넌트 내부에 격리된다.</td>
</tr>
<tr>
<td><strong>유연성(Elastic)</strong></td>
<td>작업 부하가 변화해도 시스템이 응답성을 유지한다. 리소스를 동적으로 확장/축소한다.</td>
</tr>
<tr>
<td><strong>메시지 기반(Message Driven)</strong></td>
<td>비동기 메시지 전달을 통해 컴포넌트 간 느슨한 결합을 달성한다.</td>
</tr>
</tbody>
</table>
<p>흥미롭게도 이 네 가지 속성은 독립적이지 않다. 메시지 기반 아키텍처가 토대가 되고, 그 위에 유연성과 탄력성이 구현되며, 최종적으로 응답성이 확보되는 일종의 피라미드 구조를 갖추고 있기 때문이다.</p>
<h3 id="113">1.1.3 데이터 스트림과 변화의 전파</h3>
<p>리액티브 프로그래밍에서의 가장 중요한 개념 하나는 "모든 것은 스트림"이라는 것이다. 사용자 클릭 이벤트, HTTP 요청, 데이터베이스 쿼리 결과, 센서 데이터 등 일반적으로 우리가 마주치는 모든 데이터를 시간축 위에 놓인 스트림으로 표현할 수 있다.</p>
<p>스트림이 전달하는 신호는 딱 세 가지로 나뉜다.</p>
<ol>
<li><strong>onNext(item)</strong>: 다음 데이터 항목을 전달할 때 발행되는 신호다.</li>
<li><strong>onError(error)</strong>: 오류가 발생했을 때 발행되며, 이 신호가 나오면 스트림은 종료된다.</li>
<li><strong>onComplete()</strong>: 더 이상 전달할 데이터가 없을 때 발행되며, 이것도 스트림의 정상적인 종료를 의미한다.</li>
</ol>
<p><code>시간 →
──[item1]──[item2]──[item3]──|──&gt;   (정상 완료: | = onComplete)
──[item1]──[item2]──X──&gt;            (오류 발생: X = onError)</code></p>
<h3 id="114">1.1.4 옵저버 패턴과의 관계</h3>
<p>사실 리액티브 프로그래밍은 이미 존재하는 GoF 디자인 패턴의 옵저버 패턴(Observer Pattern)을 확장한 것이라고 할 수 있다. 옵저버 패턴에서는 Subject가 상태 변화를 Observer에게 통지하는 방식을 사용하는데, 리액티브는 이것을 더 잘 구조화한 것이라고 봐도 된다.</p>
<p>```java
// 전통적인 옵저버 패턴
public interface Observer {
    void update(String event);
}</p>
<p>public class EventSource {
    private final List<Observer> observers = new ArrayList&lt;&gt;();</p>
<pre><code>public void addObserver(Observer observer) {
    observers.add(observer);
}

public void notifyAll(String event) {
    observers.forEach(o -&gt; o.update(event));
}
</code></pre>
<p>}
```</p>
<p>그래서 리액티브 프로그래밍은 이 옵저버 패턴에 세 가지를 더 추가했는데, 이것이 정말 핵심적인 개선이라고 할 수 있다.</p>
<ul>
<li><strong>완료 신호</strong>: 데이터 발행이 끝났음을 구독자에게 명시적으로 알릴 수 있도록 한 것이다.</li>
<li><strong>오류 처리</strong>: 오류를 스트림의 일부로 다루어 예외 처리처럼 흐름 제어를 할 수 있게 됐다.</li>
<li><strong>배압(Backpressure)</strong>: 구독자가 처리할 수 있는 속도에 맞춰 데이터 발행 속도를 조절할 수 있다는 게 가장 중요하다.</li>
</ul>
<hr>
<h2 id="12-vs">1.2 명령형 프로그래밍 vs 리액티브 프로그래밍</h2>
<h3 id="121">1.2.1 명령형 방식의 코드 예시</h3>
<p>구체적인 예를 통해 느껴보자. 사용자 목록에서 활성 사용자를 필터링하고, 이름을 대문자로 변환하여 정렬하는 로직을 명령형으로 작성하면 이렇게 된다.</p>
<p>```java
// 명령형 방식: 단계별로 "어떻게" 처리할지 기술
public List<String> getActiveUserNames(List<User> users) {
    List<String> activeUserNames = new ArrayList&lt;&gt;();</p>
<pre><code>for (User user : users) {
    if (user.isActive()) {
        String upperName = user.getName().toUpperCase();
        activeUserNames.add(upperName);
    }
}

Collections.sort(activeUserNames);
return activeUserNames;
</code></pre>
<p>}
```</p>
<p>이 코드는 읽기 쉽고 직관적이지만, 한 가지 문제가 있다. 처리 시작 전에 모든 사용자 데이터가 메모리에 준비되어 있어야 하고, 정렬이 완료될 때까지 호출 스레드가 계속 차단된다는 것이다.</p>
<h3 id="122">1.2.2 같은 로직의 리액티브 코드 예시</h3>
<p>같은 로직을 Project Reactor(리액티브 라이브러리)를 사용해서 작성해 보면 코드가 어떻게 달라질까?</p>
<p><code>java
// 리액티브 방식: "무엇을" 할지 선언적으로 기술
public Flux&lt;String&gt; getActiveUserNames(Flux&lt;User&gt; users) {
    return users
            .filter(User::isActive)
            .map(user -&gt; user.getName().toUpperCase())
            .sort();
}</code></p>
<p>보다시피 리액티브 코드는 훨씬 간결하다. 그리고 데이터가 도착할 때마다 파이프라인을 통해 처리되며, 각 연산자가 데이터를 하나씩 처리하고 필요한 경우에만 버퍼링한다(예: sort는 전체 데이터를 모은 후 정렬). 무엇보다 호출 스레드가 차단되지 않는다는 것이 가장 큰 장점이다.</p>
<h3 id="123-vs-vs">1.2.3 동기 vs 비동기, 블로킹 vs 논블로킹</h3>
<p>실무에서 자주 보는 혼동 사항 중 하나인데, 이 두 쌍의 개념은 서로 다른 차원의 개념이라는 것을 명확히 해야 한다.</p>
<p><strong>동기(Synchronous) vs 비동기(Asynchronous)</strong>는 호출자 입장에서 결과를 기다리는 방식에 관한 것이다.</p>
<ul>
<li>동기: 호출자가 결과가 반환될 때까지 기다린다는 것이 기본이다.</li>
<li>비동기: 호출자가 결과를 기다리지 않고, 결과가 준비되면 콜백이나 이벤트로 통지받는 방식이다.</li>
</ul>
<p><strong>블로킹(Blocking) vs 논블로킹(Non-blocking)</strong>은 호출된 함수 입장에서 스레드를 점유하는 방식에 관한 것인데, 동기/비동기와는 다르다.</p>
<ul>
<li>블로킹: 호출된 함수가 작업을 완료할 때까지 스레드를 점유하고 있다.</li>
<li>논블로킹: 호출된 함수가 즉시 반환하기 때문에 스레드를 다른 작업에 활용할 수 있다.</li>
</ul>
<p>```java
// 동기 + 블로킹: 스레드가 응답을 받을 때까지 멈춘다
User user = userRepository.findById(1L);  // 블로킹 호출</p>
<p>// 비동기 + 논블로킹: 스레드가 즉시 반환되고, 데이터가 준비되면 처리된다
Mono<User> user = userRepository.findById(1L);  // 논블로킹 호출
user.subscribe(u -&gt; System.out.println(u.getName()));
```</p>
<h3 id="124">1.2.4 장단점 비교</h3>
<table>
<thead>
<tr>
<th>구분</th>
<th>명령형</th>
<th>리액티브</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>코드 가독성</strong></td>
<td>직관적이고 이해하기 쉬움</td>
<td>학습 곡선이 존재함</td>
</tr>
<tr>
<td><strong>디버깅</strong></td>
<td>스택 트레이스가 명확함</td>
<td>비동기 스택 트레이스 추적이 어려움</td>
</tr>
<tr>
<td><strong>리소스 활용</strong></td>
<td>스레드 차단으로 비효율적</td>
<td>적은 스레드로 높은 처리량 달성</td>
</tr>
<tr>
<td><strong>확장성</strong></td>
<td>스레드 수에 비례하여 제한적</td>
<td>이벤트 루프 기반으로 높은 확장성</td>
</tr>
<tr>
<td><strong>에러 처리</strong></td>
<td>try-catch로 직관적</td>
<td>연산자 체인에서 처리</td>
</tr>
<tr>
<td><strong>적합한 상황</strong></td>
<td>CPU 집약적, 단순한 CRUD</td>
<td>I/O 집약적, 대규모 동시 연결</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="13-reactive-streams">1.3 리액티브 스트림(Reactive Streams) 표준</h2>
<h3 id="131">1.3.1 개요</h3>
<p>리액티브 스트림이란 비동기 스트림 처리를 위한 표준 인터페이스 명세를 말한다. Netflix, Lightbend, Pivotal 같은 대형 기업들이 공동으로 개발했으며, Java 9부터는 <code>java.util.concurrent.Flow</code> 클래스로 JDK에 포함되기도 했다.</p>
<p>흥미로운 것은 이 표준이 단 4개의 인터페이스로 모든 것을 설명한다는 점이다.</p>
<h3 id="132-publisher">1.3.2 Publisher</h3>
<p>Publisher는 데이터를 생산하는 주체라고 생각하면 된다. 혼자 일방적으로 데이터를 내보내는 게 아니라, 구독자의 요청에 따라 데이터를 발행하는 방식으로 동작한다.</p>
<p><code>java
public interface Publisher&lt;T&gt; {
    void subscribe(Subscriber&lt;? super T&gt; subscriber);
}</code></p>
<p><code>subscribe()</code> 메서드는 구독자를 등록한다. 호출되면 Publisher는 <code>Subscriber.onSubscribe()</code>를 호출하여 Subscription 객체를 전달한다.</p>
<h3 id="133-subscriber">1.3.3 Subscriber</h3>
<p>Subscriber는 데이터를 소비하는 쪽인데, Publisher로부터 데이터를 수신하고 처리하는 역할을 한다. 네 개의 메서드로 모든 상황을 처리하도록 설계되어 있다.</p>
<p><code>java
public interface Subscriber&lt;T&gt; {
    void onSubscribe(Subscription subscription);
    void onNext(T item);
    void onError(Throwable throwable);
    void onComplete();
}</code></p>
<table>
<thead>
<tr>
<th>메서드</th>
<th>호출 시점</th>
<th>역할</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>onSubscribe</code></td>
<td>구독 시작 시</td>
<td>Subscription을 수신하여 데이터 요청 시작</td>
</tr>
<tr>
<td><code>onNext</code></td>
<td>데이터 발행 시</td>
<td>각 데이터 항목을 처리</td>
</tr>
<tr>
<td><code>onError</code></td>
<td>오류 발생 시</td>
<td>오류를 처리하고 스트림 종료</td>
</tr>
<tr>
<td><code>onComplete</code></td>
<td>발행 완료 시</td>
<td>정상 종료 처리</td>
</tr>
</tbody>
</table>
<h3 id="134-subscription">1.3.4 Subscription</h3>
<p>Publisher와 Subscriber 사이의 연결을 나타내는 인터페이스인데, 사실 배압 제어의 핵심이 여기에 있다고 할 수 있다.</p>
<p><code>java
public interface Subscription {
    void request(long n);
    void cancel();
}</code></p>
<ul>
<li><code>request(n)</code>: Publisher에게 n개의 데이터를 명시적으로 요청하는 것인데, 이것이 배압의 핵심 메커니즘이 된다.</li>
<li><code>cancel()</code>: 구독을 중단하고 싶을 때 호출하면, 더 이상 데이터를 수신하지 않게 된다.</li>
</ul>
<h3 id="135-processor">1.3.5 Processor</h3>
<p>Processor는 Publisher와 Subscriber의 두 역할을 동시에 하는 인터페이스다. 데이터를 수신하여 변환한 뒤 다시 발행하는 중간 처리 단계에 쓰인다고 보면 된다.</p>
<p><code>java
public interface Processor&lt;T, R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; {
}</code></p>
<h3 id="136">1.3.6 상호작용 흐름</h3>
<p>이 네 인터페이스가 실제로 어떻게 상호작용하는지 순서대로 정리해 보면 아래와 같은 흐름이 된다.</p>
<p><code>Subscriber                    Publisher
    |                             |
    |--- subscribe(subscriber) --&gt;|
    |                             |
    |&lt;-- onSubscribe(subscription)|
    |                             |
    |--- request(3) -------------&gt;|   (3개 요청)
    |                             |
    |&lt;-- onNext(item1) -----------|
    |&lt;-- onNext(item2) -----------|
    |&lt;-- onNext(item3) -----------|
    |                             |
    |--- request(2) -------------&gt;|   (2개 추가 요청)
    |                             |
    |&lt;-- onNext(item4) -----------|
    |&lt;-- onComplete() ------------|   (발행 완료)</code></p>
<h3 id="137-java">1.3.7 Java 코드로 보는 전체 흐름</h3>
<p>```java
import java.util.concurrent.Flow.*;
import java.util.concurrent.SubmissionPublisher;</p>
<p>public class SimpleReactiveExample {</p>
<pre><code>public static void main(String[] args) {
    // Publisher: 1~5를 발행
    SubmissionPublisher&lt;Integer&gt; publisher = new SubmissionPublisher&lt;&gt;();

    // Subscriber: 데이터를 수신하여 출력
    Subscriber&lt;Integer&gt; subscriber = new Subscriber&lt;&gt;() {
        private Subscription subscription;

        @Override
        public void onSubscribe(Subscription subscription) {
            this.subscription = subscription;
            subscription.request(1); // 첫 번째 항목 요청
        }

        @Override
        public void onNext(Integer item) {
            System.out.println("수신: " + item);
            subscription.request(1); // 다음 항목 요청
        }

        @Override
        public void onError(Throwable throwable) {
            System.err.println("오류: " + throwable.getMessage());
        }

        @Override
        public void onComplete() {
            System.out.println("완료");
        }
    };

    publisher.subscribe(subscriber);

    // 데이터 발행
    for (int i = 1; i &lt;= 5; i++) {
        publisher.submit(i);
    }
    publisher.close();
    Thread.sleep(1000); // 비동기 처리 완료 대기
}
</code></pre>
<p>}
```</p>
<h3 id="138">1.3.8 주요 구현체</h3>
<table>
<thead>
<tr>
<th>구현체</th>
<th>개발 주체</th>
<th>특징</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Project Reactor</strong></td>
<td>Pivotal (VMware)</td>
<td>Spring WebFlux의 기본 구현체. Mono/Flux 제공</td>
</tr>
<tr>
<td><strong>RxJava</strong></td>
<td>Netflix</td>
<td>가장 오래된 리액티브 라이브러리. Observable/Flowable 제공</td>
</tr>
<tr>
<td><strong>Akka Streams</strong></td>
<td>Lightbend</td>
<td>Akka 액터 모델 기반. Source/Flow/Sink 제공</td>
</tr>
<tr>
<td><strong>Mutiny</strong></td>
<td>Red Hat</td>
<td>Quarkus 프레임워크의 기본 구현체. Uni/Multi 제공</td>
</tr>
</tbody>
</table>
<p>이 책의 나머지 내용에서는 Spring WebFlux의 기본 구현체인 <strong>Project Reactor</strong>를 주로 다룬다. 따라서 이후 코드 예시와 설명은 모두 이를 기반으로 한다.</p>
<hr>
<h2 id="14-backpressure">1.4 배압(Backpressure)의 개념</h2>
<h3 id="141">1.4.1 배압이 필요한 이유</h3>
<p>배압이 뭔지 한 문장으로 정의하면, 데이터 소비자가 생산자에게 "너무 빨리 보내지 말고 내 속도에 맞춰 달라"고 요청하는 메커니즘이다.</p>
<p>일상적인 비유로 설명하면, 컨베이어 벨트 위의 물건을 포장하는 작업자를 생각해 보자. 벨트가 너무 빨리 움직이면 물건이 쌓이고 바닥에 떨어진다. 작업자가 "속도를 줄여 주세요"라고 요청할 수 있어야 한다. 이것이 배압이다.</p>
<p>만약 배압 메커니즘이 없다면 소프트웨어 시스템에서 정말 심각한 문제들이 발생한다.</p>
<ul>
<li><strong>메모리 초과(OOM)</strong>: 처리하지 못한 데이터가 버퍼에 계속 쌓여서 결국 메모리가 고갈되어 버린다.</li>
<li><strong>응답 지연</strong>: 한 컴포넌트가 과부하 상태에 빠지면 처리 속도가 급격히 떨어진다.</li>
<li><strong>시스템 장애</strong>: 한 컴포넌트의 과부하가 다른 컴포넌트로 전파되어 전체 시스템이 먹통이 될 수 있다.</li>
</ul>
<h3 id="142">1.4.2 배압 전략</h3>
<p>이러한 배압 문제를 해결하기 위해 Project Reactor는 다양한 전략을 제공하고 있는데, 상황에 맞게 선택해서 쓸 수 있다.</p>
<table>
<thead>
<tr>
<th>전략</th>
<th>설명</th>
<th>사용 시나리오</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>BUFFER</strong></td>
<td>소비되지 못한 항목을 버퍼에 저장</td>
<td>데이터 손실이 허용되지 않을 때</td>
</tr>
<tr>
<td><strong>DROP</strong></td>
<td>소비자가 준비되지 않으면 새 항목을 버림</td>
<td>최신 데이터만 중요할 때</td>
</tr>
<tr>
<td><strong>LATEST</strong></td>
<td>가장 최근 항목만 유지하고 나머지 버림</td>
<td>센서 데이터 등 최신 값만 필요할 때</td>
</tr>
<tr>
<td><strong>ERROR</strong></td>
<td>소비자가 감당할 수 없으면 오류 발생</td>
<td>엄격한 흐름 제어가 필요할 때</td>
</tr>
</tbody>
</table>
<h3 id="143">1.4.3 코드로 보는 배압 처리</h3>
<p>```java
import reactor.core.publisher.Flux;
import reactor.core.scheduler.Schedulers;
import java.time.Duration;</p>
<p>public class BackpressureExample {</p>
<pre><code>public static void main(String[] args) throws InterruptedException {

    // 빠른 생산자: 1ms 간격으로 데이터 발행
    Flux&lt;Long&gt; fastProducer = Flux.interval(Duration.ofMillis(1));

    // onBackpressureDrop: 소비자가 처리 못하면 버림
    fastProducer
        .onBackpressureDrop(dropped -&gt;
            System.out.println("버려진 항목: " + dropped))
        .publishOn(Schedulers.boundedElastic())
        .subscribe(item -&gt; {
            // 느린 소비자: 100ms 걸림
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            System.out.println("처리: " + item);
        });

    Thread.sleep(5000);
}
</code></pre>
<p>}
```</p>
<p>그런데 <code>request()</code> 메서드를 사용해서 명시적으로 배압을 제어할 수도 있는데, 이렇게 하면 더 세밀한 제어가 가능해진다.</p>
<p>```java
import reactor.core.publisher.Flux;
import org.reactivestreams.Subscription;
import reactor.core.publisher.BaseSubscriber;</p>
<p>public class ExplicitBackpressure {</p>
<pre><code>public static void main(String[] args) {

    Flux&lt;Integer&gt; numbers = Flux.range(1, 100);

    numbers.subscribe(new BaseSubscriber&lt;&gt;() {
        private int count = 0;
        private final int BATCH_SIZE = 10;

        @Override
        protected void hookOnSubscribe(Subscription subscription) {
            // 처음에 10개만 요청
            request(BATCH_SIZE);
        }

        @Override
        protected void hookOnNext(Integer value) {
            System.out.println("처리: " + value);
            count++;
            if (count % BATCH_SIZE == 0) {
                System.out.println("--- 배치 완료, 다음 " + BATCH_SIZE + "개 요청 ---");
                request(BATCH_SIZE);
            }
        }

        @Override
        protected void hookOnComplete() {
            System.out.println("모든 데이터 처리 완료");
        }
    });
}
</code></pre>
<p>}
```</p>
<p>코드를 보면 구독자가 한 번에 10개씩만 요청하는 식으로 처리 속도를 명시적으로 제어하고 있다. 이렇게 <code>request(BATCH_SIZE)</code> 호출을 통해 배압을 직접 관리하는 것이 배압의 핵심이라고 할 수 있다.</p>
<h3 id="144-reactor">1.4.4 Reactor의 배압 연산자 요약</h3>
<p>```java
// 1. onBackpressureBuffer: 버퍼에 저장 (크기 제한 가능)
flux.onBackpressureBuffer(100)              // 최대 100개 버퍼
    .subscribe(...);</p>
<p>// 2. onBackpressureDrop: 초과분 버림
flux.onBackpressureDrop()
    .subscribe(...);</p>
<p>// 3. onBackpressureLatest: 최신 항목만 유지
flux.onBackpressureLatest()
    .subscribe(...);</p>
<p>// 4. onBackpressureError: 오류 발생
flux.onBackpressureError()
    .subscribe(...);</p>
<p>// 5. limitRate: 프리페치 크기 제한
flux.limitRate(50)                          // 한 번에 50개씩만 요청
    .subscribe(...);
```</p>
<hr>
<h2 id="15">1.5 왜 리액티브가 필요한가?</h2>
<h3 id="151-thread-per-request">1.5.1 Thread-per-request 모델의 한계</h3>
<p>이제 리액티브가 정말 필요한 이유를 실제 구체적인 예를 통해 살펴보자. 전통적인 서블릿 기반 웹 애플리케이션들은 하나의 HTTP 요청이 들어올 때마다 하나의 스레드를 할당하는 thread-per-request 모델을 사용하고 있다.</p>
<p><code>[요청 1] → [스레드 1] → DB 호출 (200ms 대기) → 응답
[요청 2] → [스레드 2] → API 호출 (300ms 대기) → 응답
[요청 3] → [스레드 3] → DB 호출 (200ms 대기) → 응답
  ...
[요청 201] → 스레드 풀 고갈 → 대기열에서 대기</code></p>
<p>이 모델의 문제점을 정리하면 생각보다 심각하다는 것을 알 수 있다.</p>
<ul>
<li><strong>스레드 풀 크기 제한</strong>: Tomcat의 기본 스레드 풀이 200개 정도인데, 201번째 요청은 그냥 대기해야 한다.</li>
<li><strong>I/O 대기 중 자원 낭비</strong>: 스레드가 데이터베이스 응답을 기다리는 동안 실제로는 아무것도 안 하는데 메모리(보통 1MB 정도)는 점유하고 있다는 게 큰 문제다.</li>
<li><strong>컨텍스트 스위칭 비용</strong>: 스레드가 늘어날수록 OS가 이들 사이를 오가는 컨텍스트 스위칭에 드는 오버헤드가 증가한다.</li>
</ul>
<h3 id="152">1.5.2 리소스 효율성 비교</h3>
<p>구체적인 숫자로 느껴보기 위해, 같은 하드웨어 위에서 10,000개의 동시 연결을 처리해야 한다는 시나리오를 생각해 보자. 두 모델 간의 차이가 정말 크다.</p>
<p><strong>thread-per-request 모델 (Spring MVC + Tomcat)</strong></p>
<p><code>필요 스레드: 10,000개
스레드당 메모리: ~1MB
총 메모리: ~10GB (스레드 스택만)
실제 CPU 작업: 약 5% (나머지 95%는 I/O 대기)</code></p>
<p><strong>이벤트 루프 모델 (Spring WebFlux + Netty)</strong></p>
<p><code>필요 스레드: CPU 코어 수 (예: 8개)
스레드당 메모리: ~1MB
총 메모리: ~8MB (스레드 스택)
실제 CPU 작업: 동일하지만 I/O 대기 없이 다른 요청 처리</code></p>
<p>```java
// Spring MVC: 블로킹 방식
@RestController
public class UserController {</p>
<pre><code>@GetMapping("/users/{id}")
public User getUser(@PathVariable Long id) {
    // 스레드가 DB 응답을 기다리며 차단됨
    User user = userRepository.findById(id);

    // 스레드가 외부 API 응답을 기다리며 차단됨
    UserProfile profile = profileClient.getProfile(user.getProfileId());

    user.setProfile(profile);
    return user;
}
</code></pre>
<p>}</p>
<p>// Spring WebFlux: 논블로킹 방식
@RestController
public class UserController {</p>
<pre><code>@GetMapping("/users/{id}")
public Mono&lt;User&gt; getUser(@PathVariable Long id) {
    // 스레드가 차단되지 않음 - 콜백으로 연결
    return userRepository.findById(id)
        .flatMap(user -&gt;
            profileClient.getProfile(user.getProfileId())
                .map(profile -&gt; {
                    user.setProfile(profile);
                    return user;
                })
        );
}
</code></pre>
<p>}
```</p>
<h3 id="153">1.5.3 리액티브가 적합한 유즈케이스</h3>
<p>여기서 한 가지 중요한 점을 짚고 넘어가야 한다. 리액티브가 모든 상황에서 최선의 선택은 절대 아니라는 것이다. 리액티브가 정말 빛나는 경우와 오히려 과할 수 있는 경우를 명확히 구분해야 한다.</p>
<p><strong>리액티브가 정말 빛나는 경우들</strong></p>
<ul>
<li><strong>높은 동시 연결 수</strong>: 채팅, 알림 푸시, 실시간 대시보드 같이 수천~수만 개의 동시 연결을 처리해야 하는 경우</li>
<li><strong>I/O 집약적 워크로드</strong>: 외부 API를 많이 호출하거나 데이터베이스 쿼리가 주를 이루는 경우가 대표적이다</li>
<li><strong>스트리밍 데이터</strong>: IoT 센서 데이터, 실시간 로그 처리, 주식 시세 같이 연속적으로 흘러들어오는 데이터</li>
<li><strong>마이크로서비스 간 통신</strong>: 여러 서비스 간에 비동기 메시지 교환이 자주 일어나는 구조</li>
<li><strong>Server-Sent Events / WebSocket</strong>: 서버가 클라이언트로 실시간 데이터를 계속 푸시해야 하는 경우</li>
</ul>
<p><strong>리액티브가 과할 수 있는 경우들</strong></p>
<ul>
<li><strong>CPU 집약적 작업</strong>: 이미지 처리, 복잡한 수학 연산처럼 CPU를 오래 점유해야 하는 작업</li>
<li><strong>단순한 CRUD 애플리케이션</strong>: 동시 사용자가 적고 비동기 흐름이 별로 필요 없는 단순한 경우</li>
<li><strong>팀의 리액티브 경험 부족</strong>: 학습 곡선이 가파르고 디버깅이 어려워서 팀이 감당하기 힘들 수 있다</li>
</ul>
<h3 id="154">1.5.4 성능 벤치마크 참고</h3>
<p>마지막으로 성능 관점에서 한 가지 더 이해하고 넘어가야 할 것이 있다. 아래는 동시 연결 수에 따른 처리량이 어떻게 달라지는지를 개념적으로 그린 것이다.</p>
<p><code>처리량(req/s)
  ^
  |
  |         ╱ WebFlux (논블로킹)
  |       ╱
  |     ╱───────────────────
  |   ╱
  | ╱   ╱── MVC (블로킹)
  |╱  ╱
  | ╱
  |╱──────────
  +────────────────────────&gt; 동시 연결 수
     100  500 1000  5000 10000</code></p>
<p>흥미로운 점은 동시 연결 수가 적을 때는 Spring MVC와 WebFlux의 성능이 거의 비슷하다는 것이다. 오히려 더 간단한 MVC가 약간 더 빠를 수도 있을 정도다. 그런데 동시 연결 수가 증가하기 시작하면 상황이 180도 달라진다. MVC의 처리량은 스레드 풀 크기라는 물리적 한계에 갇혀서 증가하지 않지만, WebFlux는 적은 스레드로도 계속해서 높은 처리량을 유지할 수 있다.</p>
<hr>
<h2 id="_1">정리</h2>
<p>이 첫 번째 장에서 배운 내용들을 한데 정리하면 다음과 같다.</p>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 내용</th>
</tr>
</thead>
<tbody>
<tr>
<td>리액티브 프로그래밍</td>
<td>데이터 스트림과 변화의 전파에 초점을 맞춘 비동기 프로그래밍 패러다임</td>
</tr>
<tr>
<td>리액티브 선언문</td>
<td>응답성, 탄력성, 유연성, 메시지 기반의 네 가지 속성</td>
</tr>
<tr>
<td>명령형 vs 리액티브</td>
<td>명령형은 "어떻게", 리액티브는 "무엇을" 선언. 각각의 장단점이 존재</td>
</tr>
<tr>
<td>리액티브 스트림</td>
<td>Publisher, Subscriber, Subscription, Processor 4개 인터페이스로 구성된 표준</td>
</tr>
<tr>
<td>배압</td>
<td>소비자가 생산자에게 속도 조절을 요청하는 메커니즘</td>
</tr>
<tr>
<td>리액티브의 필요성</td>
<td>I/O 집약적이고 높은 동시성이 요구되는 시스템에 적합</td>
</tr>
</tbody>
</table>
<p>다음 장으로 나아가면 이 개념들이 실제로 어떻게 구현되는지 구체적으로 볼 차례다. <strong>Project Reactor</strong>를 깊이 있게 살펴보면서, Mono와 Flux를 어떻게 사용하는지, 주요 연산자들은 무엇인지, 그리고 실전에서 자주 쓰이는 패턴들이 무엇인지 배워보게 될 것이다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>