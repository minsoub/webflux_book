<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 1. 리액티브 프로그래밍 소개 | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <span class="disabled">&larr; 이전</span>
    <a href="../index.html">목차</a>
    <a href="ch02.html">Chapter 2. Spring WebFlux 개요 &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-1">Chapter 1. 리액티브 프로그래밍 소개</h1>
<p>현대 소프트웨어 시스템은 수백만 사용자의 동시 요청, 밀리초 단위의 응답 시간, 무중단 운영을 요구한다. 전통적인 명령형 프로그래밍 모델로는 이러한 요구사항을 충족하기 어렵다. 이 장에서는 리액티브 프로그래밍의 핵심 개념을 살펴보고, 왜 Spring WebFlux가 이 패러다임을 채택했는지 이해한다.</p>
<hr>
<h2 id="11">1.1 리액티브 프로그래밍이란?</h2>
<h3 id="111">1.1.1 정의와 핵심 원칙</h3>
<p>리액티브 프로그래밍(Reactive Programming)은 <strong>데이터 스트림과 변화의 전파</strong>에 초점을 맞춘 프로그래밍 패러다임이다. 기존의 명령형 프로그래밍이 "이 값을 가져와서 이렇게 처리하라"라고 지시하는 방식이라면, 리액티브 프로그래밍은 "데이터가 흘러오면 이렇게 반응하라"라고 선언하는 방식이다.</p>
<p>스프레드시트를 떠올려 보자. 셀 A1에 10, B1에 20이 있고, C1에 <code>=A1+B1</code>이라는 수식을 넣으면 C1은 30이 된다. 이후 A1의 값을 50으로 바꾸면 C1은 자동으로 70으로 갱신된다. 이것이 리액티브 프로그래밍의 본질이다. C1은 A1과 B1의 <strong>변화에 반응</strong>한다.</p>
<p>리액티브 프로그래밍의 핵심 원칙은 다음과 같다.</p>
<ul>
<li><strong>비동기 데이터 스트림</strong>: 모든 데이터를 시간에 따라 흐르는 스트림으로 모델링한다.</li>
<li><strong>변화의 전파</strong>: 상류(upstream)의 변화가 하류(downstream)로 자동 전파된다.</li>
<li><strong>선언적 구성</strong>: 데이터를 어떻게(how) 처리할지가 아니라, 무엇을(what) 할지 선언한다.</li>
<li><strong>논블로킹 실행</strong>: 스레드를 차단하지 않고 비동기적으로 작업을 수행한다.</li>
</ul>
<h3 id="112-reactive-manifesto">1.1.2 리액티브 선언문 (Reactive Manifesto)</h3>
<p>2014년에 발표된 리액티브 선언문은 리액티브 시스템이 갖추어야 할 네 가지 속성을 정의한다.</p>
<table>
<thead>
<tr>
<th>속성</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>응답성(Responsive)</strong></td>
<td>시스템이 가능한 한 즉각적으로 응답한다. 응답성은 사용자 경험의 핵심이다.</td>
</tr>
<tr>
<td><strong>탄력성(Resilient)</strong></td>
<td>장애가 발생해도 시스템이 응답성을 유지한다. 장애는 각 컴포넌트 내부에 격리된다.</td>
</tr>
<tr>
<td><strong>유연성(Elastic)</strong></td>
<td>작업 부하가 변화해도 시스템이 응답성을 유지한다. 리소스를 동적으로 확장/축소한다.</td>
</tr>
<tr>
<td><strong>메시지 기반(Message Driven)</strong></td>
<td>비동기 메시지 전달을 통해 컴포넌트 간 느슨한 결합을 달성한다.</td>
</tr>
</tbody>
</table>
<p>이 네 가지 속성은 독립적이지 않다. 메시지 기반 아키텍처가 토대가 되고, 그 위에 유연성과 탄력성이 구현되며, 최종적으로 응답성이 확보된다.</p>
<h3 id="113">1.1.3 데이터 스트림과 변화의 전파</h3>
<p>리액티브 프로그래밍에서 모든 것은 스트림이다. 사용자 클릭 이벤트, HTTP 요청, 데이터베이스 쿼리 결과, 센서 데이터 등 모든 데이터가 시간축 위에 놓인 스트림으로 표현된다.</p>
<p>스트림은 세 가지 신호를 발행할 수 있다.</p>
<ol>
<li><strong>onNext(item)</strong>: 다음 데이터 항목을 전달한다.</li>
<li><strong>onError(error)</strong>: 오류가 발생했음을 알린다. 스트림이 종료된다.</li>
<li><strong>onComplete()</strong>: 더 이상 전달할 데이터가 없음을 알린다. 스트림이 종료된다.</li>
</ol>
<pre class="highlight"><code>시간 →
──[item1]──[item2]──[item3]──|──&gt;   (정상 완료: | = onComplete)
──[item1]──[item2]──X──&gt;            (오류 발생: X = onError)</code></pre>
<h3 id="114">1.1.4 옵저버 패턴과의 관계</h3>
<p>리액티브 프로그래밍은 GoF 디자인 패턴의 옵저버 패턴(Observer Pattern)을 확장한 것이다. 옵저버 패턴에서는 Subject가 상태 변화를 Observer에게 통지한다.</p>
<pre class="highlight"><code class="language-java">// 전통적인 옵저버 패턴
public interface Observer {
    void update(String event);
}

public class EventSource {
    private final List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();

    public void addObserver(Observer observer) {
        observers.add(observer);
    }

    public void notifyAll(String event) {
        observers.forEach(o -&gt; o.update(event));
    }
}</code></pre>
<p>리액티브 프로그래밍은 이 옵저버 패턴에 다음 세 가지를 추가한다.</p>
<ul>
<li><strong>완료 신호</strong>: 데이터 발행이 끝났음을 구독자에게 알릴 수 있다.</li>
<li><strong>오류 처리</strong>: 오류를 스트림의 일부로 다루어 체계적으로 처리한다.</li>
<li><strong>배압(Backpressure)</strong>: 구독자가 처리할 수 있는 속도에 맞춰 데이터 발행 속도를 조절한다.</li>
</ul>
<hr>
<h2 id="12-vs">1.2 명령형 프로그래밍 vs 리액티브 프로그래밍</h2>
<h3 id="121">1.2.1 명령형 방식의 코드 예시</h3>
<p>사용자 목록에서 활성 사용자를 필터링하고, 이름을 대문자로 변환하여 정렬하는 로직을 명령형으로 작성하면 다음과 같다.</p>
<pre class="highlight"><code class="language-java">// 명령형 방식: 단계별로 "어떻게" 처리할지 기술
public List&lt;String&gt; getActiveUserNames(List&lt;User&gt; users) {
    List&lt;String&gt; activeUserNames = new ArrayList&lt;&gt;();

    for (User user : users) {
        if (user.isActive()) {
            String upperName = user.getName().toUpperCase();
            activeUserNames.add(upperName);
        }
    }

    Collections.sort(activeUserNames);
    return activeUserNames;
}</code></pre>
<p>이 코드는 직관적이지만, 모든 데이터가 메모리에 준비되어 있어야 하고, 처리가 끝날 때까지 호출 스레드가 차단된다.</p>
<h3 id="122">1.2.2 같은 로직의 리액티브 코드 예시</h3>
<p>같은 로직을 Project Reactor를 사용한 리액티브 방식으로 작성하면 다음과 같다.</p>
<pre class="highlight"><code class="language-java">// 리액티브 방식: "무엇을" 할지 선언적으로 기술
public Flux&lt;String&gt; getActiveUserNames(Flux&lt;User&gt; users) {
    return users
            .filter(User::isActive)
            .map(user -&gt; user.getName().toUpperCase())
            .sort();
}</code></pre>
<p>리액티브 코드는 데이터가 도착할 때마다 파이프라인을 통해 처리된다. 전체 데이터가 메모리에 있을 필요가 없으며, 호출 스레드를 차단하지 않는다.</p>
<h3 id="123-vs-vs">1.2.3 동기 vs 비동기, 블로킹 vs 논블로킹</h3>
<p>이 두 쌍의 개념은 자주 혼동되지만 서로 다른 차원의 개념이다.</p>
<p><strong>동기(Synchronous) vs 비동기(Asynchronous)</strong>는 호출자가 결과를 기다리는 방식에 관한 것이다.</p>
<ul>
<li>동기: 호출자가 결과가 반환될 때까지 기다린다.</li>
<li>비동기: 호출자가 결과를 기다리지 않고, 결과가 준비되면 콜백이나 이벤트로 통지받는다.</li>
</ul>
<p><strong>블로킹(Blocking) vs 논블로킹(Non-blocking)</strong>은 호출된 함수가 스레드를 점유하는 방식에 관한 것이다.</p>
<ul>
<li>블로킹: 호출된 함수가 작업을 완료할 때까지 스레드를 점유한다.</li>
<li>논블로킹: 호출된 함수가 즉시 반환하고, 스레드를 다른 작업에 활용할 수 있다.</li>
</ul>
<pre class="highlight"><code class="language-java">// 동기 + 블로킹: 스레드가 응답을 받을 때까지 멈춘다
User user = userRepository.findById(1L);  // 블로킹 호출

// 비동기 + 논블로킹: 스레드가 즉시 반환되고, 데이터가 준비되면 처리된다
Mono&lt;User&gt; user = userRepository.findById(1L);  // 논블로킹 호출
user.subscribe(u -&gt; System.out.println(u.getName()));</code></pre>
<h3 id="124">1.2.4 장단점 비교</h3>
<table>
<thead>
<tr>
<th>구분</th>
<th>명령형</th>
<th>리액티브</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>코드 가독성</strong></td>
<td>직관적이고 이해하기 쉬움</td>
<td>학습 곡선이 존재함</td>
</tr>
<tr>
<td><strong>디버깅</strong></td>
<td>스택 트레이스가 명확함</td>
<td>비동기 스택 트레이스 추적이 어려움</td>
</tr>
<tr>
<td><strong>리소스 활용</strong></td>
<td>스레드 차단으로 비효율적</td>
<td>적은 스레드로 높은 처리량 달성</td>
</tr>
<tr>
<td><strong>확장성</strong></td>
<td>스레드 수에 비례하여 제한적</td>
<td>이벤트 루프 기반으로 높은 확장성</td>
</tr>
<tr>
<td><strong>에러 처리</strong></td>
<td>try-catch로 직관적</td>
<td>연산자 체인에서 처리</td>
</tr>
<tr>
<td><strong>적합한 상황</strong></td>
<td>CPU 집약적, 단순한 CRUD</td>
<td>I/O 집약적, 대규모 동시 연결</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="13-reactive-streams">1.3 리액티브 스트림(Reactive Streams) 표준</h2>
<h3 id="131">1.3.1 개요</h3>
<p>리액티브 스트림은 비동기 스트림 처리를 위한 표준 인터페이스 명세이다. Netflix, Lightbend, Pivotal 등이 공동으로 개발했으며, Java 9부터 <code>java.util.concurrent.Flow</code> 클래스로 JDK에 포함되었다.</p>
<p>이 표준은 단 4개의 인터페이스로 구성된다.</p>
<h3 id="132-publisher">1.3.2 Publisher</h3>
<p>데이터를 생산하는 주체이다. 구독자의 요청에 따라 데이터를 발행한다.</p>
<pre class="highlight"><code class="language-java">public interface Publisher&lt;T&gt; {
    void subscribe(Subscriber&lt;? super T&gt; subscriber);
}</code></pre>
<p><code>subscribe()</code> 메서드는 구독자를 등록한다. 호출되면 Publisher는 <code>Subscriber.onSubscribe()</code>를 호출하여 Subscription 객체를 전달한다.</p>
<h3 id="133-subscriber">1.3.3 Subscriber</h3>
<p>데이터를 소비하는 주체이다. Publisher로부터 데이터를 수신하고 처리한다.</p>
<pre class="highlight"><code class="language-java">public interface Subscriber&lt;T&gt; {
    void onSubscribe(Subscription subscription);
    void onNext(T item);
    void onError(Throwable throwable);
    void onComplete();
}</code></pre>
<table>
<thead>
<tr>
<th>메서드</th>
<th>호출 시점</th>
<th>역할</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>onSubscribe</code></td>
<td>구독 시작 시</td>
<td>Subscription을 수신하여 데이터 요청 시작</td>
</tr>
<tr>
<td><code>onNext</code></td>
<td>데이터 발행 시</td>
<td>각 데이터 항목을 처리</td>
</tr>
<tr>
<td><code>onError</code></td>
<td>오류 발생 시</td>
<td>오류를 처리하고 스트림 종료</td>
</tr>
<tr>
<td><code>onComplete</code></td>
<td>발행 완료 시</td>
<td>정상 종료 처리</td>
</tr>
</tbody>
</table>
<h3 id="134-subscription">1.3.4 Subscription</h3>
<p>Publisher와 Subscriber 사이의 연결을 나타낸다. 배압 제어의 핵심이다.</p>
<pre class="highlight"><code class="language-java">public interface Subscription {
    void request(long n);
    void cancel();
}</code></pre>
<ul>
<li><code>request(n)</code>: Publisher에게 n개의 데이터를 요청한다. 이것이 배압의 핵심 메커니즘이다.</li>
<li><code>cancel()</code>: 구독을 취소한다. 더 이상 데이터를 수신하지 않는다.</li>
</ul>
<h3 id="135-processor">1.3.5 Processor</h3>
<p>Publisher와 Subscriber를 동시에 구현한다. 데이터를 수신하여 변환한 뒤 다시 발행하는 중간 처리 단계이다.</p>
<pre class="highlight"><code class="language-java">public interface Processor&lt;T, R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; {
}</code></pre>
<h3 id="136">1.3.6 상호작용 흐름</h3>
<p>네 인터페이스의 상호작용을 순서대로 정리하면 다음과 같다.</p>
<pre class="highlight"><code>Subscriber                    Publisher
    |                             |
    |--- subscribe(subscriber) --&gt;|
    |                             |
    |&lt;-- onSubscribe(subscription)|
    |                             |
    |--- request(3) -------------&gt;|   (3개 요청)
    |                             |
    |&lt;-- onNext(item1) -----------|
    |&lt;-- onNext(item2) -----------|
    |&lt;-- onNext(item3) -----------|
    |                             |
    |--- request(2) -------------&gt;|   (2개 추가 요청)
    |                             |
    |&lt;-- onNext(item4) -----------|
    |&lt;-- onComplete() ------------|   (발행 완료)</code></pre>
<h3 id="137-java">1.3.7 Java 코드로 보는 전체 흐름</h3>
<pre class="highlight"><code class="language-java">import java.util.concurrent.Flow.*;

public class SimpleReactiveExample {

    public static void main(String[] args) {
        // Publisher: 1~5를 발행
        SubmissionPublisher&lt;Integer&gt; publisher = new SubmissionPublisher&lt;&gt;();

        // Subscriber: 데이터를 수신하여 출력
        Subscriber&lt;Integer&gt; subscriber = new Subscriber&lt;&gt;() {
            private Subscription subscription;

            @Override
            public void onSubscribe(Subscription subscription) {
                this.subscription = subscription;
                subscription.request(1); // 첫 번째 항목 요청
            }

            @Override
            public void onNext(Integer item) {
                System.out.println("수신: " + item);
                subscription.request(1); // 다음 항목 요청
            }

            @Override
            public void onError(Throwable throwable) {
                System.err.println("오류: " + throwable.getMessage());
            }

            @Override
            public void onComplete() {
                System.out.println("완료");
            }
        };

        publisher.subscribe(subscriber);

        // 데이터 발행
        for (int i = 1; i &lt;= 5; i++) {
            publisher.submit(i);
        }
        publisher.close();
    }
}</code></pre>
<h3 id="138">1.3.8 주요 구현체</h3>
<table>
<thead>
<tr>
<th>구현체</th>
<th>개발 주체</th>
<th>특징</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Project Reactor</strong></td>
<td>Pivotal (VMware)</td>
<td>Spring WebFlux의 기본 구현체. Mono/Flux 제공</td>
</tr>
<tr>
<td><strong>RxJava</strong></td>
<td>Netflix</td>
<td>가장 오래된 리액티브 라이브러리. Observable/Flowable 제공</td>
</tr>
<tr>
<td><strong>Akka Streams</strong></td>
<td>Lightbend</td>
<td>Akka 액터 모델 기반. Source/Flow/Sink 제공</td>
</tr>
<tr>
<td><strong>Mutiny</strong></td>
<td>Red Hat</td>
<td>Quarkus 프레임워크의 기본 구현체. Uni/Multi 제공</td>
</tr>
</tbody>
</table>
<p>이 책에서는 Spring WebFlux의 기본 구현체인 <strong>Project Reactor</strong>를 사용한다.</p>
<hr>
<h2 id="14-backpressure">1.4 배압(Backpressure)의 개념</h2>
<h3 id="141">1.4.1 배압이 필요한 이유</h3>
<p>배압은 데이터 소비자가 생산자에게 "속도를 늦춰 달라"고 요청하는 메커니즘이다.</p>
<p>일상적인 비유로 설명하면, 컨베이어 벨트 위의 물건을 포장하는 작업자를 생각해 보자. 벨트가 너무 빨리 움직이면 물건이 쌓이고 바닥에 떨어진다. 작업자가 "속도를 줄여 주세요"라고 요청할 수 있어야 한다. 이것이 배압이다.</p>
<p>소프트웨어 시스템에서 배압이 없으면 다음 문제가 발생한다.</p>
<ul>
<li><strong>메모리 초과(OOM)</strong>: 처리하지 못한 데이터가 버퍼에 무한히 쌓인다.</li>
<li><strong>응답 지연</strong>: 과부하된 컴포넌트의 처리 속도가 급격히 저하된다.</li>
<li><strong>시스템 장애</strong>: 한 컴포넌트의 과부하가 전체 시스템으로 전파된다.</li>
</ul>
<h3 id="142">1.4.2 배압 전략</h3>
<p>Project Reactor는 다양한 배압 전략을 제공한다.</p>
<table>
<thead>
<tr>
<th>전략</th>
<th>설명</th>
<th>사용 시나리오</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>BUFFER</strong></td>
<td>소비되지 못한 항목을 버퍼에 저장</td>
<td>데이터 손실이 허용되지 않을 때</td>
</tr>
<tr>
<td><strong>DROP</strong></td>
<td>소비자가 준비되지 않으면 새 항목을 버림</td>
<td>최신 데이터만 중요할 때</td>
</tr>
<tr>
<td><strong>LATEST</strong></td>
<td>가장 최근 항목만 유지하고 나머지 버림</td>
<td>센서 데이터 등 최신 값만 필요할 때</td>
</tr>
<tr>
<td><strong>ERROR</strong></td>
<td>소비자가 감당할 수 없으면 오류 발생</td>
<td>엄격한 흐름 제어가 필요할 때</td>
</tr>
</tbody>
</table>
<h3 id="143">1.4.3 코드로 보는 배압 처리</h3>
<pre class="highlight"><code class="language-java">import reactor.core.publisher.Flux;
import reactor.core.scheduler.Schedulers;
import java.time.Duration;

public class BackpressureExample {

    public static void main(String[] args) throws InterruptedException {

        // 빠른 생산자: 1ms 간격으로 데이터 발행
        Flux&lt;Long&gt; fastProducer = Flux.interval(Duration.ofMillis(1));

        // onBackpressureDrop: 소비자가 처리 못하면 버림
        fastProducer
            .onBackpressureDrop(dropped -&gt;
                System.out.println("버려진 항목: " + dropped))
            .publishOn(Schedulers.boundedElastic())
            .subscribe(item -&gt; {
                // 느린 소비자: 100ms 걸림
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                System.out.println("처리: " + item);
            });

        Thread.sleep(5000);
    }
}</code></pre>
<p>request를 사용하여 명시적으로 배압을 제어하는 예시도 살펴보자.</p>
<pre class="highlight"><code class="language-java">import reactor.core.publisher.Flux;
import org.reactivestreams.Subscription;
import reactor.core.publisher.BaseSubscriber;

public class ExplicitBackpressure {

    public static void main(String[] args) {

        Flux&lt;Integer&gt; numbers = Flux.range(1, 100);

        numbers.subscribe(new BaseSubscriber&lt;&gt;() {
            private int count = 0;
            private final int BATCH_SIZE = 10;

            @Override
            protected void hookOnSubscribe(Subscription subscription) {
                // 처음에 10개만 요청
                request(BATCH_SIZE);
            }

            @Override
            protected void hookOnNext(Integer value) {
                System.out.println("처리: " + value);
                count++;
                if (count % BATCH_SIZE == 0) {
                    System.out.println("--- 배치 완료, 다음 " + BATCH_SIZE + "개 요청 ---");
                    request(BATCH_SIZE);
                }
            }

            @Override
            protected void hookOnComplete() {
                System.out.println("모든 데이터 처리 완료");
            }
        });
    }
}</code></pre>
<p>위 코드에서 구독자는 한 번에 10개씩만 요청하여 처리 속도를 제어한다. <code>request(BATCH_SIZE)</code> 호출이 배압의 핵심이다.</p>
<h3 id="144-reactor">1.4.4 Reactor의 배압 연산자 요약</h3>
<pre class="highlight"><code class="language-java">// 1. onBackpressureBuffer: 버퍼에 저장 (크기 제한 가능)
flux.onBackpressureBuffer(100)              // 최대 100개 버퍼
    .subscribe(...);

// 2. onBackpressureDrop: 초과분 버림
flux.onBackpressureDrop()
    .subscribe(...);

// 3. onBackpressureLatest: 최신 항목만 유지
flux.onBackpressureLatest()
    .subscribe(...);

// 4. onBackpressureError: 오류 발생
flux.onBackpressureError()
    .subscribe(...);

// 5. limitRate: 프리페치 크기 제한
flux.limitRate(50)                          // 한 번에 50개씩만 요청
    .subscribe(...);</code></pre>
<hr>
<h2 id="15">1.5 왜 리액티브가 필요한가?</h2>
<h3 id="151-thread-per-request">1.5.1 Thread-per-request 모델의 한계</h3>
<p>전통적인 서블릿 기반 웹 애플리케이션은 하나의 HTTP 요청마다 하나의 스레드를 할당하는 thread-per-request 모델을 사용한다.</p>
<pre class="highlight"><code>[요청 1] → [스레드 1] → DB 호출 (200ms 대기) → 응답
[요청 2] → [스레드 2] → API 호출 (300ms 대기) → 응답
[요청 3] → [스레드 3] → DB 호출 (200ms 대기) → 응답
  ...
[요청 201] → 스레드 풀 고갈 → 대기열에서 대기</code></pre>
<p>이 모델의 문제점은 명확하다.</p>
<ul>
<li><strong>스레드 풀 크기 제한</strong>: Tomcat 기본 스레드 풀은 200개다. 201번째 요청은 대기해야 한다.</li>
<li><strong>I/O 대기 중 자원 낭비</strong>: 스레드가 DB 응답을 기다리는 동안 아무 일도 하지 않지만 메모리(약 1MB/스레드)를 점유한다.</li>
<li><strong>컨텍스트 스위칭 비용</strong>: 스레드 수가 늘어나면 OS의 컨텍스트 스위칭 비용이 증가한다.</li>
</ul>
<h3 id="152">1.5.2 리소스 효율성 비교</h3>
<p>같은 하드웨어에서 10,000개의 동시 연결을 처리하는 시나리오를 비교해 보자.</p>
<p><strong>thread-per-request 모델 (Spring MVC + Tomcat)</strong></p>
<pre class="highlight"><code>필요 스레드: 10,000개
스레드당 메모리: ~1MB
총 메모리: ~10GB (스레드 스택만)
실제 CPU 작업: 약 5% (나머지 95%는 I/O 대기)</code></pre>
<p><strong>이벤트 루프 모델 (Spring WebFlux + Netty)</strong></p>
<pre class="highlight"><code>필요 스레드: CPU 코어 수 (예: 8개)
스레드당 메모리: ~1MB
총 메모리: ~8MB (스레드 스택)
실제 CPU 작업: 동일하지만 I/O 대기 없이 다른 요청 처리</code></pre>
<pre class="highlight"><code class="language-java">// Spring MVC: 블로킹 방식
@RestController
public class UserController {

    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        // 스레드가 DB 응답을 기다리며 차단됨
        User user = userRepository.findById(id);

        // 스레드가 외부 API 응답을 기다리며 차단됨
        UserProfile profile = profileClient.getProfile(user.getProfileId());

        user.setProfile(profile);
        return user;
    }
}

// Spring WebFlux: 논블로킹 방식
@RestController
public class UserController {

    @GetMapping("/users/{id}")
    public Mono&lt;User&gt; getUser(@PathVariable Long id) {
        // 스레드가 차단되지 않음 - 콜백으로 연결
        return userRepository.findById(id)
            .flatMap(user -&gt;
                profileClient.getProfile(user.getProfileId())
                    .map(profile -&gt; {
                        user.setProfile(profile);
                        return user;
                    })
            );
    }
}</code></pre>
<h3 id="153">1.5.3 리액티브가 적합한 유즈케이스</h3>
<p>리액티브가 모든 상황에서 최선의 선택은 아니다. 다음은 리액티브가 적합한 경우와 그렇지 않은 경우이다.</p>
<p><strong>리액티브가 적합한 경우</strong></p>
<ul>
<li><strong>높은 동시 연결 수</strong>: 채팅, 알림, 실시간 대시보드 등 수천~수만 개의 동시 연결이 필요한 경우</li>
<li><strong>I/O 집약적 워크로드</strong>: 다수의 외부 API 호출, 데이터베이스 쿼리가 주를 이루는 경우</li>
<li><strong>스트리밍 데이터</strong>: IoT 센서 데이터, 실시간 로그 처리, 주식 시세 등 연속적인 데이터 흐름</li>
<li><strong>마이크로서비스 간 통신</strong>: 서비스 간 비동기 메시지 교환이 빈번한 경우</li>
<li><strong>Server-Sent Events / WebSocket</strong>: 서버에서 클라이언트로 실시간 데이터를 푸시하는 경우</li>
</ul>
<p><strong>리액티브가 적합하지 않은 경우</strong></p>
<ul>
<li><strong>CPU 집약적 작업</strong>: 이미지 처리, 복잡한 수학 연산 등 CPU를 오래 사용하는 작업</li>
<li><strong>단순한 CRUD 애플리케이션</strong>: 동시 사용자가 적고 복잡한 비동기 흐름이 불필요한 경우</li>
<li><strong>팀의 경험 부족</strong>: 리액티브 프로그래밍의 학습 곡선과 디버깅 난이도를 감당하기 어려운 경우</li>
</ul>
<h3 id="154">1.5.4 성능 벤치마크 참고</h3>
<p>아래는 동시 연결 수에 따른 처리량 변화를 개념적으로 나타낸 것이다.</p>
<pre class="highlight"><code>처리량(req/s)
  ^
  |
  |         ╱ WebFlux (논블로킹)
  |       ╱
  |     ╱───────────────────
  |   ╱
  | ╱   ╱── MVC (블로킹)
  |╱  ╱
  | ╱
  |╱──────────
  +────────────────────────&gt; 동시 연결 수
     100  500 1000  5000 10000</code></pre>
<p>동시 연결 수가 적을 때는 Spring MVC와 WebFlux의 성능 차이가 거의 없다. 오히려 MVC가 약간 빠를 수도 있다. 하지만 동시 연결 수가 증가하면 MVC의 처리량은 스레드 풀 크기에 의해 제한되는 반면, WebFlux는 적은 스레드로도 높은 처리량을 유지한다.</p>
<hr>
<h2 id="_1">정리</h2>
<p>이 장에서 다룬 핵심 내용을 정리하면 다음과 같다.</p>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 내용</th>
</tr>
</thead>
<tbody>
<tr>
<td>리액티브 프로그래밍</td>
<td>데이터 스트림과 변화의 전파에 초점을 맞춘 비동기 프로그래밍 패러다임</td>
</tr>
<tr>
<td>리액티브 선언문</td>
<td>응답성, 탄력성, 유연성, 메시지 기반의 네 가지 속성</td>
</tr>
<tr>
<td>명령형 vs 리액티브</td>
<td>명령형은 "어떻게", 리액티브는 "무엇을" 선언. 각각의 장단점이 존재</td>
</tr>
<tr>
<td>리액티브 스트림</td>
<td>Publisher, Subscriber, Subscription, Processor 4개 인터페이스로 구성된 표준</td>
</tr>
<tr>
<td>배압</td>
<td>소비자가 생산자에게 속도 조절을 요청하는 메커니즘</td>
</tr>
<tr>
<td>리액티브의 필요성</td>
<td>I/O 집약적이고 높은 동시성이 요구되는 시스템에 적합</td>
</tr>
</tbody>
</table>
<p>다음 장에서는 이 개념들의 구체적인 구현체인 <strong>Project Reactor</strong>를 깊이 살펴본다. Mono와 Flux의 사용법, 주요 연산자, 그리고 실전 패턴을 다룬다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>