<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Part 4. 실시간 통신과 고급 기능 (Ch.12-15) | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="part3.html">&larr; Part 3. 심화 개발 (Ch.8-11)</a>
    <a href="../index.html">목차</a>
    <a href="part5.html">Part 5. 테스트와 품질 (Ch.16-17) &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-12-server-sent-events-sse">Chapter 12. Server-Sent Events (SSE)</h1>
<p>웹 애플리케이션에서 서버가 클라이언트에게 실시간으로 데이터를 전달해야 하는 상황은 매우 흔하다. 주식 시세, 알림, 라이브 피드, 대시보드 업데이트 등이 대표적인 사례다. 이번 장에서는 Server-Sent Events(SSE) 프로토콜의 개념과 Spring WebFlux에서 <code>Flux</code>를 활용한 SSE 엔드포인트 구현, Sinks 기반의 실시간 알림 시스템 구축, 그리고 MongoDB Change Streams와 SSE를 연동하여 데이터 변경 사항을 실시간으로 전달하는 방법까지 단계별로 다룬다.</p>
<hr>
<h2 id="121-sse">12.1 SSE란 무엇인가?</h2>
<h3 id="1211-sse">12.1.1 SSE 프로토콜 개요</h3>
<p>Server-Sent Events(SSE)는 서버에서 클라이언트로 단방향 실시간 데이터를 전송하기 위한 HTTP 기반 표준 프로토콜이다. W3C에 의해 HTML5 사양의 일부로 표준화되었으며, <code>EventSource</code> API를 통해 브라우저에서 기본적으로 지원한다.</p>
<p>SSE의 핵심 특징은 다음과 같다.</p>
<ul>
<li><strong>단방향 통신</strong>: 서버에서 클라이언트로만 데이터를 전송한다. 클라이언트가 서버로 데이터를 보내려면 별도의 HTTP 요청을 사용한다.</li>
<li><strong>HTTP 기반</strong>: 일반 HTTP/1.1 또는 HTTP/2 위에서 동작하므로 별도의 프로토콜이 필요 없다.</li>
<li><strong>자동 재연결</strong>: 연결이 끊어지면 브라우저가 자동으로 재연결을 시도한다.</li>
<li><strong>이벤트 ID 지원</strong>: 마지막으로 수신한 이벤트 ID를 기억하여, 재연결 시 놓친 이벤트를 복구할 수 있다.</li>
<li><strong>텍스트 기반</strong>: <code>text/event-stream</code> MIME 타입을 사용하며, UTF-8 인코딩 텍스트로 데이터를 전송한다.</li>
</ul>
<h3 id="1212-sse">12.1.2 SSE 메시지 형식</h3>
<p>SSE 메시지는 텍스트 줄로 구성되며, 각 필드는 콜론으로 구분된다.</p>
<pre class="highlight"><code>id: 1
event: notification
data: {"message": "새 댓글이 등록되었습니다.", "postId": "abc123"}
retry: 5000
</code></pre>
<p>각 필드의 의미는 다음과 같다.</p>
<table>
<thead>
<tr>
<th>필드</th>
<th>설명</th>
<th>기본값</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>id</code></td>
<td>이벤트 고유 식별자. 재연결 시 <code>Last-Event-ID</code> 헤더로 전송됨</td>
<td>없음</td>
</tr>
<tr>
<td><code>event</code></td>
<td>이벤트 타입. 클라이언트에서 <code>addEventListener</code>로 특정 타입만 수신 가능</td>
<td><code>message</code></td>
</tr>
<tr>
<td><code>data</code></td>
<td>실제 전송 데이터. 여러 줄 가능 (각 줄마다 <code>data:</code> 접두사 필요)</td>
<td>없음</td>
</tr>
<tr>
<td><code>retry</code></td>
<td>재연결 대기 시간(밀리초). 서버가 클라이언트의 재연결 간격을 제어</td>
<td>브라우저 기본값</td>
</tr>
<tr>
<td><code>:</code> (주석)</td>
<td>콜론으로 시작하는 줄은 주석으로 처리됨. 연결 유지(keep-alive)에 활용</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>메시지와 메시지 사이는 빈 줄(<code>\n\n</code>)로 구분한다.</p>
<h3 id="1213-sse-vs-websocket-vs">12.1.3 SSE vs WebSocket vs 폴링 비교</h3>
<table>
<thead>
<tr>
<th>구분</th>
<th>SSE</th>
<th>WebSocket</th>
<th>폴링 (Polling)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>통신 방향</strong></td>
<td>단방향 (서버 -&gt; 클라이언트)</td>
<td>양방향</td>
<td>단방향 (클라이언트 요청 기반)</td>
</tr>
<tr>
<td><strong>프로토콜</strong></td>
<td>HTTP</td>
<td>WS (WebSocket 프로토콜)</td>
<td>HTTP</td>
</tr>
<tr>
<td><strong>연결 유지</strong></td>
<td>지속 연결</td>
<td>지속 연결</td>
<td>매 요청마다 연결/해제</td>
</tr>
<tr>
<td><strong>자동 재연결</strong></td>
<td>브라우저 기본 지원</td>
<td>직접 구현 필요</td>
<td>해당 없음</td>
</tr>
<tr>
<td><strong>데이터 형식</strong></td>
<td>텍스트 (UTF-8)</td>
<td>텍스트 + 바이너리</td>
<td>제한 없음</td>
</tr>
<tr>
<td><strong>방화벽/프록시</strong></td>
<td>HTTP이므로 통과 용이</td>
<td>차단될 수 있음</td>
<td>문제 없음</td>
</tr>
<tr>
<td><strong>HTTP/2 호환</strong></td>
<td>멀티플렉싱 활용 가능</td>
<td>별도 연결 필요</td>
<td>해당 없음</td>
</tr>
<tr>
<td><strong>서버 부하</strong></td>
<td>낮음</td>
<td>낮음</td>
<td>높음 (반복 요청)</td>
</tr>
</tbody>
</table>
<p>SSE가 적합한 시나리오는 알림, 뉴스 피드, 주식 시세, 진행률 업데이트 등 <strong>서버에서 클라이언트로의 단방향 스트리밍</strong>이다. 기존 HTTP 인프라(로드밸런서, 프록시, 인증)를 그대로 활용할 수 있고, 브라우저가 자동으로 재연결을 처리하므로 구현이 간단하다. 반면, 양방향 실시간 통신(채팅, 게임)이나 바이너리 데이터 전송이 필요한 경우에는 WebSocket이 더 적합하다.</p>
<h3 id="1214-eventsource-api">12.1.4 클라이언트 측 EventSource API</h3>
<p>브라우저에서 SSE를 수신하는 JavaScript 코드는 매우 간결하다.</p>
<pre class="highlight"><code class="language-javascript">const eventSource = new EventSource('/api/notifications/stream');

// 기본 message 이벤트 수신
eventSource.onmessage = (event) =&gt; {
    const data = JSON.parse(event.data);
    console.log('수신:', data);
};

// 특정 이벤트 타입 수신
eventSource.addEventListener('notification', (event) =&gt; {
    const notification = JSON.parse(event.data);
    showNotification(notification);
});

// 에러 처리 및 연결 종료
eventSource.onerror = (error) =&gt; {
    console.error('SSE 연결 오류:', error);
    if (eventSource.readyState === EventSource.CLOSED) {
        console.log('연결이 종료되었습니다.');
    }
};</code></pre>
<p><code>EventSource</code>는 연결이 끊어지면 자동으로 재연결을 시도한다. <code>readyState</code>는 <code>CONNECTING(0)</code>, <code>OPEN(1)</code>, <code>CLOSED(2)</code> 세 가지 상태를 가진다.</p>
<hr>
<h2 id="122-flux-sse">12.2 Flux를 활용한 SSE 엔드포인트 구현</h2>
<h3 id="1221-text_event_stream">12.2.1 TEXT_EVENT_STREAM 미디어 타입</h3>
<p>SSE는 Spring WebFlux에 기본 내장되어 있으므로 추가 의존성이 필요 없다. SSE 엔드포인트를 만드는 가장 간단한 방법은 컨트롤러 메서드에서 <code>Flux</code>를 반환하면서 <code>produces</code>에 <code>text/event-stream</code> 미디어 타입을 지정하는 것이다.</p>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/sse")
public class SseController {

    @GetMapping(value = "/time", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux&lt;String&gt; streamTime() {
        return Flux.interval(Duration.ofSeconds(1))
            .map(sequence -&gt; "현재 시각: " + LocalDateTime.now()
                .format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
    }
}</code></pre>
<p><code>MediaType.TEXT_EVENT_STREAM_VALUE</code>는 <code>"text/event-stream"</code> 문자열 상수다. 이 설정만으로 Spring WebFlux는 <code>Flux</code>의 각 요소를 SSE 메시지 형식(<code>data:</code> 필드)으로 변환하여 클라이언트에 전송한다.</p>
<h3 id="1222-serversentevent">12.2.2 ServerSentEvent 클래스 활용</h3>
<p>단순 <code>data</code> 필드만이 아니라 <code>id</code>, <code>event</code>, <code>retry</code> 등 SSE 메시지의 모든 필드를 제어하려면 <code>ServerSentEvent&lt;T&gt;</code> 제네릭 클래스를 사용한다.</p>
<pre class="highlight"><code class="language-java">@GetMapping(value = "/events", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;ServerSentEvent&lt;String&gt;&gt; streamEvents() {
    return Flux.interval(Duration.ofSeconds(2))
        .map(sequence -&gt; ServerSentEvent.&lt;String&gt;builder()
            .id(String.valueOf(sequence))
            .event("heartbeat")
            .data("서버 상태: 정상 (seq=" + sequence + ")")
            .retry(Duration.ofSeconds(10))
            .comment("keep-alive")
            .build());
}</code></pre>
<p><code>ServerSentEvent</code>를 반환 타입으로 사용하면 <code>produces</code> 속성을 생략해도 된다. Spring WebFlux가 반환 타입을 보고 자동으로 <code>text/event-stream</code>으로 설정한다.</p>
<pre class="highlight"><code class="language-java">// produces 생략 가능 - ServerSentEvent 반환 시 자동 적용
@GetMapping("/events-auto")
public Flux&lt;ServerSentEvent&lt;Map&lt;String, Object&gt;&gt;&gt; streamEventsAuto() {
    return Flux.interval(Duration.ofSeconds(3))
        .map(seq -&gt; ServerSentEvent.&lt;Map&lt;String, Object&gt;&gt;builder()
            .id(String.valueOf(seq))
            .event("status-update")
            .data(Map.of("sequence", seq, "timestamp", Instant.now().toString()))
            .build());
}</code></pre>
<h3 id="1223-fluxinterval">12.2.3 Flux.interval을 활용한 주기적 데이터 전송</h3>
<p><code>Flux.interval()</code>은 지정된 간격으로 0부터 시작하는 <code>Long</code> 값을 방출하는 Hot Publisher다. 주기적으로 데이터를 전송하는 SSE 엔드포인트에 적합하다.</p>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/sse")
@RequiredArgsConstructor
public class DashboardSseController {

    private final SystemMetricsService metricsService;

    @GetMapping(value = "/dashboard", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux&lt;ServerSentEvent&lt;DashboardData&gt;&gt; streamDashboard() {
        return Flux.interval(Duration.ofSeconds(5))
            .flatMap(tick -&gt; metricsService.collectMetrics())
            .map(metrics -&gt; ServerSentEvent.&lt;DashboardData&gt;builder()
                .event("dashboard-update")
                .data(metrics)
                .build())
            .doOnCancel(() -&gt; log.info("대시보드 SSE 연결 해제"));
    }
}</code></pre>
<pre class="highlight"><code class="language-java">@Data
@Builder
public class DashboardData {
    private double cpuUsage;
    private long memoryUsed;
    private long memoryTotal;
    private int activeThreads;
    private Instant timestamp;
}</code></pre>
<h3 id="1224-fluxmerge">12.2.4 이벤트 타입 혼합과 Flux.merge</h3>
<p>서로 다른 이벤트 타입을 하나의 SSE 스트림에 혼합하여 전송할 수 있다. <code>Flux.merge</code>로 여러 스트림을 결합하고, 클라이언트는 <code>addEventListener</code>로 관심 있는 이벤트만 선택적으로 수신한다.</p>
<pre class="highlight"><code class="language-java">@GetMapping(value = "/mixed", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;ServerSentEvent&lt;?&gt;&gt; streamMixedEvents() {
    Flux&lt;ServerSentEvent&lt;?&gt;&gt; statusStream = Flux.interval(Duration.ofSeconds(5))
        .map(tick -&gt; ServerSentEvent.builder()
            .event("system-status")
            .data(Map.of("status", "healthy", "uptime", tick * 5))
            .build());

    Flux&lt;ServerSentEvent&lt;?&gt;&gt; statsStream = Flux.interval(Duration.ofSeconds(10))
        .map(tick -&gt; ServerSentEvent.builder()
            .event("statistics")
            .data(Map.of("activeUsers", 42 + tick, "requestsPerSec", 150))
            .build());

    // 30초마다 주석 기반 하트비트 전송 (연결 유지용)
    Flux&lt;ServerSentEvent&lt;?&gt;&gt; heartbeat = Flux.interval(Duration.ofSeconds(30))
        .map(tick -&gt; ServerSentEvent.builder().comment("heartbeat").build());

    return Flux.merge(statusStream, statsStream, heartbeat);
}</code></pre>
<h3 id="1225-sse">12.2.5 함수형 라우터에서 SSE 구현</h3>
<p>Router Functions 스타일로도 SSE 엔드포인트를 구현할 수 있다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class SseRouterConfig {

    @Bean
    public RouterFunction&lt;ServerResponse&gt; sseRoutes(SseHandler handler) {
        return RouterFunctions.route()
            .GET("/api/sse/stream", handler::stream)
            .build();
    }
}

@Component
public class SseHandler {

    public Mono&lt;ServerResponse&gt; stream(ServerRequest request) {
        Flux&lt;ServerSentEvent&lt;String&gt;&gt; events = Flux.interval(Duration.ofSeconds(1))
            .map(seq -&gt; ServerSentEvent.&lt;String&gt;builder()
                .id(String.valueOf(seq))
                .data("tick " + seq)
                .build());

        return ServerResponse.ok()
            .contentType(MediaType.TEXT_EVENT_STREAM)
            .body(events, ServerSentEvent.class);
    }
}</code></pre>
<hr>
<h2 id="123">12.3 실시간 알림 시스템 구축</h2>
<h3 id="1231-sinks">12.3.1 Sinks를 활용한 이벤트 브로드캐스팅</h3>
<p>실제 서비스에서 SSE는 단순 타이머가 아니라 특정 이벤트 발생 시 연결된 클라이언트들에게 즉시 데이터를 전달해야 한다. Reactor의 <code>Sinks</code>는 프로그래밍 방식으로 이벤트를 발행할 수 있는 Hot Publisher로, 이 용도에 적합하다.</p>
<pre class="highlight"><code class="language-java">@Service
@Slf4j
public class NotificationBroadcaster {

    private final Sinks.Many&lt;Notification&gt; sink =
        Sinks.many().multicast().onBackpressureBuffer(256);

    public void publish(Notification notification) {
        Sinks.EmitResult result = sink.tryEmitNext(notification);
        if (result.isFailure()) {
            log.warn("알림 발행 실패: {}, result={}", notification.getId(), result);
        }
    }

    public Flux&lt;Notification&gt; subscribe() {
        return sink.asFlux();
    }
}</code></pre>
<p>Sinks의 주요 팩토리 메서드를 비교하면 다음과 같다.</p>
<table>
<thead>
<tr>
<th>메서드</th>
<th>설명</th>
<th>사용 시나리오</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Sinks.many().multicast()</code></td>
<td>여러 구독자에게 동일 이벤트를 전달. 구독 전 발행된 이벤트는 수신 불가</td>
<td>실시간 알림, 라이브 피드</td>
</tr>
<tr>
<td><code>Sinks.many().replay()</code></td>
<td>과거 이벤트를 새 구독자에게 재전송 가능</td>
<td>최근 N건의 이벤트 보여주기</td>
</tr>
<tr>
<td><code>Sinks.many().unicast()</code></td>
<td>단일 구독자만 허용</td>
<td>1:1 전용 스트림</td>
</tr>
</tbody>
</table>
<h3 id="1232">12.3.2 알림 도메인 모델</h3>
<pre class="highlight"><code class="language-java">@Document(collection = "notifications")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Notification {
    @Id
    private String id;
    private String userId;       // 수신 대상 사용자
    private String type;         // COMMENT, LIKE, FOLLOW, SYSTEM 등
    private String title;
    private String message;
    private Map&lt;String, Object&gt; metadata;  // 추가 정보 (postId, commentId 등)
    private boolean read;
    private LocalDateTime createdAt;
}</code></pre>
<pre class="highlight"><code class="language-java">public interface NotificationRepository
        extends ReactiveMongoRepository&lt;Notification, String&gt; {
    Flux&lt;Notification&gt; findByUserIdOrderByCreatedAtDesc(String userId);
    Flux&lt;Notification&gt; findByUserIdAndReadFalse(String userId);
    Mono&lt;Long&gt; countByUserIdAndReadFalse(String userId);
}</code></pre>
<h3 id="1233">12.3.3 사용자별 알림 구독 관리</h3>
<p>실제 서비스에서는 모든 알림을 모든 사용자에게 브로드캐스팅하지 않는다. 사용자별로 구독을 관리하고, 해당 사용자에게만 알림을 전달해야 한다.</p>
<pre class="highlight"><code class="language-java">@Service
@Slf4j
public class NotificationService {

    private final NotificationRepository notificationRepository;
    private final ConcurrentHashMap&lt;String, Sinks.Many&lt;Notification&gt;&gt; userSinks =
        new ConcurrentHashMap&lt;&gt;();

    public NotificationService(NotificationRepository notificationRepository) {
        this.notificationRepository = notificationRepository;
    }

    /**
     * 사용자별 알림 스트림을 구독한다.
     */
    public Flux&lt;ServerSentEvent&lt;Notification&gt;&gt; subscribe(String userId) {
        Sinks.Many&lt;Notification&gt; userSink = userSinks.computeIfAbsent(userId,
            key -&gt; {
                log.info("사용자 {} 알림 구독 생성", key);
                return Sinks.many().multicast().onBackpressureBuffer(128);
            });

        return userSink.asFlux()
            .map(notification -&gt; ServerSentEvent.&lt;Notification&gt;builder()
                .id(notification.getId())
                .event(notification.getType())
                .data(notification)
                .build());
    }

    /**
     * 특정 사용자에게 알림을 전송한다.
     * MongoDB에 저장하고, 접속 중이면 SSE로 실시간 전달한다.
     */
    public Mono&lt;Notification&gt; sendNotification(Notification notification) {
        notification.setCreatedAt(LocalDateTime.now());
        notification.setRead(false);

        return notificationRepository.save(notification)
            .doOnSuccess(saved -&gt; {
                Sinks.Many&lt;Notification&gt; userSink =
                    userSinks.get(saved.getUserId());
                if (userSink != null) {
                    Sinks.EmitResult result = userSink.tryEmitNext(saved);
                    if (result.isFailure()) {
                        log.warn("사용자 {} 알림 전송 실패: {}",
                            saved.getUserId(), result);
                    }
                } else {
                    log.debug("사용자 {} 미접속 상태, 알림은 DB에만 저장됨",
                        saved.getUserId());
                }
            });
    }

    public Mono&lt;Long&gt; getUnreadCount(String userId) {
        return notificationRepository.countByUserIdAndReadFalse(userId);
    }

    public Mono&lt;Notification&gt; markAsRead(String notificationId) {
        return notificationRepository.findById(notificationId)
            .map(notification -&gt; {
                notification.setRead(true);
                return notification;
            })
            .flatMap(notificationRepository::save);
    }

    /**
     * 사용자의 SSE 연결이 해제될 때 호출된다.
     */
    public void removeSubscription(String userId) {
        Sinks.Many&lt;Notification&gt; removed = userSinks.remove(userId);
        if (removed != null) {
            removed.tryEmitComplete();
            log.info("사용자 {} 알림 구독 해제", userId);
        }
    }
}</code></pre>
<h3 id="1234-sse">12.3.4 알림 SSE 컨트롤러</h3>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/notifications")
@RequiredArgsConstructor
@Slf4j
public class NotificationController {

    private final NotificationService notificationService;

    @GetMapping(value = "/stream/{userId}",
                produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux&lt;ServerSentEvent&lt;Notification&gt;&gt; streamNotifications(
            @PathVariable String userId) {

        log.info("SSE 연결: userId={}", userId);

        // 실시간 알림 스트림
        Flux&lt;ServerSentEvent&lt;Notification&gt;&gt; notificationStream =
            notificationService.subscribe(userId);

        // 30초마다 하트비트 전송 (프록시/로드밸런서 타임아웃 방지)
        Flux&lt;ServerSentEvent&lt;Notification&gt;&gt; heartbeat =
            Flux.interval(Duration.ofSeconds(30))
                .map(tick -&gt; ServerSentEvent.&lt;Notification&gt;builder()
                    .comment("heartbeat")
                    .build());

        return Flux.merge(notificationStream, heartbeat)
            .doOnCancel(() -&gt; {
                log.info("SSE 연결 해제: userId={}", userId);
                notificationService.removeSubscription(userId);
            });
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono&lt;Notification&gt; sendNotification(
            @RequestBody Notification notification) {
        return notificationService.sendNotification(notification);
    }

    @PatchMapping("/{notificationId}/read")
    public Mono&lt;Notification&gt; markAsRead(
            @PathVariable String notificationId) {
        return notificationService.markAsRead(notificationId);
    }
}</code></pre>
<h3 id="1235">12.3.5 연결 해제 처리와 리소스 정리</h3>
<p>SSE 연결이 종료되는 경우는 다음과 같다.</p>
<ol>
<li><strong>클라이언트가 연결을 닫는 경우</strong>: <code>EventSource.close()</code> 호출 또는 브라우저 탭 닫기</li>
<li><strong>서버에서 스트림을 완료하는 경우</strong>: <code>Flux</code>가 <code>onComplete</code> 또는 <code>onError</code> 신호를 발생</li>
<li><strong>네트워크 문제</strong>: 연결이 예기치 않게 끊어지는 경우</li>
<li><strong>프록시/로드밸런서 타임아웃</strong>: 일정 시간 동안 데이터가 전송되지 않으면 연결이 종료</li>
</ol>
<p>각 상황에 대한 처리는 <code>doFinally</code>를 활용한다. <code>doFinally</code>는 <code>onComplete</code>, <code>onError</code>, <code>cancel</code> 모든 종료 신호에 대해 실행되므로, 리소스 정리에 가장 적합하다.</p>
<pre class="highlight"><code class="language-java">@GetMapping(value = "/stream/{userId}",
            produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;ServerSentEvent&lt;Notification&gt;&gt; streamWithCleanup(
        @PathVariable String userId) {

    return notificationService.subscribe(userId)
        .timeout(Duration.ofHours(1))
        .onErrorResume(TimeoutException.class, e -&gt; {
            log.info("SSE 타임아웃: userId={}", userId);
            return Flux.empty();
        })
        .doFinally(signalType -&gt; {
            log.info("SSE 스트림 종료: userId={}, signal={}", userId, signalType);
            notificationService.removeSubscription(userId);
        });
}</code></pre>
<h3 id="1236">12.3.6 알림 발행 연동 예제</h3>
<p>게시글에 댓글이 달릴 때 알림을 전송하는 시나리오를 구현한다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class CommentService {

    private final CommentRepository commentRepository;
    private final PostRepository postRepository;
    private final NotificationService notificationService;

    public Mono&lt;Comment&gt; addComment(String postId, CommentRequest request) {
        Comment comment = Comment.builder()
            .postId(postId)
            .authorId(request.getAuthorId())
            .authorName(request.getAuthorName())
            .content(request.getContent())
            .createdAt(LocalDateTime.now())
            .build();

        return commentRepository.save(comment)
            .flatMap(saved -&gt; postRepository.findById(postId)
                .flatMap(post -&gt; {
                    if (!post.getAuthorId().equals(request.getAuthorId())) {
                        Notification notification = Notification.builder()
                            .userId(post.getAuthorId())
                            .type("COMMENT")
                            .title("새 댓글")
                            .message(request.getAuthorName() + "님이 '"
                                + post.getTitle() + "'에 댓글을 남겼습니다.")
                            .metadata(Map.of(
                                "postId", postId,
                                "commentId", saved.getId()))
                            .build();
                        return notificationService.sendNotification(notification)
                            .thenReturn(saved);
                    }
                    return Mono.just(saved);
                }));
    }
}</code></pre>
<p>11장에서 다룬 JWT 인증과 연동하면, <code>ReactiveSecurityContextHolder</code>에서 현재 사용자를 꺼내어 인증된 사용자 전용 SSE 구독을 구현할 수도 있다.</p>
<pre class="highlight"><code class="language-java">@GetMapping(value = "/stream/me",
            produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;ServerSentEvent&lt;Notification&gt;&gt; streamMyNotifications() {
    return ReactiveSecurityContextHolder.getContext()
        .map(ctx -&gt; ctx.getAuthentication().getName())
        .flatMapMany(username -&gt; notificationService.subscribe(username)
            .doFinally(signal -&gt;
                notificationService.removeSubscription(username)));
}</code></pre>
<hr>
<h2 id="124-mongodb-change-streams-sse">12.4 MongoDB Change Streams + SSE 연동</h2>
<h3 id="1241-change-streams">12.4.1 Change Streams 개요</h3>
<p>MongoDB Change Streams는 컬렉션, 데이터베이스, 또는 전체 클러스터의 데이터 변경 사항을 실시간으로 감시하는 기능이다. 8장에서 기본 개념을 다루었으며, 이번 절에서는 이를 SSE와 연동하여 데이터 변경 사항을 클라이언트에 실시간으로 전달하는 방법에 초점을 맞춘다.</p>
<ul>
<li><strong>이벤트 타입</strong>: <code>insert</code>, <code>update</code>, <code>replace</code>, <code>delete</code>, <code>invalidate</code></li>
<li><strong>Resume Token</strong>: 연결이 끊어진 지점부터 이벤트를 다시 수신할 수 있다</li>
<li><strong>필터링</strong>: Aggregation Pipeline을 사용하여 관심 있는 변경만 수신 가능</li>
<li><strong>요구사항</strong>: Replica Set 또는 Sharded Cluster 환경에서만 동작한다</li>
</ul>
<h3 id="1242-reactivemongotemplate-changestream">12.4.2 ReactiveMongoTemplate의 changeStream()</h3>
<p>Spring Data MongoDB의 <code>ReactiveMongoTemplate</code>은 <code>changeStream()</code> 메서드를 통해 Change Streams를 <code>Flux</code>로 변환한다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
@Slf4j
public class ProductChangeStreamService {

    private final ReactiveMongoTemplate mongoTemplate;

    public Flux&lt;ChangeStreamEvent&lt;Product&gt;&gt; watchProducts() {
        return mongoTemplate.changeStream("products",
                ChangeStreamOptions.builder()
                    .filter(Aggregation.newAggregation(
                        Aggregation.match(Criteria.where("operationType")
                            .in("insert", "update", "replace"))))
                    .build(),
                Product.class)
            .doOnNext(event -&gt; log.info("변경 감지: type={}, id={}",
                event.getOperationType(), event.getBody()));
    }

    public Flux&lt;ChangeStreamEvent&lt;Product&gt;&gt; watchProductsByCategory(
            String category) {
        return mongoTemplate.changeStream("products",
                ChangeStreamOptions.builder()
                    .filter(Aggregation.newAggregation(
                        Aggregation.match(Criteria.where("operationType")
                            .in("insert", "update", "replace")
                            .and("fullDocument.category").is(category))))
                    .build(),
                Product.class);
    }
}</code></pre>
<h3 id="1243-change-streams-sse">12.4.3 Change Streams를 SSE로 전달</h3>
<p>Change Streams에서 수신한 이벤트를 SSE를 통해 클라이언트에 전달하는 컨트롤러를 구현한다.</p>
<pre class="highlight"><code class="language-java">@Data
@Builder
public class ProductChangeEvent {
    private String operationType;
    private Product product;
    private Instant timestamp;
}</code></pre>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/products")
@RequiredArgsConstructor
@Slf4j
public class ProductSseController {

    private final ProductChangeStreamService changeStreamService;

    @GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux&lt;ServerSentEvent&lt;ProductChangeEvent&gt;&gt; streamProductChanges() {

        Flux&lt;ServerSentEvent&lt;ProductChangeEvent&gt;&gt; changeStream =
            changeStreamService.watchProducts()
                .map(event -&gt; {
                    ProductChangeEvent payload = ProductChangeEvent.builder()
                        .operationType(event.getOperationType().getValue())
                        .product(event.getBody())
                        .timestamp(Instant.now())
                        .build();

                    return ServerSentEvent.&lt;ProductChangeEvent&gt;builder()
                        .id(event.getResumeToken() != null
                            ? event.getResumeToken().toJson() : null)
                        .event("product-" + event.getOperationType().getValue())
                        .data(payload)
                        .build();
                });

        Flux&lt;ServerSentEvent&lt;ProductChangeEvent&gt;&gt; heartbeat =
            Flux.interval(Duration.ofSeconds(30))
                .map(tick -&gt; ServerSentEvent.&lt;ProductChangeEvent&gt;builder()
                    .comment("heartbeat")
                    .build());

        return Flux.merge(changeStream, heartbeat)
            .doOnCancel(() -&gt; log.info("상품 변경 SSE 연결 해제"));
    }
}</code></pre>
<h3 id="1244-resume-token">12.4.4 Resume Token을 활용한 이벤트 복구</h3>
<p>클라이언트가 재연결할 때 놓친 이벤트를 복구하려면 Resume Token을 활용한다. SSE의 <code>id</code> 필드에 Resume Token을 설정하면, 브라우저가 재연결 시 <code>Last-Event-ID</code> 헤더로 자동 전송한다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
@Slf4j
public class ResumableChangeStreamService {

    private final ReactiveMongoTemplate mongoTemplate;

    public Flux&lt;ChangeStreamEvent&lt;Product&gt;&gt; watchProducts(String resumeToken) {
        ChangeStreamOptions.ChangeStreamOptionsBuilder optionsBuilder =
            ChangeStreamOptions.builder()
                .filter(Aggregation.newAggregation(
                    Aggregation.match(Criteria.where("operationType")
                        .in("insert", "update", "replace"))));

        if (resumeToken != null &amp;&amp; !resumeToken.isEmpty()) {
            try {
                BsonDocument token = BsonDocument.parse(resumeToken);
                optionsBuilder.resumeAfter(token);
                log.info("Resume Token으로 변경 스트림 재개");
            } catch (Exception e) {
                log.warn("유효하지 않은 Resume Token, 처음부터 시작");
            }
        }

        return mongoTemplate.changeStream("products",
            optionsBuilder.build(), Product.class);
    }
}</code></pre>
<pre class="highlight"><code class="language-java">@GetMapping(value = "/stream/resumable",
            produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;ServerSentEvent&lt;ProductChangeEvent&gt;&gt; streamResumable(
        @RequestHeader(value = "Last-Event-ID", required = false)
        String lastEventId) {

    return resumableChangeStreamService.watchProducts(lastEventId)
        .map(event -&gt; {
            String tokenJson = event.getResumeToken() != null
                ? event.getResumeToken().toJson() : null;

            ProductChangeEvent payload = ProductChangeEvent.builder()
                .operationType(event.getOperationType().getValue())
                .product(event.getBody())
                .timestamp(Instant.now())
                .build();

            return ServerSentEvent.&lt;ProductChangeEvent&gt;builder()
                .id(tokenJson)
                .event("product-change")
                .data(payload)
                .build();
        });
}</code></pre>
<p>클라이언트에서는 별도 처리 없이 <code>EventSource</code>가 재연결 시 <code>Last-Event-ID</code>를 자동 전송한다.</p>
<pre class="highlight"><code class="language-javascript">const es = new EventSource('/api/products/stream/resumable');
es.addEventListener('product-change', (e) =&gt; {
    console.log('이벤트 ID:', e.lastEventId);
    const change = JSON.parse(e.data);
    applyChange(change);
});</code></pre>
<h3 id="1245">12.4.5 실시간 데이터 동기화 패턴</h3>
<p>Change Streams + SSE를 조합하면 여러 클라이언트 간의 실시간 데이터 동기화를 구현할 수 있다. 한 사용자가 데이터를 수정하면, 같은 화면을 보고 있는 다른 사용자에게 즉시 변경 사항이 반영되는 구조다. 구현의 핵심은 다음과 같다.</p>
<ol>
<li><strong><code>@PostConstruct</code>에서 Change Stream 시작</strong>: 애플리케이션 기동 시 감시할 컬렉션에 대해 Change Stream을 구독한다.</li>
<li><strong>세션별 Sink 관리</strong>: <code>ConcurrentHashMap&lt;String, Sinks.Many&lt;ChangeEvent&gt;&gt;</code>로 세션마다 독립적인 Sink를 생성한다.</li>
<li><strong>이벤트 분배</strong>: Change Stream에서 수신한 이벤트를 해당 컬렉션을 구독 중인 모든 세션의 Sink에 <code>tryEmitNext</code>로 전달한다.</li>
<li><strong>SSE 엔드포인트</strong>: <code>GET /api/sync/stream/{collection}?sessionId=xxx</code> 형태로 클라이언트가 특정 컬렉션의 변경 사항을 구독한다.</li>
</ol>
<p>이 패턴은 12.3절의 사용자별 알림 구독과 동일한 <code>ConcurrentHashMap</code> + <code>Sinks</code> 구조를 컬렉션 단위로 확장한 것이다.</p>
<h3 id="1246">12.4.6 프로덕션 환경 고려사항</h3>
<p>SSE를 프로덕션 환경에서 운영할 때 반드시 고려해야 할 사항들을 정리한다.</p>
<p><strong>1. 연결 수 관리</strong></p>
<p>SSE는 HTTP 연결을 지속적으로 유지하므로, 동시 연결 수가 많아지면 서버 리소스가 소진될 수 있다. <code>AtomicInteger</code>로 활성 연결 수를 추적하고 최대치를 제한하는 것이 좋다.</p>
<p><strong>2. 프록시/로드밸런서 설정</strong></p>
<p>Nginx 등의 리버스 프록시를 사용할 경우, SSE 연결이 조기에 종료되지 않도록 버퍼링을 비활성화하고 타임아웃을 늘려야 한다.</p>
<pre class="highlight"><code class="language-nginx">location /api/sse/ {
    proxy_pass http://backend;
    proxy_http_version 1.1;
    proxy_set_header Connection '';
    proxy_buffering off;
    proxy_cache off;
    proxy_read_timeout 86400s;
    chunked_transfer_encoding off;
}</code></pre>
<p><strong>3. 하트비트</strong></p>
<p>프록시의 유휴 타임아웃을 방지하기 위해 주기적으로 하트비트를 전송한다. SSE의 주석(<code>:</code> 접두사)을 사용하면 클라이언트 측 이벤트 핸들러가 트리거되지 않는다.</p>
<p><strong>4. 에러 복구 전략</strong></p>
<p>Change Stream이 중단되었을 때 자동으로 재시작하는 전략이 필요하다. <code>retryWhen</code>에 지수 백오프를 적용하면 일시적 장애에서 안정적으로 복구할 수 있다.</p>
<pre class="highlight"><code class="language-java">private void watchCollectionWithRetry(String collectionName) {
    mongoTemplate.changeStream(collectionName,
            ChangeStreamOptions.empty(), Document.class)
        .doOnError(e -&gt; log.error("{} Change Stream 오류", collectionName, e))
        .retryWhen(Retry.backoff(Long.MAX_VALUE, Duration.ofSeconds(1))
            .maxBackoff(Duration.ofMinutes(1))
            .doBeforeRetry(signal -&gt; log.warn("{} Change Stream 재시도 #{}",
                collectionName, signal.totalRetries())))
        .subscribe(this::processChangeEvent);
}</code></pre>
<hr>
<h2 id="_1">요약</h2>
<p>이번 장에서 다룬 핵심 내용을 정리한다.</p>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 내용</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SSE 프로토콜</strong></td>
<td>서버에서 클라이언트로의 단방향 HTTP 기반 실시간 스트리밍, 자동 재연결, 이벤트 ID 지원</td>
</tr>
<tr>
<td><strong>SSE vs WebSocket</strong></td>
<td>SSE는 단방향/HTTP 기반으로 인프라 호환성이 높고, WebSocket은 양방향/바이너리 지원</td>
</tr>
<tr>
<td><strong>Flux + SSE</strong></td>
<td><code>TEXT_EVENT_STREAM</code> 미디어 타입과 <code>ServerSentEvent&lt;T&gt;</code> 클래스로 SSE 엔드포인트 구현</td>
</tr>
<tr>
<td><strong>Sinks 브로드캐스팅</strong></td>
<td><code>Sinks.many().multicast()</code>로 이벤트를 발행하고 여러 SSE 구독자에게 실시간 전달</td>
</tr>
<tr>
<td><strong>사용자별 알림</strong></td>
<td><code>ConcurrentHashMap</code>으로 사용자별 Sink를 관리하여 개인화된 알림 스트림 구현</td>
</tr>
<tr>
<td><strong>연결 해제 처리</strong></td>
<td><code>doOnCancel</code>, <code>doFinally</code>로 SSE 연결 종료 시 리소스 정리</td>
</tr>
<tr>
<td><strong>Change Streams + SSE</strong></td>
<td>MongoDB 데이터 변경을 감지하여 SSE로 실시간 전달, Resume Token으로 이벤트 복구</td>
</tr>
<tr>
<td><strong>실시간 데이터 동기화</strong></td>
<td>Change Streams + Sinks + SSE를 조합하여 여러 클라이언트 간 데이터 동기화</td>
</tr>
</tbody>
</table>
<p>다음 장에서는 WebSocket을 활용한 양방향 실시간 통신과 채팅 애플리케이션 구현을 다룬다.</p>
<hr>
<h1 id="chapter-13-websocket">Chapter 13. WebSocket</h1>
<p>실시간 양방향 통신이 필요한 채팅, 게임, 실시간 대시보드 등의 애플리케이션에서는 HTTP의 요청-응답 모델만으로는 한계가 있다. WebSocket은 클라이언트와 서버 간에 지속적인 양방향 통신 채널을 제공하며, Spring WebFlux는 리액티브 스트림 기반의 WebSocket 지원을 내장하고 있다. 이번 장에서는 WebSocket 프로토콜의 동작 원리를 이해하고, WebFlux에서 WebSocket 핸들러를 구현하며, 실시간 채팅 애플리케이션을 구축하고, 세션 관리 전략까지 단계별로 다룬다.</p>
<hr>
<h2 id="131-websocket">13.1 WebSocket 프로토콜 이해</h2>
<h3 id="1311-websocket">13.1.1 WebSocket이란?</h3>
<p>WebSocket은 RFC 6455로 표준화된 통신 프로토콜로, 단일 TCP 연결 위에서 클라이언트와 서버 간 <strong>전이중(Full-Duplex) 양방향 통신</strong>을 가능하게 한다. 기존 HTTP는 클라이언트가 요청을 보내야만 서버가 응답하는 반이중 구조인 반면, WebSocket은 연결 수립 후 양쪽 모두 자유롭게 메시지를 주고받을 수 있다.</p>
<table>
<thead>
<tr>
<th>특징</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>양방향 통신</strong></td>
<td>클라이언트와 서버 모두 독립적으로 메시지를 전송할 수 있다</td>
</tr>
<tr>
<td><strong>지속 연결</strong></td>
<td>한 번 연결이 수립되면 명시적으로 종료할 때까지 유지된다</td>
</tr>
<tr>
<td><strong>낮은 오버헤드</strong></td>
<td>HTTP 헤더 없이 최소 2바이트의 프레임 헤더로 메시지를 교환한다</td>
</tr>
<tr>
<td><strong>실시간성</strong></td>
<td>폴링 없이 서버에서 즉시 클라이언트로 데이터를 전송할 수 있다</td>
</tr>
</tbody>
</table>
<h3 id="1312-http">13.1.2 HTTP 핸드셰이크</h3>
<p>WebSocket 연결은 HTTP Upgrade 핸드셰이크로 시작된다.</p>
<p><strong>클라이언트 요청:</strong></p>
<pre class="highlight"><code>GET /ws/chat HTTP/1.1
Host: localhost:8080
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13</code></pre>
<p><strong>서버 응답:</strong></p>
<pre class="highlight"><code>HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</code></pre>
<p>핸드셰이크 과정은 다음과 같다.</p>
<ol>
<li>클라이언트가 <code>Upgrade: websocket</code> 헤더를 포함한 HTTP GET 요청을 전송한다.</li>
<li>서버는 <code>Sec-WebSocket-Key</code>에 매직 GUID(<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>)를 연결하여 SHA-1 해시를 생성하고 <code>Sec-WebSocket-Accept</code>에 포함한다.</li>
<li>서버가 <code>101 Switching Protocols</code>를 반환하면 TCP 연결은 유지된 채 프로토콜이 WebSocket으로 전환된다.</li>
<li>이후부터 양쪽 모두 WebSocket 프레임으로 메시지를 교환한다.</li>
</ol>
<h3 id="1313">13.1.3 프레임 구조</h3>
<p>핸드셰이크 완료 후 데이터는 프레임(Frame) 단위로 교환된다. 주요 Opcode는 다음과 같다.</p>
<table>
<thead>
<tr>
<th>Opcode</th>
<th>의미</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x1</code></td>
<td>텍스트 프레임 (UTF-8)</td>
</tr>
<tr>
<td><code>0x2</code></td>
<td>바이너리 프레임</td>
</tr>
<tr>
<td><code>0x8</code></td>
<td>연결 종료 (Close)</td>
</tr>
<tr>
<td><code>0x9</code></td>
<td>Ping</td>
</tr>
<tr>
<td><code>0xA</code></td>
<td>Pong</td>
</tr>
</tbody>
</table>
<p>각 프레임은 FIN 비트(마지막 프레임 여부), Opcode(프레임 유형), MASK 비트(클라이언트-&gt;서버는 반드시 마스킹), Payload 길이, 실제 데이터로 구성된다. 텍스트 프레임은 채팅 메시지 같은 문자열 데이터에, 바이너리 프레임은 이미지나 파일 전송에 사용한다.</p>
<h3 id="1314-websocket-vs-sse-vs-long-polling">13.1.4 WebSocket vs SSE vs Long Polling 비교</h3>
<table>
<thead>
<tr>
<th>특성</th>
<th>WebSocket</th>
<th>SSE</th>
<th>Long Polling</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>통신 방향</strong></td>
<td>양방향 (Full-Duplex)</td>
<td>단방향 (서버-&gt;클라이언트)</td>
<td>단방향</td>
</tr>
<tr>
<td><strong>프로토콜</strong></td>
<td>ws:// / wss://</td>
<td>HTTP</td>
<td>HTTP</td>
</tr>
<tr>
<td><strong>오버헤드</strong></td>
<td>매우 낮음 (2-14바이트)</td>
<td>낮음</td>
<td>높음 (매번 HTTP 헤더)</td>
</tr>
<tr>
<td><strong>자동 재연결</strong></td>
<td>직접 구현 필요</td>
<td>EventSource 자동 지원</td>
<td>직접 구현 필요</td>
</tr>
<tr>
<td><strong>바이너리 전송</strong></td>
<td>지원</td>
<td>미지원</td>
<td>미지원</td>
</tr>
</tbody>
</table>
<p>Chapter 12에서 다룬 SSE는 단방향 스트리밍에 적합하지만, 채팅처럼 양방향 통신이 필요한 시나리오에서는 WebSocket이 필수적이다. 실시간 알림처럼 서버 푸시만 필요하면 SSE가 더 간단하다.</p>
<hr>
<h2 id="132-webflux-websocket">13.2 WebFlux에서 WebSocket 핸들러 구현</h2>
<h3 id="1321">13.2.1 의존성 설정</h3>
<p>Spring WebFlux에는 WebSocket 지원이 기본 포함되어 있으므로 별도의 의존성이 필요 없다.</p>
<pre class="highlight"><code class="language-groovy">dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    implementation 'org.springframework.boot:spring-boot-starter-data-mongodb-reactive'
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
}</code></pre>
<h3 id="1322-websockethandler">13.2.2 WebSocketHandler 인터페이스</h3>
<p>Spring WebFlux의 WebSocket 지원은 <code>WebSocketHandler</code> 인터페이스를 중심으로 설계되어 있다.</p>
<pre class="highlight"><code class="language-java">public interface WebSocketHandler {
    Mono&lt;Void&gt; handle(WebSocketSession session);
}</code></pre>
<p><code>handle()</code> 메서드는 WebSocket 연결 수립 시 호출되며, 반환하는 <code>Mono&lt;Void&gt;</code>가 완료되면 연결이 종료된다. <code>WebSocketSession</code>은 <code>receive()</code>로 수신 메시지 스트림(<code>Flux&lt;WebSocketMessage&gt;</code>)을, <code>send()</code>로 송신 스트림을 제공한다.</p>
<p>가장 기본적인 에코 핸들러를 구현한다.</p>
<pre class="highlight"><code class="language-java">@Component
@Slf4j
public class EchoWebSocketHandler implements WebSocketHandler {

    @Override
    public Mono&lt;Void&gt; handle(WebSocketSession session) {
        log.info("WebSocket 연결 수립: sessionId={}", session.getId());

        Flux&lt;WebSocketMessage&gt; output = session.receive()
            .map(message -&gt; {
                String payload = message.getPayloadAsText();
                log.info("수신 메시지: {}", payload);
                return session.textMessage("Echo: " + payload);
            });

        return session.send(output)
            .doFinally(signal -&gt;
                log.info("WebSocket 연결 종료: sessionId={}", session.getId()));
    }
}</code></pre>
<h3 id="1323-handlermapping">13.2.3 HandlerMapping 설정</h3>
<p>WebSocket 핸들러를 URL 경로에 매핑하려면 <code>HandlerMapping</code>과 <code>WebSocketHandlerAdapter</code>를 설정한다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class WebSocketConfig {

    @Bean
    public HandlerMapping webSocketHandlerMapping(EchoWebSocketHandler echoHandler) {
        Map&lt;String, WebSocketHandler&gt; handlerMap = Map.of("/ws/echo", echoHandler);

        SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
        mapping.setUrlMap(handlerMap);
        mapping.setOrder(Ordered.HIGHEST_PRECEDENCE);
        return mapping;
    }

    @Bean
    public WebSocketHandlerAdapter webSocketHandlerAdapter() {
        return new WebSocketHandlerAdapter();
    }
}</code></pre>
<p><code>order</code>를 <code>Ordered.HIGHEST_PRECEDENCE</code>로 설정하여 다른 핸들러 매핑보다 먼저 WebSocket 요청을 처리한다.</p>
<h3 id="1324">13.2.4 메시지 송수신 패턴</h3>
<p>WebSocket 메시지 송수신은 세 가지 패턴으로 나눌 수 있다.</p>
<p><strong>패턴 1: 수신 전용</strong> -- 클라이언트 메시지를 받아 처리만 한다.</p>
<pre class="highlight"><code class="language-java">public Mono&lt;Void&gt; handle(WebSocketSession session) {
    return session.receive()
        .doOnNext(msg -&gt; log.info("수신: {}", msg.getPayloadAsText()))
        .then();
}</code></pre>
<p><strong>패턴 2: 송신 전용</strong> -- 서버에서 클라이언트로 일방적으로 푸시한다.</p>
<pre class="highlight"><code class="language-java">public Mono&lt;Void&gt; handle(WebSocketSession session) {
    Flux&lt;WebSocketMessage&gt; output = Flux.interval(Duration.ofSeconds(1))
        .map(tick -&gt; session.textMessage("서버 시간: " + LocalDateTime.now()));
    return session.send(output);
}</code></pre>
<p><strong>패턴 3: 양방향</strong> -- <code>Mono.zip()</code>으로 수신과 송신을 동시에 구독한다.</p>
<pre class="highlight"><code class="language-java">public Mono&lt;Void&gt; handle(WebSocketSession session) {
    Mono&lt;Void&gt; input = session.receive()
        .doOnNext(msg -&gt; processMessage(msg.getPayloadAsText()))
        .then();

    Mono&lt;Void&gt; output = session.send(
        externalEventSource().map(event -&gt; session.textMessage(event)));

    return Mono.zip(input, output).then();
}</code></pre>
<h3 id="1325-json">13.2.5 JSON 메시지 처리</h3>
<p>실제 애플리케이션에서는 JSON 형식의 구조화된 메시지를 교환한다.</p>
<pre class="highlight"><code class="language-java">@Data @Builder @NoArgsConstructor @AllArgsConstructor
public class ChatMessage {
    private String type;       // MESSAGE, JOIN, LEAVE
    private String roomId;
    private String sender;
    private String content;
    private LocalDateTime timestamp;
}</code></pre>
<pre class="highlight"><code class="language-java">@Component
@RequiredArgsConstructor @Slf4j
public class JsonWebSocketHandler implements WebSocketHandler {

    private final ObjectMapper objectMapper;

    @Override
    public Mono&lt;Void&gt; handle(WebSocketSession session) {
        Flux&lt;WebSocketMessage&gt; output = session.receive()
            .map(WebSocketMessage::getPayloadAsText)
            .flatMap(payload -&gt; {
                try {
                    ChatMessage msg = objectMapper.readValue(payload, ChatMessage.class);
                    msg.setTimestamp(LocalDateTime.now());
                    return Mono.just(session.textMessage(
                        objectMapper.writeValueAsString(msg)));
                } catch (JsonProcessingException e) {
                    log.error("JSON 파싱 오류: {}", e.getMessage());
                    return Mono.empty();
                }
            });
        return session.send(output);
    }
}</code></pre>
<p>JavaScript 클라이언트로 동작을 확인한다.</p>
<pre class="highlight"><code class="language-javascript">const ws = new WebSocket('ws://localhost:8080/ws/echo');
ws.onopen = () =&gt; ws.send('Hello WebSocket!');
ws.onmessage = (event) =&gt; console.log('수신:', event.data);
ws.onclose = (event) =&gt; console.log('종료:', event.code);</code></pre>
<hr>
<h2 id="133">13.3 실시간 채팅 애플리케이션 구축</h2>
<p>WebSocket과 MongoDB를 결합하여 다중 채팅방을 지원하는 실시간 채팅 애플리케이션을 구축한다.</p>
<h3 id="1331">13.3.1 도메인 모델과 리포지토리</h3>
<pre class="highlight"><code class="language-java">@Document(collection = "chat_rooms")
@Data @Builder @NoArgsConstructor @AllArgsConstructor
public class ChatRoom {
    @Id private String id;
    private String name;
    private String description;
    private String createdBy;
    private Set&lt;String&gt; participants;
    private LocalDateTime createdAt;
}</code></pre>
<pre class="highlight"><code class="language-java">@Document(collection = "chat_messages")
@Data @Builder @NoArgsConstructor @AllArgsConstructor
public class ChatMessageDocument {
    @Id private String id;
    @Indexed private String roomId;
    private String sender;
    private String content;
    private MessageType type;
    private LocalDateTime timestamp;

    public enum MessageType { MESSAGE, JOIN, LEAVE, SYSTEM }
}</code></pre>
<pre class="highlight"><code class="language-java">public interface ChatRoomRepository extends ReactiveMongoRepository&lt;ChatRoom, String&gt; {
    Flux&lt;ChatRoom&gt; findByParticipantsContaining(String username);
}

public interface ChatMessageRepository
        extends ReactiveMongoRepository&lt;ChatMessageDocument, String&gt; {
    Flux&lt;ChatMessageDocument&gt; findByRoomIdOrderByTimestampDesc(
        String roomId, Pageable pageable);
    Flux&lt;ChatMessageDocument&gt; findByRoomIdAndTimestampAfterOrderByTimestampAsc(
        String roomId, LocalDateTime after);
}</code></pre>
<h3 id="1332">13.3.2 채팅방 관리 서비스</h3>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class ChatRoomService {

    private final ChatRoomRepository chatRoomRepository;

    public Mono&lt;ChatRoom&gt; createRoom(String name, String description,
                                      String createdBy) {
        ChatRoom room = ChatRoom.builder()
            .name(name).description(description).createdBy(createdBy)
            .participants(new HashSet&lt;&gt;(Set.of(createdBy)))
            .createdAt(LocalDateTime.now()).build();
        return chatRoomRepository.save(room);
    }

    public Flux&lt;ChatRoom&gt; getAllRooms() {
        return chatRoomRepository.findAll();
    }

    public Mono&lt;ChatRoom&gt; joinRoom(String roomId, String username) {
        return chatRoomRepository.findById(roomId)
            .flatMap(room -&gt; {
                room.getParticipants().add(username);
                return chatRoomRepository.save(room);
            });
    }

    public Mono&lt;ChatRoom&gt; leaveRoom(String roomId, String username) {
        return chatRoomRepository.findById(roomId)
            .flatMap(room -&gt; {
                room.getParticipants().remove(username);
                return chatRoomRepository.save(room);
            });
    }
}</code></pre>
<h3 id="1333">13.3.3 메시지 브로드캐스팅</h3>
<p>채팅 메시지를 같은 채팅방의 모든 세션에 브로드캐스팅하는 핵심 서비스를 구현한다. Reactor의 <code>Sinks</code>를 사용하여 메시지를 발행하고, 각 세션이 이를 구독하는 구조로 설계한다.</p>
<pre class="highlight"><code class="language-java">@Service
@Slf4j
public class ChatMessageBroker {

    private final Map&lt;String, Sinks.Many&lt;ChatMessageDocument&gt;&gt; roomSinks =
        new ConcurrentHashMap&lt;&gt;();

    public Sinks.Many&lt;ChatMessageDocument&gt; getRoomSink(String roomId) {
        return roomSinks.computeIfAbsent(roomId,
            id -&gt; Sinks.many().multicast().onBackpressureBuffer(256));
    }

    public void publish(String roomId, ChatMessageDocument message) {
        Sinks.EmitResult result = getRoomSink(roomId).tryEmitNext(message);
        if (result.isFailure()) {
            log.warn("메시지 발행 실패: roomId={}, result={}", roomId, result);
        }
    }

    public Flux&lt;ChatMessageDocument&gt; subscribe(String roomId) {
        return getRoomSink(roomId).asFlux();
    }

    public void removeRoom(String roomId) {
        Sinks.Many&lt;ChatMessageDocument&gt; removed = roomSinks.remove(roomId);
        if (removed != null) removed.tryEmitComplete();
    }
}</code></pre>
<p><code>Sinks.many().multicast().onBackpressureBuffer(256)</code>는 여러 구독자에게 동시에 메시지를 전달하는 Hot Publisher를 생성한다. 구독자가 처리하지 못한 메시지는 최대 256개까지 버퍼에 저장된다.</p>
<h3 id="1334">13.3.4 채팅 메시지 서비스</h3>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor @Slf4j
public class ChatMessageService {

    private final ChatMessageRepository chatMessageRepository;
    private final ChatMessageBroker messageBroker;

    public Mono&lt;ChatMessageDocument&gt; saveAndBroadcast(ChatMessageDocument message) {
        message.setTimestamp(LocalDateTime.now());
        return chatMessageRepository.save(message)
            .doOnSuccess(saved -&gt; messageBroker.publish(saved.getRoomId(), saved));
    }

    public Flux&lt;ChatMessageDocument&gt; getRecentMessages(String roomId, int limit) {
        return chatMessageRepository.findByRoomIdOrderByTimestampDesc(
            roomId, PageRequest.of(0, limit));
    }

    public Flux&lt;ChatMessageDocument&gt; getMessagesSince(
            String roomId, LocalDateTime since) {
        return chatMessageRepository
            .findByRoomIdAndTimestampAfterOrderByTimestampAsc(roomId, since);
    }
}</code></pre>
<h3 id="1335-websocket">13.3.5 채팅 WebSocket 핸들러</h3>
<p>서비스를 조합하여 채팅 전용 WebSocket 핸들러를 완성한다.</p>
<pre class="highlight"><code class="language-java">@Component
@RequiredArgsConstructor @Slf4j
public class ChatWebSocketHandler implements WebSocketHandler {

    private final ChatMessageService chatMessageService;
    private final ChatMessageBroker messageBroker;
    private final ObjectMapper objectMapper;

    @Override
    public Mono&lt;Void&gt; handle(WebSocketSession session) {
        URI uri = session.getHandshakeInfo().getUri();
        Map&lt;String, String&gt; params = parseQueryParams(uri);
        String roomId = params.get("roomId");
        String username = params.get("username");

        if (roomId == null || username == null) {
            return session.close(CloseStatus.POLICY_VIOLATION);
        }

        log.info("채팅 연결: roomId={}, username={}", roomId, username);

        // 입장 알림
        Mono&lt;Void&gt; joinNotification = createSystemMessage(
            roomId, username + "님이 입장했습니다.",
            ChatMessageDocument.MessageType.JOIN);

        // 수신: 클라이언트 메시지를 저장 및 브로드캐스트
        Mono&lt;Void&gt; input = session.receive()
            .flatMap(msg -&gt; handleIncoming(msg.getPayloadAsText(), roomId, username))
            .doFinally(signal -&gt; createSystemMessage(roomId,
                username + "님이 퇴장했습니다.",
                ChatMessageDocument.MessageType.LEAVE).subscribe())
            .then();

        // 송신: 채팅방 브로드캐스트 스트림 구독
        Flux&lt;WebSocketMessage&gt; output = messageBroker.subscribe(roomId)
            .mapNotNull(chatMsg -&gt; toWebSocketMessage(session, chatMsg));

        return joinNotification
            .then(Mono.zip(input, session.send(output)).then());
    }

    private Mono&lt;ChatMessageDocument&gt; handleIncoming(
            String payload, String roomId, String sender) {
        try {
            ChatMessage incoming = objectMapper.readValue(payload, ChatMessage.class);
            ChatMessageDocument doc = ChatMessageDocument.builder()
                .roomId(roomId).sender(sender).content(incoming.getContent())
                .type(ChatMessageDocument.MessageType.MESSAGE).build();
            return chatMessageService.saveAndBroadcast(doc);
        } catch (JsonProcessingException e) {
            log.error("메시지 파싱 오류: {}", e.getMessage());
            return Mono.empty();
        }
    }

    private Mono&lt;Void&gt; createSystemMessage(String roomId, String content,
                                            ChatMessageDocument.MessageType type) {
        ChatMessageDocument msg = ChatMessageDocument.builder()
            .roomId(roomId).sender("SYSTEM").content(content).type(type).build();
        return chatMessageService.saveAndBroadcast(msg).then();
    }

    private WebSocketMessage toWebSocketMessage(
            WebSocketSession session, ChatMessageDocument msg) {
        try {
            return session.textMessage(objectMapper.writeValueAsString(msg));
        } catch (JsonProcessingException e) {
            return null;
        }
    }

    private Map&lt;String, String&gt; parseQueryParams(URI uri) {
        Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
        String query = uri.getQuery();
        if (query == null) return params;
        for (String param : query.split("&amp;")) {
            String[] pair = param.split("=", 2);
            if (pair.length == 2) params.put(pair[0], pair[1]);
        }
        return params;
    }
}</code></pre>
<p>WebSocket 라우팅에 등록한다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class WebSocketConfig {
    @Bean
    public HandlerMapping webSocketHandlerMapping(ChatWebSocketHandler chatHandler) {
        SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
        mapping.setUrlMap(Map.of("/ws/chat", chatHandler));
        mapping.setOrder(Ordered.HIGHEST_PRECEDENCE);
        return mapping;
    }

    @Bean
    public WebSocketHandlerAdapter webSocketHandlerAdapter() {
        return new WebSocketHandlerAdapter();
    }
}</code></pre>
<h3 id="1336-rest-api">13.3.6 채팅방 REST API</h3>
<p>WebSocket 연결 전 채팅방을 관리하기 위한 REST API를 제공한다.</p>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/chat/rooms")
@RequiredArgsConstructor
public class ChatRoomController {

    private final ChatRoomService chatRoomService;
    private final ChatMessageService chatMessageService;

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono&lt;ChatRoom&gt; createRoom(@RequestBody CreateRoomRequest request) {
        return chatRoomService.createRoom(
            request.getName(), request.getDescription(), request.getCreatedBy());
    }

    @GetMapping
    public Flux&lt;ChatRoom&gt; getAllRooms() {
        return chatRoomService.getAllRooms();
    }

    @GetMapping("/{roomId}/messages")
    public Flux&lt;ChatMessageDocument&gt; getRecentMessages(
            @PathVariable String roomId,
            @RequestParam(defaultValue = "50") int limit) {
        return chatMessageService.getRecentMessages(roomId, limit);
    }

    @PostMapping("/{roomId}/join")
    public Mono&lt;ChatRoom&gt; joinRoom(@PathVariable String roomId,
                                    @RequestParam String username) {
        return chatRoomService.joinRoom(roomId, username);
    }
}</code></pre>
<h3 id="1337">13.3.7 이전 메시지 로드</h3>
<p>클라이언트가 채팅방에 접속할 때 이전 메시지를 로드하는 두 가지 전략이 있다.</p>
<p><strong>전략 1: REST API를 통한 초기 로드</strong> -- WebSocket 연결 전에 REST API로 최근 메시지를 가져온다.</p>
<pre class="highlight"><code class="language-javascript">async function joinChatRoom(roomId, username) {
    const res = await fetch(`/api/chat/rooms/${roomId}/messages?limit=50`);
    const history = await res.json();
    history.reverse().forEach(msg =&gt; displayMessage(msg));

    const ws = new WebSocket(
        `ws://localhost:8080/ws/chat?roomId=${roomId}&amp;username=${username}`);
    ws.onmessage = (e) =&gt; displayMessage(JSON.parse(e.data));
}</code></pre>
<p><strong>전략 2: WebSocket 내 히스토리 전송</strong> -- <code>concatWith()</code>로 히스토리 후 실시간 스트림을 연결한다.</p>
<pre class="highlight"><code class="language-java">Flux&lt;WebSocketMessage&gt; history = chatMessageService.getRecentMessages(roomId, 50)
    .mapNotNull(msg -&gt; toWebSocketMessage(session, msg));
Flux&lt;WebSocketMessage&gt; live = messageBroker.subscribe(roomId)
    .mapNotNull(msg -&gt; toWebSocketMessage(session, msg));

Flux&lt;WebSocketMessage&gt; output = history.concatWith(live);</code></pre>
<p>전략 1이 관리가 용이하고, 히스토리-실시간 사이 메시지 누락 위험이 적어 프로덕션에서 권장된다.</p>
<h3 id="1338-mongodb">13.3.8 MongoDB 인덱스 설정</h3>
<p>채팅 메시지 조회 성능을 위해 복합 인덱스를 설정한다.</p>
<pre class="highlight"><code class="language-java">@Configuration
@RequiredArgsConstructor
public class MongoIndexConfig {
    private final ReactiveMongoTemplate mongoTemplate;

    @PostConstruct
    public void initIndexes() {
        mongoTemplate.indexOps(ChatMessageDocument.class)
            .ensureIndex(new Index()
                .on("roomId", Sort.Direction.ASC)
                .on("timestamp", Sort.Direction.DESC))
            .subscribe();
    }
}</code></pre>
<hr>
<h2 id="134-websocket">13.4 WebSocket 세션 관리</h2>
<h3 id="1341">13.4.1 세션 라이프사이클</h3>
<p>WebSocket 세션은 <code>CONNECTING -&gt; OPEN -&gt; CLOSING -&gt; CLOSED</code> 순서의 라이프사이클을 따른다. 세션을 체계적으로 관리하기 위해 세션 레지스트리를 구현한다.</p>
<pre class="highlight"><code class="language-java">@Component @Slf4j
public class WebSocketSessionRegistry {

    private final Map&lt;String, Map&lt;String, WebSocketSession&gt;&gt; roomSessions =
        new ConcurrentHashMap&lt;&gt;();
    private final Map&lt;String, String&gt; sessionUserMap = new ConcurrentHashMap&lt;&gt;();

    public void register(String roomId, String username, WebSocketSession session) {
        roomSessions.computeIfAbsent(roomId, k -&gt; new ConcurrentHashMap&lt;&gt;())
            .put(session.getId(), session);
        sessionUserMap.put(session.getId(), username);
        log.info("세션 등록: roomId={}, username={}, 현재 인원={}",
            roomId, username, getSessionCount(roomId));
    }

    public void unregister(String roomId, WebSocketSession session) {
        Map&lt;String, WebSocketSession&gt; sessions = roomSessions.get(roomId);
        if (sessions != null) {
            sessions.remove(session.getId());
            if (sessions.isEmpty()) roomSessions.remove(roomId);
        }
        sessionUserMap.remove(session.getId());
    }

    public int getSessionCount(String roomId) {
        Map&lt;String, WebSocketSession&gt; s = roomSessions.get(roomId);
        return s != null ? s.size() : 0;
    }

    public Set&lt;String&gt; getOnlineUsers(String roomId) {
        Map&lt;String, WebSocketSession&gt; sessions = roomSessions.get(roomId);
        if (sessions == null) return Collections.emptySet();
        return sessions.keySet().stream()
            .map(sessionUserMap::get).filter(Objects::nonNull)
            .collect(Collectors.toSet());
    }

    public Map&lt;String, WebSocketSession&gt; getAllSessions() {
        Map&lt;String, WebSocketSession&gt; all = new ConcurrentHashMap&lt;&gt;();
        roomSessions.values().forEach(all::putAll);
        return all;
    }
}</code></pre>
<p>세션 레지스트리를 ChatWebSocketHandler에 통합하면 <code>register()</code>를 연결 시에, <code>unregister()</code>를 <code>doFinally()</code>에서 호출하여 세션 생명주기를 관리한다.</p>
<h3 id="1342-pingpong">13.4.2 Ping/Pong 하트비트</h3>
<p>WebSocket 연결이 네트워크 문제나 유휴 상태로 끊어질 수 있다. Ping/Pong 메커니즘으로 연결 상태를 주기적으로 확인한다.</p>
<p><strong>서버 측 Ping 스케줄러:</strong></p>
<pre class="highlight"><code class="language-java">@Component
@RequiredArgsConstructor @Slf4j
public class WebSocketPingScheduler {

    private final WebSocketSessionRegistry sessionRegistry;

    @Scheduled(fixedRate = 30000)
    public void sendPing() {
        sessionRegistry.getAllSessions().forEach((sessionId, session) -&gt; {
            if (session.isOpen()) {
                session.send(Mono.just(session.pingMessage(factory -&gt;
                    factory.wrap("ping".getBytes(StandardCharsets.UTF_8)))))
                    .subscribe(null, error -&gt;
                        log.warn("Ping 실패: sessionId={}", sessionId));
            }
        });
    }
}</code></pre>
<p><code>@EnableScheduling</code>을 메인 애플리케이션에 추가해야 한다.</p>
<p><strong>애플리케이션 레벨 하트비트:</strong></p>
<p>프록시가 WebSocket 프레임을 지원하지 않는 환경에서는 애플리케이션 레벨 하트비트를 사용한다.</p>
<pre class="highlight"><code class="language-java">// 수신 시 하트비트 필터링
Mono&lt;Void&gt; input = session.receive()
    .filter(msg -&gt; !"HEARTBEAT".equals(msg.getPayloadAsText()))
    .flatMap(msg -&gt; handleIncoming(msg.getPayloadAsText(), roomId, username))
    .then();

// 송신 시 하트비트와 실시간 메시지 병합
Flux&lt;WebSocketMessage&gt; heartbeat = Flux.interval(Duration.ofSeconds(25))
    .map(tick -&gt; session.textMessage("HEARTBEAT"));
Flux&lt;WebSocketMessage&gt; output = Flux.merge(
    messageBroker.subscribe(roomId).mapNotNull(m -&gt; toWebSocketMessage(session, m)),
    heartbeat);</code></pre>
<h3 id="1343">13.4.3 재연결 처리</h3>
<p>네트워크 불안정으로 연결이 끊어질 때를 대비하여 클라이언트 측 자동 재연결과 서버 측 메시지 복구를 구현한다.</p>
<p><strong>클라이언트 재연결 (지수 백오프):</strong></p>
<pre class="highlight"><code class="language-javascript">class ReconnectingWebSocket {
    constructor(url, options = {}) {
        this.url = url;
        this.maxRetries = options.maxRetries || 10;
        this.retryDelay = options.retryDelay || 1000;
        this.maxRetryDelay = options.maxRetryDelay || 30000;
        this.retryCount = 0;
        this.lastMessageTimestamp = null;
        this.connect();
    }

    connect() {
        let connectUrl = this.url;
        if (this.lastMessageTimestamp) {
            const sep = connectUrl.includes('?') ? '&amp;' : '?';
            connectUrl += `${sep}since=${this.lastMessageTimestamp}`;
        }
        this.ws = new WebSocket(connectUrl);

        this.ws.onopen = () =&gt; { this.retryCount = 0; };
        this.ws.onmessage = (e) =&gt; {
            if (e.data === 'HEARTBEAT') return;
            const msg = JSON.parse(e.data);
            this.lastMessageTimestamp = msg.timestamp;
            this.onMessage?.(msg);
        };
        this.ws.onclose = (e) =&gt; {
            if (e.code !== 1000 &amp;&amp; this.retryCount &lt; this.maxRetries) {
                const delay = Math.min(
                    this.retryDelay * Math.pow(2, this.retryCount),
                    this.maxRetryDelay);
                setTimeout(() =&gt; { this.retryCount++; this.connect(); }, delay);
            }
        };
    }

    send(data) {
        if (this.ws?.readyState === WebSocket.OPEN)
            this.ws.send(typeof data === 'string' ? data : JSON.stringify(data));
    }

    close() { this.maxRetries = 0; this.ws?.close(1000); }
}</code></pre>
<p><strong>서버 측 메시지 복구:</strong></p>
<pre class="highlight"><code class="language-java">@Override
public Mono&lt;Void&gt; handle(WebSocketSession session) {
    // ... 파라미터 추출 ...
    String sinceParam = params.get("since");

    // 재연결 시 놓친 메시지 복구
    Flux&lt;WebSocketMessage&gt; missedMessages = Flux.empty();
    if (sinceParam != null) {
        LocalDateTime since = LocalDateTime.parse(sinceParam);
        missedMessages = chatMessageService.getMessagesSince(roomId, since)
            .mapNotNull(msg -&gt; toWebSocketMessage(session, msg));
    }

    Flux&lt;WebSocketMessage&gt; liveMessages = messageBroker.subscribe(roomId)
        .mapNotNull(msg -&gt; toWebSocketMessage(session, msg));

    // 놓친 메시지 먼저 전송 후 실시간 스트림 전환
    Flux&lt;WebSocketMessage&gt; output = missedMessages.concatWith(liveMessages);

    Mono&lt;Void&gt; input = session.receive()
        .filter(msg -&gt; !"HEARTBEAT".equals(msg.getPayloadAsText()))
        .flatMap(msg -&gt; handleIncoming(msg.getPayloadAsText(), roomId, username))
        .doFinally(signal -&gt; sessionRegistry.unregister(roomId, session))
        .then();

    return Mono.zip(input, session.send(output)).then();
}</code></pre>
<h3 id="1344">13.4.4 연결 종료와 보안</h3>
<p>주요 <code>CloseStatus</code> 코드를 정리한다.</p>
<table>
<thead>
<tr>
<th>코드</th>
<th>의미</th>
</tr>
</thead>
<tbody>
<tr>
<td>1000</td>
<td>정상 종료</td>
</tr>
<tr>
<td>1001</td>
<td>서버 종료 또는 페이지 이동</td>
</tr>
<tr>
<td>1008</td>
<td>정책 위반</td>
</tr>
<tr>
<td>1011</td>
<td>서버 내부 오류</td>
</tr>
<tr>
<td>4000+</td>
<td>애플리케이션 정의 코드</td>
</tr>
</tbody>
</table>
<p>서버에서 특정 사용자를 강제 퇴장시키는 예시이다.</p>
<pre class="highlight"><code class="language-java">public Mono&lt;Void&gt; disconnectUser(String roomId, String targetUsername) {
    return Flux.fromIterable(sessionRegistry.getSessions(roomId).entrySet())
        .filter(e -&gt; targetUsername.equals(sessionRegistry.getUsername(e.getKey())))
        .flatMap(e -&gt; e.getValue()
            .close(new CloseStatus(4001, "관리자에 의해 종료")))
        .then();
}</code></pre>
<p>WebSocket 엔드포인트에도 Spring Security를 적용할 수 있다. WebSocket 핸드셰이크는 HTTP 요청이므로, JWT 토큰을 쿼리 파라미터로 전달하고 핸들러에서 검증한다.</p>
<pre class="highlight"><code class="language-java">@Bean
public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
    return http
        .authorizeExchange(ex -&gt; ex
            .pathMatchers("/ws/**").authenticated()
            .pathMatchers("/api/auth/**").permitAll()
            .anyExchange().authenticated())
        .csrf(csrf -&gt; csrf.disable())
        .build();
}</code></pre>
<pre class="highlight"><code class="language-java">// 핸들러 내부에서 JWT 검증
String token = params.get("token");
if (token == null || !jwtTokenProvider.validateToken(token)) {
    return session.close(new CloseStatus(4401, "인증 실패"));
}
String username = jwtTokenProvider.getUsernameFromToken(token);</code></pre>
<pre class="highlight"><code class="language-javascript">// 클라이언트에서 토큰 전달
const token = localStorage.getItem('accessToken');
const ws = new WebSocket(
    `ws://localhost:8080/ws/chat?roomId=${roomId}&amp;username=${user}&amp;token=${token}`);</code></pre>
<blockquote>
<p><strong>주의</strong>: URL 쿼리 파라미터로 토큰을 전달하면 로그에 노출될 수 있다. 프로덕션에서는 쿠키나 첫 번째 메시지를 통한 인증, 또는 핸드셰이크 전 별도 토큰 발급 엔드포인트를 활용하는 것이 더 안전하다.</p>
</blockquote>
<hr>
<h2 id="_2">요약</h2>
<p>이번 장에서 다룬 핵심 내용을 정리한다.</p>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 내용</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>WebSocket 프로토콜</strong></td>
<td>HTTP 핸드셰이크로 연결 수립, 프레임 기반 양방향 통신, SSE/Long Polling과의 차이</td>
</tr>
<tr>
<td><strong>WebSocket 핸들러</strong></td>
<td><code>WebSocketHandler</code> 인터페이스, <code>SimpleUrlHandlerMapping</code>으로 경로 매핑, 수신/송신/양방향 패턴</td>
</tr>
<tr>
<td><strong>실시간 채팅</strong></td>
<td><code>Sinks.Many</code>를 활용한 메시지 브로드캐스팅, MongoDB 저장, 이전 메시지 로드, REST API 연동</td>
</tr>
<tr>
<td><strong>세션 관리</strong></td>
<td>세션 레지스트리, Ping/Pong 하트비트, 지수 백오프 재연결, 보안 설정</td>
</tr>
</tbody>
</table>
<p>WebSocket은 실시간 양방향 통신이 필요한 다양한 시나리오에서 핵심적인 역할을 한다. Spring WebFlux의 리액티브 WebSocket 지원과 Reactor의 <code>Sinks</code>를 활용하면, 높은 동시 연결 수를 효율적으로 처리하는 확장성 있는 실시간 애플리케이션을 구축할 수 있다. 다음 장에서는 WebClient를 활용하여 외부 API를 리액티브하게 호출하는 방법을 다룬다.</p>
<hr>
<h1 id="chapter-14-webclient-http">Chapter 14. WebClient: 리액티브 HTTP 클라이언트</h1>
<p>Spring WebFlux 애플리케이션에서 외부 서비스와 통신해야 할 때, 전통적인 <code>RestTemplate</code> 대신 <code>WebClient</code>를 사용한다. <code>WebClient</code>는 Spring 5에서 도입된 <strong>논블로킹 리액티브 HTTP 클라이언트</strong>로, 이번 장에서는 설정과 기본 사용법부터 에러 핸들링, 재시도, 타임아웃, 외부 API 동시 호출, 필터까지 실전에서 필요한 모든 내용을 다룬다.</p>
<hr>
<h2 id="141-webclient">14.1 WebClient 설정과 기본 사용법</h2>
<h3 id="1411-webclient">14.1.1 WebClient란?</h3>
<p><code>WebClient</code>는 Spring WebFlux 모듈에 포함된 논블로킹 HTTP 클라이언트다. 내부적으로 Reactor Netty의 <code>HttpClient</code>를 사용하며, 리액티브 스트림 기반으로 요청과 응답을 처리한다.</p>
<table>
<thead>
<tr>
<th>특성</th>
<th>RestTemplate</th>
<th>WebClient</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>블로킹 여부</strong></td>
<td>블로킹</td>
<td>논블로킹</td>
</tr>
<tr>
<td><strong>반환 타입</strong></td>
<td>직접 객체 반환</td>
<td><code>Mono&lt;T&gt;</code>, <code>Flux&lt;T&gt;</code></td>
</tr>
<tr>
<td><strong>스트리밍</strong></td>
<td>미지원</td>
<td>SSE, 스트리밍 응답 지원</td>
</tr>
<tr>
<td><strong>유지 상태</strong></td>
<td>Spring 6에서 deprecated</td>
<td>현재 권장 방식</td>
</tr>
</tbody>
</table>
<h3 id="1412-webclient">14.1.2 WebClient 생성과 빈 설정</h3>
<p><code>WebClient</code>는 <code>create()</code>, <code>create(baseUrl)</code>, <code>builder()</code> 세 가지 방식으로 생성한다. 실전에서는 <code>builder()</code>를 사용하여 빈으로 등록하는 것이 일반적이다. 여러 외부 서비스를 호출하는 경우, 서비스별로 별도의 빈을 정의한다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class WebClientConfig {

    @Bean("userServiceClient")
    public WebClient userServiceClient() {
        return WebClient.builder()
            .baseUrl("https://user-service.example.com")
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .build();
    }

    @Bean("orderServiceClient")
    public WebClient orderServiceClient() {
        return WebClient.builder()
            .baseUrl("https://order-service.example.com")
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .build();
    }
}</code></pre>
<h3 id="1413">14.1.3 커넥션 풀 설정</h3>
<p>운영 환경에서는 Reactor Netty의 커넥션 풀을 명시적으로 설정하는 것이 바람직하다.</p>
<pre class="highlight"><code class="language-java">@Bean
public WebClient webClient() {
    ConnectionProvider provider = ConnectionProvider.builder("custom-pool")
        .maxConnections(500)                           // 최대 커넥션 수
        .maxIdleTime(Duration.ofSeconds(20))            // 유휴 커넥션 유지 시간
        .maxLifeTime(Duration.ofSeconds(60))            // 커넥션 최대 수명
        .pendingAcquireTimeout(Duration.ofSeconds(60))  // 커넥션 대기 타임아웃
        .evictInBackground(Duration.ofSeconds(120))     // 백그라운드 정리 주기
        .build();

    HttpClient httpClient = HttpClient.create(provider)
        .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)
        .compress(true);

    return WebClient.builder()
        .baseUrl("https://api.example.com")
        .clientConnector(new ReactorClientHttpConnector(httpClient))
        .build();
}</code></pre>
<h3 id="1414-codec">14.1.4 코덱(Codec) 설정</h3>
<p>대용량 응답 처리나 커스텀 직렬화가 필요한 경우 코덱을 설정한다. <code>maxInMemorySize</code>는 응답 본문의 메모리 버퍼 최대 크기(기본 256KB)이며, 대용량 JSON 응답 시 <code>DataBufferLimitException</code>이 발생하면 이 값을 늘린다.</p>
<pre class="highlight"><code class="language-java">@Bean
public WebClient webClient() {
    return WebClient.builder()
        .codecs(configurer -&gt; {
            configurer.defaultCodecs().maxInMemorySize(10 * 1024 * 1024); // 10MB

            ObjectMapper mapper = new ObjectMapper();
            mapper.registerModule(new JavaTimeModule());
            mapper.setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);
            configurer.defaultCodecs().jackson2JsonEncoder(
                new Jackson2JsonEncoder(mapper, MediaType.APPLICATION_JSON));
            configurer.defaultCodecs().jackson2JsonDecoder(
                new Jackson2JsonDecoder(mapper, MediaType.APPLICATION_JSON));
        })
        .build();
}</code></pre>
<hr>
<h2 id="142-get-post-put-delete">14.2 요청/응답 처리 (GET, POST, PUT, DELETE)</h2>
<h3 id="1421-get">14.2.1 GET 요청</h3>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class ProductClientService {

    private final WebClient webClient;

    // 단일 객체 조회
    public Mono&lt;Product&gt; getProduct(String id) {
        return webClient.get()
            .uri("/api/products/{id}", id)
            .retrieve()
            .bodyToMono(Product.class);
    }

    // 목록 조회
    public Flux&lt;Product&gt; getAllProducts() {
        return webClient.get()
            .uri("/api/products")
            .retrieve()
            .bodyToFlux(Product.class);
    }

    // 쿼리 파라미터 사용
    public Flux&lt;Product&gt; searchProducts(String keyword, int page, int size) {
        return webClient.get()
            .uri(uriBuilder -&gt; uriBuilder
                .path("/api/products/search")
                .queryParam("keyword", keyword)
                .queryParam("page", page)
                .queryParam("size", size)
                .build())
            .retrieve()
            .bodyToFlux(Product.class);
    }
}</code></pre>
<h3 id="1422-post">14.2.2 POST 요청</h3>
<pre class="highlight"><code class="language-java">// JSON 본문 전송
public Mono&lt;Product&gt; createProduct(ProductRequest request) {
    return webClient.post()
        .uri("/api/products")
        .bodyValue(request)
        .retrieve()
        .bodyToMono(Product.class);
}

// Mono를 본문으로 전송
public Mono&lt;Product&gt; createProductReactive(Mono&lt;ProductRequest&gt; request) {
    return webClient.post()
        .uri("/api/products")
        .body(request, ProductRequest.class)
        .retrieve()
        .bodyToMono(Product.class);
}

// 폼 데이터 전송
public Mono&lt;String&gt; submitForm(String username, String password) {
    return webClient.post()
        .uri("/api/auth/login")
        .contentType(MediaType.APPLICATION_FORM_URLENCODED)
        .body(BodyInserters.fromFormData("username", username)
            .with("password", password))
        .retrieve()
        .bodyToMono(String.class);
}</code></pre>
<p><code>bodyValue()</code>는 이미 준비된 객체를 전송할 때, <code>body()</code>는 <code>Publisher</code> 타입(Mono, Flux)을 전송할 때 사용한다.</p>
<h3 id="1423-put-delete">14.2.3 PUT과 DELETE 요청</h3>
<pre class="highlight"><code class="language-java">public Mono&lt;Product&gt; updateProduct(String id, ProductRequest request) {
    return webClient.put()
        .uri("/api/products/{id}", id)
        .bodyValue(request)
        .retrieve()
        .bodyToMono(Product.class);
}

public Mono&lt;Void&gt; deleteProduct(String id) {
    return webClient.delete()
        .uri("/api/products/{id}", id)
        .retrieve()
        .bodyToMono(Void.class);
}</code></pre>
<h3 id="1424-retrieve-vs-exchangetomono">14.2.4 retrieve() vs exchangeToMono()</h3>
<p><strong>retrieve()</strong>: 간결한 방식. 4xx/5xx 상태 코드에 대해 자동으로 예외를 발생시킨다.</p>
<pre class="highlight"><code class="language-java">Mono&lt;Product&gt; product = webClient.get()
    .uri("/api/products/{id}", id)
    .retrieve()
    .bodyToMono(Product.class);</code></pre>
<p><strong>exchangeToMono()</strong>: 상태 코드, 헤더 등 전체 응답 정보에 접근할 수 있다.</p>
<pre class="highlight"><code class="language-java">public Mono&lt;Product&gt; getProductWithStatus(String id) {
    return webClient.get()
        .uri("/api/products/{id}", id)
        .exchangeToMono(response -&gt; {
            if (response.statusCode().is2xxSuccessful()) {
                return response.bodyToMono(Product.class);
            } else if (response.statusCode() == HttpStatus.NOT_FOUND) {
                return Mono.empty();
            } else {
                return response.createError();
            }
        });
}</code></pre>
<blockquote>
<p><strong>주의</strong>: 이전 버전의 <code>exchange()</code> 메서드는 deprecated되었다. 리소스 누수 위험이 있으므로, 반드시 <code>exchangeToMono()</code> 또는 <code>exchangeToFlux()</code>를 사용한다.</p>
</blockquote>
<p>응답 헤더와 상태 코드가 모두 필요하면 <code>toEntity()</code>를 사용한다.</p>
<pre class="highlight"><code class="language-java">public Mono&lt;ResponseEntity&lt;Product&gt;&gt; getProductWithHeaders(String id) {
    return webClient.get()
        .uri("/api/products/{id}", id)
        .retrieve()
        .toEntity(Product.class);
}</code></pre>
<h3 id="1425">14.2.5 스트리밍 응답 처리</h3>
<p>SSE 스트림이나 NDJSON 스트림을 구독할 수 있다.</p>
<pre class="highlight"><code class="language-java">public Flux&lt;ServerSentEvent&lt;String&gt;&gt; subscribeToEvents() {
    return webClient.get()
        .uri("/api/events/stream")
        .accept(MediaType.TEXT_EVENT_STREAM)
        .retrieve()
        .bodyToFlux(new ParameterizedTypeReference&lt;ServerSentEvent&lt;String&gt;&gt;() {});
}

public Flux&lt;Product&gt; streamProducts() {
    return webClient.get()
        .uri("/api/products/stream")
        .accept(MediaType.APPLICATION_NDJSON)
        .retrieve()
        .bodyToFlux(Product.class);
}</code></pre>
<hr>
<h2 id="143">14.3 에러 핸들링과 재시도 전략</h2>
<h3 id="1431-onstatus">14.3.1 onStatus()를 활용한 상태 코드별 처리</h3>
<p><code>retrieve()</code>는 4xx/5xx 상태 코드에 대해 자동으로 <code>WebClientResponseException</code>을 발생시킨다. <code>onStatus()</code>로 상태 코드별 커스텀 에러 처리를 정의할 수 있다.</p>
<pre class="highlight"><code class="language-java">public Mono&lt;Product&gt; getProduct(String id) {
    return webClient.get()
        .uri("/api/products/{id}", id)
        .retrieve()
        .onStatus(HttpStatusCode::is4xxClientError, response -&gt; {
            if (response.statusCode() == HttpStatus.NOT_FOUND) {
                return Mono.error(
                    new ProductNotFoundException("상품을 찾을 수 없습니다: " + id));
            }
            return response.bodyToMono(ErrorResponse.class)
                .flatMap(error -&gt; Mono.error(
                    new InvalidRequestException(error.getMessage())));
        })
        .onStatus(HttpStatusCode::is5xxServerError, response -&gt;
            response.bodyToMono(String.class)
                .flatMap(body -&gt; Mono.error(
                    new ExternalServiceException("서버 에러: " + body)))
        )
        .bodyToMono(Product.class);
}</code></pre>
<h3 id="1432-retrywhen-retrybackoff">14.3.2 retryWhen()과 Retry.backoff()</h3>
<p><code>retry(n)</code>은 즉시 재시도하므로 서버에 과부하를 유발할 수 있다. 운영 환경에서는 <code>Retry.backoff()</code>로 지수 백오프(exponential backoff) 전략을 사용한다.</p>
<pre class="highlight"><code class="language-java">public Mono&lt;Product&gt; getProductWithBackoff(String id) {
    return webClient.get()
        .uri("/api/products/{id}", id)
        .retrieve()
        .bodyToMono(Product.class)
        .retryWhen(Retry.backoff(3, Duration.ofSeconds(1))
            .maxBackoff(Duration.ofSeconds(10))
            .jitter(0.5)
            .filter(ex -&gt; ex instanceof WebClientResponseException.ServiceUnavailable
                       || ex instanceof ConnectException)
            .doBeforeRetry(signal -&gt; log.warn(
                "재시도 #{} - 원인: {}",
                signal.totalRetries() + 1,
                signal.failure().getMessage()))
            .onRetryExhaustedThrow((spec, signal) -&gt;
                new ExternalServiceException(
                    "재시도 횟수 초과: " + signal.failure().getMessage(),
                    signal.failure()))
        );
}</code></pre>
<table>
<thead>
<tr>
<th>재시도 횟수</th>
<th>최소 대기 시간</th>
<th>jitter=0.5 적용 시 범위</th>
</tr>
</thead>
<tbody>
<tr>
<td>1회차</td>
<td>1초</td>
<td>0.5초 ~ 1.5초</td>
</tr>
<tr>
<td>2회차</td>
<td>2초</td>
<td>1초 ~ 3초</td>
</tr>
<tr>
<td>3회차</td>
<td>4초</td>
<td>2초 ~ 6초</td>
</tr>
</tbody>
</table>
<p><code>jitter</code>는 여러 클라이언트가 동시에 재시도하여 부하가 집중되는 "thundering herd" 문제를 방지한다.</p>
<h3 id="1433">14.3.3 서킷 브레이커 패턴</h3>
<p>외부 서비스가 장시간 장애 상태일 때, Resilience4j로 서킷 브레이커를 적용한다.</p>
<pre class="highlight"><code class="language-groovy">dependencies {
    implementation 'io.github.resilience4j:resilience4j-spring-boot3:2.2.0'
    implementation 'io.github.resilience4j:resilience4j-reactor:2.2.0'
}</code></pre>
<pre class="highlight"><code class="language-yaml">resilience4j:
  circuitbreaker:
    instances:
      productService:
        sliding-window-size: 10
        failure-rate-threshold: 50
        wait-duration-in-open-state: 30s
        permitted-number-of-calls-in-half-open-state: 3</code></pre>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class ProductClientService {

    private final WebClient webClient;
    private final CircuitBreakerRegistry circuitBreakerRegistry;

    public Mono&lt;Product&gt; getProduct(String id) {
        CircuitBreaker cb = circuitBreakerRegistry.circuitBreaker("productService");

        return webClient.get()
            .uri("/api/products/{id}", id)
            .retrieve()
            .bodyToMono(Product.class)
            .transformDeferred(CircuitBreakerOperator.of(cb))
            .onErrorResume(CallNotPermittedException.class, ex -&gt; {
                log.warn("서킷 브레이커 OPEN - 폴백 실행");
                return Mono.just(Product.fallback(id));
            })
            .retryWhen(Retry.backoff(2, Duration.ofMillis(500))
                .filter(ex -&gt; !(ex instanceof CallNotPermittedException)));
    }
}</code></pre>
<table>
<thead>
<tr>
<th>상태</th>
<th>동작</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CLOSED</strong></td>
<td>정상 상태. 모든 요청 전달, 실패율 모니터링</td>
</tr>
<tr>
<td><strong>OPEN</strong></td>
<td>차단 상태. 즉시 폴백 실행. 대기 시간 후 HALF_OPEN 전환</td>
</tr>
<tr>
<td><strong>HALF_OPEN</strong></td>
<td>일부 요청만 허용하여 복구 확인. 성공하면 CLOSED, 실패하면 OPEN</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="144">14.4 타임아웃 설정</h2>
<p>외부 서비스 호출 시 타임아웃은 필수다. 타임아웃 없이 호출하면 외부 장애가 자신의 애플리케이션까지 전파될 수 있다.</p>
<h3 id="1441">14.4.1 계층별 타임아웃</h3>
<pre class="highlight"><code class="language-java">HttpClient httpClient = HttpClient.create()
    // 1. 커넥션 타임아웃: TCP 연결 수립
    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 3000)
    // 2. 응답 타임아웃: 첫 응답 바이트 수신까지
    .responseTimeout(Duration.ofSeconds(5))
    // 3. 읽기/쓰기 타임아웃: 데이터 전송 중 무응답
    .doOnConnected(conn -&gt; conn
        .addHandlerLast(new ReadTimeoutHandler(10, TimeUnit.SECONDS))
        .addHandlerLast(new WriteTimeoutHandler(10, TimeUnit.SECONDS)));

WebClient webClient = WebClient.builder()
    .clientConnector(new ReactorClientHttpConnector(httpClient))
    .build();</code></pre>
<h3 id="1442-reactor-timeout">14.4.2 Reactor timeout() 연산자</h3>
<p>리액티브 체인 수준에서 재시도 포함 전체 시간을 제한한다.</p>
<pre class="highlight"><code class="language-java">public Mono&lt;Product&gt; getProduct(String id) {
    return webClient.get()
        .uri("/api/products/{id}", id)
        .retrieve()
        .bodyToMono(Product.class)
        .retryWhen(Retry.backoff(3, Duration.ofSeconds(1)))
        .timeout(Duration.ofSeconds(15))
        .onErrorResume(TimeoutException.class, ex -&gt;
            Mono.error(new ExternalServiceException("응답 시간 초과")));
}</code></pre>
<h3 id="1443">14.4.3 타임아웃 종합 정리</h3>
<table>
<thead>
<tr>
<th>타임아웃</th>
<th>적용 계층</th>
<th>대상</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>커넥션 타임아웃</strong></td>
<td>TCP</td>
<td>서버와 TCP 연결 수립</td>
</tr>
<tr>
<td><strong>응답 타임아웃</strong></td>
<td>HTTP</td>
<td>첫 응답 바이트 수신까지</td>
</tr>
<tr>
<td><strong>읽기 타임아웃</strong></td>
<td>TCP</td>
<td>데이터 읽기 중 무응답</td>
</tr>
<tr>
<td><strong>쓰기 타임아웃</strong></td>
<td>TCP</td>
<td>데이터 쓰기 중 무응답</td>
</tr>
<tr>
<td><strong>Reactor timeout()</strong></td>
<td>리액티브</td>
<td>전체 리액티브 체인 완료</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="145-api">14.5 외부 API 연동 실전 예제</h2>
<h3 id="1451-rest-api">14.5.1 REST API 호출 서비스</h3>
<p>외부 날씨 API를 호출하는 실전 예제다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Service
public class WeatherClientService {

    private final WebClient webClient;

    public WeatherClientService(WebClient.Builder builder,
                                @Value("${weather.api.key}") String apiKey) {
        this.webClient = builder
            .baseUrl("https://api.openweathermap.org/data/2.5")
            .defaultUriVariables(Map.of("appid", apiKey))
            .build();
    }

    public Mono&lt;WeatherResponse&gt; getCurrentWeather(String city) {
        return webClient.get()
            .uri(uriBuilder -&gt; uriBuilder
                .path("/weather")
                .queryParam("q", city)
                .queryParam("appid", "{appid}")
                .queryParam("units", "metric")
                .build())
            .retrieve()
            .onStatus(HttpStatusCode::is4xxClientError, response -&gt; {
                if (response.statusCode() == HttpStatus.NOT_FOUND) {
                    return Mono.error(new CityNotFoundException("도시를 찾을 수 없습니다: " + city));
                }
                return response.createException();
            })
            .bodyToMono(WeatherResponse.class)
            .retryWhen(Retry.backoff(2, Duration.ofSeconds(1))
                .filter(ex -&gt; ex instanceof WebClientResponseException.ServiceUnavailable))
            .timeout(Duration.ofSeconds(10));
    }
}</code></pre>
<h3 id="1452-api-zip">14.5.2 여러 API 동시 호출 (zip)</h3>
<p><code>Mono.zip()</code>으로 독립적인 여러 API를 병렬 실행하고 결과를 조합한다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class DashboardService {

    private final UserClientService userClient;
    private final OrderClientService orderClient;
    private final WeatherClientService weatherClient;

    public Mono&lt;DashboardResponse&gt; getDashboard(String userId) {
        Mono&lt;UserProfile&gt; userMono = userClient.getProfile(userId);
        Mono&lt;List&lt;Order&gt;&gt; ordersMono = orderClient.getRecentOrders(userId).collectList();
        Mono&lt;WeatherResponse&gt; weatherMono = weatherClient.getCurrentWeather("Seoul");

        return Mono.zip(userMono, ordersMono, weatherMono)
            .map(tuple -&gt; DashboardResponse.builder()
                .user(tuple.getT1())
                .recentOrders(tuple.getT2())
                .weather(tuple.getT3())
                .build());
    }
}</code></pre>
<p>세 개의 API 호출은 <strong>동시에</strong> 실행된다. 순차 호출 시 각 응답 시간의 합만큼 걸리지만, <code>Mono.zip()</code>은 가장 느린 호출 기준으로만 대기한다.</p>
<h3 id="1453-api-merge">14.5.3 여러 API 결과 병합 (merge)</h3>
<p><code>Flux.merge()</code>는 여러 소스의 결과를 도착 순서대로 합친다. 동일한 타입의 데이터를 여러 소스에서 수집할 때 유용하다.</p>
<pre class="highlight"><code class="language-java">public Flux&lt;PriceQuote&gt; getPriceQuotes(String productId) {
    Flux&lt;PriceQuote&gt; a = webClient.get()
        .uri("https://supplier-a.com/api/price/{id}", productId)
        .retrieve().bodyToMono(PriceQuote.class).flux();
    Flux&lt;PriceQuote&gt; b = webClient.get()
        .uri("https://supplier-b.com/api/price/{id}", productId)
        .retrieve().bodyToMono(PriceQuote.class).flux();
    Flux&lt;PriceQuote&gt; c = webClient.get()
        .uri("https://supplier-c.com/api/price/{id}", productId)
        .retrieve().bodyToMono(PriceQuote.class).flux();

    return Flux.merge(a, b, c)
        .timeout(Duration.ofSeconds(5))
        .onErrorResume(ex -&gt; Flux.empty());
}</code></pre>
<h3 id="1454-api-flatmap">14.5.4 순차 API 호출 (flatMap 체이닝)</h3>
<p>하나의 API 결과를 다음 API의 입력으로 사용하는 경우 <code>flatMap</code>으로 체이닝한다.</p>
<pre class="highlight"><code class="language-java">// 1. 사용자 조회 → 2. 주문 생성 → 3. 결제 처리
public Mono&lt;PaymentResult&gt; processOrder(String userId, OrderRequest orderRequest) {
    return webClient.get()
        .uri("/api/users/{id}", userId)
        .retrieve()
        .bodyToMono(UserProfile.class)
        .flatMap(user -&gt; {
            orderRequest.setShippingAddress(user.getAddress());
            return webClient.post()
                .uri("/api/orders")
                .bodyValue(orderRequest)
                .retrieve()
                .bodyToMono(OrderResponse.class);
        })
        .flatMap(order -&gt; webClient.post()
            .uri("/api/payments")
            .bodyValue(new PaymentRequest(order.getId(), order.getTotalAmount()))
            .retrieve()
            .bodyToMono(PaymentResult.class));
}</code></pre>
<h3 id="1455-fallback">14.5.5 폴백(Fallback) 패턴</h3>
<p>외부 API 실패 시 대체 데이터를 반환한다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Service
@RequiredArgsConstructor
public class ProductService {

    private final WebClient webClient;
    private final ProductRepository productRepository;

    public Mono&lt;Product&gt; getProduct(String id) {
        return webClient.get()
            .uri("/api/products/{id}", id)
            .retrieve().bodyToMono(Product.class)
            .timeout(Duration.ofSeconds(3))
            .onErrorResume(ex -&gt; {
                log.warn("외부 API 실패, 로컬 DB 폴백: {}", ex.getMessage());
                return productRepository.findById(id);
            });
    }

    // 다단계 폴백: 캐시 → 외부 API → 기본값
    public Mono&lt;ExchangeRate&gt; getExchangeRate(String currency) {
        return getFromCache(currency)
            .switchIfEmpty(getFromExternalApi(currency)
                .doOnNext(rate -&gt; saveToCache(currency, rate)))
            .switchIfEmpty(Mono.just(ExchangeRate.defaultRate(currency)))
            .onErrorReturn(ExchangeRate.defaultRate(currency));
    }
}</code></pre>
<h3 id="1456-api">14.5.6 페이지네이션 API 전체 조회</h3>
<p><code>expand()</code> 연산자로 재귀적으로 다음 페이지를 호출한다.</p>
<pre class="highlight"><code class="language-java">public Flux&lt;Product&gt; getAllProductsPaginated() {
    return fetchPage(0)
        .expand(page -&gt; page.hasNext()
            ? fetchPage(page.getPage() + 1)
            : Mono.empty())
        .flatMapIterable(PageResponse::getContent);
}

private Mono&lt;PageResponse&lt;Product&gt;&gt; fetchPage(int page) {
    return webClient.get()
        .uri(uriBuilder -&gt; uriBuilder
            .path("/api/products")
            .queryParam("page", page)
            .queryParam("size", 100)
            .build())
        .retrieve()
        .bodyToMono(new ParameterizedTypeReference&lt;PageResponse&lt;Product&gt;&gt;() {});
}</code></pre>
<hr>
<h2 id="146-webclient">14.6 WebClient 필터와 인터셉터</h2>
<h3 id="1461-exchangefilterfunction">14.6.1 ExchangeFilterFunction과 로깅 필터</h3>
<p><code>ExchangeFilterFunction</code>은 <code>WebClient</code>의 요청/응답 파이프라인에 횡단 관심사를 추가하는 메커니즘이다. <code>WebClient.builder().filter()</code>로 등록하며, 여러 필터를 등록하면 등록 순서대로 체이닝된다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
public class WebClientFilters {

    public static ExchangeFilterFunction logRequestResponse() {
        return (request, next) -&gt; {
            long startTime = System.currentTimeMillis();
            log.info("&gt;&gt;&gt; {} {}", request.method(), request.url());

            return next.exchange(request)
                .doOnNext(response -&gt; {
                    long duration = System.currentTimeMillis() - startTime;
                    log.info("&lt;&lt;&lt; {} {} - {}ms",
                        response.statusCode(), request.url(), duration);
                });
        };
    }
}</code></pre>
<h3 id="1462">14.6.2 인증 필터</h3>
<p>정적 API 키 필터와 동적 토큰 갱신 필터를 구현한다.</p>
<pre class="highlight"><code class="language-java">public static ExchangeFilterFunction apiKeyAuth(String apiKey) {
    return (request, next) -&gt; {
        ClientRequest filtered = ClientRequest.from(request)
            .header("X-API-Key", apiKey).build();
        return next.exchange(filtered);
    };
}</code></pre>
<pre class="highlight"><code class="language-java">@Component
@RequiredArgsConstructor
public class DynamicAuthFilter {

    private final TokenService tokenService;

    public ExchangeFilterFunction authFilter() {
        return (request, next) -&gt;
            tokenService.getValidToken()
                .flatMap(token -&gt; {
                    ClientRequest filtered = ClientRequest.from(request)
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                        .build();
                    return next.exchange(filtered);
                });
    }
}</code></pre>
<pre class="highlight"><code class="language-java">@Service
public class TokenService {

    private final WebClient authClient;
    private final AtomicReference&lt;TokenInfo&gt; cachedToken = new AtomicReference&lt;&gt;();

    public TokenService(WebClient.Builder builder) {
        this.authClient = builder.baseUrl("https://auth.example.com").build();
    }

    public Mono&lt;String&gt; getValidToken() {
        TokenInfo current = cachedToken.get();
        if (current != null &amp;&amp; !current.isExpired()) {
            return Mono.just(current.getAccessToken());
        }
        return authClient.post().uri("/oauth/token")
            .contentType(MediaType.APPLICATION_FORM_URLENCODED)
            .body(BodyInserters.fromFormData("grant_type", "client_credentials")
                .with("client_id", "my-client").with("client_secret", "my-secret"))
            .retrieve().bodyToMono(TokenInfo.class)
            .doOnNext(cachedToken::set).map(TokenInfo::getAccessToken);
    }
}</code></pre>
<h3 id="1463-id">14.6.3 에러 처리 필터와 요청 ID 전파 필터</h3>
<pre class="highlight"><code class="language-java">public static ExchangeFilterFunction errorHandlingFilter() {
    return (request, next) -&gt; next.exchange(request)
        .flatMap(response -&gt; {
            if (response.statusCode().is5xxServerError()) {
                return response.bodyToMono(String.class)
                    .flatMap(body -&gt; Mono.error(new ExternalServiceException(
                        "서버 에러 [" + request.method() + " " + request.url() + "]: " + body)));
            }
            return Mono.just(response);
        });
}

public static ExchangeFilterFunction traceIdFilter() {
    return (request, next) -&gt; {
        String traceId = Optional.ofNullable(MDC.get("traceId"))
            .orElse(UUID.randomUUID().toString().substring(0, 8));
        ClientRequest filtered = ClientRequest.from(request)
            .header("X-Trace-Id", traceId).build();
        return next.exchange(filtered);
    };
}</code></pre>
<h3 id="1464">14.6.4 필터 조합과 적용</h3>
<p>여러 필터를 조합하여 적용하는 전체 예제다.</p>
<pre class="highlight"><code class="language-java">@Configuration
@RequiredArgsConstructor
public class WebClientConfig {

    private final DynamicAuthFilter dynamicAuthFilter;

    @Value("${external.api.base-url}")
    private String baseUrl;

    @Bean
    public WebClient webClient() {
        HttpClient httpClient = HttpClient.create()
            .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)
            .responseTimeout(Duration.ofSeconds(10))
            .doOnConnected(conn -&gt; conn
                .addHandlerLast(new ReadTimeoutHandler(10, TimeUnit.SECONDS))
                .addHandlerLast(new WriteTimeoutHandler(10, TimeUnit.SECONDS)));

        return WebClient.builder()
            .baseUrl(baseUrl)
            .clientConnector(new ReactorClientHttpConnector(httpClient))
            .codecs(c -&gt; c.defaultCodecs().maxInMemorySize(5 * 1024 * 1024))
            // 필터 순서: 추적 → 인증 → 로깅 → 에러 처리
            .filter(WebClientFilters.traceIdFilter())
            .filter(dynamicAuthFilter.authFilter())
            .filter(WebClientFilters.logRequestResponse())
            .filter(WebClientFilters.errorHandlingFilter())
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .build();
    }
}</code></pre>
<p>필터 등록 순서가 곧 실행 순서다. 권장 순서는 추적 -&gt; 인증 -&gt; 로깅 -&gt; 에러 처리 순이다.</p>
<h3 id="1465-webclient">14.6.5 테스트에서의 WebClient 모킹</h3>
<p><code>MockWebServer</code>로 외부 API를 모킹하여 테스트한다.</p>
<pre class="highlight"><code class="language-groovy">testImplementation 'com.squareup.okhttp3:mockwebserver:4.12.0'</code></pre>
<pre class="highlight"><code class="language-java">class ProductClientServiceTest {

    private MockWebServer mockWebServer;
    private ProductClientService service;

    @BeforeEach
    void setUp() throws IOException {
        mockWebServer = new MockWebServer();
        mockWebServer.start();
        service = new ProductClientService(
            WebClient.builder().baseUrl(mockWebServer.url("/").toString()).build());
    }

    @AfterEach
    void tearDown() throws IOException { mockWebServer.shutdown(); }

    @Test
    void getProduct_성공() {
        mockWebServer.enqueue(new MockResponse()
            .setBody("{\"id\":\"123\",\"name\":\"테스트 상품\",\"price\":10000}")
            .addHeader("Content-Type", "application/json"));

        StepVerifier.create(service.getProduct("123"))
            .assertNext(p -&gt; assertThat(p.getName()).isEqualTo("테스트 상품"))
            .verifyComplete();
    }

    @Test
    void getProduct_재시도_후_성공() {
        // 처음 두 번은 503, 세 번째는 성공
        mockWebServer.enqueue(new MockResponse().setResponseCode(503));
        mockWebServer.enqueue(new MockResponse().setResponseCode(503));
        mockWebServer.enqueue(new MockResponse()
            .setBody("{\"id\":\"123\",\"name\":\"상품\",\"price\":5000}")
            .addHeader("Content-Type", "application/json"));

        StepVerifier.create(service.getProductWithBackoff("123"))
            .assertNext(p -&gt; assertThat(p.getId()).isEqualTo("123"))
            .verifyComplete();
        assertThat(mockWebServer.getRequestCount()).isEqualTo(3);
    }
}</code></pre>
<hr>
<h2 id="_3">요약</h2>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 내용</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>WebClient 설정</strong></td>
<td><code>WebClient.builder()</code>로 빈 생성, 커넥션 풀(<code>ConnectionProvider</code>), 코덱(<code>maxInMemorySize</code>, Jackson) 설정</td>
</tr>
<tr>
<td><strong>요청/응답 처리</strong></td>
<td>GET/POST/PUT/DELETE, <code>retrieve()</code> vs <code>exchangeToMono()</code>, <code>bodyToMono</code>/<code>bodyToFlux</code>, 스트리밍</td>
</tr>
<tr>
<td><strong>에러 핸들링</strong></td>
<td><code>onStatus()</code>로 상태 코드별 처리, <code>onErrorResume()</code>으로 폴백, 서킷 브레이커로 장애 전파 차단</td>
</tr>
<tr>
<td><strong>재시도 전략</strong></td>
<td><code>Retry.backoff()</code>로 지수 백오프, <code>jitter</code>로 부하 분산, <code>filter()</code>로 재시도 대상 예외 선별</td>
</tr>
<tr>
<td><strong>타임아웃</strong></td>
<td>커넥션/읽기/쓰기/응답 타임아웃 계층별 설정, Reactor <code>timeout()</code>으로 전체 체인 시간 제한</td>
</tr>
<tr>
<td><strong>외부 API 연동</strong></td>
<td><code>Mono.zip()</code>으로 병렬 호출, <code>Flux.merge()</code>로 결과 병합, 폴백 패턴, 페이지네이션 순회</td>
</tr>
<tr>
<td><strong>필터</strong></td>
<td><code>ExchangeFilterFunction</code>으로 로깅/인증/에러 처리/추적 필터 구현, 필터 체이닝 순서</td>
</tr>
</tbody>
</table>
<p>다음 장에서는 R2DBC를 활용하여 관계형 데이터베이스를 리액티브 방식으로 접근하고, MongoDB와 함께 멀티 데이터소스를 구성하는 방법을 다룬다.</p>
<hr>
<h1 id="chapter-15-r2dbc">Chapter 15. R2DBC와의 통합 (보너스)</h1>
<p>지금까지 이 책에서는 MongoDB를 중심으로 리액티브 데이터 접근을 다루었다. 하지만 실무에서는 관계형 데이터베이스(RDBMS)와 함께 사용해야 하는 상황이 빈번하다. 예를 들어 사용자 인증과 결제 정보는 PostgreSQL에, 상품 카탈로그와 리뷰는 MongoDB에 저장하는 아키텍처가 대표적이다. 이번 장에서는 리액티브 환경에서 관계형 DB에 접근하기 위한 <strong>R2DBC(Reactive Relational Database Connectivity)</strong>를 소개하고, MongoDB와 R2DBC를 동시에 사용하는 <strong>멀티 데이터소스</strong> 구성 방법을 실전 예제와 함께 다룬다.</p>
<hr>
<h2 id="151-r2dbc">15.1 R2DBC란?</h2>
<h3 id="1511-r2dbc">15.1.1 R2DBC 소개</h3>
<p>R2DBC는 <strong>Reactive Relational Database Connectivity</strong>의 약자로, 관계형 데이터베이스에 대한 비동기/논블로킹 접근을 제공하는 SPI(Service Provider Interface) 명세다. 전통적인 JDBC가 블로킹 I/O 기반으로 설계된 반면, R2DBC는 Reactive Streams 표준을 기반으로 처음부터 논블로킹으로 설계되었다.</p>
<table>
<thead>
<tr>
<th>원칙</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>완전한 논블로킹</strong></td>
<td>데이터베이스 연결, 쿼리 실행, 결과 처리 모든 과정이 논블로킹</td>
</tr>
<tr>
<td><strong>Reactive Streams 기반</strong></td>
<td><code>Publisher</code>, <code>Subscriber</code> 패턴을 사용하여 배압(Backpressure) 지원</td>
</tr>
<tr>
<td><strong>SPI 명세</strong></td>
<td>드라이버 제공자가 구현하는 인터페이스 규격</td>
</tr>
<tr>
<td><strong>SQL 중심</strong></td>
<td>ORM이 아닌 SQL 기반 접근 (Spring Data R2DBC가 리포지토리 추상화 제공)</td>
</tr>
</tbody>
</table>
<h3 id="1512-jdbc-vs-r2dbc">15.1.2 JDBC vs R2DBC</h3>
<table>
<thead>
<tr>
<th>구분</th>
<th>JDBC</th>
<th>R2DBC</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>I/O 모델</strong></td>
<td>블로킹</td>
<td>논블로킹</td>
</tr>
<tr>
<td><strong>스레드 모델</strong></td>
<td>요청당 스레드 점유</td>
<td>이벤트 루프 기반</td>
</tr>
<tr>
<td><strong>반환 타입</strong></td>
<td><code>ResultSet</code>, <code>List&lt;T&gt;</code></td>
<td><code>Mono&lt;T&gt;</code>, <code>Flux&lt;T&gt;</code></td>
</tr>
<tr>
<td><strong>배압 지원</strong></td>
<td>없음</td>
<td>Reactive Streams 기반 지원</td>
</tr>
<tr>
<td><strong>트랜잭션</strong></td>
<td><code>ThreadLocal</code> 기반</td>
<td>Reactor Context 기반</td>
</tr>
<tr>
<td><strong>커넥션 풀</strong></td>
<td>HikariCP 등</td>
<td><code>r2dbc-pool</code></td>
</tr>
<tr>
<td><strong>Spring 통합</strong></td>
<td>Spring Data JPA</td>
<td>Spring Data R2DBC</td>
</tr>
</tbody>
</table>
<p>JDBC 기반의 <code>JdbcTemplate</code>이나 JPA를 WebFlux 환경에서 사용하면 이벤트 루프 스레드가 블로킹되어 전체 애플리케이션의 처리량이 급격히 저하된다. R2DBC는 이 문제를 근본적으로 해결한다.</p>
<pre class="highlight"><code>[JDBC + WebFlux]
이벤트 루프 스레드 → DB 쿼리 실행(블로킹) → 스레드 대기 → 처리량 저하

[R2DBC + WebFlux]
이벤트 루프 스레드 → DB 쿼리 요청(논블로킹) → 다른 요청 처리 → 결과 도착 시 콜백</code></pre>
<h3 id="1513">15.1.3 지원 데이터베이스와 의존성 설정</h3>
<p>R2DBC는 SPI 명세이므로, 각 데이터베이스 벤더 또는 커뮤니티가 드라이버를 제공한다.</p>
<table>
<thead>
<tr>
<th>데이터베이스</th>
<th>Maven/Gradle Artifact</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>PostgreSQL</strong></td>
<td><code>org.postgresql:r2dbc-postgresql</code></td>
</tr>
<tr>
<td><strong>MySQL</strong></td>
<td><code>io.asyncer:r2dbc-mysql</code></td>
</tr>
<tr>
<td><strong>MariaDB</strong></td>
<td><code>org.mariadb:r2dbc-mariadb</code></td>
</tr>
<tr>
<td><strong>H2</strong></td>
<td><code>io.r2dbc:r2dbc-h2</code></td>
</tr>
<tr>
<td><strong>Oracle</strong></td>
<td><code>com.oracle.database.r2dbc:oracle-r2dbc</code></td>
</tr>
</tbody>
</table>
<p>이 장에서는 가장 널리 사용되는 <strong>PostgreSQL</strong>을 기준으로 설명한다. <code>build.gradle</code>에 R2DBC 관련 의존성을 추가한다.</p>
<pre class="highlight"><code class="language-groovy">dependencies {
    // 기존 의존성
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    implementation 'org.springframework.boot:spring-boot-starter-data-mongodb-reactive'

    // R2DBC 의존성 추가
    implementation 'org.springframework.boot:spring-boot-starter-data-r2dbc'
    implementation 'org.postgresql:r2dbc-postgresql'

    // Flyway (스키마 마이그레이션) - R2DBC에서는 JDBC 드라이버도 필요
    implementation 'org.flywaydb:flyway-core'
    implementation 'org.flywaydb:flyway-database-postgresql'
    runtimeOnly 'org.postgresql:postgresql'

    testImplementation 'io.r2dbc:r2dbc-h2'
}</code></pre>
<blockquote>
<p><strong>참고</strong>: Flyway 같은 스키마 마이그레이션 도구는 아직 R2DBC를 직접 지원하지 않으므로, 마이그레이션 실행 시에만 JDBC 드라이버가 필요하다. Spring Boot는 시작 시 JDBC 드라이버로 마이그레이션을 수행한 후, 런타임에는 R2DBC 드라이버를 사용한다.</p>
</blockquote>
<h3 id="1514-spring-data-r2dbc">15.1.4 Spring Data R2DBC의 핵심 구성 요소</h3>
<table>
<thead>
<tr>
<th>구성 요소</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ReactiveCrudRepository</code></td>
<td>기본 CRUD 연산을 제공하는 리포지토리 인터페이스</td>
</tr>
<tr>
<td><code>R2dbcEntityTemplate</code></td>
<td><code>ReactiveMongoTemplate</code>에 대응하는 저수준 템플릿</td>
</tr>
<tr>
<td><code>@Table</code>, <code>@Id</code>, <code>@Column</code></td>
<td>엔티티 매핑 어노테이션 (<code>@Entity</code>는 사용하지 않음)</td>
</tr>
<tr>
<td><code>DatabaseClient</code></td>
<td>SQL을 직접 작성하여 실행하는 저수준 클라이언트</td>
</tr>
<tr>
<td><code>R2dbcTransactionManager</code></td>
<td>리액티브 트랜잭션 관리자</td>
</tr>
</tbody>
</table>
<p>MongoDB의 <code>ReactiveMongoRepository</code>를 사용해본 개발자라면 R2DBC 리포지토리도 거의 동일한 방식으로 사용할 수 있다.</p>
<pre class="highlight"><code class="language-java">// MongoDB 리포지토리 (이미 익숙한 패턴)
public interface ProductRepository
        extends ReactiveMongoRepository&lt;Product, String&gt; {
    Flux&lt;Product&gt; findByCategory(String category);
}

// R2DBC 리포지토리 (거의 동일한 패턴)
public interface PaymentRepository
        extends ReactiveCrudRepository&lt;Payment, Long&gt; {
    Flux&lt;Payment&gt; findByUserId(Long userId);
}</code></pre>
<hr>
<h2 id="152-mongodb-r2dbc-db">15.2 MongoDB + R2DBC(관계형 DB) 멀티 데이터소스 구성</h2>
<h3 id="1521">15.2.1 아키텍처 설계</h3>
<p>멀티 데이터소스 아키텍처에서 각 데이터베이스의 역할을 명확히 나누는 것이 중요하다.</p>
<pre class="highlight"><code>┌─────────────────────────────────────────────────┐
│                   Spring WebFlux                 │
│                                                  │
│  ┌──────────────┐         ┌──────────────────┐  │
│  │  R2DBC Layer │         │  MongoDB Layer   │  │
│  │ - 사용자     │         │ - 상품 카탈로그  │  │
│  │ - 주문/결제  │         │ - 상품 리뷰      │  │
│  │ - 재고       │         │ - 활동 로그      │  │
│  └──────┬───────┘         └────────┬─────────┘  │
└─────────┼──────────────────────────┼─────────────┘
          │                          │
    ┌─────▼─────┐             ┌──────▼──────┐
    │ PostgreSQL │             │   MongoDB   │
    └───────────┘             └─────────────┘</code></pre>
<table>
<thead>
<tr>
<th>PostgreSQL (R2DBC)</th>
<th>MongoDB</th>
</tr>
</thead>
<tbody>
<tr>
<td>강한 일관성, ACID 트랜잭션 필수</td>
<td>유연한 스키마, 비정형 데이터</td>
</tr>
<tr>
<td>복잡한 조인이 필요한 데이터</td>
<td>높은 쓰기 처리량이 필요한 데이터</td>
</tr>
<tr>
<td>예: 사용자, 주문, 결제, 재고</td>
<td>예: 상품 카탈로그, 리뷰, 로그</td>
</tr>
</tbody>
</table>
<h3 id="1522-applicationyml">15.2.2 application.yml 두 데이터소스 설정</h3>
<pre class="highlight"><code class="language-yaml">spring:
  # MongoDB 설정
  data:
    mongodb:
      uri: mongodb://localhost:27017/shopdb
      auto-index-creation: true

  # R2DBC (PostgreSQL) 설정
  r2dbc:
    url: r2dbc:postgresql://localhost:5432/shopdb
    username: shopuser
    password: ${DB_PASSWORD:shoppass}
    pool:
      initial-size: 5
      max-size: 20
      max-idle-time: 30m

  # Flyway (JDBC 기반 마이그레이션)
  flyway:
    enabled: true
    url: jdbc:postgresql://localhost:5432/shopdb
    user: shopuser
    password: ${DB_PASSWORD:shoppass}
    locations: classpath:db/migration</code></pre>
<h3 id="1523-flyway">15.2.3 Flyway 스키마 마이그레이션</h3>
<p>R2DBC는 관계형 DB를 사용하므로 테이블 스키마를 사전에 정의해야 한다. <code>src/main/resources/db/migration/V1__init.sql</code> 파일을 작성한다.</p>
<pre class="highlight"><code class="language-sql">CREATE TABLE users (
    id          BIGSERIAL PRIMARY KEY,
    username    VARCHAR(50)  NOT NULL UNIQUE,
    email       VARCHAR(100) NOT NULL UNIQUE,
    password    VARCHAR(255) NOT NULL,
    role        VARCHAR(20)  NOT NULL DEFAULT 'USER',
    created_at  TIMESTAMP    NOT NULL DEFAULT NOW()
);

CREATE TABLE orders (
    id              BIGSERIAL PRIMARY KEY,
    user_id         BIGINT       NOT NULL REFERENCES users(id),
    order_number    VARCHAR(30)  NOT NULL UNIQUE,
    status          VARCHAR(20)  NOT NULL DEFAULT 'PENDING',
    total_amount    DECIMAL(12,2) NOT NULL,
    shipping_address TEXT,
    created_at      TIMESTAMP    NOT NULL DEFAULT NOW()
);

CREATE TABLE order_items (
    id          BIGSERIAL PRIMARY KEY,
    order_id    BIGINT       NOT NULL REFERENCES orders(id),
    product_id  VARCHAR(50)  NOT NULL,  -- MongoDB ObjectId 참조
    product_name VARCHAR(200) NOT NULL,
    quantity    INT          NOT NULL,
    unit_price  DECIMAL(10,2) NOT NULL,
    subtotal    DECIMAL(12,2) NOT NULL
);

CREATE TABLE payments (
    id              BIGSERIAL PRIMARY KEY,
    order_id        BIGINT       NOT NULL REFERENCES orders(id),
    payment_method  VARCHAR(30)  NOT NULL,
    amount          DECIMAL(12,2) NOT NULL,
    status          VARCHAR(20)  NOT NULL DEFAULT 'PENDING',
    transaction_id  VARCHAR(100),
    created_at      TIMESTAMP    NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_order_items_order_id ON order_items(order_id);</code></pre>
<h3 id="1524-mongodbr2dbc">15.2.4 MongoDB/R2DBC 설정 클래스</h3>
<p>두 데이터소스의 리포지토리 스캔 경로를 분리한다.</p>
<pre class="highlight"><code class="language-java">@Configuration
@EnableR2dbcRepositories(basePackages = "com.example.shop.repository.r2dbc")
public class R2dbcConfig extends AbstractR2dbcConfiguration {

    @Value("${spring.r2dbc.url}")
    private String url;

    @Value("${spring.r2dbc.username}")
    private String username;

    @Value("${spring.r2dbc.password}")
    private String password;

    @Override
    @Bean
    public ConnectionFactory connectionFactory() {
        return ConnectionFactories.get(ConnectionFactoryOptions.builder()
            .from(ConnectionFactoryOptions.parse(url))
            .option(ConnectionFactoryOptions.USER, username)
            .option(ConnectionFactoryOptions.PASSWORD, password)
            .build());
    }

    @Bean
    public ReactiveTransactionManager transactionManager(
            ConnectionFactory connectionFactory) {
        return new R2dbcTransactionManager(connectionFactory);
    }
}</code></pre>
<pre class="highlight"><code class="language-java">@Configuration
@EnableReactiveMongoRepositories(
    basePackages = "com.example.shop.repository.mongo"
)
public class MongoConfig extends AbstractReactiveMongoConfiguration {

    @Value("${spring.data.mongodb.uri}")
    private String mongoUri;

    @Override
    protected String getDatabaseName() {
        return "shopdb";
    }

    @Override
    @Bean
    public MongoClient reactiveMongoClient() {
        return MongoClients.create(mongoUri);
    }

    @Bean
    public ReactiveMongoTransactionManager mongoTransactionManager(
            ReactiveMongoDatabaseFactory dbFactory) {
        return new ReactiveMongoTransactionManager(dbFactory);
    }
}</code></pre>
<h3 id="1525">15.2.5 패키지 구조</h3>
<p>멀티 데이터소스를 사용할 때 패키지 구조를 명확히 분리하는 것이 유지보수에 유리하다.</p>
<pre class="highlight"><code>com.example.shop
├── config
│   ├── R2dbcConfig.java
│   └── MongoConfig.java
├── domain
│   ├── rdb                         # R2DBC 엔티티
│   │   ├── UserEntity.java
│   │   ├── OrderEntity.java
│   │   └── OrderItemEntity.java
│   └── mongo                       # MongoDB 도큐먼트
│       ├── Product.java
│       └── Review.java
├── repository
│   ├── r2dbc                       # R2DBC 리포지토리
│   │   ├── UserRepository.java
│   │   └── OrderRepository.java
│   └── mongo                       # MongoDB 리포지토리
│       ├── ProductRepository.java
│       └── ReviewRepository.java
├── service
└── controller</code></pre>
<h3 id="1526">15.2.6 엔티티와 도큐먼트 정의</h3>
<p>R2DBC 엔티티는 <code>@Table</code>, <code>@Id</code>, <code>@Column</code> 어노테이션을 사용한다.</p>
<pre class="highlight"><code class="language-java">@Table("orders")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OrderEntity {

    @Id
    private Long id;

    @Column("user_id")
    private Long userId;

    @Column("order_number")
    private String orderNumber;

    private String status;

    @Column("total_amount")
    private BigDecimal totalAmount;

    @Column("shipping_address")
    private String shippingAddress;

    @Column("created_at")
    private LocalDateTime createdAt;
}</code></pre>
<p>MongoDB 도큐먼트는 유연한 스키마의 장점을 활용한다.</p>
<pre class="highlight"><code class="language-java">@Document(collection = "products")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Product {

    @Id
    private String id;
    private String name;
    private String description;
    private String category;
    private BigDecimal price;
    private int stockQuantity;
    private List&lt;String&gt; tags;
    private Map&lt;String, String&gt; attributes;  // 유연한 속성
    private LocalDateTime createdAt;
}</code></pre>
<h3 id="1527">15.2.7 각 리포지토리</h3>
<p>두 데이터소스의 리포지토리를 패키지별로 분리하여 정의한다.</p>
<pre class="highlight"><code class="language-java">// R2DBC 리포지토리 (com.example.shop.repository.r2dbc)
public interface OrderRepository extends ReactiveCrudRepository&lt;OrderEntity, Long&gt; {
    Flux&lt;OrderEntity&gt; findByUserIdOrderByCreatedAtDesc(Long userId);
    Mono&lt;OrderEntity&gt; findByOrderNumber(String orderNumber);
}

public interface OrderItemRepository
        extends ReactiveCrudRepository&lt;OrderItemEntity, Long&gt; {
    Flux&lt;OrderItemEntity&gt; findByOrderId(Long orderId);
}</code></pre>
<pre class="highlight"><code class="language-java">// MongoDB 리포지토리 (com.example.shop.repository.mongo)
public interface ProductRepository
        extends ReactiveMongoRepository&lt;Product, String&gt; {
    Flux&lt;Product&gt; findByCategory(String category);

    @Query("{ 'price': { '$gte': ?0, '$lte': ?1 } }")
    Flux&lt;Product&gt; findByPriceRange(BigDecimal minPrice, BigDecimal maxPrice);
}

public interface ReviewRepository
        extends ReactiveMongoRepository&lt;Review, String&gt; {
    Flux&lt;Review&gt; findByProductIdOrderByCreatedAtDesc(String productId);
    Mono&lt;Long&gt; countByProductId(String productId);
}</code></pre>
<hr>
<h2 id="153">15.3 리액티브 환경에서 여러 데이터소스 조합하기</h2>
<h3 id="1531">15.3.1 데이터 조합 패턴</h3>
<p>두 데이터소스의 데이터를 조합할 때 Reactor의 연산자를 활용한다.</p>
<p><strong>패턴 1: 순차 조합 (flatMap)</strong> -- 한쪽 결과를 기반으로 다른 데이터소스를 조회한다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class OrderQueryService {

    private final OrderRepository orderRepository;         // R2DBC
    private final OrderItemRepository orderItemRepository; // R2DBC
    private final ProductRepository productRepository;     // MongoDB

    public Mono&lt;OrderDetailResponse&gt; getOrderDetail(Long orderId) {
        return orderRepository.findById(orderId)
            .switchIfEmpty(Mono.error(
                new NotFoundException("주문을 찾을 수 없습니다: " + orderId)))
            .flatMap(order -&gt; orderItemRepository.findByOrderId(orderId)
                .flatMap(item -&gt; productRepository.findById(item.getProductId())
                    .map(product -&gt; OrderItemDetail.builder()
                        .productName(product.getName())
                        .category(product.getCategory())
                        .quantity(item.getQuantity())
                        .unitPrice(item.getUnitPrice())
                        .build()))
                .collectList()
                .map(items -&gt; OrderDetailResponse.builder()
                    .orderId(order.getId())
                    .orderNumber(order.getOrderNumber())
                    .status(order.getStatus())
                    .totalAmount(order.getTotalAmount())
                    .items(items)
                    .createdAt(order.getCreatedAt())
                    .build()));
    }
}</code></pre>
<p><strong>패턴 2: 병렬 조합 (zip)</strong> -- 서로 독립적인 데이터를 병렬로 조회하여 조합한다.</p>
<pre class="highlight"><code class="language-java">public Mono&lt;ProductPageResponse&gt; getProductPage(String productId) {
    Mono&lt;Product&gt; productMono = productRepository.findById(productId)
        .switchIfEmpty(Mono.error(
            new NotFoundException("상품을 찾을 수 없습니다: " + productId)));

    Mono&lt;List&lt;Review&gt;&gt; reviewsMono = reviewRepository
        .findByProductIdOrderByCreatedAtDesc(productId)
        .collectList();

    Mono&lt;Long&gt; reviewCountMono = reviewRepository.countByProductId(productId);

    return Mono.zip(productMono, reviewsMono, reviewCountMono)
        .map(tuple -&gt; ProductPageResponse.builder()
            .product(tuple.getT1())
            .reviews(tuple.getT2())
            .totalReviews(tuple.getT3())
            .build());
}</code></pre>
<h3 id="1532">15.3.2 트랜잭션 주의사항</h3>
<p>멀티 데이터소스 환경에서 트랜잭션은 가장 까다로운 부분이다.</p>
<p><strong>원칙 1: 각 데이터소스의 트랜잭션은 독립적이다</strong></p>
<pre class="highlight"><code class="language-java">// 이 코드는 PostgreSQL 트랜잭션만 보장한다.
// MongoDB 저장이 실패해도 PostgreSQL 변경은 롤백되지 않는다!
@Transactional  // R2dbcTransactionManager가 기본으로 동작
public Mono&lt;Order&gt; createOrder(OrderRequest request) {
    return orderRepository.save(orderEntity)           // PostgreSQL - 트랜잭션 O
        .flatMap(order -&gt;
            productRepository.save(updatedProduct)     // MongoDB - 트랜잭션 X
                .thenReturn(order));
}</code></pre>
<p><strong>원칙 2: 트랜잭션 매니저를 명시적으로 지정한다</strong></p>
<pre class="highlight"><code class="language-java">// PostgreSQL 트랜잭션 사용
@Transactional("transactionManager")
public Mono&lt;OrderEntity&gt; saveOrder(OrderEntity order) {
    return orderRepository.save(order);
}

// MongoDB 트랜잭션 사용
@Transactional("mongoTransactionManager")
public Mono&lt;Product&gt; updateProduct(Product product) {
    return productRepository.save(product);
}</code></pre>
<p><strong>원칙 3: 보상 트랜잭션(Saga) 패턴을 활용한다</strong></p>
<p>두 데이터소스에 걸친 작업에서 일관성을 보장하려면 Saga 패턴을 적용한다. 한쪽이 실패하면 이미 성공한 다른 쪽의 변경을 보상(되돌리기)하는 방식이다.</p>
<h3 id="1533-saga">15.3.3 실전 예제: 주문 시스템 (Saga 패턴)</h3>
<p>재고 차감(MongoDB) -&gt; 주문 생성(PostgreSQL) -&gt; 결제 처리(PostgreSQL) 순서로 진행하며, 각 단계 실패 시 이전 단계를 보상하는 서비스를 구현한다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
@Slf4j
public class OrderSagaService {

    private final OrderRepository orderRepository;
    private final OrderItemRepository orderItemRepository;
    private final ProductRepository productRepository;
    private final PaymentRepository paymentRepository;

    /**
     * 보상 트랜잭션 패턴:
     * 1. 재고 차감 (MongoDB) -&gt; 실패 시 즉시 에러
     * 2. 주문 생성 (PostgreSQL) -&gt; 실패 시 재고 복원
     * 3. 결제 처리 (PostgreSQL) -&gt; 실패 시 주문 취소 + 재고 복원
     */
    public Mono&lt;OrderResult&gt; placeOrder(Long userId, OrderRequest request) {
        return decreaseStock(request.getItems())
            .then(createOrderInDb(userId, request))
            .flatMap(order -&gt; processPayment(order, request)
                .thenReturn(order)
                .onErrorResume(paymentError -&gt; {
                    log.error("결제 실패, 보상 시작", paymentError);
                    return cancelOrder(order)
                        .then(restoreStock(request.getItems()))
                        .then(Mono.error(new PaymentException(
                            "결제 처리에 실패했습니다.", paymentError)));
                }))
            .onErrorResume(orderError -&gt; {
                if (!(orderError instanceof PaymentException)) {
                    log.error("주문 생성 실패, 재고 복원", orderError);
                    return restoreStock(request.getItems())
                        .then(Mono.error(new OrderException(
                            "주문 생성에 실패했습니다.", orderError)));
                }
                return Mono.error(orderError);
            })
            .map(order -&gt; OrderResult.builder()
                .orderId(order.getId())
                .orderNumber(order.getOrderNumber())
                .status("COMPLETED")
                .build());
    }

    private Mono&lt;Void&gt; decreaseStock(List&lt;OrderItemRequest&gt; items) {
        return Flux.fromIterable(items)
            .flatMap(item -&gt; productRepository.findById(item.getProductId())
                .switchIfEmpty(Mono.error(new NotFoundException(
                    "상품을 찾을 수 없습니다: " + item.getProductId())))
                .flatMap(product -&gt; {
                    if (product.getStockQuantity() &lt; item.getQuantity()) {
                        return Mono.error(new InsufficientStockException(
                            product.getName() + " 재고가 부족합니다."));
                    }
                    product.setStockQuantity(
                        product.getStockQuantity() - item.getQuantity());
                    return productRepository.save(product);
                }))
            .then();
    }

    private Mono&lt;Void&gt; restoreStock(List&lt;OrderItemRequest&gt; items) {
        return Flux.fromIterable(items)
            .flatMap(item -&gt; productRepository.findById(item.getProductId())
                .flatMap(product -&gt; {
                    product.setStockQuantity(
                        product.getStockQuantity() + item.getQuantity());
                    return productRepository.save(product);
                }))
            .then();
    }

    private Mono&lt;OrderEntity&gt; createOrderInDb(Long userId, OrderRequest request) {
        OrderEntity order = OrderEntity.builder()
            .userId(userId)
            .orderNumber("ORD-" + System.currentTimeMillis())
            .status("PENDING")
            .totalAmount(request.calculateTotalAmount())
            .shippingAddress(request.getShippingAddress())
            .createdAt(LocalDateTime.now())
            .build();

        return orderRepository.save(order)
            .flatMap(savedOrder -&gt; {
                List&lt;OrderItemEntity&gt; orderItems = request.getItems().stream()
                    .map(item -&gt; OrderItemEntity.builder()
                        .orderId(savedOrder.getId())
                        .productId(item.getProductId())
                        .productName(item.getProductName())
                        .quantity(item.getQuantity())
                        .unitPrice(item.getUnitPrice())
                        .subtotal(item.getUnitPrice()
                            .multiply(BigDecimal.valueOf(item.getQuantity())))
                        .build())
                    .toList();
                return orderItemRepository.saveAll(orderItems)
                    .then(Mono.just(savedOrder));
            });
    }

    private Mono&lt;Void&gt; processPayment(OrderEntity order, OrderRequest request) {
        PaymentEntity payment = PaymentEntity.builder()
            .orderId(order.getId())
            .paymentMethod(request.getPaymentMethod())
            .amount(order.getTotalAmount())
            .status("COMPLETED")
            .transactionId("TXN-" + UUID.randomUUID())
            .createdAt(LocalDateTime.now())
            .build();
        return paymentRepository.save(payment).then();
    }

    private Mono&lt;Void&gt; cancelOrder(OrderEntity order) {
        order.setStatus("CANCELLED");
        return orderRepository.save(order).then();
    }
}</code></pre>
<h3 id="1534">15.3.4 컨트롤러 구현</h3>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/orders")
@RequiredArgsConstructor
public class OrderController {

    private final OrderSagaService orderSagaService;
    private final OrderQueryService orderQueryService;

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono&lt;OrderResult&gt; placeOrder(
            @AuthenticationPrincipal Mono&lt;UserDetails&gt; principal,
            @Valid @RequestBody OrderRequest request) {
        return principal.flatMap(user -&gt; {
            Long userId = Long.parseLong(user.getUsername());
            return orderSagaService.placeOrder(userId, request);
        });
    }

    @GetMapping("/{orderId}")
    public Mono&lt;OrderDetailResponse&gt; getOrderDetail(@PathVariable Long orderId) {
        return orderQueryService.getOrderDetail(orderId);
    }

    @GetMapping("/my")
    public Flux&lt;OrderSummaryResponse&gt; getMyOrders(
            @AuthenticationPrincipal Mono&lt;UserDetails&gt; principal) {
        return principal.flatMapMany(user -&gt; {
            Long userId = Long.parseLong(user.getUsername());
            return orderQueryService.getUserOrders(userId);
        });
    }
}</code></pre>
<h3 id="1535-databaseclient">15.3.5 DatabaseClient를 활용한 복잡한 쿼리</h3>
<p>Spring Data R2DBC의 메서드 이름 기반 쿼리로 부족할 때, <code>DatabaseClient</code>로 SQL을 직접 작성한다.</p>
<pre class="highlight"><code class="language-java">@Repository
@RequiredArgsConstructor
public class OrderCustomRepository {

    private final DatabaseClient databaseClient;

    public Flux&lt;SalesStatistics&gt; getSalesStatistics(
            LocalDateTime from, LocalDateTime to) {
        String sql = """
            SELECT DATE(o.created_at) AS sale_date,
                   COUNT(o.id) AS order_count,
                   SUM(o.total_amount) AS total_sales
            FROM orders o
            WHERE o.status = 'COMPLETED'
              AND o.created_at BETWEEN :from AND :to
            GROUP BY DATE(o.created_at)
            ORDER BY sale_date DESC
            """;

        return databaseClient.sql(sql)
            .bind("from", from)
            .bind("to", to)
            .map((row, metadata) -&gt; SalesStatistics.builder()
                .saleDate(row.get("sale_date", LocalDate.class))
                .orderCount(row.get("order_count", Long.class))
                .totalSales(row.get("total_sales", BigDecimal.class))
                .build())
            .all();
    }
}</code></pre>
<h3 id="1536">15.3.6 두 데이터소스 통계 조합</h3>
<p>PostgreSQL의 주문 통계와 MongoDB의 상품 상세 정보를 조합하는 대시보드 서비스다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class DashboardService {

    private final OrderCustomRepository orderCustomRepository;
    private final ProductRepository productRepository;
    private final ReviewRepository reviewRepository;

    public Flux&lt;PopularProductDashboard&gt; getPopularProductDashboard(int limit) {
        return orderCustomRepository.getPopularProducts(limit)
            .flatMap(stats -&gt; {
                Mono&lt;Product&gt; productMono = productRepository
                    .findById(stats.getProductId())
                    .defaultIfEmpty(Product.builder()
                        .id(stats.getProductId())
                        .name(stats.getProductName())
                        .category("UNKNOWN").build());

                Mono&lt;Double&gt; avgRatingMono = reviewRepository
                    .findByProductIdOrderByCreatedAtDesc(stats.getProductId())
                    .map(Review::getRating)
                    .collectList()
                    .map(ratings -&gt; ratings.stream()
                        .mapToInt(Integer::intValue).average().orElse(0.0));

                return Mono.zip(productMono, avgRatingMono)
                    .map(tuple -&gt; PopularProductDashboard.builder()
                        .productId(stats.getProductId())
                        .productName(stats.getProductName())
                        .category(tuple.getT1().getCategory())
                        .totalQuantitySold(stats.getTotalQuantity())
                        .averageRating(tuple.getT2())
                        .build());
            });
    }
}</code></pre>
<h3 id="1537">15.3.7 멀티 데이터소스 환경의 베스트 프랙티스</h3>
<p><strong>1. 데이터 비정규화로 정합성 관리</strong></p>
<pre class="highlight"><code class="language-java">// 올바른 패턴: 주문 시점의 상품 정보를 비정규화하여 저장
@Table("order_items")
public class OrderItemEntity {
    private String productId;     // MongoDB ObjectId 참조
    private String productName;   // 비정규화 (주문 시점 상품명)
    private BigDecimal unitPrice; // 비정규화 (주문 시점 가격)
}</code></pre>
<p><strong>2. 에러 처리 통합</strong></p>
<pre class="highlight"><code class="language-java">@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(DataIntegrityViolationException.class)
    @ResponseStatus(HttpStatus.CONFLICT)
    public Mono&lt;ErrorResponse&gt; handleDataIntegrity(
            DataIntegrityViolationException ex) {
        return Mono.just(ErrorResponse.of("DATA_CONFLICT",
            "데이터 무결성 위반이 발생했습니다."));
    }

    @ExceptionHandler(DuplicateKeyException.class)
    @ResponseStatus(HttpStatus.CONFLICT)
    public Mono&lt;ErrorResponse&gt; handleDuplicateKey(DuplicateKeyException ex) {
        return Mono.just(ErrorResponse.of("DUPLICATE_KEY",
            "중복된 데이터가 존재합니다."));
    }
}</code></pre>
<p><strong>3. 헬스 체크 통합</strong></p>
<pre class="highlight"><code class="language-java">@Component
@RequiredArgsConstructor
public class MultiDataSourceHealthIndicator
        implements ReactiveHealthIndicator {

    private final ConnectionFactory connectionFactory;
    private final ReactiveMongoTemplate mongoTemplate;

    @Override
    public Mono&lt;Health&gt; health() {
        Mono&lt;String&gt; r2dbcHealth = Mono.from(connectionFactory.create())
            .flatMap(conn -&gt; Mono.from(conn.createStatement("SELECT 1")
                .execute())
                .flatMap(result -&gt; Mono.from(result.map((row, meta) -&gt; "UP")))
                .doFinally(signal -&gt; conn.close()))
            .onErrorReturn("DOWN");

        Mono&lt;String&gt; mongoHealth = mongoTemplate.executeCommand("{ ping: 1 }")
            .map(doc -&gt; "UP")
            .onErrorReturn("DOWN");

        return Mono.zip(r2dbcHealth, mongoHealth)
            .map(tuple -&gt; {
                boolean allUp = "UP".equals(tuple.getT1())
                             &amp;&amp; "UP".equals(tuple.getT2());
                return (allUp ? Health.up() : Health.down())
                    .withDetail("postgresql", tuple.getT1())
                    .withDetail("mongodb", tuple.getT2())
                    .build();
            });
    }
}</code></pre>
<h3 id="1538">15.3.8 주의사항 정리</h3>
<table>
<thead>
<tr>
<th>함정</th>
<th>대응 방법</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>분산 트랜잭션 불가</strong>: <code>@Transactional</code> 하나로 두 DB를 묶을 수 없음</td>
<td>Saga 패턴, 보상 트랜잭션</td>
</tr>
<tr>
<td><strong>참조 무결성 부재</strong>: 두 DB 간 외래 키 제약 없음</td>
<td>비정규화, 방어적 코딩, 정기 정합성 검증 배치</td>
</tr>
<tr>
<td><strong>트랜잭션 매니저 충돌</strong>: 기본 <code>@Transactional</code>이 어느 매니저를 쓸지 모호</td>
<td><code>@Transactional("매니저명")</code> 명시</td>
</tr>
<tr>
<td><strong>N+1 쿼리</strong>: 두 데이터소스 조합 시 반복 조회 발생</td>
<td><code>collectList()</code> 후 일괄 조회, 캐싱</td>
</tr>
<tr>
<td><strong>에러 타입 혼재</strong>: R2DBC와 MongoDB가 다른 예외 체계 사용</td>
<td>통합 예외 핸들러, 비즈니스 예외로 래핑</td>
</tr>
<tr>
<td><strong>스키마 관리</strong>: R2DBC는 DDL 자동 생성 미지원</td>
<td>Flyway 또는 Liquibase 사용</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="_4">요약</h2>
<p>이번 장에서는 리액티브 환경에서 관계형 데이터베이스에 접근하기 위한 R2DBC를 소개하고, MongoDB와 함께 사용하는 멀티 데이터소스 아키텍처를 다루었다.</p>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 내용</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>R2DBC 소개</strong></td>
<td>JDBC의 리액티브 대안, Reactive Streams 기반 논블로킹 DB 접근</td>
</tr>
<tr>
<td><strong>JDBC vs R2DBC</strong></td>
<td>블로킹 vs 논블로킹, ThreadLocal vs Reactor Context 기반 트랜잭션</td>
</tr>
<tr>
<td><strong>멀티 데이터소스 구성</strong></td>
<td>패키지 분리, 설정 클래스 분리, 리포지토리 스캔 경로 분리</td>
</tr>
<tr>
<td><strong>데이터 조합</strong></td>
<td><code>flatMap</code>(순차), <code>zip</code>(병렬)을 활용한 조합 패턴</td>
</tr>
<tr>
<td><strong>트랜잭션 관리</strong></td>
<td>분산 트랜잭션 불가, Saga 패턴과 보상 트랜잭션으로 대응</td>
</tr>
<tr>
<td><strong>실전 예제</strong></td>
<td>주문 시스템 -- 재고 차감(MongoDB) + 주문 생성(PostgreSQL) + 결제 처리</td>
</tr>
</tbody>
</table>
<p>R2DBC는 WebFlux 기반 애플리케이션에서 관계형 데이터베이스를 사용할 때 유일한 리액티브 선택지다. MongoDB와 함께 사용하면 각 데이터베이스의 장점을 최대한 활용할 수 있지만, 분산 트랜잭션과 데이터 정합성에 대한 신중한 설계가 필요하다.</p>
<p>다음 장에서는 리액티브 테스트 전략을 다루며, StepVerifier와 WebTestClient를 활용한 테스트 작성법을 살펴본다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>