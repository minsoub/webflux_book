<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 20. 컨테이너화와 배포 | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="ch19.html">&larr; Chapter 19. 성능 최적화</a>
    <a href="../index.html">목차</a>
    <a href="ch21.html">Chapter 21. 실전 프로젝트: 실시간 게시판 서비스 &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-20">Chapter 20. 컨테이너화와 배포</h1>
<p>리액티브 애플리케이션을 개발하고 최적화했다면, 이제 이를 안정적으로 운영 환경에 배포해야 한다. 현대 소프트웨어 배포의 표준은 <strong>컨테이너(Container)</strong>다. Docker를 활용하면 애플리케이션과 실행 환경을 하나의 이미지로 패키징하여 어디서든 동일하게 실행할 수 있고, Kubernetes를 통해 이를 자동으로 확장하고 관리할 수 있다. 이번 장에서는 Spring Boot WebFlux + MongoDB 리액티브 애플리케이션을 <strong>Docker 이미지로 빌드</strong>하고, <strong>Docker Compose로 전체 스택을 구성</strong>하며, <strong>Kubernetes에 배포</strong>하고, <strong>MongoDB Atlas와 연동</strong>하고, <strong>GitHub Actions CI/CD 파이프라인</strong>을 구축하며, <strong>GraalVM Native Image</strong>로 빌드하는 전 과정을 다룬다.</p>
<hr>
<h2 id="201-docker-jib-buildpacks">20.1 Docker 이미지 빌드 (Jib, Buildpacks)</h2>
<p>Spring Boot 애플리케이션을 Docker 이미지로 만드는 방법은 크게 세 가지다. 직접 Dockerfile을 작성하는 방법, Google의 Jib을 사용하는 방법, 그리고 Spring Boot가 내장 지원하는 Cloud Native Buildpacks를 사용하는 방법이다.</p>
<h3 id="2011-jib-docker">20.1.1 Jib을 활용한 Docker 이미지 빌드</h3>
<p>Jib은 Google이 개발한 Java 컨테이너 이미지 빌드 도구다. <strong>Docker 데몬 없이</strong> 이미지를 빌드하고 레지스트리에 직접 푸시할 수 있다. <code>build.gradle</code>에 플러그인을 추가한다.</p>
<pre class="highlight"><code class="language-groovy">plugins {
    id 'org.springframework.boot' version '3.4.1'
    id 'io.spring.dependency-management' version '1.1.7'
    id 'com.google.cloud.tools.jib' version '3.4.4'
    id 'java'
}

jib {
    from {
        image = 'eclipse-temurin:21-jre'
        platforms {
            platform {
                architecture = 'amd64'
                os = 'linux'
            }
            platform {
                architecture = 'arm64'
                os = 'linux'
            }
        }
    }
    to {
        image = 'ghcr.io/myorg/webflux-app'
        tags = [project.version, 'latest']
        auth {
            username = System.getenv('REGISTRY_USERNAME')
            password = System.getenv('REGISTRY_PASSWORD')
        }
    }
    container {
        jvmFlags = [
            '-XX:+UseZGC',
            '-XX:MaxRAMPercentage=75.0',
            '-Djava.security.egd=file:/dev/./urandom',
            '-Dspring.profiles.active=prod'
        ]
        ports = ['8080']
        creationTime = 'USE_CURRENT_TIMESTAMP'
        user = '1000:1000'
    }
}</code></pre>
<p>빌드 명령어는 세 가지로 구분된다.</p>
<pre class="highlight"><code class="language-bash"># Docker 데몬 없이 레지스트리에 직접 푸시
./gradlew jib

# 로컬 Docker 데몬에 이미지 빌드
./gradlew jibDockerBuild

# tar 파일로 이미지 내보내기
./gradlew jibBuildTar</code></pre>
<blockquote>
<p><strong>Tip</strong>: Jib은 애플리케이션을 <code>classes</code>, <code>resources</code>, <code>dependencies</code>, <code>snapshot-dependencies</code>의 네 레이어로 자동 분리한다. 소스 코드만 변경하면 <code>classes</code> 레이어만 다시 빌드되므로 CI/CD에서 빌드 시간을 크게 단축할 수 있다.</p>
</blockquote>
<h3 id="2012-cloud-native-buildpacks">20.1.2 Cloud Native Buildpacks</h3>
<p>Spring Boot 3.x는 Cloud Native Buildpacks를 기본 지원한다. 별도 플러그인 없이 Gradle 태스크로 OCI 이미지를 빌드할 수 있다.</p>
<pre class="highlight"><code class="language-groovy">bootBuildImage {
    imageName = "ghcr.io/myorg/webflux-app:${project.version}"
    environment = [
        'BP_JVM_VERSION': '21',
        'BP_JVM_TYPE': 'JRE',
        'BPE_JAVA_TOOL_OPTIONS': '-XX:+UseZGC -XX:MaxRAMPercentage=75.0'
    ]
    docker {
        publishRegistry {
            username = System.getenv('REGISTRY_USERNAME')
            password = System.getenv('REGISTRY_PASSWORD')
            url = 'https://ghcr.io'
        }
    }
}</code></pre>
<pre class="highlight"><code class="language-bash">./gradlew bootBuildImage</code></pre>
<h3 id="2013">20.1.3 빌드 방식 비교</h3>
<table>
<thead>
<tr>
<th>항목</th>
<th>Dockerfile</th>
<th>Jib</th>
<th>Buildpacks</th>
</tr>
</thead>
<tbody>
<tr>
<td>Docker 데몬 필요</td>
<td>O</td>
<td>X</td>
<td>O</td>
</tr>
<tr>
<td>Dockerfile 필요</td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>빌드 속도</td>
<td>보통</td>
<td>빠름</td>
<td>느림</td>
</tr>
<tr>
<td>레이어 최적화</td>
<td>수동</td>
<td>자동</td>
<td>자동</td>
</tr>
<tr>
<td>멀티 아키텍처</td>
<td>수동 설정</td>
<td>선언적</td>
<td>제한적</td>
</tr>
<tr>
<td>CI/CD 친화성</td>
<td>보통</td>
<td>높음</td>
<td>높음</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>주의</strong>: Buildpacks는 초기 빌드가 느리지만 캐시가 쌓이면 이후 빌드는 빨라진다. CI/CD 환경에서 Docker 데몬 설정이 어렵다면 Jib을 권장한다.</p>
</blockquote>
<hr>
<h2 id="202-docker-compose">20.2 Docker Compose로 전체 스택 구성</h2>
<p>로컬 개발 및 스테이징 환경에서는 Docker Compose를 활용하여 Spring Boot 애플리케이션, MongoDB, Prometheus, Grafana를 한 번에 구성할 수 있다.</p>
<h3 id="2021-docker-compose">20.2.1 Docker Compose 구성 파일</h3>
<pre class="highlight"><code class="language-yaml"># docker/docker-compose.yml
version: '3.8'
services:
  app:
    build:
      context: ..
      dockerfile: Dockerfile
    container_name: webflux-app
    ports:
      - "8080:8080"
    environment:
      SPRING_PROFILES_ACTIVE: docker
      SPRING_DATA_MONGODB_URI: mongodb://appuser:apppass@mongodb:27017/webfluxdb?authSource=admin
      JAVA_TOOL_OPTIONS: &gt;-
        -XX:+UseZGC
        -XX:MaxRAMPercentage=75.0
    depends_on:
      mongodb:
        condition: service_healthy
    networks:
      - app-network
    deploy:
      resources:
        limits:
          memory: 512M
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
      interval: 15s
      timeout: 5s
      retries: 5
      start_period: 30s
  mongodb:
    image: mongo:7.0
    container_name: mongodb
    ports:
      - "27017:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: appuser
      MONGO_INITDB_ROOT_PASSWORD: apppass
      MONGO_INITDB_DATABASE: webfluxdb
    volumes:
      - mongodb-data:/data/db
      - ./mongo/init-mongo.js:/docker-entrypoint-initdb.d/init-mongo.js:ro
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
      interval: 10s
      timeout: 5s
      retries: 5
  prometheus:
    image: prom/prometheus:v2.51.0
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus-data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.retention.time=7d'
    networks:
      - app-network
  grafana:
    image: grafana/grafana:10.4.0
    container_name: grafana
    ports:
      - "3000:3000"
    environment:
      GF_SECURITY_ADMIN_USER: admin
      GF_SECURITY_ADMIN_PASSWORD: admin
    volumes:
      - grafana-data:/var/lib/grafana
      - ./grafana/provisioning:/etc/grafana/provisioning:ro
    networks:
      - app-network
    depends_on:
      - prometheus
volumes:
  mongodb-data:
  prometheus-data:
  grafana-data:
networks:
  app-network:
    driver: bridge</code></pre>
<h3 id="2022-prometheus-mongodb">20.2.2 Prometheus 설정과 MongoDB 초기화</h3>
<pre class="highlight"><code class="language-yaml"># docker/prometheus/prometheus.yml
global:
  scrape_interval: 15s
scrape_configs:
  - job_name: 'webflux-app'
    metrics_path: '/actuator/prometheus'
    scrape_interval: 5s
    static_configs:
      - targets: ['app:8080']</code></pre>
<pre class="highlight"><code class="language-javascript">// docker/mongo/init-mongo.js
db = db.getSiblingDB('webfluxdb');
db.createCollection('products');
db.products.createIndex({ "name": 1 }, { unique: true });
db.products.createIndex({ "category": 1, "price": 1 });</code></pre>
<h3 id="2023-docker">20.2.3 Docker 프로파일용 애플리케이션 설정</h3>
<pre class="highlight"><code class="language-yaml"># src/main/resources/application-docker.yml
spring:
  data:
    mongodb:
      uri: ${SPRING_DATA_MONGODB_URI:mongodb://localhost:27017/webfluxdb}

management:
  endpoints:
    web:
      exposure:
        include: health,info,prometheus,metrics
  endpoint:
    health:
      show-details: always
      probes:
        enabled: true
server:
  port: 8080
  netty:
    connection-timeout: 5s</code></pre>
<pre class="highlight"><code class="language-bash"># 전체 스택 시작
docker compose -f docker/docker-compose.yml up -d

# 로그 확인
docker compose -f docker/docker-compose.yml logs -f app

# 전체 스택 종료 및 볼륨 삭제
docker compose -f docker/docker-compose.yml down -v</code></pre>
<hr>
<h2 id="203-kubernetes">20.3 Kubernetes 배포 기초</h2>
<p>프로덕션 환경에서는 Kubernetes(이하 K8s)를 활용하여 컨테이너화된 애플리케이션을 오케스트레이션한다.</p>
<h3 id="2031-configmap-secret">20.3.1 ConfigMap과 Secret</h3>
<pre class="highlight"><code class="language-yaml"># k8s/base/configmap.yml
apiVersion: v1
kind: ConfigMap
metadata:
  name: webflux-app-config
  namespace: webflux-app
data:
  SPRING_PROFILES_ACTIVE: "k8s"
  JAVA_TOOL_OPTIONS: &gt;-
    -XX:+UseZGC
    -XX:MaxRAMPercentage=75.0
    -XX:+ExitOnOutOfMemoryError
  MANAGEMENT_SERVER_PORT: "8081"</code></pre>
<pre class="highlight"><code class="language-yaml"># k8s/base/secret.yml
apiVersion: v1
kind: Secret
metadata:
  name: webflux-app-secret
  namespace: webflux-app
type: Opaque
stringData:
  SPRING_DATA_MONGODB_URI: "mongodb+srv://appuser:securepass@cluster0.example.mongodb.net/webfluxdb?retryWrites=true&amp;w=majority"</code></pre>
<blockquote>
<p><strong>주의</strong>: Secret을 Git에 평문으로 커밋하면 안 된다. 프로덕션에서는 <strong>Sealed Secrets</strong>, <strong>External Secrets Operator</strong>, 또는 <strong>HashiCorp Vault</strong>를 사용하여 시크릿을 관리한다.</p>
</blockquote>
<h3 id="2032-deployment">20.3.2 Deployment</h3>
<pre class="highlight"><code class="language-yaml"># k8s/base/deployment.yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webflux-app
  namespace: webflux-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app.kubernetes.io/name: webflux-app
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 0
      maxSurge: 1
  template:
    metadata:
      labels:
        app.kubernetes.io/name: webflux-app
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8081"
        prometheus.io/path: "/actuator/prometheus"
    spec:
      terminationGracePeriodSeconds: 30
      containers:
        - name: webflux-app
          image: ghcr.io/myorg/webflux-app:1.0.0
          ports:
            - name: http
              containerPort: 8080
            - name: management
              containerPort: 8081
          envFrom:
            - configMapRef:
                name: webflux-app-config
            - secretRef:
                name: webflux-app-secret
          resources:
            requests:
              memory: "256Mi"
              cpu: "250m"
            limits:
              memory: "512Mi"
              cpu: "1000m"
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: management
            initialDelaySeconds: 10
            periodSeconds: 5
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness
              port: management
            initialDelaySeconds: 30
            periodSeconds: 10
          startupProbe:
            httpGet:
              path: /actuator/health/liveness
              port: management
            initialDelaySeconds: 5
            periodSeconds: 5
            failureThreshold: 20
          lifecycle:
            preStop:
              exec:
                command: ["sh", "-c", "sleep 5"]</code></pre>
<p>K8s 프로브와 Spring Boot Actuator의 매핑 관계를 이해하는 것이 중요하다.</p>
<table>
<thead>
<tr>
<th>K8s 프로브</th>
<th>Actuator 엔드포인트</th>
<th>역할</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>startupProbe</code></td>
<td><code>/actuator/health/liveness</code></td>
<td>애플리케이션 시작 완료 확인</td>
</tr>
<tr>
<td><code>readinessProbe</code></td>
<td><code>/actuator/health/readiness</code></td>
<td>트래픽 수신 준비 확인</td>
</tr>
<tr>
<td><code>livenessProbe</code></td>
<td><code>/actuator/health/liveness</code></td>
<td>프로세스 정상 동작 확인</td>
</tr>
</tbody>
</table>
<p><code>preStop</code> 훅에서 <code>sleep 5</code>를 실행하는 이유는 K8s가 Service 엔드포인트 목록에서 파드를 제거하는 시간을 확보하여 <strong>정상 종료(Graceful Shutdown)</strong> 중 요청 유실을 방지하기 위해서다.</p>
<h3 id="2033-service-hpa">20.3.3 Service와 HPA</h3>
<pre class="highlight"><code class="language-yaml"># k8s/base/service.yml
apiVersion: v1
kind: Service
metadata:
  name: webflux-app
  namespace: webflux-app
spec:
  type: ClusterIP
  ports:
    - name: http
      port: 80
      targetPort: http
  selector:
    app.kubernetes.io/name: webflux-app</code></pre>
<pre class="highlight"><code class="language-yaml"># k8s/base/hpa.yml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: webflux-app
  namespace: webflux-app
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: webflux-app
  minReplicas: 2
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300</code></pre>
<blockquote>
<p><strong>Tip</strong>: 리액티브 애플리케이션은 CPU 사용률이 낮은 상태에서도 높은 처리량을 달성한다. CPU 기반 HPA만으로는 스케일링 시점을 정확히 판단하기 어려우므로, 커스텀 메트릭(요청 큐 크기, p99 지연시간)을 함께 활용하는 것을 권장한다.</p>
</blockquote>
<hr>
<h2 id="204-mongodb-atlas">20.4 MongoDB Atlas 클라우드 연동</h2>
<p>프로덕션 환경에서는 MongoDB를 직접 운영하는 대신 관리형 서비스인 <strong>MongoDB Atlas</strong>를 사용하는 것이 운영 부담을 줄이는 효과적인 방법이다.</p>
<h3 id="2041-atlas">20.4.1 Atlas 연결 설정</h3>
<pre class="highlight"><code class="language-yaml"># src/main/resources/application-prod.yml
spring:
  data:
    mongodb:
      uri: mongodb+srv://${MONGO_USERNAME}:${MONGO_PASSWORD}@cluster0.abc123.mongodb.net/${MONGO_DATABASE}?retryWrites=true&amp;w=majority&amp;maxPoolSize=50&amp;minPoolSize=5&amp;connectTimeoutMS=10000&amp;serverSelectionTimeoutMS=10000</code></pre>
<table>
<thead>
<tr>
<th>옵션</th>
<th>권장값</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>retryWrites</code></td>
<td>true</td>
<td>일시적 네트워크 오류 시 쓰기 자동 재시도</td>
</tr>
<tr>
<td><code>w</code></td>
<td>majority</td>
<td>과반수 노드 쓰기 확인</td>
</tr>
<tr>
<td><code>maxPoolSize</code></td>
<td>50</td>
<td>최대 커넥션 풀 크기</td>
</tr>
<tr>
<td><code>minPoolSize</code></td>
<td>5</td>
<td>최소 유지 커넥션 수</td>
</tr>
<tr>
<td><code>connectTimeoutMS</code></td>
<td>10000</td>
<td>연결 타임아웃</td>
</tr>
</tbody>
</table>
<h3 id="2042-java">20.4.2 Java 설정과 헬스 체크</h3>
<pre class="highlight"><code class="language-java">@Configuration
public class MongoAtlasConfig {

    @Bean
    public MongoClientSettings mongoClientSettings() {
        return MongoClientSettings.builder()
            .applyConnectionString(
                new ConnectionString(System.getenv("SPRING_DATA_MONGODB_URI"))
            )
            .applyToSslSettings(ssl -&gt; ssl.enabled(true))
            .applyToConnectionPoolSettings(pool -&gt; pool
                .maxSize(50)
                .minSize(5)
                .maxConnectionIdleTime(60, TimeUnit.SECONDS)
                .maxWaitTime(10, TimeUnit.SECONDS)
            )
            .retryWrites(true)
            .retryReads(true)
            .build();
    }
}</code></pre>
<pre class="highlight"><code class="language-java">@Component
@RequiredArgsConstructor
public class MongoAtlasHealthIndicator implements ReactiveHealthIndicator {

    private final ReactiveMongoTemplate mongoTemplate;

    @Override
    public Mono&lt;Health&gt; health() {
        return mongoTemplate.executeCommand(new org.bson.Document("ping", 1))
            .map(result -&gt; Health.up()
                .withDetail("database", "MongoDB Atlas")
                .build())
            .onErrorResume(ex -&gt; Mono.just(
                Health.down()
                    .withDetail("error", ex.getMessage())
                    .build()))
            .timeout(Duration.ofSeconds(5))
            .onErrorReturn(Health.down()
                .withDetail("error", "Health check timeout")
                .build());
    }
}</code></pre>
<h3 id="2043-k8s-atlas">20.4.3 K8s에서 Atlas 연결 시 고려사항</h3>
<ol>
<li><strong>고정 Egress IP</strong>: K8s 클러스터의 아웃바운드 트래픽이 고정 IP를 사용하도록 NAT Gateway를 설정하고, 해당 IP를 Atlas IP Access List에 등록한다.</li>
<li><strong>VPC Peering / Private Link</strong>: 보안이 중요한 환경에서는 Atlas의 VPC Peering 또는 AWS PrivateLink를 활용한다.</li>
<li><strong>DNS 해석</strong>: <code>mongodb+srv://</code> URI는 DNS SRV 레코드를 사용하므로 K8s 클러스터의 DNS가 외부 DNS를 정상 해석할 수 있어야 한다.</li>
</ol>
<blockquote>
<p><strong>주의</strong>: Atlas Free Tier(M0)는 VPC Peering과 Private Link를 지원하지 않는다. 프로덕션에서는 최소 M10 이상을 사용한다.</p>
</blockquote>
<hr>
<h2 id="205-cicd-github-actions">20.5 CI/CD 파이프라인 구성 (GitHub Actions)</h2>
<p>GitHub Actions를 활용하여 소스 코드 푸시부터 테스트, Docker 이미지 빌드, K8s 배포까지의 전체 파이프라인을 구성한다.</p>
<h3 id="2051-cicd">20.5.1 CI/CD 워크플로우</h3>
<pre class="highlight"><code class="language-yaml"># .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

permissions:
  contents: read
  packages: write

env:
  JAVA_VERSION: '21'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    name: Build &amp; Test
    runs-on: ubuntu-latest
    services:
      mongodb:
        image: mongo:7.0
        ports:
          - 27017:27017
        env:
          MONGO_INITDB_ROOT_USERNAME: testuser
          MONGO_INITDB_ROOT_PASSWORD: testpass
        options: &gt;-
          --health-cmd "mongosh --eval 'db.adminCommand({ping:1})'"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
      - uses: gradle/actions/setup-gradle@v4
      - name: Run Tests
        env:
          SPRING_DATA_MONGODB_URI: mongodb://testuser:testpass@localhost:27017/testdb?authSource=admin
        run: ./gradlew test

  build-image:
    name: Build &amp; Push Image
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' &amp;&amp; github.ref == 'refs/heads/main'
    outputs:
      image-tag: ${{ steps.meta.outputs.version }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
      - uses: gradle/actions/setup-gradle@v4
      - uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=
            type=ref,event=branch
      - name: Build and Push with Jib
        run: |
          ./gradlew jib \
            -Djib.to.image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
            -Djib.to.tags=${{ steps.meta.outputs.version }}
        env:
          REGISTRY_USERNAME: ${{ github.actor }}
          REGISTRY_PASSWORD: ${{ secrets.GITHUB_TOKEN }}

  deploy:
    name: Deploy to Kubernetes
    needs: build-image
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
      - uses: actions/checkout@v4
      - uses: azure/setup-kubectl@v4
      - name: Set Kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d &gt; $HOME/.kube/config
      - name: Deploy
        run: |
          kubectl apply -k k8s/overlays/prod/
          kubectl -n webflux-app rollout status deployment/webflux-app --timeout=300s</code></pre>
<h3 id="2052">20.5.2 브랜치 전략과 시크릿 관리</h3>
<table>
<thead>
<tr>
<th>브랜치</th>
<th>트리거</th>
<th>수행 작업</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>feature/*</code></td>
<td>PR 생성</td>
<td>빌드, 테스트</td>
</tr>
<tr>
<td><code>develop</code></td>
<td>Push</td>
<td>빌드, 테스트, 스테이징 배포</td>
</tr>
<tr>
<td><code>main</code></td>
<td>Push</td>
<td>빌드, 테스트, 이미지 빌드, 프로덕션 배포</td>
</tr>
</tbody>
</table>
<p>필요한 GitHub Secrets:</p>
<table>
<thead>
<tr>
<th>시크릿 이름</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GITHUB_TOKEN</code></td>
<td>자동 제공 (GHCR 인증용)</td>
</tr>
<tr>
<td><code>KUBE_CONFIG</code></td>
<td>K8s kubeconfig (Base64 인코딩)</td>
</tr>
<tr>
<td><code>MONGO_URI</code></td>
<td>MongoDB Atlas 연결 문자열</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Tip</strong>: <code>environment: production</code> 설정을 활용하면 프로덕션 배포 전 수동 승인(Manual Approval) 단계를 추가할 수 있다.</p>
</blockquote>
<hr>
<h2 id="206-graalvm-native-image">20.6 GraalVM Native Image 빌드</h2>
<p>GraalVM Native Image는 Java 애플리케이션을 AOT(Ahead-of-Time) 컴파일하여 네이티브 실행 파일로 변환한다. 시작 시간이 밀리초 단위로 단축되고 메모리 사용량이 대폭 감소하여, 서버리스(Serverless) 환경에 적합하다.</p>
<h3 id="2061-jvm-vs-native-image">20.6.1 JVM vs Native Image 비교</h3>
<table>
<thead>
<tr>
<th>항목</th>
<th>JVM</th>
<th>Native Image</th>
</tr>
</thead>
<tbody>
<tr>
<td>시작 시간</td>
<td>2~5초</td>
<td>50~200ms</td>
</tr>
<tr>
<td>메모리 사용</td>
<td>256~512MB</td>
<td>64~128MB</td>
</tr>
<tr>
<td>최대 처리량</td>
<td>높음 (JIT 최적화)</td>
<td>보통 (AOT 제한)</td>
</tr>
<tr>
<td>빌드 시간</td>
<td>짧음</td>
<td>김 (수 분)</td>
</tr>
<tr>
<td>리플렉션 지원</td>
<td>완전</td>
<td>설정 필요</td>
</tr>
</tbody>
</table>
<h3 id="2062-gradle">20.6.2 Gradle 빌드 설정</h3>
<pre class="highlight"><code class="language-groovy">plugins {
    id 'org.springframework.boot' version '3.4.1'
    id 'io.spring.dependency-management' version '1.1.7'
    id 'org.graalvm.buildtools.native' version '0.10.4'
    id 'java'
}

graalvmNative {
    binaries {
        main {
            buildArgs.addAll([
                '--initialize-at-build-time',
                '-H:+ReportExceptionStackTraces'
            ])
            javaLauncher = javaToolchains.launcherFor {
                languageVersion = JavaLanguageVersion.of(21)
                vendor = JvmVendorSpec.GRAAL_VM
            }
        }
    }
    metadataRepository {
        enabled = true
    }
}</code></pre>
<h3 id="2063">20.6.3 리플렉션 힌트 설정</h3>
<p>Spring Boot 3.x는 AOT 처리를 통해 대부분의 리플렉션 힌트를 자동 생성한다. 동적으로 로드되는 클래스는 수동으로 등록해야 한다.</p>
<pre class="highlight"><code class="language-java">@Configuration
@ImportRuntimeHints(NativeHintsRegistrar.class)
public class NativeImageConfig {
}

public class NativeHintsRegistrar implements RuntimeHintsRegistrar {

    @Override
    public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
        hints.reflection()
            .registerType(Product.class, MemberCategory.values())
            .registerType(Order.class, MemberCategory.values());

        hints.resources()
            .registerPattern("application*.yml");
    }
}</code></pre>
<h3 id="2064-native-image-docker">20.6.4 Native Image Docker 빌드</h3>
<p>Buildpacks를 활용하면 GraalVM 로컬 설치 없이 네이티브 이미지를 빌드할 수 있다.</p>
<pre class="highlight"><code class="language-groovy">bootBuildImage {
    imageName = "ghcr.io/myorg/webflux-app-native:${project.version}"
    environment = [
        'BP_NATIVE_IMAGE': 'true',
        'BP_JVM_VERSION': '21'
    ]
}</code></pre>
<p>멀티 스테이지 Dockerfile로 직접 빌드하는 방법도 있다.</p>
<pre class="highlight"><code class="language-dockerfile">FROM ghcr.io/graalvm/native-image-community:21 AS builder
WORKDIR /app
COPY gradle/ gradle/
COPY gradlew build.gradle settings.gradle ./
COPY src/ src/
RUN ./gradlew nativeCompile --no-daemon

FROM debian:bookworm-slim
WORKDIR /app
RUN groupadd -r appuser &amp;&amp; useradd -r -g appuser appuser
COPY --from=builder /app/build/native/nativeCompile/webflux-app ./
USER appuser
EXPOSE 8080
ENTRYPOINT ["./webflux-app"]</code></pre>
<h3 id="2065">20.6.5 주의사항</h3>
<p>네이티브 이미지 환경에서 주의해야 할 핵심 사항을 정리한다.</p>
<ol>
<li><strong>빌드 리소스</strong>: 네이티브 이미지 빌드는 최소 8GB RAM이 필요하며 5~10분 이상 소요된다. CI/CD에서 대규모 프로젝트는 Larger Runner 사용을 고려한다.</li>
<li><strong>프로파일 결정 시점</strong>: 네이티브 이미지는 빌드 시점에 프로파일이 결정된다. 런타임 변경이 필요하면 AOT 처리 시 명시해야 한다.</li>
</ol>
<pre class="highlight"><code class="language-bash">./gradlew nativeCompile -Pspring.profiles.active=prod</code></pre>
<ol>
<li><strong>서드파티 호환성</strong>: 모든 라이브러리가 네이티브 이미지를 지원하는 것은 아니다. <a href="https://github.com/oracle/graalvm-reachability-metadata">GraalVM Reachability Metadata Repository</a>에서 호환성을 확인한다.</li>
<li><strong>GitHub Actions 빌드</strong>: 태그 푸시 시 네이티브 이미지를 빌드하는 워크플로우를 구성한다.</li>
</ol>
<pre class="highlight"><code class="language-yaml"># .github/workflows/native-build.yml
name: Native Image Build
on:
  push:
    tags: ['v*']
jobs:
  native-build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: graalvm/setup-graalvm@v1
        with:
          java-version: '21'
          distribution: 'graalvm-community'
      - uses: gradle/actions/setup-gradle@v4
      - run: ./gradlew nativeCompile
      - run: |
          docker build -f Dockerfile.native \
            -t ghcr.io/${{ github.repository }}-native:${{ github.ref_name }} .
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          docker push ghcr.io/${{ github.repository }}-native:${{ github.ref_name }}</code></pre>
<hr>
<h2 id="_1">요약</h2>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 도구</th>
<th>권장 사항</th>
</tr>
</thead>
<tbody>
<tr>
<td>Docker 빌드</td>
<td>Jib, Buildpacks</td>
<td>CI/CD에서는 Jib 권장</td>
</tr>
<tr>
<td>로컬 스택</td>
<td>Docker Compose</td>
<td>헬스 체크와 의존성 순서 필수</td>
</tr>
<tr>
<td>K8s 배포</td>
<td>Deployment, HPA</td>
<td>3종 프로브와 preStop 훅 설정</td>
</tr>
<tr>
<td>Atlas 연동</td>
<td>SRV 연결</td>
<td>VPC Peering으로 보안 강화</td>
</tr>
<tr>
<td>CI/CD</td>
<td>GitHub Actions</td>
<td>브랜치 전략과 시크릿 관리</td>
</tr>
<tr>
<td>Native Image</td>
<td>GraalVM, AOT</td>
<td>서버리스 환경에 적합</td>
</tr>
</tbody>
</table>
<p>컨테이너화와 CI/CD는 한 번 구축하면 이후 배포가 자동화된다. 다음 장에서는 <strong>장애 대응과 트러블슈팅</strong>을 다룬다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>