<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 20. 컨테이너화와 배포 | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="ch19.html">&larr; Chapter 19. 성능 최적화</a>
    <a href="../index.html">목차</a>
    <a href="ch21.html">Chapter 21. 실전 프로젝트: 실시간 게시판 서비스 &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-20">Chapter 20. 컨테이너화와 배포</h1>
<p>개발을 마치고 실전 운영 환경으로 나가려면 어떻게 해야 할까? 그 답이 <strong>컨테이너(Container)</strong>다. Docker와 Kubernetes는 이제 거의 표준이 되었다. Docker를 쓰면 애플리케이션과 실행 환경을 하나의 이미지로 묶어 어디서든 동일하게 실행할 수 있고, Kubernetes로는 수십 개의 컨테이너를 마치 한 대의 머신인 것처럼 관리할 수 있다.</p>
<p>이번 장에서는 실제 프로젝트에서 어떻게 Spring Boot WebFlux + MongoDB 애플리케이션을 컨테이너화하고 운영 환경으로 보내는지 살펴본다. Docker 이미지 빌드부터 Docker Compose를 이용한 로컬 환경 구성, Kubernetes 배포, MongoDB Atlas 연동, GitHub Actions로 자동화된 CI/CD 파이프라인 구축, 그리고 GraalVM Native Image까지 단계별로 진행해보자.</p>
<hr>
<h2 id="201-docker-jib-buildpacks">20.1 Docker 이미지 빌드 (Jib, Buildpacks)</h2>
<p>Docker 이미지를 만드는 방법은 여러 가지가 있다. 전통적인 Dockerfile부터 시작해서 요즘 핫한 도구들까지 선택지가 많다. Google Jib과 Spring Boot의 Cloud Native Buildpacks가 가장 인기 있는 방식이고, 각각 장단점이 있다.</p>
<h3 id="2011-jib-docker">20.1.1 Jib을 활용한 Docker 이미지 빌드</h3>
<p>Jib은 Google이 만든 도구인데, 사실 꽤 편리하다. Docker 데몬을 설치하고 실행할 필요가 없다는 게 큰 장점이다. <strong>Docker 데몬 없이도</strong> 빌드하고 바로 레지스트리에 올릴 수 있다. <code>build.gradle</code>에 플러그인을 추가하기만 하면 된다.</p>
<p>```groovy
plugins {
    id 'org.springframework.boot' version '3.5.11'
    id 'io.spring.dependency-management' version '1.1.7'
    id 'com.google.cloud.tools.jib' version '3.5.3'
    id 'java'
}</p>
<p>jib {
    from {
        image = 'eclipse-temurin:21-jre'
        platforms {
            platform {
                architecture = 'amd64'
                os = 'linux'
            }
            platform {
                architecture = 'arm64'
                os = 'linux'
            }
        }
    }
    to {
        image = 'ghcr.io/myorg/webflux-app'
        tags = [project.version, 'latest']
        auth {
            username = System.getenv('REGISTRY_USERNAME')
            password = System.getenv('REGISTRY_PASSWORD')
        }
    }
    container {
        jvmFlags = [
            '-XX:+UseZGC',
            '-XX:MaxRAMPercentage=75.0',
            '-Djava.security.egd=file:/dev/./urandom',
            '-Dspring.profiles.active=prod'
        ]
        ports = ['8080']
        creationTime = 'USE_CURRENT_TIMESTAMP'
        user = '1000:1000'
    }
}
```</p>
<p>상황에 따라 사용할 수 있는 명령어가 세 가지다.</p>
<p>```bash</p>
<h1 id="docker">Docker 데몬 없이 레지스트리에 직접 푸시</h1>
<p>./gradlew jib</p>
<h1 id="docker_1">로컬 Docker 데몬에 이미지 빌드</h1>
<p>./gradlew jibDockerBuild</p>
<h1 id="tar">tar 파일로 이미지 내보내기</h1>
<p>./gradlew jibBuildTar
```</p>
<blockquote>
<p><strong>Tip</strong>: Jib은 애플리케이션을 <code>classes</code>, <code>resources</code>, <code>dependencies</code>, <code>snapshot-dependencies</code>의 네 레이어로 자동 분리한다. 소스 코드만 변경하면 <code>classes</code> 레이어만 다시 빌드되므로 CI/CD에서 빌드 시간을 크게 단축할 수 있다.</p>
</blockquote>
<h3 id="2012-cloud-native-buildpacks">20.1.2 Cloud Native Buildpacks</h3>
<p>Spring Boot 3.x부터는 Cloud Native Buildpacks를 바로 사용할 수 있다. 추가 플러그인 설치 없이 기본 Gradle 명령어로 OCI 이미지를 빌드하면 되니까 편하다.</p>
<p><code>groovy
bootBuildImage {
    imageName = "ghcr.io/myorg/webflux-app:${project.version}"
    environment = [
        'BP_JVM_VERSION': '21',
        'BP_JVM_TYPE': 'JRE',
        'BPE_JAVA_TOOL_OPTIONS': '-XX:+UseZGC -XX:MaxRAMPercentage=75.0'
    ]
    docker {
        publishRegistry {
            username = System.getenv('REGISTRY_USERNAME')
            password = System.getenv('REGISTRY_PASSWORD')
            url = 'https://ghcr.io'
        }
    }
}</code></p>
<p><code>bash
./gradlew bootBuildImage</code></p>
<h3 id="2013">20.1.3 빌드 방식 비교</h3>
<p>세 가지 방식의 특징을 정리하면 아래와 같다.</p>
<table>
<thead>
<tr>
<th>항목</th>
<th>Dockerfile</th>
<th>Jib</th>
<th>Buildpacks</th>
</tr>
</thead>
<tbody>
<tr>
<td>Docker 데몬 필요</td>
<td>O</td>
<td>X</td>
<td>O</td>
</tr>
<tr>
<td>Dockerfile 필요</td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>빌드 속도</td>
<td>보통</td>
<td>빠름</td>
<td>느림</td>
</tr>
<tr>
<td>레이어 최적화</td>
<td>수동</td>
<td>자동</td>
<td>자동</td>
</tr>
<tr>
<td>멀티 아키텍처</td>
<td>수동 설정</td>
<td>선언적</td>
<td>제한적</td>
</tr>
<tr>
<td>CI/CD 친화성</td>
<td>보통</td>
<td>높음</td>
<td>높음</td>
</tr>
</tbody>
</table>
<p>필자의 경험상, Buildpacks는 초기 빌드가 상당히 오래 걸린다. 하지만 캐시가 쌓인 후에는 빌드가 빨라진다. CI/CD 환경에서 Docker 데몬을 설정하기 어렵다면 Jib을 쓰는 게 가장 무난하다.</p>
<hr>
<h2 id="202-docker-compose">20.2 Docker Compose로 전체 스택 구성</h2>
<p>이제 로컬에서 전체 환경을 한 번에 띄워보자. Docker Compose를 쓰면 Spring Boot 앱, MongoDB, Prometheus, Grafana를 한 번의 명령어로 구성할 수 있다.</p>
<h3 id="2021-docker-compose">20.2.1 Docker Compose 구성 파일</h3>
<p>```yaml</p>
<h1 id="dockerdocker-composeyml">docker/docker-compose.yml</h1>
<p>version: '3.8'
services:
  app:
    build:
      context: ..
      dockerfile: Dockerfile
    container_name: webflux-app
    ports:
      - "8080:8080"
    environment:
      SPRING_PROFILES_ACTIVE: docker
      SPRING_DATA_MONGODB_URI: mongodb://appuser:apppass@mongodb:27017/webfluxdb?authSource=admin
      JAVA_TOOL_OPTIONS: &gt;-
        -XX:+UseZGC
        -XX:MaxRAMPercentage=75.0
    depends_on:
      mongodb:
        condition: service_healthy
    networks:
      - app-network
    deploy:
      resources:
        limits:
          memory: 512M
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
      interval: 15s
      timeout: 5s
      retries: 5
      start_period: 30s
  mongodb:
    image: mongo:7.0
    container_name: mongodb
    ports:
      - "27017:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: appuser
      MONGO_INITDB_ROOT_PASSWORD: apppass
      MONGO_INITDB_DATABASE: webfluxdb
    volumes:
      - mongodb-data:/data/db
      - ./mongo/init-mongo.js:/docker-entrypoint-initdb.d/init-mongo.js:ro
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
      interval: 10s
      timeout: 5s
      retries: 5
  prometheus:
    image: prom/prometheus:v2.51.0
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus-data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.retention.time=7d'
    networks:
      - app-network
  grafana:
    image: grafana/grafana:10.4.0
    container_name: grafana
    ports:
      - "3000:3000"
    environment:
      GF_SECURITY_ADMIN_USER: admin
      GF_SECURITY_ADMIN_PASSWORD: admin
    volumes:
      - grafana-data:/var/lib/grafana
      - ./grafana/provisioning:/etc/grafana/provisioning:ro
    networks:
      - app-network
    depends_on:
      - prometheus
volumes:
  mongodb-data:
  prometheus-data:
  grafana-data:
networks:
  app-network:
    driver: bridge
```</p>
<h3 id="2022-prometheus-mongodb">20.2.2 Prometheus 설정과 MongoDB 초기화</h3>
<p>```yaml</p>
<h1 id="dockerprometheusprometheusyml">docker/prometheus/prometheus.yml</h1>
<p>global:
  scrape_interval: 15s
scrape_configs:
  - job_name: 'webflux-app'
    metrics_path: '/actuator/prometheus'
    scrape_interval: 5s
    static_configs:
      - targets: ['app:8080']
```</p>
<p><code>javascript
// docker/mongo/init-mongo.js
db = db.getSiblingDB('webfluxdb');
db.createCollection('products');
db.products.createIndex({ "name": 1 }, { unique: true });
db.products.createIndex({ "category": 1, "price": 1 });</code></p>
<h3 id="2023-docker">20.2.3 Docker 프로파일용 애플리케이션 설정</h3>
<p>```yaml</p>
<h1 id="srcmainresourcesapplication-dockeryml">src/main/resources/application-docker.yml</h1>
<p>spring:
  data:
    mongodb:
      uri: ${SPRING_DATA_MONGODB_URI:mongodb://localhost:27017/webfluxdb}</p>
<p>management:
  endpoints:
    web:
      exposure:
        include: health,info,prometheus,metrics
  endpoint:
    health:
      show-details: always
      probes:
        enabled: true
server:
  port: 8080
  netty:
    connection-timeout: 5s
```</p>
<p>```bash</p>
<h1 id="_1">전체 스택 시작</h1>
<p>docker compose -f docker/docker-compose.yml up -d</p>
<h1 id="_2">로그 확인</h1>
<p>docker compose -f docker/docker-compose.yml logs -f app</p>
<h1 id="_3">전체 스택 종료 및 볼륨 삭제</h1>
<p>docker compose -f docker/docker-compose.yml down -v
```</p>
<p>실제로는 이 정도면 로컬에서 프로덕션과 거의 같은 환경을 구성할 수 있다.</p>
<hr>
<h2 id="203-kubernetes">20.3 Kubernetes 배포 기초</h2>
<p>프로덕션으로 나가려면 보통 Kubernetes(K8s)를 쓴다. 수십, 수백 개의 컨테이너를 관리해야 할 때 정말 강력하다.</p>
<h3 id="2031-configmap-secret">20.3.1 ConfigMap과 Secret</h3>
<p>```yaml</p>
<h1 id="k8sbaseconfigmapyml">k8s/base/configmap.yml</h1>
<p>apiVersion: v1
kind: ConfigMap
metadata:
  name: webflux-app-config
  namespace: webflux-app
data:
  SPRING_PROFILES_ACTIVE: "k8s"
  JAVA_TOOL_OPTIONS: &gt;-
    -XX:+UseZGC
    -XX:MaxRAMPercentage=75.0
    -XX:+ExitOnOutOfMemoryError
  MANAGEMENT_SERVER_PORT: "8081"
```</p>
<p>```yaml</p>
<h1 id="k8sbasesecretyml">k8s/base/secret.yml</h1>
<p>apiVersion: v1
kind: Secret
metadata:
  name: webflux-app-secret
  namespace: webflux-app
type: Opaque
stringData:
  SPRING_DATA_MONGODB_URI: "mongodb+srv://appuser:securepass@cluster0.example.mongodb.net/webfluxdb?retryWrites=true&amp;w=majority"
```</p>
<blockquote>
<p><strong>주의</strong>: Secret을 Git에 평문으로 커밋하면 안 된다. 프로덕션에서는 <strong>Sealed Secrets</strong>, <strong>External Secrets Operator</strong>, 또는 <strong>HashiCorp Vault</strong>를 사용하여 시크릿을 관리한다.</p>
</blockquote>
<h3 id="2032-deployment">20.3.2 Deployment</h3>
<p>```yaml</p>
<h1 id="k8sbasedeploymentyml">k8s/base/deployment.yml</h1>
<p>apiVersion: apps/v1
kind: Deployment
metadata:
  name: webflux-app
  namespace: webflux-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app.kubernetes.io/name: webflux-app
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 0
      maxSurge: 1
  template:
    metadata:
      labels:
        app.kubernetes.io/name: webflux-app
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8081"
        prometheus.io/path: "/actuator/prometheus"
    spec:
      terminationGracePeriodSeconds: 30
      containers:
        - name: webflux-app
          image: ghcr.io/myorg/webflux-app:1.0.0
          ports:
            - name: http
              containerPort: 8080
            - name: management
              containerPort: 8081
          envFrom:
            - configMapRef:
                name: webflux-app-config
            - secretRef:
                name: webflux-app-secret
          resources:
            requests:
              memory: "256Mi"
              cpu: "250m"
            limits:
              memory: "512Mi"
              cpu: "1000m"
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: management
            initialDelaySeconds: 10
            periodSeconds: 5
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness
              port: management
            initialDelaySeconds: 30
            periodSeconds: 10
          startupProbe:
            httpGet:
              path: /actuator/health/liveness
              port: management
            initialDelaySeconds: 5
            periodSeconds: 5
            failureThreshold: 20
          lifecycle:
            preStop:
              exec:
                command: ["sh", "-c", "sleep 5"]
```</p>
<p>여기서 중요한 게 K8s 프로브와 Spring Boot Actuator의 관계다. 각 프로브가 어떤 엔드포인트를 호출하는지 잘 이해해야 한다.</p>
<table>
<thead>
<tr>
<th>K8s 프로브</th>
<th>Actuator 엔드포인트</th>
<th>역할</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>startupProbe</code></td>
<td><code>/actuator/health/liveness</code></td>
<td>애플리케이션 시작 완료 확인</td>
</tr>
<tr>
<td><code>readinessProbe</code></td>
<td><code>/actuator/health/readiness</code></td>
<td>트래픽 수신 준비 확인</td>
</tr>
<tr>
<td><code>livenessProbe</code></td>
<td><code>/actuator/health/liveness</code></td>
<td>프로세스 정상 동작 확인</td>
</tr>
</tbody>
</table>
<p>그리고 <code>preStop</code> 훅의 <code>sleep 5</code>가 중요한데, 이건 K8s가 Service 엔드포인트 목록에서 파드를 제거하는 동안 추가 시간을 주는 거다. 이렇게 해야 <strong>정상 종료(Graceful Shutdown)</strong> 중에 요청을 잃지 않는다.</p>
<h3 id="2033-service-hpa">20.3.3 Service와 HPA</h3>
<p>```yaml</p>
<h1 id="k8sbaseserviceyml">k8s/base/service.yml</h1>
<p>apiVersion: v1
kind: Service
metadata:
  name: webflux-app
  namespace: webflux-app
spec:
  type: ClusterIP
  ports:
    - name: http
      port: 80
      targetPort: http
  selector:
    app.kubernetes.io/name: webflux-app
```</p>
<p>```yaml</p>
<h1 id="k8sbasehpayml">k8s/base/hpa.yml</h1>
<p>apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: webflux-app
  namespace: webflux-app
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: webflux-app
  minReplicas: 2
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
```</p>
<p>여기서 한 가지 주의할 점이 있다. 필자의 경험상 리액티브 애플리케이션은 CPU 사용률이 낮아 보이는데도 높은 처리량을 낸다. 따라서 CPU 기반 HPA만으로는 정확한 스케일링 시점을 판단하기 어렵다. 커스텀 메트릭(요청 큐 크기, p99 지연시간 등)을 함께 활용하는 게 좋다.</p>
<hr>
<h2 id="204-mongodb-atlas">20.4 MongoDB Atlas 클라우드 연동</h2>
<p>프로덕션에서 MongoDB를 직접 관리하는 건 번거롭다. <strong>MongoDB Atlas</strong>라는 관리형 서비스를 쓰면 훨씬 편하다. 필자의 경험상 자동 백업, 패치 관리, 고가용성 설정 등이 모두 자동으로 되니까 개발팀이 코드에 집중할 수 있다.</p>
<h3 id="2041-atlas">20.4.1 Atlas 연결 설정</h3>
<p>```yaml</p>
<h1 id="srcmainresourcesapplication-prodyml">src/main/resources/application-prod.yml</h1>
<p>spring:
  data:
    mongodb:
      uri: mongodb+srv://${MONGO_USERNAME}:${MONGO_PASSWORD}@cluster0.abc123.mongodb.net/${MONGO_DATABASE}?retryWrites=true&amp;w=majority&amp;maxPoolSize=50&amp;minPoolSize=5&amp;connectTimeoutMS=10000&amp;serverSelectionTimeoutMS=10000
```</p>
<table>
<thead>
<tr>
<th>옵션</th>
<th>권장값</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>retryWrites</code></td>
<td>true</td>
<td>일시적 네트워크 오류 시 쓰기 자동 재시도</td>
</tr>
<tr>
<td><code>w</code></td>
<td>majority</td>
<td>과반수 노드 쓰기 확인</td>
</tr>
<tr>
<td><code>maxPoolSize</code></td>
<td>50</td>
<td>최대 커넥션 풀 크기</td>
</tr>
<tr>
<td><code>minPoolSize</code></td>
<td>5</td>
<td>최소 유지 커넥션 수</td>
</tr>
<tr>
<td><code>connectTimeoutMS</code></td>
<td>10000</td>
<td>연결 타임아웃</td>
</tr>
</tbody>
</table>
<h3 id="2042-java">20.4.2 Java 설정과 헬스 체크</h3>
<p>```java
@Configuration
public class MongoAtlasConfig {</p>
<pre><code>@Bean
public MongoClientSettings mongoClientSettings() {
    return MongoClientSettings.builder()
        .applyConnectionString(
            new ConnectionString(System.getenv("SPRING_DATA_MONGODB_URI"))
        )
        .applyToSslSettings(ssl -&gt; ssl.enabled(true))
        .applyToConnectionPoolSettings(pool -&gt; pool
            .maxSize(50)
            .minSize(5)
            .maxConnectionIdleTime(60, TimeUnit.SECONDS)
            .maxWaitTime(10, TimeUnit.SECONDS)
        )
        .retryWrites(true)
        .retryReads(true)
        .build();
}
</code></pre>
<p>}
```</p>
<p>```java
@Component
@RequiredArgsConstructor
public class MongoAtlasHealthIndicator implements ReactiveHealthIndicator {</p>
<pre><code>private final ReactiveMongoTemplate mongoTemplate;

@Override
public Mono&lt;Health&gt; health() {
    return mongoTemplate.executeCommand(new org.bson.Document("ping", 1))
        .map(result -&gt; Health.up()
            .withDetail("database", "MongoDB Atlas")
            .build())
        .onErrorResume(ex -&gt; Mono.just(
            Health.down()
                .withDetail("error", ex.getMessage())
                .build()))
        .timeout(Duration.ofSeconds(5))
        .onErrorReturn(Health.down()
            .withDetail("error", "Health check timeout")
            .build());
}
</code></pre>
<p>}
```</p>
<h3 id="2043-k8s-atlas">20.4.3 K8s에서 Atlas 연결 시 고려사항</h3>
<p>K8s에서 Atlas로 연결할 때 생각해야 할 부분들이 있다.</p>
<ol>
<li><strong>고정 Egress IP</strong>: K8s 클러스터의 모든 아웃바운드 트래픽이 고정 IP를 사용하도록 NAT Gateway를 설정하고, 그 IP를 Atlas IP Access List에 등록한다.</li>
<li><strong>VPC Peering / Private Link</strong>: 보안이 중요한 프로덕션 환경이라면 Atlas의 VPC Peering이나 AWS PrivateLink를 설정하자.</li>
<li><strong>DNS 해석</strong>: <code>mongodb+srv://</code> URI는 DNS SRV 레코드를 사용한다. K8s 클러스터의 DNS가 외부 DNS를 제대로 해석할 수 있어야 한다.</li>
</ol>
<p>한 가지 더, Atlas의 무료 등급(M0)은 VPC Peering과 Private Link를 지원하지 않는다. 프로덕션에서는 최소 M10 이상을 써야 한다.</p>
<hr>
<h2 id="205-cicd-github-actions">20.5 CI/CD 파이프라인 구성 (GitHub Actions)</h2>
<p>이제 자동화 차례다. GitHub Actions를 쓰면 코드 푸시부터 테스트, 빌드, K8s 배포까지 자동으로 진행된다. 직접 배포할 필요 없이 git push 하나면 된다.</p>
<h3 id="2051-cicd">20.5.1 CI/CD 워크플로우</h3>
<p>```yaml</p>
<h1 id="githubworkflowsciyml">.github/workflows/ci.yml</h1>
<p>name: CI/CD Pipeline</p>
<p>on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]</p>
<p>permissions:
  contents: read
  packages: write</p>
<p>env:
  JAVA_VERSION: '21'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}</p>
<p>jobs:
  test:
    name: Build &amp; Test
    runs-on: ubuntu-latest
    services:
      mongodb:
        image: mongo:7.0
        ports:
          - 27017:27017
        env:
          MONGO_INITDB_ROOT_USERNAME: testuser
          MONGO_INITDB_ROOT_PASSWORD: testpass
        options: &gt;-
          --health-cmd "mongosh --eval 'db.adminCommand({ping:1})'"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
      - uses: gradle/actions/setup-gradle@v4
      - name: Run Tests
        env:
          SPRING_DATA_MONGODB_URI: mongodb://testuser:testpass@localhost:27017/testdb?authSource=admin
        run: ./gradlew test</p>
<p>build-image:
    name: Build &amp; Push Image
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' &amp;&amp; github.ref == 'refs/heads/main'
    outputs:
      image-tag: ${{ steps.meta.outputs.version }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
      - uses: gradle/actions/setup-gradle@v4
      - uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=
            type=ref,event=branch
      - name: Build and Push with Jib
        run: |
          ./gradlew jib \
            -Djib.to.image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
            -Djib.to.tags=${{ steps.meta.outputs.version }}
        env:
          REGISTRY_USERNAME: ${{ github.actor }}
          REGISTRY_PASSWORD: ${{ secrets.GITHUB_TOKEN }}</p>
<p>deploy:
    name: Deploy to Kubernetes
    needs: build-image
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
      - uses: actions/checkout@v4
      - uses: azure/setup-kubectl@v4
      - name: Set Kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d &gt; $HOME/.kube/config
      - name: Deploy
        run: |
          kubectl apply -k k8s/overlays/prod/
          kubectl -n webflux-app rollout status deployment/webflux-app --timeout=300s
```</p>
<h3 id="2052">20.5.2 브랜치 전략과 시크릿 관리</h3>
<p>브랜치별로 다른 동작을 하도록 설정할 수 있다.</p>
<table>
<thead>
<tr>
<th>브랜치</th>
<th>트리거</th>
<th>수행 작업</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>feature/*</code></td>
<td>PR 생성</td>
<td>빌드, 테스트</td>
</tr>
<tr>
<td><code>develop</code></td>
<td>Push</td>
<td>빌드, 테스트, 스테이징 배포</td>
</tr>
<tr>
<td><code>main</code></td>
<td>Push</td>
<td>빌드, 테스트, 이미지 빌드, 프로덕션 배포</td>
</tr>
</tbody>
</table>
<p>필요한 GitHub Secrets:</p>
<table>
<thead>
<tr>
<th>시크릿 이름</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GITHUB_TOKEN</code></td>
<td>자동 제공 (GHCR 인증용)</td>
</tr>
<tr>
<td><code>KUBE_CONFIG</code></td>
<td>K8s kubeconfig (Base64 인코딩)</td>
</tr>
<tr>
<td><code>MONGO_URI</code></td>
<td>MongoDB Atlas 연결 문자열</td>
</tr>
</tbody>
</table>
<p>팁으로, <code>environment: production</code> 설정을 쓰면 프로덕션 배포 전에 수동 승인(Manual Approval) 단계를 추가할 수 있다. 이렇게 하면 실수로 잘못된 코드가 배포되는 실수를 줄일 수 있다.</p>
<hr>
<h2 id="206-graalvm-native-image">20.6 GraalVM Native Image 빌드</h2>
<p>마지막으로 GraalVM Native Image를 살펴보자. 이건 Java를 컴파일 시점에 네이티브 코드로 변환해버린다. 덕분에 시작 시간이 몇 초에서 수백 밀리초로 줄어들고, 메모리도 훨씬 적게 쓴다. 서버리스 환경이나 마이크로서비스 아키텍처에 정말 좋다.</p>
<h3 id="2061-jvm-vs-native-image">20.6.1 JVM vs Native Image 비교</h3>
<table>
<thead>
<tr>
<th>항목</th>
<th>JVM</th>
<th>Native Image</th>
</tr>
</thead>
<tbody>
<tr>
<td>시작 시간</td>
<td>2~5초</td>
<td>50~200ms</td>
</tr>
<tr>
<td>메모리 사용</td>
<td>256~512MB</td>
<td>64~128MB</td>
</tr>
<tr>
<td>최대 처리량</td>
<td>높음 (JIT 최적화)</td>
<td>보통 (AOT 제한)</td>
</tr>
<tr>
<td>빌드 시간</td>
<td>짧음</td>
<td>김 (수 분)</td>
</tr>
<tr>
<td>리플렉션 지원</td>
<td>완전</td>
<td>설정 필요</td>
</tr>
</tbody>
</table>
<h3 id="2062-gradle">20.6.2 Gradle 빌드 설정</h3>
<p>```groovy
plugins {
    id 'org.springframework.boot' version '3.5.11'
    id 'io.spring.dependency-management' version '1.1.7'
    id 'org.graalvm.buildtools.native' version '0.11.4'
    id 'java'
}</p>
<p>graalvmNative {
    binaries {
        main {
            buildArgs.addAll([
                '--initialize-at-build-time',
                '-H:+ReportExceptionStackTraces'
            ])
            javaLauncher = javaToolchains.launcherFor {
                languageVersion = JavaLanguageVersion.of(21)
                vendor = JvmVendorSpec.GRAAL_VM
            }
        }
    }
    metadataRepository {
        enabled = true
    }
}
```</p>
<h3 id="2063">20.6.3 리플렉션 힌트 설정</h3>
<p>Spring Boot 3.x는 대부분의 리플렉션 힌트를 자동으로 생성해준다. 다행히 개발자가 직접 설정할 필요가 거의 없다. 다만 동적으로 로드되는 특수한 클래스는 수동으로 등록해야 한다.</p>
<p>```java
@Configuration
@ImportRuntimeHints(NativeHintsRegistrar.class)
public class NativeImageConfig {
}</p>
<p>public class NativeHintsRegistrar implements RuntimeHintsRegistrar {</p>
<pre><code>@Override
public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
    hints.reflection()
        .registerType(Product.class, MemberCategory.values())
        .registerType(Order.class, MemberCategory.values());

    hints.resources()
        .registerPattern("application*.yml");
}
</code></pre>
<p>}
```</p>
<h3 id="2064-native-image-docker">20.6.4 Native Image Docker 빌드</h3>
<p>GraalVM을 로컬에 설치할 필요는 없다. Buildpacks를 쓰면 Docker 컨테이너 안에서 자동으로 빌드된다.</p>
<p><code>groovy
bootBuildImage {
    imageName = "ghcr.io/myorg/webflux-app-native:${project.version}"
    environment = [
        'BP_NATIVE_IMAGE': 'true',
        'BP_JVM_VERSION': '21'
    ]
}</code></p>
<p>혹은 멀티 스테이지 Dockerfile로 직접 빌드할 수도 있다.</p>
<p>```dockerfile
FROM ghcr.io/graalvm/native-image-community:21 AS builder
WORKDIR /app
COPY gradle/ gradle/
COPY gradlew build.gradle settings.gradle ./
COPY src/ src/
RUN ./gradlew nativeCompile --no-daemon</p>
<p>FROM debian:bookworm-slim
WORKDIR /app
RUN groupadd -r appuser &amp;&amp; useradd -r -g appuser appuser
COPY --from=builder /app/build/native/nativeCompile/webflux-app ./
USER appuser
EXPOSE 8080
ENTRYPOINT ["./webflux-app"]
```</p>
<h3 id="2065">20.6.5 주의사항</h3>
<p>실제로 네이티브 이미지를 빌드할 때 주의할 점들이 있다.</p>
<ol>
<li><strong>빌드 리소스</strong>: 네이티브 이미지 컴파일은 상당히 무겁다. 최소 8GB 메모리가 필요하고 5~10분 이상 걸린다. CI/CD에서 대규모 프로젝트는 GitHub Actions의 Larger Runner를 사용하는 게 좋다.</li>
<li><strong>프로파일 결정 시점</strong>: 네이티브 이미지는 빌드할 때 프로파일이 확정된다. 런타임에 바꿀 수 없다는 뜻이다. 나중에 런타임 변경이 필요하면 AOT 처리 시 명시적으로 설정해야 한다.</li>
</ol>
<p><code>bash
./gradlew nativeCompile -Pspring.profiles.active=prod</code></p>
<ol>
<li><strong>서드파티 호환성</strong>: 모든 라이브러리가 네이티브 이미지를 지원하진 않는다. 사용하는 라이브러리가 지원되는지 <a href="https://github.com/oracle/graalvm-reachability-metadata">GraalVM Reachability Metadata Repository</a>에서 확인하자.</li>
<li><strong>GitHub Actions 빌드</strong>: 보통 Git 태그를 푸시할 때 네이티브 이미지 빌드를 트리거하는 방식으로 구성한다.</li>
</ol>
<p>```yaml</p>
<h1 id="githubworkflowsnative-buildyml">.github/workflows/native-build.yml</h1>
<p>name: Native Image Build
on:
  push:
    tags: ['v*']
jobs:
  native-build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: graalvm/setup-graalvm@v1
        with:
          java-version: '21'
          distribution: 'graalvm-community'
      - uses: gradle/actions/setup-gradle@v4
      - run: ./gradlew nativeCompile
      - run: |
          docker build -f Dockerfile.native \
            -t ghcr.io/${{ github.repository }}-native:${{ github.ref_name }} .
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          docker push ghcr.io/${{ github.repository }}-native:${{ github.ref_name }}
```</p>
<hr>
<h2 id="_4">요약</h2>
<p>지금까지 배포의 전체 과정을 다뤘다.</p>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 도구</th>
<th>권장 사항</th>
</tr>
</thead>
<tbody>
<tr>
<td>Docker 빌드</td>
<td>Jib, Buildpacks</td>
<td>CI/CD에서는 Jib 권장</td>
</tr>
<tr>
<td>로컬 스택</td>
<td>Docker Compose</td>
<td>헬스 체크와 의존성 순서 필수</td>
</tr>
<tr>
<td>K8s 배포</td>
<td>Deployment, HPA</td>
<td>3종 프로브와 preStop 훅 설정</td>
</tr>
<tr>
<td>Atlas 연동</td>
<td>SRV 연결</td>
<td>VPC Peering으로 보안 강화</td>
</tr>
<tr>
<td>CI/CD</td>
<td>GitHub Actions</td>
<td>브랜치 전략과 시크릿 관리</td>
</tr>
<tr>
<td>Native Image</td>
<td>GraalVM, AOT</td>
<td>서버리스 환경에 적합</td>
</tr>
</tbody>
</table>
<p>컨테이너화와 CI/CD를 제대로 구축해놓으면, 이후 배포는 거의 자동화된다. 개발팀은 코드만 푸시하면 되고, 나머지는 파이프라인이 알아서 처리한다. 다음 장에서는 이런 환경에서 문제가 생겼을 때 <strong>장애 대응과 트러블슈팅</strong>을 어떻게 하는지 다룬다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>