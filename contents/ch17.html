<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 17. 문서화와 API 관리 | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="ch16.html">&larr; Chapter 16. 리액티브 테스트 전략</a>
    <a href="../index.html">목차</a>
    <a href="ch18.html">Chapter 18. 모니터링과 관측 가능성 &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-17-api">Chapter 17. 문서화와 API 관리</h1>
<p>훌륭한 API를 설계하는 것은 중요하지만, 정직하게 말하자면 그것만으로는 부족하다. 아무리 좋은 리액티브 API를 만들어도 팀 동료, 프론트엔드 개발자, 외부 파트너가 그것을 어떻게 써야 할지 몰라버리면 의미가 없다. 필자의 경험상, API는 구현하는 그 순간보다 <strong>유지보수되는 기간이 훨씬 길다</strong>. 그리고 그 긴 기간 동안 그 API를 사용하는 사람들은 대부분 문서를 읽는다.</p>
<p>이 장에서는 Spring WebFlux 환경에서 API 문서를 체계적으로 만들고 관리하는 방법을 살펴본다. SpringDoc OpenAPI(Swagger)를 통한 자동 문서 생성부터, 리액티브 타입의 문서화 처리, 그리고 API 버전을 어떻게 관리할지까지 다룰 예정이다.</p>
<hr>
<h2 id="171-springdoc-openapiswagger">17.1 SpringDoc OpenAPI(Swagger) 연동</h2>
<h3 id="1711-springdoc-openapi">17.1.1 SpringDoc OpenAPI란?</h3>
<p>SpringDoc OpenAPI는 Spring Boot 애플리케이션에서 <strong>OpenAPI 3.0/3.1 명세</strong>를 자동으로 생성해주는 라이브러리 정도로 이해하면 된다. 한때는 Springfox(Swagger 2)라는 도구를 많이 썼는데, Spring Boot 3.x가 나오면서 SpringDoc이 실질적인 표준이 되었다.</p>
<table>
<thead>
<tr>
<th>구분</th>
<th>Springfox</th>
<th>SpringDoc</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>OpenAPI 버전</strong></td>
<td>Swagger 2.0</td>
<td>OpenAPI 3.0/3.1</td>
</tr>
<tr>
<td><strong>Spring Boot 3 지원</strong></td>
<td>미지원</td>
<td>지원</td>
</tr>
<tr>
<td><strong>WebFlux 지원</strong></td>
<td>제한적</td>
<td>네이티브 지원</td>
</tr>
<tr>
<td><strong>유지보수 상태</strong></td>
<td>사실상 중단</td>
<td>활발히 유지보수</td>
</tr>
<tr>
<td><strong>RouterFunction 지원</strong></td>
<td>미지원</td>
<td>지원</td>
</tr>
</tbody>
</table>
<h3 id="1712">17.1.2 의존성 설정</h3>
<p>WebFlux를 사용한다면 <code>springdoc-openapi-starter-webflux-ui</code> 의존성을 추가하면 된다. 주의할 점은 일반 MVC용인 <code>springdoc-openapi-starter-webmvc-ui</code>와 헷갈리는 것인데, 프로젝트 특성에 맞는 것을 선택해야 한다.</p>
<pre class="highlight"><code class="language-groovy">dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    implementation 'org.springframework.boot:spring-boot-starter-data-mongodb-reactive'

    // SpringDoc OpenAPI - WebFlux 전용
    implementation 'org.springdoc:springdoc-openapi-starter-webflux-ui:2.8.4'
}</code></pre>
<p>의존성을 추가하는 것만으로 다음 두 엔드포인트가 자동으로 활성화된다.</p>
<table>
<thead>
<tr>
<th>엔드포인트</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/v3/api-docs</code></td>
<td>OpenAPI 3.0 JSON 명세</td>
</tr>
<tr>
<td><code>/swagger-ui.html</code></td>
<td>Swagger UI 웹 인터페이스</td>
</tr>
</tbody>
</table>
<h3 id="1713">17.1.3 기본 설정</h3>
<p><code>application.yml</code>에 설정을 조금 추가하면 SpringDoc의 동작을 원하는 대로 제어할 수 있다.</p>
<pre class="highlight"><code class="language-yaml">springdoc:
  api-docs:
    path: /v3/api-docs
    enabled: true
  swagger-ui:
    path: /swagger-ui.html
    enabled: true
    operations-sorter: method
    tags-sorter: alpha
    display-request-duration: true
  default-produces-media-type: application/json
  default-consumes-media-type: application/json
  show-actuator: false</code></pre>
<p>운영 환경에서는 보안을 생각해서 Swagger UI를 꺼두는 게 관례다.</p>
<pre class="highlight"><code class="language-yaml"># application-prod.yml
springdoc:
  api-docs:
    enabled: false
  swagger-ui:
    enabled: false</code></pre>
<h3 id="1714-openapi">17.1.4 OpenAPI 전역 설정 빈</h3>
<p>API 문서 전체의 제목, 설명, 버전 정보 같은 것들은 <code>OpenAPI</code> 빈으로 따로 정의하는 것이 깔끔하다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
            .info(new Info()
                .title("상품 관리 API")
                .description("Spring WebFlux + MongoDB 기반 리액티브 상품 관리 시스템")
                .version("1.0.0")
                .contact(new Contact()
                    .name("개발팀")
                    .email("dev@example.com"))
                .license(new License()
                    .name("Apache 2.0")
                    .url("https://www.apache.org/licenses/LICENSE-2.0")))
            .externalDocs(new ExternalDocumentation()
                .description("프로젝트 위키")
                .url("https://wiki.example.com/product-api"));
    }
}</code></pre>
<h3 id="1715-operation-apiresponse">17.1.5 @Operation과 @ApiResponse</h3>
<p><code>@Operation</code> 어노테이션을 메서드에 붙이면 각 API마다 설명을 달 수 있고, <code>@ApiResponse</code>로는 응답 코드를 상세히 문서화할 수 있다.</p>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/v1/products")
@Tag(name = "상품", description = "상품 CRUD API")
public class ProductController {

    private final ProductService productService;

    public ProductController(ProductService productService) {
        this.productService = productService;
    }

    @Operation(summary = "상품 목록 조회",
               description = "등록된 모든 상품을 페이징하여 조회한다.")
    @ApiResponses({
        @ApiResponse(responseCode = "200", description = "조회 성공",
            content = @Content(mediaType = "application/json",
                array = @ArraySchema(schema = @Schema(implementation = ProductResponse.class))))
    })
    @GetMapping
    public Flux&lt;ProductResponse&gt; getAllProducts(
            @Parameter(description = "페이지 번호 (0부터 시작)", example = "0")
            @RequestParam(defaultValue = "0") int page,
            @Parameter(description = "페이지 크기", example = "20")
            @RequestParam(defaultValue = "20") int size) {
        return productService.findAll(page, size);
    }

    @Operation(summary = "상품 단건 조회",
               description = "상품 ID로 단건 조회한다. 존재하지 않으면 404를 반환한다.")
    @ApiResponses({
        @ApiResponse(responseCode = "200", description = "조회 성공"),
        @ApiResponse(responseCode = "404", description = "상품을 찾을 수 없음",
            content = @Content(schema = @Schema(implementation = ErrorResponse.class)))
    })
    @GetMapping("/{id}")
    public Mono&lt;ProductResponse&gt; getProduct(
            @Parameter(description = "상품 ID", required = true,
                       example = "665a1b2c3d4e5f6a7b8c9d0e")
            @PathVariable String id) {
        return productService.findById(id);
    }

    @Operation(summary = "상품 등록")
    @ApiResponses({
        @ApiResponse(responseCode = "201", description = "등록 성공"),
        @ApiResponse(responseCode = "400", description = "유효성 검증 실패")
    })
    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono&lt;ProductResponse&gt; createProduct(
            @Valid @RequestBody ProductCreateRequest request) {
        return productService.create(request);
    }
}</code></pre>
<h3 id="1716-schema">17.1.6 @Schema를 활용한 모델 문서화</h3>
<p>DTO에 <code>@Schema</code>를 붙여놓으면, Swagger UI에서 필드별 설명, 필수 여부, 예시 같은 정보가 깔끔하게 표시된다.</p>
<pre class="highlight"><code class="language-java">@Schema(description = "상품 등록 요청")
public record ProductCreateRequest(

    @Schema(description = "상품명", example = "무선 키보드",
            requiredMode = RequiredMode.REQUIRED)
    @NotBlank(message = "상품명은 필수입니다")
    String name,

    @Schema(description = "가격 (원)", example = "45000", minimum = "0")
    @NotNull @Positive
    Integer price,

    @Schema(description = "카테고리", example = "ELECTRONICS",
            allowableValues = {"ELECTRONICS", "CLOTHING", "FOOD", "BOOKS"})
    @NotNull
    Category category,

    @Schema(description = "태그 목록", example = "[\"bluetooth\", \"keyboard\"]")
    List&lt;String&gt; tags
) {}</code></pre>
<pre class="highlight"><code class="language-java">@Schema(description = "상품 응답")
public record ProductResponse(

    @Schema(description = "상품 ID", example = "665a1b2c3d4e5f6a7b8c9d0e")
    String id,

    @Schema(description = "상품명", example = "무선 키보드")
    String name,

    @Schema(description = "가격 (원)", example = "45000")
    Integer price,

    @Schema(description = "카테고리")
    Category category,

    @Schema(description = "등록일시", example = "2025-01-15T10:30:00")
    LocalDateTime createdAt
) {}</code></pre>
<hr>
<h2 id="172-api">17.2 리액티브 API 문서 자동 생성</h2>
<h3 id="1721-monoflux">17.2.1 Mono/Flux 반환 타입 처리</h3>
<p>SpringDoc은 <code>Mono</code>나 <code>Flux</code> 같은 리액티브 타입을 아주 잘 이해한다. 내부에 감싸진 타입이 뭔지 파악해서 자동으로 스키마를 만들어낸다.</p>
<table>
<thead>
<tr>
<th>메서드 반환 타입</th>
<th>OpenAPI 스키마</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Mono&lt;Product&gt;</code></td>
<td><code>Product</code> (단일 객체)</td>
</tr>
<tr>
<td><code>Flux&lt;Product&gt;</code></td>
<td><code>Product[]</code> (배열)</td>
</tr>
<tr>
<td><code>Mono&lt;Void&gt;</code></td>
<td>응답 본문 없음</td>
</tr>
<tr>
<td><code>Mono&lt;ResponseEntity&lt;Product&gt;&gt;</code></td>
<td><code>Product</code> + 상태 코드</td>
</tr>
<tr>
<td><code>Flux&lt;ServerSentEvent&lt;Product&gt;&gt;</code></td>
<td>SSE 스트림으로 표현</td>
</tr>
</tbody>
</table>
<p>스트리밍 응답을 다룬다면, <code>produces</code> 미디어 타입을 명시적으로 지정해두는 게 문서 작성 입장에서도 명확하다.</p>
<pre class="highlight"><code class="language-java">@Operation(summary = "상품 실시간 스트림")
@GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;ProductResponse&gt; streamProducts() {
    return productService.streamAll();
}</code></pre>
<h3 id="1722-routerfunction">17.2.2 RouterFunction 문서화</h3>
<p>함수형 라우터(<code>RouterFunction</code>)는 일반 컨트롤러와 달라서 리플렉션으로 메타데이터를 뽑아낼 수 없다. 그래서 SpringDoc은 별도로 두 가지 방법을 제공한다: <code>@RouterOperation</code> 어노테이션 방식과 <code>OpenApiCustomizer</code> 프로그래밍 방식이다.</p>
<p><strong>방법 1: @RouterOperation 어노테이션</strong></p>
<pre class="highlight"><code class="language-java">@Configuration
public class ProductRouter {

    @RouterOperations({
        @RouterOperation(
            path = "/api/v1/products", method = RequestMethod.GET,
            beanClass = ProductHandler.class, beanMethod = "getAllProducts",
            operation = @Operation(
                operationId = "getAllProducts", summary = "상품 목록 조회",
                tags = {"상품"},
                responses = @ApiResponse(responseCode = "200",
                    description = "조회 성공",
                    content = @Content(array = @ArraySchema(
                        schema = @Schema(implementation = ProductResponse.class)))))),
        @RouterOperation(
            path = "/api/v1/products/{id}", method = RequestMethod.GET,
            beanClass = ProductHandler.class, beanMethod = "getProduct",
            operation = @Operation(
                operationId = "getProduct", summary = "상품 단건 조회",
                tags = {"상품"},
                parameters = @Parameter(in = ParameterIn.PATH, name = "id",
                    description = "상품 ID", required = true),
                responses = {
                    @ApiResponse(responseCode = "200", description = "조회 성공"),
                    @ApiResponse(responseCode = "404", description = "상품을 찾을 수 없음")}))
    })
    @Bean
    public RouterFunction&lt;ServerResponse&gt; productRoutes(ProductHandler handler) {
        return RouterFunctions.route()
            .path("/api/v1/products", builder -&gt; builder
                .GET("", handler::getAllProducts)
                .GET("/{id}", handler::getProduct))
            .build();
    }
}</code></pre>
<p><strong>방법 2: OpenApiCustomizer 프로그래밍 방식</strong></p>
<p>라우트가 많다거나, 문서 정보를 동적으로 관리하고 싶은 경우 <code>OpenApiCustomizer</code> 빈을 만들어서 <code>openApi.getPaths().addPathItem()</code> 같은 메서드로 경로와 오퍼레이션을 프로그래밍 방식으로 등록할 수 있다.</p>
<h3 id="1723-securityscheme">17.2.3 SecurityScheme 설정</h3>
<p>JWT 인증을 쓰는 API라면, Swagger UI에 직접 토큰을 입력하고 테스트하고 싶을 테니 <code>SecurityScheme</code>을 설정해두자.</p>
<pre class="highlight"><code class="language-java">@Bean
public OpenAPI customOpenAPI() {
    final String securitySchemeName = "bearerAuth";

    return new OpenAPI()
        .info(new Info().title("상품 관리 API").version("1.0.0"))
        .addSecurityItem(new SecurityRequirement().addList(securitySchemeName))
        .components(new Components()
            .addSecuritySchemes(securitySchemeName,
                new SecurityScheme()
                    .name(securitySchemeName)
                    .type(SecurityScheme.Type.HTTP)
                    .scheme("bearer")
                    .bearerFormat("JWT")
                    .description("JWT 토큰을 입력하세요.")));
}</code></pre>
<p>그런데 어떤 엔드포인트는 인증이 필요하고 어떤 건 불필요하다면? <code>@SecurityRequirement</code>를 메서드마다 붙여서 선택적으로 적용하면 된다.</p>
<pre class="highlight"><code class="language-java">// 인증이 필요한 엔드포인트
@Operation(summary = "상품 등록",
           security = @SecurityRequirement(name = "bearerAuth"))
@PostMapping
public Mono&lt;ProductResponse&gt; createProduct(@Valid @RequestBody ProductCreateRequest req) {
    return productService.create(req);
}

// 인증이 필요 없는 엔드포인트 (전역 보안 설정 무시)
@Operation(summary = "상품 목록 조회", security = {})
@GetMapping
public Flux&lt;ProductResponse&gt; getAllProducts() {
    return productService.findAll();
}</code></pre>
<h3 id="1724-group">17.2.4 그룹(Group)별 문서 분리</h3>
<p>프로젝트가 커지면 API가 여러 도메인에 흩어진다. 문서도 그에 맞춰 그룹 단위로 분리하는 게 읽기 훨씬 편하다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class OpenApiGroupConfig {

    @Bean
    public GroupedOpenApi productApi() {
        return GroupedOpenApi.builder()
            .group("product-api").displayName("상품 API")
            .pathsToMatch("/api/v1/products/**")
            .build();
    }

    @Bean
    public GroupedOpenApi orderApi() {
        return GroupedOpenApi.builder()
            .group("order-api").displayName("주문 API")
            .pathsToMatch("/api/v1/orders/**")
            .build();
    }
}</code></pre>
<p>Swagger UI의 상단 드롭다운에서 그룹을 고르면, 선택한 그룹의 API만 보이는 식으로 작동한다.</p>
<hr>
<h2 id="173-api">17.3 API 버전 관리 전략</h2>
<h3 id="1731-api">17.3.1 왜 API 버전 관리가 필요한가?</h3>
<p>API를 한 번 공개하면, 그 순간부터 누군가는 그걸 사용하고 있다. 필자의 경험상 가장 많이 실수하는 부분이 바로 이것이다: 기존 API 사용자를 깨뜨리면서 마음대로 변경하면 안 된다. 체계적인 버전 관리가 없으면, 어느 날 갑자기 누군가의 클라이언트가 멈춰있고, 왜 변경되었는지 추적할 수도 없게 된다.</p>
<h3 id="1732-url">17.3.2 URL 경로 기반 버전 관리</h3>
<p>가장 간단하고 직관적인 방법이다. 그냥 URL에 버전 번호를 넣어버리는 것이다.</p>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/v1/products")
@Tag(name = "상품 V1")
public class ProductV1Controller {

    private final ProductService productService;

    public ProductV1Controller(ProductService productService) {
        this.productService = productService;
    }

    @GetMapping("/{id}")
    public Mono&lt;ProductV1Response&gt; getProduct(@PathVariable String id) {
        return productService.findById(id).map(ProductV1Response::from);
    }
}

@RestController
@RequestMapping("/api/v2/products")
@Tag(name = "상품 V2", description = "카테고리 구조 변경")
public class ProductV2Controller {

    private final ProductService productService;

    public ProductV2Controller(ProductService productService) {
        this.productService = productService;
    }

    @GetMapping("/{id}")
    public Mono&lt;ProductV2Response&gt; getProduct(@PathVariable String id) {
        return productService.findById(id).map(ProductV2Response::from);
    }
}</code></pre>
<p>이렇게 하면 버전마다 DTO를 따로 만들어야 한다.</p>
<pre class="highlight"><code class="language-java">// V1: 카테고리를 단일 문자열로 표현
public record ProductV1Response(String id, String name, int price, String category) {
    public static ProductV1Response from(Product p) {
        return new ProductV1Response(p.getId(), p.getName(), p.getPrice(),
            p.getCategory().name());
    }
}

// V2: 카테고리를 계층 구조 객체로 표현
public record ProductV2Response(String id, String name, int price,
                                CategoryInfo category, List&lt;String&gt; tags) {
    public record CategoryInfo(String code, String displayName, String parentCode) {}

    public static ProductV2Response from(Product p) {
        return new ProductV2Response(p.getId(), p.getName(), p.getPrice(),
            new CategoryInfo(p.getCategory().name(),
                p.getCategory().getDisplayName(),
                p.getCategory().getParentCode()),
            p.getTags());
    }
}</code></pre>
<table>
<thead>
<tr>
<th>장점</th>
<th>단점</th>
</tr>
</thead>
<tbody>
<tr>
<td>직관적이고 이해하기 쉬움</td>
<td>컨트롤러가 버전만큼 증가</td>
</tr>
<tr>
<td>URL만 보면 버전 파악 가능</td>
<td>공통 로직 중복 가능성</td>
</tr>
<tr>
<td>캐싱, 라우팅, 로깅에서 구분 용이</td>
<td>URL이 길어짐</td>
</tr>
</tbody>
</table>
<h3 id="1733">17.3.3 헤더 기반 버전 관리</h3>
<p>URL을 깔끔하게 놔두고 싶다면, 헤더에다가 버전을 넣는 방법도 있다.</p>
<pre class="highlight"><code>GET /api/products
X-API-Version: 2</code></pre>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/products")
public class ProductController {

    private final ProductService productService;

    public ProductController(ProductService productService) {
        this.productService = productService;
    }

    @Operation(summary = "상품 조회",
        parameters = @Parameter(name = "X-API-Version", in = ParameterIn.HEADER,
            description = "API 버전", required = false,
            schema = @Schema(type = "integer", defaultValue = "1")))
    @GetMapping("/{id}")
    public Mono&lt;?&gt; getProduct(
            @PathVariable String id,
            @RequestHeader(value = "X-API-Version", defaultValue = "1") int version) {
        return productService.findById(id)
            .map(product -&gt; switch (version) {
                case 2 -&gt; ProductV2Response.from(product);
                default -&gt; ProductV1Response.from(product);
            });
    }
}</code></pre>
<table>
<thead>
<tr>
<th>장점</th>
<th>단점</th>
</tr>
</thead>
<tbody>
<tr>
<td>URL이 깔끔하게 유지됨</td>
<td>브라우저에서 직접 테스트 어려움</td>
</tr>
<tr>
<td>동일 리소스에 대한 단일 URL</td>
<td>캐싱 설정 복잡 (Vary 헤더 필요)</td>
</tr>
<tr>
<td>컨트롤러 중복 감소</td>
<td>문서화 시 헤더 명시 필요</td>
</tr>
</tbody>
</table>
<h3 id="1734-content-negotiation">17.3.4 미디어 타입(Content Negotiation) 기반 버전 관리</h3>
<p>또 다른 방법은 <code>Accept</code> 헤더에 버전을 넣는 것이다. GitHub API가 이렇게 한다고 알려져 있다.</p>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/products")
public class ProductController {

    private final ProductService productService;

    public ProductController(ProductService productService) {
        this.productService = productService;
    }

    @GetMapping(value = "/{id}", produces = "application/vnd.example.v1+json")
    @Operation(summary = "상품 조회 (V1)")
    public Mono&lt;ProductV1Response&gt; getProductV1(@PathVariable String id) {
        return productService.findById(id).map(ProductV1Response::from);
    }

    @GetMapping(value = "/{id}", produces = "application/vnd.example.v2+json")
    @Operation(summary = "상품 조회 (V2)")
    public Mono&lt;ProductV2Response&gt; getProductV2(@PathVariable String id) {
        return productService.findById(id).map(ProductV2Response::from);
    }
}</code></pre>
<p>다만 이 방식은 구현이 좀 복잡하다. Spring이 커스텀 미디어 타입을 JSON으로 처리하도록 <code>WebFluxConfigurer</code>의 <code>configureHttpMessageCodecs</code> 메서드에서 코덱을 등록해야 한다.</p>
<table>
<thead>
<tr>
<th>장점</th>
<th>단점</th>
</tr>
</thead>
<tbody>
<tr>
<td>RESTful 원칙에 가장 부합</td>
<td>구현 복잡도 높음</td>
</tr>
<tr>
<td>URL과 헤더 모두 깨끗</td>
<td>클라이언트가 Accept 헤더를 올바르게 설정해야 함</td>
</tr>
<tr>
<td>HTTP 콘텐츠 협상 표준 활용</td>
<td>코덱 설정 필요</td>
</tr>
</tbody>
</table>
<h3 id="1735">17.3.5 하위 호환성 유지 전략</h3>
<p>어떤 방식으로 버전을 관리하든, <strong>하위 호환성(Backward Compatibility)</strong>을 지키는 게 최고의 전략이다. 필자의 경험상, 새 버전을 만드는 건 정말 마지막 수단으로 남겨두어야 한다.</p>
<p><strong>하위 호환이 유지되는 변경 (Non-Breaking)</strong></p>
<table>
<thead>
<tr>
<th>변경 유형</th>
<th>예시</th>
</tr>
</thead>
<tbody>
<tr>
<td>응답 필드 추가</td>
<td><code>tags</code> 필드 추가 (기존 클라이언트는 무시)</td>
</tr>
<tr>
<td>선택적 요청 파라미터 추가</td>
<td><code>?sortBy=name</code> (기존 요청에 영향 없음)</td>
</tr>
<tr>
<td>새 엔드포인트 추가</td>
<td><code>POST /api/v1/products/bulk</code></td>
</tr>
</tbody>
</table>
<p><strong>하위 호환이 깨지는 변경 (Breaking)</strong></p>
<table>
<thead>
<tr>
<th>변경 유형</th>
<th>예시</th>
</tr>
</thead>
<tbody>
<tr>
<td>응답 필드 제거/타입 변경</td>
<td><code>price: int</code> -&gt; <code>price: object</code></td>
</tr>
<tr>
<td>필수 파라미터 추가</td>
<td><code>?category</code> 필수로 변경</td>
</tr>
<tr>
<td>URL 구조 변경</td>
<td><code>/products/{id}</code> -&gt; <code>/items/{id}</code></td>
</tr>
</tbody>
</table>
<p><strong>Deprecation 정책 구현</strong></p>
<p>만약 정말로 API의 어떤 필드나 엔드포인트를 없애야 한다면, 충분한 유예 기간을 두고 미리 경고해야 한다.</p>
<pre class="highlight"><code class="language-java">@GetMapping("/{id}")
public Mono&lt;ResponseEntity&lt;ProductV1Response&gt;&gt; getProductV1(@PathVariable String id) {
    return productService.findById(id)
        .map(ProductV1Response::from)
        .map(response -&gt; ResponseEntity.ok()
            .header("Deprecation", "true")
            .header("Sunset", "2026-06-01T00:00:00Z")
            .header("Link", "&lt;/api/v2/products&gt;; rel=\"successor-version\"")
            .body(response));
}</code></pre>
<h3 id="1736">17.3.6 버전 관리 전략 비교 및 권장사항</h3>
<table>
<thead>
<tr>
<th>기준</th>
<th>URL 경로</th>
<th>헤더</th>
<th>미디어 타입</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>구현 난이도</strong></td>
<td>쉬움</td>
<td>보통</td>
<td>어려움</td>
</tr>
<tr>
<td><strong>직관성</strong></td>
<td>높음</td>
<td>낮음</td>
<td>낮음</td>
</tr>
<tr>
<td><strong>RESTful 준수</strong></td>
<td>보통</td>
<td>보통</td>
<td>높음</td>
</tr>
<tr>
<td><strong>캐싱 용이성</strong></td>
<td>높음</td>
<td>낮음</td>
<td>보통</td>
</tr>
<tr>
<td><strong>대표 사용 사례</strong></td>
<td>Stripe, Twitter</td>
<td>Azure</td>
<td>GitHub</td>
</tr>
</tbody>
</table>
<p><strong>실전 권장 가이드라인</strong></p>
<ol>
<li><strong>URL 경로 기반을 기본으로 사용하자.</strong> 제일 직관적이고 문제 추적도 쉽다.</li>
<li><strong>하위 호환이 유지되는 변경이라면 버전을 올리지 않는다.</strong> 필드 추가나 선택 파라미터 추가 정도면 기존 버전에 포함시킨다.</li>
<li><strong>Breaking Change는 정말 피할 수 없을 때만 새 버전을 만든다.</strong></li>
<li><strong>이전 버전도 최소 6개월 정도는 유지해야 한다.</strong> Sunset 헤더로 언제 종료될지 미리 알려준다.</li>
<li><strong>동시 운영하는 버전은 최대 2개로 제한해야 한다.</strong> 3개 이상이면 유지보수 비용이 지수적으로 늘어난다.</li>
</ol>
<hr>
<h2 id="174">17.4 정리</h2>
<p>이 장에서 나눈 내용을 빠르게 정리해보면 다음과 같다.</p>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 내용</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SpringDoc 연동</strong></td>
<td><code>springdoc-openapi-starter-webflux-ui</code> 의존성 추가만으로 자동 문서 생성</td>
</tr>
<tr>
<td><strong>어노테이션 활용</strong></td>
<td><code>@Operation</code>, <code>@Parameter</code>, <code>@ApiResponse</code>, <code>@Schema</code>로 상세 문서화</td>
</tr>
<tr>
<td><strong>리액티브 타입</strong></td>
<td><code>Mono</code>/<code>Flux</code>를 자동 인식하여 내부 타입 기준으로 스키마 생성</td>
</tr>
<tr>
<td><strong>RouterFunction</strong></td>
<td><code>@RouterOperation</code> 또는 <code>OpenApiCustomizer</code>로 문서화</td>
</tr>
<tr>
<td><strong>SecurityScheme</strong></td>
<td>JWT Bearer 인증을 Swagger UI에서 테스트 가능하도록 설정</td>
</tr>
<tr>
<td><strong>버전 관리</strong></td>
<td>URL 경로 기반이 가장 실용적, 하위 호환성 유지가 최우선</td>
</tr>
</tbody>
</table>
<p>마지막으로 한 가지 더. API 문서화와 버전 관리는 프레임워크나 도구보다 <strong>팀의 규칙과 일관성</strong>이 훨씬 더 중요하다. SpringDoc이 아무리 훌륭해도, 팀원들이 문서화를 제대로 하지 않으면 소용없다. 반대로 규칙이 정해져 있으면 좋은 도구가 없어도 충분히 잘할 수 있다.</p>
<p>다음 장에서는 이제 프로덕션 환경으로 나간다. 애플리케이션이 실제로 돌아가는 상황에서 뭐가 일어나는지 관찰하고 모니터링하는 <strong>Observability</strong> 전략을 다루려고 한다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>