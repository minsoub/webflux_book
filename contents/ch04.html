<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 4. MongoDB 소개 | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="ch03.html">&larr; Chapter 3. Project Reactor 핵심</a>
    <a href="../index.html">목차</a>
    <a href="ch05.html">Chapter 5. 개발 환경 구성 &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-4-mongodb">Chapter 4. MongoDB 소개</h1>
<p>앞서 리액티브 프로그래밍과 Project Reactor의 기초를 갖췄다면, 이제는 이들과 자연스럽게 어울리는 데이터베이스와의 만남이 필요하다. MongoDB가 왜 리액티브 애플리케이션에 강력한지, 그리고 도큐먼트 모델이 어떻게 작동하는지 직접 경험해보자. 설치부터 CRUD 조작까지 손으로 해보며, 리액티브 드라이버의 동작 방식까지 이해하게 될 것이다.</p>
<hr>
<h2 id="41-nosql-mongodb">4.1 NoSQL과 MongoDB의 특징</h2>
<h3 id="411-rdbms-vs-nosql">4.1.1 RDBMS vs NoSQL 비교</h3>
<p>전통적인 관계형 데이터베이스(RDBMS)에서는 정규화된 테이블, SQL 쿼리, ACID 트랜잭션이 중심이다. 반면 NoSQL은 특정 사용 사례에 최적화된 다양한 데이터 모델을 제공하기 때문에, 프로젝트의 특성에 맞는 선택이 가능해진다.</p>
<table>
<thead>
<tr>
<th>구분</th>
<th>RDBMS</th>
<th>NoSQL (MongoDB)</th>
</tr>
</thead>
<tbody>
<tr>
<td>데이터 모델</td>
<td>테이블, 행, 열</td>
<td>도큐먼트 (JSON/BSON)</td>
</tr>
<tr>
<td>스키마</td>
<td>고정 스키마 (DDL 필수)</td>
<td>유연한 스키마 (스키마리스)</td>
</tr>
<tr>
<td>확장 방식</td>
<td>주로 수직 확장 (Scale-up)</td>
<td>수평 확장 (Scale-out, 샤딩)</td>
</tr>
<tr>
<td>트랜잭션</td>
<td>강력한 ACID 지원</td>
<td>단일 도큐먼트 ACID, 멀티 도큐먼트 트랜잭션 지원</td>
</tr>
<tr>
<td>조인</td>
<td>JOIN 연산 기본 지원</td>
<td>일반적으로 비정규화, <code>$lookup</code>으로 제한적 지원</td>
</tr>
<tr>
<td>쿼리 언어</td>
<td>SQL</td>
<td>MQL (MongoDB Query Language)</td>
</tr>
<tr>
<td>적합한 사용 사례</td>
<td>복잡한 관계, 정합성 중시</td>
<td>빠른 반복 개발, 대규모 읽기/쓰기, 유연한 구조</td>
</tr>
</tbody>
</table>
<h3 id="412-mongodb">4.1.2 MongoDB 핵심 특징</h3>
<p><strong>스키마 유연성</strong></p>
<p>같은 컬렉션 안에 서로 다른 구조의 도큐먼트를 저장할 수 있다는 점이 MongoDB의 큰 매력이다. 애플리케이션이 빠르게 변화할 때 스키마 마이그레이션 부담을 크게 덜 수 있기 때문이다.</p>
<p><code>javascript
// 같은 컬렉션에 서로 다른 구조의 도큐먼트가 공존 가능
{ name: "Alice", email: "alice@example.com" }
{ name: "Bob", email: "bob@example.com", phone: "010-1234-5678", address: { city: "Seoul" } }</code></p>
<p><strong>수평 확장 (Sharding)</strong></p>
<p>데이터가 늘어나도 샤드를 추가하여 여러 서버에 나눠 저장할 수 있다. 그러면서도 애플리케이션 코드는 손댈 필요가 없는 셈이다.</p>
<p><strong>높은 가용성 (Replica Set)</strong></p>
<p>복제 세트(Replica Set)는 여러 노드에 데이터 복제본을 유지하기 때문에, 프라이머리 노드에 장애가 발생하면 세컨더리 노드가 자동으로 프라이머리로 승격된다.</p>
<h3 id="413-cap-mongodb">4.1.3 CAP 정리에서의 MongoDB 위치</h3>
<p>분산 시스템의 세 가지 요구사항을 살펴보자. 일관성(Consistency), 가용성(Availability), 분단 내성(Partition Tolerance)인데, CAP 정리는 이 세 가지를 동시에 모두 만족할 수 없다는 것을 말한다.</p>
<ul>
<li><strong>C (Consistency)</strong>: 모든 노드가 같은 시점에 같은 데이터를 반환한다.</li>
<li><strong>A (Availability)</strong>: 모든 요청에 대해 응답을 반환한다.</li>
<li><strong>P (Partition Tolerance)</strong>: 네트워크 분단이 발생해도 시스템이 동작한다.</li>
</ul>
<p>MongoDB는 기본적으로 <strong>CP 시스템</strong>이다. 프라이머리 노드에 쓰기를 집중하여 일관성을 보장하고, 네트워크 분단이 생기면 가용성보다 일관성을 우선한다. 다만 <code>readPreference</code>와 <code>writeConcern</code> 설정을 조정하면, 가용성과 일관성 사이의 균형을 프로젝트의 요구에 맞게 조절할 수 있기 때문에 실제로는 더 유연한 선택이 가능하다.</p>
<p><code>javascript
// writeConcern 설정 예시
db.orders.insertOne(
  { item: "laptop", qty: 1 },
  { writeConcern: { w: "majority", wtimeout: 5000 } }
)</code></p>
<ul>
<li><code>w: "majority"</code> — 과반수 노드에 쓰기가 확인되어야 성공으로 간주</li>
<li><code>w: 1</code> — 프라이머리에만 쓰기 확인 (기본값, 더 빠르지만 덜 안전)</li>
</ul>
<hr>
<h2 id="42">4.2 도큐먼트 모델과 컬렉션</h2>
<h3 id="421-bson">4.2.1 BSON 형식과 도큐먼트 구조</h3>
<p>MongoDB 내부에서 데이터가 어떤 형태로 저장될까? <strong>BSON</strong>(Binary JSON) 형식이 그 답이다. BSON은 JSON을 확장한 것으로, JSON이 제공하지 못하는 여러 데이터 타입을 추가로 지원한다.</p>
<table>
<thead>
<tr>
<th>BSON 타입</th>
<th>설명</th>
<th>예시</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>UTF-8 문자열</td>
<td><code>"Hello"</code></td>
</tr>
<tr>
<td>Int32 / Int64</td>
<td>정수형</td>
<td><code>42</code>, <code>NumberLong(123456789)</code></td>
</tr>
<tr>
<td>Double</td>
<td>부동소수점</td>
<td><code>3.14</code></td>
</tr>
<tr>
<td>Boolean</td>
<td>논리값</td>
<td><code>true</code>, <code>false</code></td>
</tr>
<tr>
<td>Date</td>
<td>날짜/시간</td>
<td><code>ISODate("2025-01-01T00:00:00Z")</code></td>
</tr>
<tr>
<td>ObjectId</td>
<td>12바이트 고유 식별자</td>
<td><code>ObjectId("507f1f77bcf86cd799439011")</code></td>
</tr>
<tr>
<td>Array</td>
<td>배열</td>
<td><code>[1, 2, 3]</code></td>
</tr>
<tr>
<td>Object</td>
<td>내장 도큐먼트</td>
<td><code>{ city: "Seoul" }</code></td>
</tr>
<tr>
<td>Decimal128</td>
<td>고정밀 소수점</td>
<td><code>NumberDecimal("19.99")</code></td>
</tr>
<tr>
<td>Binary</td>
<td>바이너리 데이터</td>
<td>—</td>
</tr>
</tbody>
</table>
<p>도큐먼트의 기본 구조를 보면 다음과 같은데, 이 예시를 보며 각 요소를 이해해보자.</p>
<p><code>javascript
{
  _id: ObjectId("65a1b2c3d4e5f6a7b8c9d0e1"),  // 자동 생성되는 고유 식별자
  title: "Spring WebFlux 입문",
  author: {                                     // 내장 도큐먼트
    name: "홍길동",
    email: "hong@example.com"
  },
  tags: ["spring", "webflux", "reactive"],      // 배열
  price: NumberDecimal("35000"),
  publishedAt: ISODate("2025-03-15T09:00:00Z"),
  inStock: true
}</code></p>
<p><code>_id</code> 필드는 컬렉션 내에서 도큐먼트의 유일한 식별자 역할을 한다. 개발자가 값을 지정하지 않으면 MongoDB가 자동으로 <code>ObjectId</code>를 생성해주는 것도 편리한 부분이다.</p>
<h3 id="422">4.2.2 컬렉션 개념</h3>
<p>컬렉션(Collection)은 RDBMS의 테이블과 비슷한 역할을 한다. 하지만 결정적인 차이가 있다—컬렉션의 도큐먼트들이 반드시 같은 스키마를 따를 필요가 없다는 점 말이다.</p>
<p>```javascript
// 컬렉션 생성 (명시적)
db.createCollection("books")</p>
<p>// 또는 첫 번째 도큐먼트 삽입 시 자동 생성
db.books.insertOne({ title: "MongoDB in Action" })
```</p>
<p>필요한 경우 <strong>Schema Validation</strong>을 적용하여 도큐먼트 구조를 강제할 수 있다.</p>
<p><code>javascript
db.createCollection("books", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["title", "author", "price"],
      properties: {
        title:  { bsonType: "string", description: "제목은 필수 문자열" },
        author: { bsonType: "string", description: "저자는 필수 문자열" },
        price:  { bsonType: "number", minimum: 0, description: "가격은 0 이상" }
      }
    }
  }
})</code></p>
<h3 id="423-embedded-vs-reference">4.2.3 내장 도큐먼트(Embedded) vs 참조(Reference)</h3>
<p>MongoDB 스키마 설계에서 가장 고민이 되는 순간이 바로 <strong>데이터를 내장할 것인가, 참조할 것인가</strong>를 결정하는 때다.</p>
<p><strong>내장 도큐먼트 방식</strong></p>
<p>관련된 데이터를 하나의 도큐먼트 안에 중첩시켜 모두 저장하는 방식이다.</p>
<p><code>javascript
// 주문 도큐먼트에 배송 주소를 내장
{
  _id: ObjectId("..."),
  orderNumber: "ORD-2025-001",
  customer: "김철수",
  items: [
    { productName: "키보드", quantity: 1, price: 89000 },
    { productName: "마우스", quantity: 2, price: 45000 }
  ],
  shippingAddress: {
    zipCode: "06234",
    city: "서울",
    detail: "강남구 테헤란로 123"
  }
}</code></p>
<p><strong>참조 방식</strong></p>
<p>반대로 데이터를 별도의 컬렉션에 보관하고, <code>_id</code>로 참조하는 방식이다.</p>
<p>```javascript
// users 컬렉션
{ _id: ObjectId("user001"), name: "김철수", email: "kim@example.com" }</p>
<p>// orders 컬렉션 - userId로 참조
{
  _id: ObjectId("order001"),
  userId: ObjectId("user001"),   // 참조
  orderNumber: "ORD-2025-001",
  items: [...]
}
```</p>
<p><strong>선택 기준</strong></p>
<table>
<thead>
<tr>
<th>기준</th>
<th>내장 (Embedded)</th>
<th>참조 (Reference)</th>
</tr>
</thead>
<tbody>
<tr>
<td>관계 유형</td>
<td>1:1, 1:N (소량)</td>
<td>1:N (대량), N:M</td>
</tr>
<tr>
<td>읽기 패턴</td>
<td>함께 조회하는 경우</td>
<td>독립적으로 조회하는 경우</td>
</tr>
<tr>
<td>데이터 크기</td>
<td>내장 데이터가 작을 때</td>
<td>내장 시 도큐먼트가 16MB 제한에 근접할 때</td>
</tr>
<tr>
<td>갱신 빈도</td>
<td>드물게 변경</td>
<td>자주 독립적으로 변경</td>
</tr>
</tbody>
</table>
<h3 id="424">4.2.4 스키마 설계 패턴</h3>
<p>MongoDB 커뮤니티에서 시간이 지나며 검증된 설계 패턴들을 살펴보자.</p>
<p><strong>버킷 패턴 (Bucket Pattern)</strong>: 시계열 데이터처럼 연속적으로 들어오는 데이터를 일정한 단위(시간 또는 개수)로 묶어, 하나의 도큐먼트에 저장하는 방식이다.</p>
<p><code>javascript
{
  sensorId: "sensor-001",
  date: ISODate("2025-01-15"),
  readings: [
    { time: ISODate("2025-01-15T00:00:00Z"), value: 23.5 },
    { time: ISODate("2025-01-15T00:05:00Z"), value: 23.7 },
    // ... 하루치 데이터를 하나의 도큐먼트에 저장
  ],
  count: 288,
  avg: 24.1
}</code></p>
<p><strong>다형성 패턴 (Polymorphic Pattern)</strong>: 기본적으로 유사하지만 세부 구조가 조금씩 다른 데이터들을 같은 컬렉션에 보관할 수 있게 해주는 패턴이다. <code>type</code> 필드로 각 도큐먼트의 종류를 구분한다.</p>
<p><code>javascript
// products 컬렉션
{ type: "book", title: "MongoDB 가이드", author: "홍길동", pages: 500 }
{ type: "electronics", title: "무선 마우스", brand: "Logitech", weight: 85 }</code></p>
<hr>
<h2 id="43-mongodb-crud">4.3 MongoDB 설치 및 기본 CRUD</h2>
<h3 id="431-docker">4.3.1 Docker를 통한 설치</h3>
<p>개발할 때는 Docker를 활용하면 MongoDB를 가장 빠르고 깔끔하게 띄울 수 있다. 로컬 시스템에 영향을 주지 않으면서도 필요한 대로 시작하고 종료할 수 있기 때문이다.</p>
<p>```bash</p>
<h1 id="mongodb">MongoDB 최신 버전 실행</h1>
<p>docker run -d \
  --name mongodb \
  -p 27017:27017 \
  -e MONGO_INITDB_ROOT_USERNAME=admin \
  -e MONGO_INITDB_ROOT_PASSWORD=secret1234 \
  -v mongodb_data:/data/db \
  mongo:7</p>
<h1 id="_1">컨테이너 상태 확인</h1>
<p>docker ps</p>
<h1 id="_2">로그 확인</h1>
<p>docker logs mongodb
```</p>
<p><code>docker-compose.yml</code>로 관리하면 더 편리하다.</p>
<p>```yaml
version: "3.8"</p>
<p>services:
  mongodb:
    image: mongo:7
    container_name: mongodb
    ports:
      - "27017:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: secret1234
      MONGO_INITDB_DATABASE: webflux_demo
    volumes:
      - mongodb_data:/data/db</p>
<p>volumes:
  mongodb_data:
```</p>
<p>```bash</p>
<h1 id="_3">실행</h1>
<p>docker compose up -d</p>
<h1 id="_4">종료</h1>
<p>docker compose down
```</p>
<h3 id="432-mongosh">4.3.2 mongosh 사용법</h3>
<p><code>mongosh</code>는 MongoDB의 공식 셸 클라이언트다. Docker 컨테이너 안에서 직접 실행하여 데이터베이스와 상호작용할 수 있다.</p>
<p>```bash</p>
<h1 id="mongosh">mongosh 접속</h1>
<p>docker exec -it mongodb mongosh -u admin -p secret1234</p>
<h1 id="_5">데이터베이스 목록 조회</h1>
<p>show dbs</p>
<h1 id="_6">데이터베이스 선택 (없으면 첫 도큐먼트 삽입 시 자동 생성)</h1>
<p>use webflux_demo</p>
<h1 id="_7">컬렉션 목록 조회</h1>
<p>show collections</p>
<h1 id="_8">현재 데이터베이스 확인</h1>
<p>db.getName()
```</p>
<h3 id="433-insertone-insertmany">4.3.3 insertOne / insertMany</h3>
<p>```javascript
// 단일 도큐먼트 삽입
db.books.insertOne({
  title: "Spring WebFlux 완벽 가이드",
  author: "홍길동",
  price: 35000,
  tags: ["spring", "webflux", "reactive"],
  publishedAt: new Date("2025-03-15")
})</p>
<p>// 다수 도큐먼트 삽입
db.books.insertMany([
  {
    title: "MongoDB 실전 활용",
    author: "김영희",
    price: 32000,
    tags: ["mongodb", "nosql"],
    publishedAt: new Date("2025-01-10")
  },
  {
    title: "리액티브 프로그래밍 입문",
    author: "이철수",
    price: 28000,
    tags: ["reactive", "java"],
    publishedAt: new Date("2024-11-20")
  },
  {
    title: "Kotlin과 WebFlux",
    author: "박민수",
    price: 38000,
    tags: ["kotlin", "webflux", "spring"],
    publishedAt: new Date("2025-06-01")
  }
])
```</p>
<h3 id="434-find-findone">4.3.4 find / findOne</h3>
<p>```javascript
// 전체 조회
db.books.find()</p>
<p>// 보기 좋게 출력
db.books.find().pretty()</p>
<p>// 조건 조회: 가격이 30000 이상인 책
db.books.find({ price: { $gte: 30000 } })</p>
<p>// 특정 필드만 조회 (프로젝션)
db.books.find(
  { price: { $gte: 30000 } },
  { title: 1, price: 1, _id: 0 }
)
// 결과:
// { title: "Spring WebFlux 완벽 가이드", price: 35000 }
// { title: "MongoDB 실전 활용", price: 32000 }
// { title: "Kotlin과 WebFlux", price: 38000 }</p>
<p>// 단일 도큐먼트 조회
db.books.findOne({ author: "홍길동" })</p>
<p>// 배열 필드 조건: tags에 "webflux"가 포함된 책
db.books.find({ tags: "webflux" })</p>
<p>// 논리 연산자 조합
db.books.find({
  $or: [
    { price: { $lt: 30000 } },
    { author: "홍길동" }
  ]
})</p>
<p>// 정렬, 스킵, 제한
db.books.find().sort({ price: -1 }).skip(0).limit(2)
```</p>
<h3 id="435-update">4.3.5 update</h3>
<p>```javascript
// 단일 도큐먼트 수정
db.books.updateOne(
  { title: "MongoDB 실전 활용" },
  { $set: { price: 34000, updatedAt: new Date() } }
)</p>
<p>// 다수 도큐먼트 수정: 모든 책의 가격을 10% 인상
db.books.updateMany(
  {},
  { $mul: { price: 1.1 } }
)</p>
<p>// 배열에 요소 추가
db.books.updateOne(
  { title: "Spring WebFlux 완벽 가이드" },
  { $push: { tags: "java" } }
)</p>
<p>// 필드 제거
db.books.updateOne(
  { title: "Spring WebFlux 완벽 가이드" },
  { $unset: { updatedAt: "" } }
)</p>
<p>// upsert: 있으면 수정, 없으면 삽입
db.books.updateOne(
  { title: "새로운 책" },
  { $set: { author: "신규 저자", price: 25000 } },
  { upsert: true }
)
```</p>
<p>주요 업데이트 연산자 정리:</p>
<table>
<thead>
<tr>
<th>연산자</th>
<th>설명</th>
<th>예시</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$set</code></td>
<td>필드 값 설정</td>
<td><code>{ $set: { price: 30000 } }</code></td>
</tr>
<tr>
<td><code>$unset</code></td>
<td>필드 제거</td>
<td><code>{ $unset: { field: "" } }</code></td>
</tr>
<tr>
<td><code>$inc</code></td>
<td>숫자 증감</td>
<td><code>{ $inc: { stock: -1 } }</code></td>
</tr>
<tr>
<td><code>$mul</code></td>
<td>숫자 곱셈</td>
<td><code>{ $mul: { price: 1.1 } }</code></td>
</tr>
<tr>
<td><code>$push</code></td>
<td>배열에 요소 추가</td>
<td><code>{ $push: { tags: "new" } }</code></td>
</tr>
<tr>
<td><code>$pull</code></td>
<td>배열에서 요소 제거</td>
<td><code>{ $pull: { tags: "old" } }</code></td>
</tr>
<tr>
<td><code>$addToSet</code></td>
<td>배열에 중복 없이 추가</td>
<td><code>{ $addToSet: { tags: "new" } }</code></td>
</tr>
</tbody>
</table>
<h3 id="436-delete">4.3.6 delete</h3>
<p>```javascript
// 단일 도큐먼트 삭제
db.books.deleteOne({ title: "새로운 책" })</p>
<p>// 조건에 맞는 다수 도큐먼트 삭제
db.books.deleteMany({ price: { $lt: 30000 } })</p>
<p>// 컬렉션의 모든 도큐먼트 삭제
db.books.deleteMany({})</p>
<p>// 컬렉션 자체 삭제
db.books.drop()
```</p>
<h3 id="437-mongodb-compass">4.3.7 MongoDB Compass</h3>
<p>MongoDB Compass는 공식 GUI 클라이언트로, mongosh의 명령어 방식이 불편하다면 시각적으로 데이터를 다루는 것을 선호하는 개발자들에게 훌륭한 도구가 된다. 주요 기능을 살펴보자.</p>
<ul>
<li><strong>연결</strong>: <code>mongodb://admin:secret1234@localhost:27017</code> 형식의 URI로 접속</li>
<li><strong>도큐먼트 탐색</strong>: 시각적으로 데이터를 조회, 편집, 삭제</li>
<li><strong>쿼리 작성</strong>: 필터, 프로젝션, 정렬을 GUI에서 구성</li>
<li><strong>Aggregation Pipeline 빌더</strong>: 파이프라인 스테이지를 시각적으로 조합</li>
<li><strong>인덱스 관리</strong>: 인덱스 생성, 삭제, 성능 분석</li>
<li><strong>스키마 분석</strong>: 컬렉션 내 도큐먼트 구조를 시각적으로 파악</li>
</ul>
<blockquote>
<p><strong>Tip</strong>: 개발 단계에서 복잡한 쿼리를 작성할 때 Compass의 Aggregation Pipeline 빌더로 먼저 검증한 뒤, 코드로 옮기는 방법을 추천한다.</p>
</blockquote>
<hr>
<h2 id="44">4.4 인덱싱과 쿼리 최적화 기초</h2>
<h3 id="441">4.4.1 인덱스 종류</h3>
<p>작은 도큐먼트로 테스트할 때는 문제가 없지만, 데이터가 커지는 순간 성능이 급격히 떨어지는 경험을 할 수 있다. 인덱스가 없으면 MongoDB가 컬렉션 전체를 스캔(COLLSCAN)해야 하기 때문이다. 반대로 적절한 인덱스를 미리 준비하면, 쿼리 성능을 크게 향상시킬 수 있다.</p>
<p><strong>단일 필드 인덱스</strong></p>
<p>```javascript
// author 필드에 오름차순 인덱스 생성
db.books.createIndex({ author: 1 })</p>
<p>// price 필드에 내림차순 인덱스 생성
db.books.createIndex({ price: -1 })
```</p>
<p><strong>복합 인덱스 (Compound Index)</strong></p>
<p>여러 필드를 함께 인덱싱하는 방식인데, 여기서 필드의 순서가 굉장히 중요하다는 점을 반드시 기억해야 한다. <strong>ESR 규칙</strong>(Equality, Sort, Range)을 따르면 효율적인 복합 인덱스를 설계할 수 있다—동등 조건 필드를 앞에, 정렬 필드를 중간에, 범위 조건 필드를 뒤에 배치하는 식이다.</p>
<p>```javascript
// author(동등) + publishedAt(정렬/범위)에 복합 인덱스
db.books.createIndex({ author: 1, publishedAt: -1 })</p>
<p>// 활용 쿼리: 특정 저자의 책을 최신순으로 조회
db.books.find({ author: "홍길동" }).sort({ publishedAt: -1 })
```</p>
<p><strong>멀티키 인덱스 (Multikey Index)</strong></p>
<p>배열 필드에 인덱스를 만들면, MongoDB가 자동으로 멀티키 인덱스를 생성한다. 배열의 각 요소 하나하나에 대해 인덱스 항목이 만들어지는 것이다.</p>
<p>```javascript
// tags 배열 필드에 인덱스
db.books.createIndex({ tags: 1 })</p>
<p>// 활용: tags에 "webflux"가 포함된 도큐먼트 조회
db.books.find({ tags: "webflux" })
```</p>
<p><strong>텍스트 인덱스 (Text Index)</strong></p>
<p>사용자가 입력한 문자열로 문서를 검색하고 싶을 때 필요한 것이 전문 검색(Full-Text Search)이고, 이를 지원하는 인덱스다.</p>
<p>```javascript
// title과 author에 텍스트 인덱스 생성
db.books.createIndex({ title: "text", author: "text" })</p>
<p>// 텍스트 검색
db.books.find({ $text: { $search: "WebFlux 가이드" } })</p>
<p>// 관련도 점수와 함께 조회
db.books.find(
  { $text: { $search: "WebFlux 가이드" } },
  { score: { $meta: "textScore" } }
).sort({ score: { $meta: "textScore" } })
```</p>
<p><strong>고유 인덱스 (Unique Index)</strong></p>
<p><code>javascript
// email 필드에 고유 인덱스 생성
db.users.createIndex({ email: 1 }, { unique: true })</code></p>
<p><strong>TTL 인덱스</strong></p>
<p>지정한 시간이 지나면 도큐먼트를 백그라운드에서 자동으로 삭제해주는 기능이다. 세션 정보나 로그 같이 일정 기간이 지나면 더 이상 필요 없는 데이터를 관리할 때 매우 유용하다.</p>
<p><code>javascript
// createdAt 기준으로 24시간(86400초) 후 자동 삭제
db.sessions.createIndex({ createdAt: 1 }, { expireAfterSeconds: 86400 })</code></p>
<h3 id="442">4.4.2 인덱스 생성과 관리</h3>
<p>```javascript
// 현재 컬렉션의 모든 인덱스 조회
db.books.getIndexes()</p>
<p>// 인덱스 삭제
db.books.dropIndex("author_1")</p>
<p>// 모든 인덱스 삭제 (_id 인덱스 제외)
db.books.dropIndexes()</p>
<p>// 인덱스 크기 확인
db.books.stats().indexSizes
```</p>
<blockquote>
<p><strong>주의</strong>: 인덱스는 읽기 성능을 향상시키지만 쓰기 시 인덱스 갱신 비용이 발생한다. 불필요한 인덱스는 오히려 성능을 저하시킨다. 실제 쿼리 패턴을 분석하여 필요한 인덱스만 생성하자.</p>
</blockquote>
<h3 id="443-explain">4.4.3 explain()으로 쿼리 실행 계획 분석</h3>
<p>우리가 작성한 쿼리가 실제로 어떻게 동작하고 있는지 궁금한 적이 있을까? <code>explain()</code> 메서드를 사용하면 쿼리의 실행 계획을 상세히 볼 수 있다.</p>
<p><code>javascript
// 실행 계획 확인
db.books.find({ author: "홍길동" }).explain("executionStats")</code></p>
<p>주요 확인 항목:</p>
<p><code>javascript
{
  "executionStats": {
    "executionSuccess": true,
    "nReturned": 1,              // 반환된 도큐먼트 수
    "executionTimeMillis": 0,     // 실행 시간 (ms)
    "totalKeysExamined": 1,       // 검사한 인덱스 키 수
    "totalDocsExamined": 1,       // 검사한 도큐먼트 수
    "executionStages": {
      "stage": "FETCH",           // 실행 스테이지
      "inputStage": {
        "stage": "IXSCAN",        // 인덱스 스캔 사용
        "indexName": "author_1"
      }
    }
  }
}</code></p>
<p>핵심 지표 해석:</p>
<table>
<thead>
<tr>
<th>지표</th>
<th>좋은 상태</th>
<th>나쁜 상태</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>stage</code></td>
<td><code>IXSCAN</code> (인덱스 스캔)</td>
<td><code>COLLSCAN</code> (컬렉션 풀 스캔)</td>
</tr>
<tr>
<td><code>totalDocsExamined</code> / <code>nReturned</code></td>
<td>비율이 1에 가까움</td>
<td>비율이 매우 큼 (불필요한 스캔)</td>
</tr>
<tr>
<td><code>executionTimeMillis</code></td>
<td>짧음</td>
<td>길면 최적화 필요</td>
</tr>
</tbody>
</table>
<p><strong>COLLSCAN이 나타나는 것을 보면</strong>, 그 쿼리 조건에 맞는 인덱스를 만들어야 한다는 신호다.</p>
<p>```javascript
// 인덱스 없이 조회 (COLLSCAN)
db.books.find({ price: { $gte: 30000 } }).explain("executionStats")
// =&gt; stage: "COLLSCAN", totalDocsExamined: 전체 도큐먼트 수</p>
<p>// 인덱스 생성 후 조회 (IXSCAN)
db.books.createIndex({ price: 1 })
db.books.find({ price: { $gte: 30000 } }).explain("executionStats")
// =&gt; stage: "IXSCAN", totalDocsExamined ≈ nReturned
```</p>
<hr>
<h2 id="45-mongodb">4.5 MongoDB와 리액티브 드라이버</h2>
<h3 id="451-mongodb-reactive-streams-driver">4.5.1 MongoDB Reactive Streams Driver</h3>
<p>이제 MongoDB를 리액티브 방식으로 다루는 방법을 살펴보자. MongoDB는 공식적으로 <strong>Reactive Streams</strong> 사양을 구현한 Java 드라이버를 제공하는데, 이것이 논블로킹 I/O를 기반으로 동작하며 Netty를 내부 네트워크 계층으로 쓴다.</p>
<p>```xml</p>
<!-- pom.xml -->
<p><dependency>
    <groupId>org.mongodb</groupId>
    <artifactId>mongodb-driver-reactivestreams</artifactId>
    <version>5.3.0</version>
</dependency>
```</p>
<p>Reactive Streams Driver를 직접 사용하는 예시:</p>
<p>```java
import com.mongodb.reactivestreams.client.MongoClients;
import com.mongodb.reactivestreams.client.MongoClient;
import com.mongodb.reactivestreams.client.MongoDatabase;
import com.mongodb.reactivestreams.client.MongoCollection;
import org.bson.Document;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;</p>
<p>// 클라이언트 생성
MongoClient mongoClient = MongoClients.create("mongodb://admin:secret1234@localhost:27017");
MongoDatabase database = mongoClient.getDatabase("webflux_demo");
MongoCollection<Document> collection = database.getCollection("books");</p>
<p>// 도큐먼트 삽입 (Publisher를 Reactor의 Mono로 래핑)
Document book = new Document("title", "Reactive MongoDB")
    .append("author", "Jane Doe")
    .append("price", 42000);</p>
<p>Mono.from(collection.insertOne(book))
    .subscribe(result -&gt;
        System.out.println("Inserted ID: " + result.getInsertedId()));</p>
<p>// 도큐먼트 조회 (Publisher를 Reactor의 Flux로 래핑)
Flux.from(collection.find())
    .doOnNext(doc -&gt; System.out.println(doc.toJson()))
    .subscribe();
```</p>
<h3 id="452-vs">4.5.2 동기 vs 리액티브 드라이버 비교</h3>
<table>
<thead>
<tr>
<th>구분</th>
<th>동기 드라이버</th>
<th>리액티브 드라이버</th>
</tr>
</thead>
<tbody>
<tr>
<td>아티팩트</td>
<td><code>mongodb-driver-sync</code></td>
<td><code>mongodb-driver-reactivestreams</code></td>
</tr>
<tr>
<td>I/O 모델</td>
<td>블로킹</td>
<td>논블로킹</td>
</tr>
<tr>
<td>반환 타입</td>
<td><code>List&lt;T&gt;</code>, <code>T</code></td>
<td><code>Publisher&lt;T&gt;</code></td>
</tr>
<tr>
<td>스레드 모델</td>
<td>요청당 스레드 점유</td>
<td>이벤트 루프 기반, 스레드 공유</td>
</tr>
<tr>
<td>배압 지원</td>
<td>없음</td>
<td>Reactive Streams 배압 지원</td>
</tr>
<tr>
<td>적합한 프레임워크</td>
<td>Spring MVC</td>
<td>Spring WebFlux</td>
</tr>
</tbody>
</table>
<p>동기 드라이버와 리액티브 드라이버의 근본적인 차이를 경험해보자. 동기 드라이버에서 <code>find()</code>를 호출하면, 결과가 모두 돌아올 때까지 해당 스레드가 계속 기다리고 있다. 반면 리액티브 드라이버는 <code>Publisher</code>를 즉시 반환하고, 구독이 이루어지면 데이터가 준비되는 대로 비동기로 스트리밍하는 방식이다.</p>
<p>```java
// 동기 드라이버 — 스레드가 결과 반환까지 대기
List<Document> books = syncCollection.find().into(new ArrayList&lt;&gt;());</p>
<p>// 리액티브 드라이버 — 논블로킹, 데이터가 준비되면 콜백
Flux.from(reactiveCollection.find())
    .collectList()
    .subscribe(books -&gt; { /<em> 결과 처리 </em>/ });
```</p>
<h3 id="453-spring-data-mongodb-reactive">4.5.3 Spring Data MongoDB Reactive 모듈 소개</h3>
<p>실제 개발 현장에서 Reactive Streams Driver를 직접 다루는 경우는 거의 없다. 그 대신 <strong>Spring Data MongoDB Reactive</strong> 모듈이 드라이버를 깔끔하게 추상화하여, 개발자가 훨씬 편하게 작업할 수 있는 프로그래밍 모델을 제공한다는 점이 중요하다.</p>
<p><strong>의존성 추가</strong></p>
<p>```xml</p>
<!-- pom.xml -->
<p><dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-mongodb-reactive</artifactId>
</dependency>
```</p>
<p><code>groovy
// build.gradle (Kotlin DSL)
implementation("org.springframework.boot:spring-boot-starter-data-mongodb-reactive")</code></p>
<p><strong>도메인 모델 정의</strong></p>
<p>```java
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;</p>
<p>@Document(collection = "books")   // MongoDB 컬렉션 매핑
public class Book {</p>
<pre><code>@Id
private String id;            // MongoDB의 _id에 매핑
private String title;
private String author;
private BigDecimal price;
private List&lt;String&gt; tags;
private LocalDateTime publishedAt;

// 생성자, getter, setter 생략
</code></pre>
<p>}
```</p>
<p><strong>ReactiveMongoRepository 정의</strong></p>
<p>```java
import org.springframework.data.mongodb.repository.ReactiveMongoRepository;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;</p>
<p>public interface BookRepository extends ReactiveMongoRepository<Book, String> {</p>
<pre><code>// 메서드 이름 기반 쿼리 자동 생성
Flux&lt;Book&gt; findByAuthor(String author);

Flux&lt;Book&gt; findByPriceGreaterThanEqual(BigDecimal price);

Flux&lt;Book&gt; findByTagsContaining(String tag);

Mono&lt;Book&gt; findByTitle(String title);
</code></pre>
<p>}
```</p>
<p><strong>서비스 및 컨트롤러 예시</strong></p>
<p>```java
@Service
@RequiredArgsConstructor
public class BookService {</p>
<pre><code>private final BookRepository bookRepository;

public Flux&lt;Book&gt; findAll() {
    return bookRepository.findAll();
}

public Mono&lt;Book&gt; findById(String id) {
    return bookRepository.findById(id)
        .switchIfEmpty(Mono.error(
            new RuntimeException("Book not found: " + id)));
}

public Mono&lt;Book&gt; create(Book book) {
    return bookRepository.save(book);
}

public Mono&lt;Void&gt; delete(String id) {
    return bookRepository.deleteById(id);
}
</code></pre>
<p>}</p>
<p>@RestController
@RequestMapping("/api/books")
@RequiredArgsConstructor
public class BookController {</p>
<pre><code>private final BookService bookService;

@GetMapping
public Flux&lt;Book&gt; getAll() {
    return bookService.findAll();
}

@GetMapping("/{id}")
public Mono&lt;Book&gt; getById(@PathVariable String id) {
    return bookService.findById(id);
}

@PostMapping
@ResponseStatus(HttpStatus.CREATED)
public Mono&lt;Book&gt; create(@RequestBody Book book) {
    return bookService.create(book);
}

@DeleteMapping("/{id}")
@ResponseStatus(HttpStatus.NO_CONTENT)
public Mono&lt;Void&gt; delete(@PathVariable String id) {
    return bookService.delete(id);
}
</code></pre>
<p>}
```</p>
<p>위 코드에서 눈여겨봐야 할 부분이 있다. <strong>반환 타입이 모두 <code>Mono</code> 또는 <code>Flux</code>라는 것</strong>이 바로 그것인데, 이게 리액티브 스택의 핵심이다. 컨트롤러에서 <code>Mono</code>나 <code>Flux</code>를 반환하면 WebFlux가 구독을 담당하고, 데이터가 준비되는 순간순간 논블로킹 방식으로 HTTP 응답을 클라이언트에게 흘려보낸다. 필자의 경험상 이런 방식이 동기 방식보다 고속 처리 환경에서 훨씬 효율적이라는 것을 여러 번 확인했다—데이터베이스 쿼리부터 HTTP 응답까지, 전체 흐름에서 스레드 하나가 오래 묶여있지 않기 때문이다.</p>
<p><strong>application.yml 설정</strong></p>
<p><code>yaml
spring:
  data:
    mongodb:
      uri: mongodb://admin:secret1234@localhost:27017/webflux_demo?authSource=admin</code></p>
<blockquote>
<p><strong>Spring Data MongoDB Reactive의 핵심 구성 요소</strong>들은 Chapter 5에서 프로젝트를 직접 세팅하면서 자세히 학습하고, Chapter 6에서 실제 REST API를 만들며 손으로 익히게 된다. 더 나아가 Chapter 8에서는 <code>ReactiveMongoTemplate</code>, Aggregation, Change Streams처럼 더 심화된 기능들을 깊이 있게 다룬다.</p>
</blockquote>
<hr>
<h2 id="4">4장 정리</h2>
<p>지금까지 MongoDB와 리액티브 드라이버의 전반적인 개념을 살펴봤다. 다음 표는 각 주제별로 핵심을 간추린 것이니, 필요할 때마다 참고하자.</p>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 요약</th>
</tr>
</thead>
<tbody>
<tr>
<td>NoSQL vs RDBMS</td>
<td>MongoDB는 유연한 스키마, 수평 확장, 높은 가용성을 제공하는 도큐먼트 DB</td>
</tr>
<tr>
<td>CAP 정리</td>
<td>MongoDB는 CP 시스템. <code>writeConcern</code>, <code>readPreference</code>로 균형 조절 가능</td>
</tr>
<tr>
<td>도큐먼트 모델</td>
<td>BSON 형식, 내장 vs 참조 설계 결정이 핵심</td>
</tr>
<tr>
<td>기본 CRUD</td>
<td><code>insertOne/Many</code>, <code>find</code>, <code>updateOne/Many</code>, <code>deleteOne/Many</code></td>
</tr>
<tr>
<td>인덱스</td>
<td>단일, 복합, 멀티키, 텍스트, TTL. <code>explain()</code>으로 실행 계획 분석</td>
</tr>
<tr>
<td>리액티브 드라이버</td>
<td>논블로킹 I/O, <code>Publisher&lt;T&gt;</code> 반환, Spring Data MongoDB Reactive로 추상화</td>
</tr>
</tbody>
</table>
<p>다음 Chapter 5에서는 이론을 실제로 옮겨놓는 작업을 시작한다. Spring Boot + WebFlux + MongoDB Reactive 프로젝트를 하나하나 세팅하면서, 지금까지 배운 개념들이 어떻게 실무에서 연결되는지 경험하게 될 것이다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>