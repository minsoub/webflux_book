<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 4. MongoDB 소개 | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="ch03.html">&larr; Chapter 3. Project Reactor 핵심</a>
    <a href="../index.html">목차</a>
    <a href="ch05.html">Chapter 5. 개발 환경 구성 &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-4-mongodb">Chapter 4. MongoDB 소개</h1>
<p>앞선 장에서 리액티브 프로그래밍의 개념과 Project Reactor의 핵심을 다뤘다. 이번 장에서는 리액티브 스택과 궁합이 뛰어난 데이터베이스인 MongoDB를 살펴본다. MongoDB가 왜 리액티브 애플리케이션에 적합한지, 도큐먼트 모델의 특성은 무엇인지, 그리고 실제 설치부터 CRUD 조작까지 실습한다.</p>
<hr>
<h2 id="41-nosql-mongodb">4.1 NoSQL과 MongoDB의 특징</h2>
<h3 id="411-rdbms-vs-nosql">4.1.1 RDBMS vs NoSQL 비교</h3>
<p>전통적인 관계형 데이터베이스(RDBMS)는 정규화된 테이블, SQL 쿼리, ACID 트랜잭션을 기반으로 한다. 반면 NoSQL은 특정 사용 사례에 최적화된 다양한 데이터 모델을 제공한다.</p>
<table>
<thead>
<tr>
<th>구분</th>
<th>RDBMS</th>
<th>NoSQL (MongoDB)</th>
</tr>
</thead>
<tbody>
<tr>
<td>데이터 모델</td>
<td>테이블, 행, 열</td>
<td>도큐먼트 (JSON/BSON)</td>
</tr>
<tr>
<td>스키마</td>
<td>고정 스키마 (DDL 필수)</td>
<td>유연한 스키마 (스키마리스)</td>
</tr>
<tr>
<td>확장 방식</td>
<td>주로 수직 확장 (Scale-up)</td>
<td>수평 확장 (Scale-out, 샤딩)</td>
</tr>
<tr>
<td>트랜잭션</td>
<td>강력한 ACID 지원</td>
<td>단일 도큐먼트 ACID, 멀티 도큐먼트 트랜잭션 지원</td>
</tr>
<tr>
<td>조인</td>
<td>JOIN 연산 기본 지원</td>
<td>일반적으로 비정규화, <code>$lookup</code>으로 제한적 지원</td>
</tr>
<tr>
<td>쿼리 언어</td>
<td>SQL</td>
<td>MQL (MongoDB Query Language)</td>
</tr>
<tr>
<td>적합한 사용 사례</td>
<td>복잡한 관계, 정합성 중시</td>
<td>빠른 반복 개발, 대규모 읽기/쓰기, 유연한 구조</td>
</tr>
</tbody>
</table>
<h3 id="412-mongodb">4.1.2 MongoDB 핵심 특징</h3>
<p><strong>스키마 유연성</strong></p>
<p>MongoDB는 같은 컬렉션 안에 서로 다른 구조의 도큐먼트를 저장할 수 있다. 애플리케이션 요구사항이 빠르게 변화하는 환경에서 스키마 마이그레이션 부담을 크게 줄여준다.</p>
<pre class="highlight"><code class="language-javascript">// 같은 컬렉션에 서로 다른 구조의 도큐먼트가 공존 가능
{ name: "Alice", email: "alice@example.com" }
{ name: "Bob", email: "bob@example.com", phone: "010-1234-5678", address: { city: "Seoul" } }</code></pre>
<p><strong>수평 확장 (Sharding)</strong></p>
<p>데이터가 증가하면 샤드를 추가하여 여러 서버에 데이터를 분산 저장한다. 애플리케이션 코드 변경 없이 처리 용량을 늘릴 수 있다.</p>
<p><strong>높은 가용성 (Replica Set)</strong></p>
<p>복제 세트(Replica Set)를 통해 데이터의 복제본을 여러 노드에 유지한다. 프라이머리 노드가 장애를 겪으면 자동으로 세컨더리 노드가 프라이머리로 승격된다.</p>
<h3 id="413-cap-mongodb">4.1.3 CAP 정리에서의 MongoDB 위치</h3>
<p>분산 시스템에서는 일관성(Consistency), 가용성(Availability), 분단 내성(Partition Tolerance) 세 가지를 동시에 모두 만족할 수 없다는 것이 CAP 정리다.</p>
<ul>
<li><strong>C (Consistency)</strong>: 모든 노드가 같은 시점에 같은 데이터를 반환한다.</li>
<li><strong>A (Availability)</strong>: 모든 요청에 대해 응답을 반환한다.</li>
<li><strong>P (Partition Tolerance)</strong>: 네트워크 분단이 발생해도 시스템이 동작한다.</li>
</ul>
<p>MongoDB는 기본적으로 <strong>CP 시스템</strong>으로 분류된다. 프라이머리 노드에 쓰기를 집중하여 일관성을 보장하고, 네트워크 분단 시 가용성보다 일관성을 우선한다. 단, <code>readPreference</code>와 <code>writeConcern</code> 설정을 조정하면 가용성과 일관성 사이의 균형을 유연하게 조절할 수 있다.</p>
<pre class="highlight"><code class="language-javascript">// writeConcern 설정 예시
db.orders.insertOne(
  { item: "laptop", qty: 1 },
  { writeConcern: { w: "majority", wtimeout: 5000 } }
)</code></pre>
<ul>
<li><code>w: "majority"</code> — 과반수 노드에 쓰기가 확인되어야 성공으로 간주</li>
<li><code>w: 1</code> — 프라이머리에만 쓰기 확인 (기본값, 더 빠르지만 덜 안전)</li>
</ul>
<hr>
<h2 id="42">4.2 도큐먼트 모델과 컬렉션</h2>
<h3 id="421-bson">4.2.1 BSON 형식과 도큐먼트 구조</h3>
<p>MongoDB는 내부적으로 <strong>BSON</strong>(Binary JSON) 형식으로 데이터를 저장한다. BSON은 JSON의 확장으로, JSON이 지원하지 않는 추가 데이터 타입을 포함한다.</p>
<table>
<thead>
<tr>
<th>BSON 타입</th>
<th>설명</th>
<th>예시</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>UTF-8 문자열</td>
<td><code>"Hello"</code></td>
</tr>
<tr>
<td>Int32 / Int64</td>
<td>정수형</td>
<td><code>42</code>, <code>NumberLong(123456789)</code></td>
</tr>
<tr>
<td>Double</td>
<td>부동소수점</td>
<td><code>3.14</code></td>
</tr>
<tr>
<td>Boolean</td>
<td>논리값</td>
<td><code>true</code>, <code>false</code></td>
</tr>
<tr>
<td>Date</td>
<td>날짜/시간</td>
<td><code>ISODate("2025-01-01T00:00:00Z")</code></td>
</tr>
<tr>
<td>ObjectId</td>
<td>12바이트 고유 식별자</td>
<td><code>ObjectId("507f1f77bcf86cd799439011")</code></td>
</tr>
<tr>
<td>Array</td>
<td>배열</td>
<td><code>[1, 2, 3]</code></td>
</tr>
<tr>
<td>Object</td>
<td>내장 도큐먼트</td>
<td><code>{ city: "Seoul" }</code></td>
</tr>
<tr>
<td>Decimal128</td>
<td>고정밀 소수점</td>
<td><code>NumberDecimal("19.99")</code></td>
</tr>
<tr>
<td>Binary</td>
<td>바이너리 데이터</td>
<td>—</td>
</tr>
</tbody>
</table>
<p>도큐먼트의 기본 구조는 다음과 같다.</p>
<pre class="highlight"><code class="language-javascript">{
  _id: ObjectId("65a1b2c3d4e5f6a7b8c9d0e1"),  // 자동 생성되는 고유 식별자
  title: "Spring WebFlux 입문",
  author: {                                     // 내장 도큐먼트
    name: "홍길동",
    email: "hong@example.com"
  },
  tags: ["spring", "webflux", "reactive"],      // 배열
  price: NumberDecimal("35000"),
  publishedAt: ISODate("2025-03-15T09:00:00Z"),
  inStock: true
}</code></pre>
<p><code>_id</code> 필드는 컬렉션 내에서 도큐먼트를 고유하게 식별하는 기본 키다. 명시적으로 지정하지 않으면 MongoDB가 <code>ObjectId</code>를 자동으로 생성한다.</p>
<h3 id="422">4.2.2 컬렉션 개념</h3>
<p>컬렉션(Collection)은 RDBMS의 테이블에 대응하는 개념이다. 그러나 테이블과 달리 컬렉션에 저장되는 도큐먼트들이 반드시 같은 스키마를 가질 필요는 없다.</p>
<pre class="highlight"><code class="language-javascript">// 컬렉션 생성 (명시적)
db.createCollection("books")

// 또는 첫 번째 도큐먼트 삽입 시 자동 생성
db.books.insertOne({ title: "MongoDB in Action" })</code></pre>
<p>필요한 경우 <strong>Schema Validation</strong>을 적용하여 도큐먼트 구조를 강제할 수 있다.</p>
<pre class="highlight"><code class="language-javascript">db.createCollection("books", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["title", "author", "price"],
      properties: {
        title:  { bsonType: "string", description: "제목은 필수 문자열" },
        author: { bsonType: "string", description: "저자는 필수 문자열" },
        price:  { bsonType: "number", minimum: 0, description: "가격은 0 이상" }
      }
    }
  }
})</code></pre>
<h3 id="423-embedded-vs-reference">4.2.3 내장 도큐먼트(Embedded) vs 참조(Reference)</h3>
<p>MongoDB 스키마 설계에서 가장 중요한 결정 중 하나는 <strong>데이터를 내장할 것인가, 참조할 것인가</strong>이다.</p>
<p><strong>내장 도큐먼트 방식</strong></p>
<p>관련 데이터를 하나의 도큐먼트 안에 중첩하여 저장한다.</p>
<pre class="highlight"><code class="language-javascript">// 주문 도큐먼트에 배송 주소를 내장
{
  _id: ObjectId("..."),
  orderNumber: "ORD-2025-001",
  customer: "김철수",
  items: [
    { productName: "키보드", quantity: 1, price: 89000 },
    { productName: "마우스", quantity: 2, price: 45000 }
  ],
  shippingAddress: {
    zipCode: "06234",
    city: "서울",
    detail: "강남구 테헤란로 123"
  }
}</code></pre>
<p><strong>참조 방식</strong></p>
<p>별도의 컬렉션에 데이터를 저장하고 <code>_id</code>로 연결한다.</p>
<pre class="highlight"><code class="language-javascript">// users 컬렉션
{ _id: ObjectId("user001"), name: "김철수", email: "kim@example.com" }

// orders 컬렉션 - userId로 참조
{
  _id: ObjectId("order001"),
  userId: ObjectId("user001"),   // 참조
  orderNumber: "ORD-2025-001",
  items: [...]
}</code></pre>
<p><strong>선택 기준</strong></p>
<table>
<thead>
<tr>
<th>기준</th>
<th>내장 (Embedded)</th>
<th>참조 (Reference)</th>
</tr>
</thead>
<tbody>
<tr>
<td>관계 유형</td>
<td>1:1, 1:N (소량)</td>
<td>1:N (대량), N:M</td>
</tr>
<tr>
<td>읽기 패턴</td>
<td>함께 조회하는 경우</td>
<td>독립적으로 조회하는 경우</td>
</tr>
<tr>
<td>데이터 크기</td>
<td>내장 데이터가 작을 때</td>
<td>내장 시 도큐먼트가 16MB 제한에 근접할 때</td>
</tr>
<tr>
<td>갱신 빈도</td>
<td>드물게 변경</td>
<td>자주 독립적으로 변경</td>
</tr>
</tbody>
</table>
<h3 id="424">4.2.4 스키마 설계 패턴</h3>
<p>MongoDB에서 자주 사용되는 설계 패턴 몇 가지를 소개한다.</p>
<p><strong>버킷 패턴 (Bucket Pattern)</strong>: 시계열 데이터처럼 연속적인 데이터를 일정 단위(시간, 개수)로 묶어 하나의 도큐먼트에 저장한다.</p>
<pre class="highlight"><code class="language-javascript">{
  sensorId: "sensor-001",
  date: ISODate("2025-01-15"),
  readings: [
    { time: ISODate("2025-01-15T00:00:00Z"), value: 23.5 },
    { time: ISODate("2025-01-15T00:05:00Z"), value: 23.7 },
    // ... 하루치 데이터를 하나의 도큐먼트에 저장
  ],
  count: 288,
  avg: 24.1
}</code></pre>
<p><strong>다형성 패턴 (Polymorphic Pattern)</strong>: 유사하지만 구조가 약간 다른 데이터를 같은 컬렉션에 저장한다. <code>type</code> 필드로 구분한다.</p>
<pre class="highlight"><code class="language-javascript">// products 컬렉션
{ type: "book", title: "MongoDB 가이드", author: "홍길동", pages: 500 }
{ type: "electronics", title: "무선 마우스", brand: "Logitech", weight: 85 }</code></pre>
<hr>
<h2 id="43-mongodb-crud">4.3 MongoDB 설치 및 기본 CRUD</h2>
<h3 id="431-docker">4.3.1 Docker를 통한 설치</h3>
<p>개발 환경에서는 Docker를 사용하면 가장 간편하게 MongoDB를 실행할 수 있다.</p>
<pre class="highlight"><code class="language-bash"># MongoDB 최신 버전 실행
docker run -d \
  --name mongodb \
  -p 27017:27017 \
  -e MONGO_INITDB_ROOT_USERNAME=admin \
  -e MONGO_INITDB_ROOT_PASSWORD=secret1234 \
  -v mongodb_data:/data/db \
  mongo:7

# 컨테이너 상태 확인
docker ps

# 로그 확인
docker logs mongodb</code></pre>
<p><code>docker-compose.yml</code>로 관리하면 더 편리하다.</p>
<pre class="highlight"><code class="language-yaml">version: "3.8"

services:
  mongodb:
    image: mongo:7
    container_name: mongodb
    ports:
      - "27017:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: secret1234
      MONGO_INITDB_DATABASE: webflux_demo
    volumes:
      - mongodb_data:/data/db

volumes:
  mongodb_data:</code></pre>
<pre class="highlight"><code class="language-bash"># 실행
docker compose up -d

# 종료
docker compose down</code></pre>
<h3 id="432-mongosh">4.3.2 mongosh 사용법</h3>
<p><code>mongosh</code>는 MongoDB의 공식 셸 클라이언트다. Docker 컨테이너 안에서 바로 실행할 수 있다.</p>
<pre class="highlight"><code class="language-bash"># mongosh 접속
docker exec -it mongodb mongosh -u admin -p secret1234

# 데이터베이스 목록 조회
show dbs

# 데이터베이스 선택 (없으면 첫 도큐먼트 삽입 시 자동 생성)
use webflux_demo

# 컬렉션 목록 조회
show collections

# 현재 데이터베이스 확인
db.getName()</code></pre>
<h3 id="433-insertone-insertmany">4.3.3 insertOne / insertMany</h3>
<pre class="highlight"><code class="language-javascript">// 단일 도큐먼트 삽입
db.books.insertOne({
  title: "Spring WebFlux 완벽 가이드",
  author: "홍길동",
  price: 35000,
  tags: ["spring", "webflux", "reactive"],
  publishedAt: new Date("2025-03-15")
})

// 다수 도큐먼트 삽입
db.books.insertMany([
  {
    title: "MongoDB 실전 활용",
    author: "김영희",
    price: 32000,
    tags: ["mongodb", "nosql"],
    publishedAt: new Date("2025-01-10")
  },
  {
    title: "리액티브 프로그래밍 입문",
    author: "이철수",
    price: 28000,
    tags: ["reactive", "java"],
    publishedAt: new Date("2024-11-20")
  },
  {
    title: "Kotlin과 WebFlux",
    author: "박민수",
    price: 38000,
    tags: ["kotlin", "webflux", "spring"],
    publishedAt: new Date("2025-06-01")
  }
])</code></pre>
<h3 id="434-find-findone">4.3.4 find / findOne</h3>
<pre class="highlight"><code class="language-javascript">// 전체 조회
db.books.find()

// 보기 좋게 출력
db.books.find().pretty()

// 조건 조회: 가격이 30000 이상인 책
db.books.find({ price: { $gte: 30000 } })

// 특정 필드만 조회 (프로젝션)
db.books.find(
  { price: { $gte: 30000 } },
  { title: 1, price: 1, _id: 0 }
)
// 결과:
// { title: "Spring WebFlux 완벽 가이드", price: 35000 }
// { title: "MongoDB 실전 활용", price: 32000 }
// { title: "Kotlin과 WebFlux", price: 38000 }

// 단일 도큐먼트 조회
db.books.findOne({ author: "홍길동" })

// 배열 필드 조건: tags에 "webflux"가 포함된 책
db.books.find({ tags: "webflux" })

// 논리 연산자 조합
db.books.find({
  $or: [
    { price: { $lt: 30000 } },
    { author: "홍길동" }
  ]
})

// 정렬, 스킵, 제한
db.books.find().sort({ price: -1 }).skip(0).limit(2)</code></pre>
<h3 id="435-update">4.3.5 update</h3>
<pre class="highlight"><code class="language-javascript">// 단일 도큐먼트 수정
db.books.updateOne(
  { title: "MongoDB 실전 활용" },
  { $set: { price: 34000, updatedAt: new Date() } }
)

// 다수 도큐먼트 수정: 모든 책의 가격을 10% 인상
db.books.updateMany(
  {},
  { $mul: { price: 1.1 } }
)

// 배열에 요소 추가
db.books.updateOne(
  { title: "Spring WebFlux 완벽 가이드" },
  { $push: { tags: "java" } }
)

// 필드 제거
db.books.updateOne(
  { title: "Spring WebFlux 완벽 가이드" },
  { $unset: { updatedAt: "" } }
)

// upsert: 있으면 수정, 없으면 삽입
db.books.updateOne(
  { title: "새로운 책" },
  { $set: { author: "신규 저자", price: 25000 } },
  { upsert: true }
)</code></pre>
<p>주요 업데이트 연산자 정리:</p>
<table>
<thead>
<tr>
<th>연산자</th>
<th>설명</th>
<th>예시</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$set</code></td>
<td>필드 값 설정</td>
<td><code>{ $set: { price: 30000 } }</code></td>
</tr>
<tr>
<td><code>$unset</code></td>
<td>필드 제거</td>
<td><code>{ $unset: { field: "" } }</code></td>
</tr>
<tr>
<td><code>$inc</code></td>
<td>숫자 증감</td>
<td><code>{ $inc: { stock: -1 } }</code></td>
</tr>
<tr>
<td><code>$mul</code></td>
<td>숫자 곱셈</td>
<td><code>{ $mul: { price: 1.1 } }</code></td>
</tr>
<tr>
<td><code>$push</code></td>
<td>배열에 요소 추가</td>
<td><code>{ $push: { tags: "new" } }</code></td>
</tr>
<tr>
<td><code>$pull</code></td>
<td>배열에서 요소 제거</td>
<td><code>{ $pull: { tags: "old" } }</code></td>
</tr>
<tr>
<td><code>$addToSet</code></td>
<td>배열에 중복 없이 추가</td>
<td><code>{ $addToSet: { tags: "new" } }</code></td>
</tr>
</tbody>
</table>
<h3 id="436-delete">4.3.6 delete</h3>
<pre class="highlight"><code class="language-javascript">// 단일 도큐먼트 삭제
db.books.deleteOne({ title: "새로운 책" })

// 조건에 맞는 다수 도큐먼트 삭제
db.books.deleteMany({ price: { $lt: 30000 } })

// 컬렉션의 모든 도큐먼트 삭제
db.books.deleteMany({})

// 컬렉션 자체 삭제
db.books.drop()</code></pre>
<h3 id="437-mongodb-compass">4.3.7 MongoDB Compass</h3>
<p>MongoDB Compass는 공식 GUI 클라이언트로, 다음과 같은 기능을 제공한다.</p>
<ul>
<li><strong>연결</strong>: <code>mongodb://admin:secret1234@localhost:27017</code> 형식의 URI로 접속</li>
<li><strong>도큐먼트 탐색</strong>: 시각적으로 데이터를 조회, 편집, 삭제</li>
<li><strong>쿼리 작성</strong>: 필터, 프로젝션, 정렬을 GUI에서 구성</li>
<li><strong>Aggregation Pipeline 빌더</strong>: 파이프라인 스테이지를 시각적으로 조합</li>
<li><strong>인덱스 관리</strong>: 인덱스 생성, 삭제, 성능 분석</li>
<li><strong>스키마 분석</strong>: 컬렉션 내 도큐먼트 구조를 시각적으로 파악</li>
</ul>
<blockquote>
<p><strong>Tip</strong>: 개발 단계에서 복잡한 쿼리를 작성할 때 Compass의 Aggregation Pipeline 빌더로 먼저 검증한 뒤, 코드로 옮기는 방법을 추천한다.</p>
</blockquote>
<hr>
<h2 id="44">4.4 인덱싱과 쿼리 최적화 기초</h2>
<h3 id="441">4.4.1 인덱스 종류</h3>
<p>인덱스가 없으면 MongoDB는 컬렉션 전체를 스캔(COLLSCAN)해야 한다. 적절한 인덱스를 생성하면 쿼리 성능을 크게 향상시킬 수 있다.</p>
<p><strong>단일 필드 인덱스</strong></p>
<pre class="highlight"><code class="language-javascript">// author 필드에 오름차순 인덱스 생성
db.books.createIndex({ author: 1 })

// price 필드에 내림차순 인덱스 생성
db.books.createIndex({ price: -1 })</code></pre>
<p><strong>복합 인덱스 (Compound Index)</strong></p>
<p>여러 필드를 조합한 인덱스다. 필드 순서가 중요하다. <strong>ESR 규칙</strong>(Equality, Sort, Range)에 따라 동등 조건 필드를 앞에, 정렬 필드를 중간에, 범위 조건 필드를 뒤에 배치하면 효율적이다.</p>
<pre class="highlight"><code class="language-javascript">// author(동등) + publishedAt(정렬/범위)에 복합 인덱스
db.books.createIndex({ author: 1, publishedAt: -1 })

// 활용 쿼리: 특정 저자의 책을 최신순으로 조회
db.books.find({ author: "홍길동" }).sort({ publishedAt: -1 })</code></pre>
<p><strong>멀티키 인덱스 (Multikey Index)</strong></p>
<p>배열 필드에 인덱스를 생성하면 자동으로 멀티키 인덱스가 된다. 배열의 각 요소에 대해 인덱스 항목이 생성된다.</p>
<pre class="highlight"><code class="language-javascript">// tags 배열 필드에 인덱스
db.books.createIndex({ tags: 1 })

// 활용: tags에 "webflux"가 포함된 도큐먼트 조회
db.books.find({ tags: "webflux" })</code></pre>
<p><strong>텍스트 인덱스 (Text Index)</strong></p>
<p>전문 검색(Full-Text Search)을 위한 인덱스다.</p>
<pre class="highlight"><code class="language-javascript">// title과 author에 텍스트 인덱스 생성
db.books.createIndex({ title: "text", author: "text" })

// 텍스트 검색
db.books.find({ $text: { $search: "WebFlux 가이드" } })

// 관련도 점수와 함께 조회
db.books.find(
  { $text: { $search: "WebFlux 가이드" } },
  { score: { $meta: "textScore" } }
).sort({ score: { $meta: "textScore" } })</code></pre>
<p><strong>고유 인덱스 (Unique Index)</strong></p>
<pre class="highlight"><code class="language-javascript">// email 필드에 고유 인덱스 생성
db.users.createIndex({ email: 1 }, { unique: true })</code></pre>
<p><strong>TTL 인덱스</strong></p>
<p>일정 시간이 지난 도큐먼트를 자동으로 삭제한다. 세션, 로그 등 만료가 필요한 데이터에 유용하다.</p>
<pre class="highlight"><code class="language-javascript">// createdAt 기준으로 24시간(86400초) 후 자동 삭제
db.sessions.createIndex({ createdAt: 1 }, { expireAfterSeconds: 86400 })</code></pre>
<h3 id="442">4.4.2 인덱스 생성과 관리</h3>
<pre class="highlight"><code class="language-javascript">// 현재 컬렉션의 모든 인덱스 조회
db.books.getIndexes()

// 인덱스 삭제
db.books.dropIndex("author_1")

// 모든 인덱스 삭제 (_id 인덱스 제외)
db.books.dropIndexes()

// 인덱스 크기 확인
db.books.stats().indexSizes</code></pre>
<blockquote>
<p><strong>주의</strong>: 인덱스는 읽기 성능을 향상시키지만 쓰기 시 인덱스 갱신 비용이 발생한다. 불필요한 인덱스는 오히려 성능을 저하시킨다. 실제 쿼리 패턴을 분석하여 필요한 인덱스만 생성하자.</p>
</blockquote>
<h3 id="443-explain">4.4.3 explain()으로 쿼리 실행 계획 분석</h3>
<p><code>explain()</code> 메서드를 사용하면 쿼리가 어떻게 실행되는지 확인할 수 있다.</p>
<pre class="highlight"><code class="language-javascript">// 실행 계획 확인
db.books.find({ author: "홍길동" }).explain("executionStats")</code></pre>
<p>주요 확인 항목:</p>
<pre class="highlight"><code class="language-javascript">{
  "executionStats": {
    "executionSuccess": true,
    "nReturned": 1,              // 반환된 도큐먼트 수
    "executionTimeMillis": 0,     // 실행 시간 (ms)
    "totalKeysExamined": 1,       // 검사한 인덱스 키 수
    "totalDocsExamined": 1,       // 검사한 도큐먼트 수
    "executionStages": {
      "stage": "FETCH",           // 실행 스테이지
      "inputStage": {
        "stage": "IXSCAN",        // 인덱스 스캔 사용
        "indexName": "author_1"
      }
    }
  }
}</code></pre>
<p>핵심 지표 해석:</p>
<table>
<thead>
<tr>
<th>지표</th>
<th>좋은 상태</th>
<th>나쁜 상태</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>stage</code></td>
<td><code>IXSCAN</code> (인덱스 스캔)</td>
<td><code>COLLSCAN</code> (컬렉션 풀 스캔)</td>
</tr>
<tr>
<td><code>totalDocsExamined</code> / <code>nReturned</code></td>
<td>비율이 1에 가까움</td>
<td>비율이 매우 큼 (불필요한 스캔)</td>
</tr>
<tr>
<td><code>executionTimeMillis</code></td>
<td>짧음</td>
<td>길면 최적화 필요</td>
</tr>
</tbody>
</table>
<p><strong>COLLSCAN이 나타나면</strong> 해당 쿼리 조건에 맞는 인덱스 생성을 검토해야 한다.</p>
<pre class="highlight"><code class="language-javascript">// 인덱스 없이 조회 (COLLSCAN)
db.books.find({ price: { $gte: 30000 } }).explain("executionStats")
// =&gt; stage: "COLLSCAN", totalDocsExamined: 전체 도큐먼트 수

// 인덱스 생성 후 조회 (IXSCAN)
db.books.createIndex({ price: 1 })
db.books.find({ price: { $gte: 30000 } }).explain("executionStats")
// =&gt; stage: "IXSCAN", totalDocsExamined ≈ nReturned</code></pre>
<hr>
<h2 id="45-mongodb">4.5 MongoDB와 리액티브 드라이버</h2>
<h3 id="451-mongodb-reactive-streams-driver">4.5.1 MongoDB Reactive Streams Driver</h3>
<p>MongoDB는 공식적으로 <strong>Reactive Streams</strong> 사양을 구현한 Java 드라이버를 제공한다. 이 드라이버는 논블로킹 I/O를 기반으로 동작하며, Netty를 내부 네트워크 레이어로 사용한다.</p>
<pre class="highlight"><code class="language-xml">&lt;!-- pom.xml --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mongodb&lt;/groupId&gt;
    &lt;artifactId&gt;mongodb-driver-reactivestreams&lt;/artifactId&gt;
    &lt;version&gt;5.3.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<p>Reactive Streams Driver를 직접 사용하는 예시:</p>
<pre class="highlight"><code class="language-java">import com.mongodb.reactivestreams.client.MongoClients;
import com.mongodb.reactivestreams.client.MongoClient;
import com.mongodb.reactivestreams.client.MongoDatabase;
import com.mongodb.reactivestreams.client.MongoCollection;
import org.bson.Document;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

// 클라이언트 생성
MongoClient mongoClient = MongoClients.create("mongodb://admin:secret1234@localhost:27017");
MongoDatabase database = mongoClient.getDatabase("webflux_demo");
MongoCollection&lt;Document&gt; collection = database.getCollection("books");

// 도큐먼트 삽입 (Publisher를 Reactor의 Mono로 래핑)
Document book = new Document("title", "Reactive MongoDB")
    .append("author", "Jane Doe")
    .append("price", 42000);

Mono.from(collection.insertOne(book))
    .subscribe(result -&gt;
        System.out.println("Inserted ID: " + result.getInsertedId()));

// 도큐먼트 조회 (Publisher를 Reactor의 Flux로 래핑)
Flux.from(collection.find())
    .doOnNext(doc -&gt; System.out.println(doc.toJson()))
    .subscribe();</code></pre>
<h3 id="452-vs">4.5.2 동기 vs 리액티브 드라이버 비교</h3>
<table>
<thead>
<tr>
<th>구분</th>
<th>동기 드라이버</th>
<th>리액티브 드라이버</th>
</tr>
</thead>
<tbody>
<tr>
<td>아티팩트</td>
<td><code>mongodb-driver-sync</code></td>
<td><code>mongodb-driver-reactivestreams</code></td>
</tr>
<tr>
<td>I/O 모델</td>
<td>블로킹</td>
<td>논블로킹</td>
</tr>
<tr>
<td>반환 타입</td>
<td><code>List&lt;T&gt;</code>, <code>T</code></td>
<td><code>Publisher&lt;T&gt;</code></td>
</tr>
<tr>
<td>스레드 모델</td>
<td>요청당 스레드 점유</td>
<td>이벤트 루프 기반, 스레드 공유</td>
</tr>
<tr>
<td>배압 지원</td>
<td>없음</td>
<td>Reactive Streams 배압 지원</td>
</tr>
<tr>
<td>적합한 프레임워크</td>
<td>Spring MVC</td>
<td>Spring WebFlux</td>
</tr>
</tbody>
</table>
<p>동기 드라이버에서 <code>find()</code>를 호출하면 결과가 모두 반환될 때까지 호출 스레드가 블로킹된다. 리액티브 드라이버에서는 <code>Publisher</code>를 반환하고 구독 시점에 비동기로 데이터를 스트리밍한다.</p>
<pre class="highlight"><code class="language-java">// 동기 드라이버 — 스레드가 결과 반환까지 대기
List&lt;Document&gt; books = syncCollection.find().into(new ArrayList&lt;&gt;());

// 리액티브 드라이버 — 논블로킹, 데이터가 준비되면 콜백
Flux.from(reactiveCollection.find())
    .collectList()
    .subscribe(books -&gt; { /* 결과 처리 */ });</code></pre>
<h3 id="453-spring-data-mongodb-reactive">4.5.3 Spring Data MongoDB Reactive 모듈 소개</h3>
<p>실무에서 Reactive Streams Driver를 직접 사용하는 일은 드물다. <strong>Spring Data MongoDB Reactive</strong> 모듈이 드라이버를 추상화하여 훨씬 편리한 프로그래밍 모델을 제공한다.</p>
<p><strong>의존성 추가</strong></p>
<pre class="highlight"><code class="language-xml">&lt;!-- pom.xml --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-mongodb-reactive&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<pre class="highlight"><code class="language-groovy">// build.gradle (Kotlin DSL)
implementation("org.springframework.boot:spring-boot-starter-data-mongodb-reactive")</code></pre>
<p><strong>도메인 모델 정의</strong></p>
<pre class="highlight"><code class="language-java">import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@Document(collection = "books")   // MongoDB 컬렉션 매핑
public class Book {

    @Id
    private String id;            // MongoDB의 _id에 매핑
    private String title;
    private String author;
    private BigDecimal price;
    private List&lt;String&gt; tags;
    private LocalDateTime publishedAt;

    // 생성자, getter, setter 생략
}</code></pre>
<p><strong>ReactiveMongoRepository 정의</strong></p>
<pre class="highlight"><code class="language-java">import org.springframework.data.mongodb.repository.ReactiveMongoRepository;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

public interface BookRepository extends ReactiveMongoRepository&lt;Book, String&gt; {

    // 메서드 이름 기반 쿼리 자동 생성
    Flux&lt;Book&gt; findByAuthor(String author);

    Flux&lt;Book&gt; findByPriceGreaterThanEqual(BigDecimal price);

    Flux&lt;Book&gt; findByTagsContaining(String tag);

    Mono&lt;Book&gt; findByTitle(String title);
}</code></pre>
<p><strong>서비스 및 컨트롤러 예시</strong></p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class BookService {

    private final BookRepository bookRepository;

    public Flux&lt;Book&gt; findAll() {
        return bookRepository.findAll();
    }

    public Mono&lt;Book&gt; findById(String id) {
        return bookRepository.findById(id)
            .switchIfEmpty(Mono.error(
                new RuntimeException("Book not found: " + id)));
    }

    public Mono&lt;Book&gt; create(Book book) {
        return bookRepository.save(book);
    }

    public Mono&lt;Void&gt; delete(String id) {
        return bookRepository.deleteById(id);
    }
}

@RestController
@RequestMapping("/api/books")
@RequiredArgsConstructor
public class BookController {

    private final BookService bookService;

    @GetMapping
    public Flux&lt;Book&gt; getAll() {
        return bookService.findAll();
    }

    @GetMapping("/{id}")
    public Mono&lt;Book&gt; getById(@PathVariable String id) {
        return bookService.findById(id);
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono&lt;Book&gt; create(@RequestBody Book book) {
        return bookService.create(book);
    }

    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public Mono&lt;Void&gt; delete(@PathVariable String id) {
        return bookService.delete(id);
    }
}</code></pre>
<p>위 코드에서 중요한 점은 <strong>반환 타입이 모두 <code>Mono</code> 또는 <code>Flux</code>라는 것</strong>이다. 컨트롤러에서 <code>Mono</code>나 <code>Flux</code>를 반환하면 WebFlux가 구독을 관리하고, 데이터가 준비되는 대로 논블로킹 방식으로 HTTP 응답을 스트리밍한다. 데이터베이스 쿼리부터 HTTP 응답까지 전체 흐름에서 스레드가 블로킹되지 않는다.</p>
<p><strong>application.yml 설정</strong></p>
<pre class="highlight"><code class="language-yaml">spring:
  data:
    mongodb:
      uri: mongodb://admin:secret1234@localhost:27017/webflux_demo?authSource=admin</code></pre>
<blockquote>
<p><strong>Spring Data MongoDB Reactive의 핵심 구성 요소</strong>는 Chapter 5에서 프로젝트를 직접 구성하면서 상세하게 다루고, Chapter 6에서 실제 REST API를 구현하며 실습한다. Chapter 8에서는 <code>ReactiveMongoTemplate</code>, Aggregation, Change Streams 등 심화 기능을 다룬다.</p>
</blockquote>
<hr>
<h2 id="4">4장 정리</h2>
<p>이번 장에서 다룬 핵심 내용을 정리한다.</p>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 요약</th>
</tr>
</thead>
<tbody>
<tr>
<td>NoSQL vs RDBMS</td>
<td>MongoDB는 유연한 스키마, 수평 확장, 높은 가용성을 제공하는 도큐먼트 DB</td>
</tr>
<tr>
<td>CAP 정리</td>
<td>MongoDB는 CP 시스템. <code>writeConcern</code>, <code>readPreference</code>로 균형 조절 가능</td>
</tr>
<tr>
<td>도큐먼트 모델</td>
<td>BSON 형식, 내장 vs 참조 설계 결정이 핵심</td>
</tr>
<tr>
<td>기본 CRUD</td>
<td><code>insertOne/Many</code>, <code>find</code>, <code>updateOne/Many</code>, <code>deleteOne/Many</code></td>
</tr>
<tr>
<td>인덱스</td>
<td>단일, 복합, 멀티키, 텍스트, TTL. <code>explain()</code>으로 실행 계획 분석</td>
</tr>
<tr>
<td>리액티브 드라이버</td>
<td>논블로킹 I/O, <code>Publisher&lt;T&gt;</code> 반환, Spring Data MongoDB Reactive로 추상화</td>
</tr>
</tbody>
</table>
<p>다음 Chapter 5에서는 실제 개발 환경을 구성하고, Spring Boot + WebFlux + MongoDB Reactive 프로젝트를 처음부터 세팅한다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>