<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Part 3. 심화 개발 (Ch.8-11) | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="part2.html">&larr; Part 2. 프로젝트 시작하기 (Ch.5-7)</a>
    <a href="../index.html">목차</a>
    <a href="part4.html">Part 4. 실시간 통신과 고급 기능 (Ch.12-15) &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-8-mongodb">Chapter 8. MongoDB 리액티브 데이터 접근 심화</h1>
<p>Chapter 6에서 <code>ReactiveMongoRepository</code>를 활용한 기본 CRUD를 구현했다. 이번 장에서는 <code>ReactiveMongoTemplate</code>을 중심으로 MongoDB의 고급 기능을 리액티브 방식으로 활용하는 방법을 다룬다. Criteria API를 이용한 동적 쿼리, Aggregation Pipeline을 활용한 통계 API, Change Streams를 이용한 실시간 데이터 감시, 트랜잭션 처리, 그리고 인덱스 관리와 쿼리 성능 최적화까지 실전에서 필요한 심화 주제를 집중적으로 살펴본다.</p>
<hr>
<h2 id="81-reactivemongotemplate">8.1 ReactiveMongoTemplate 활용</h2>
<h3 id="811-reactivemongotemplate-vs-reactivemongorepository">8.1.1 ReactiveMongoTemplate vs ReactiveMongoRepository</h3>
<p>Chapter 6에서 사용한 <code>ReactiveMongoRepository</code>는 메서드 이름 기반 쿼리 자동 생성, 기본 CRUD 메서드 제공 등 편리한 추상화를 제공한다. 그러나 복잡한 쿼리, 부분 업데이트, Aggregation, Change Streams 등 고급 기능을 사용하려면 <code>ReactiveMongoTemplate</code>이 필요하다.</p>
<table>
<thead>
<tr>
<th>비교 항목</th>
<th>ReactiveMongoRepository</th>
<th>ReactiveMongoTemplate</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>추상화 수준</strong></td>
<td>높음 (인터페이스 선언만으로 사용)</td>
<td>낮음 (직접 Query/Update 객체 구성)</td>
</tr>
<tr>
<td><strong>기본 CRUD</strong></td>
<td>자동 제공</td>
<td>직접 구현</td>
</tr>
<tr>
<td><strong>부분 업데이트</strong></td>
<td>미지원 (전체 도큐먼트 교체)</td>
<td><code>Update</code> 객체로 특정 필드만 수정</td>
</tr>
<tr>
<td><strong>Upsert / Aggregation</strong></td>
<td>미지원</td>
<td><code>upsert()</code>, <code>aggregate()</code> 제공</td>
</tr>
<tr>
<td><strong>Change Streams</strong></td>
<td>미지원</td>
<td><code>changeStream()</code> 메서드 제공</td>
</tr>
<tr>
<td><strong>동적 쿼리</strong></td>
<td>제한적 (<code>@Query</code> + SpEL)</td>
<td><code>Criteria</code>로 자유롭게 조합</td>
</tr>
</tbody>
</table>
<p>실무에서는 두 가지를 함께 사용하는 경우가 많다. 간단한 CRUD는 <code>ReactiveMongoRepository</code>로 처리하고, 복잡한 쿼리나 고급 기능이 필요한 부분에서 <code>ReactiveMongoTemplate</code>을 사용한다.</p>
<h3 id="812-reactivemongotemplate-crud">8.1.2 ReactiveMongoTemplate 기본 CRUD</h3>
<p><code>ReactiveMongoTemplate</code>은 Spring Boot의 자동 설정에 의해 빈으로 등록된다. 별도의 설정 없이 주입받아 사용할 수 있다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class ProductQueryService {

    private final ReactiveMongoTemplate mongoTemplate;

    public Flux&lt;Product&gt; findAll() {
        return mongoTemplate.findAll(Product.class);
    }

    public Mono&lt;Product&gt; findById(String id) {
        return mongoTemplate.findById(id, Product.class);
    }

    public Flux&lt;Product&gt; findByCategory(String category) {
        Query query = Query.query(Criteria.where("category").is(category));
        return mongoTemplate.find(query, Product.class);
    }

    public Mono&lt;Product&gt; insert(Product product) {
        return mongoTemplate.insert(product);
    }

    public Mono&lt;DeleteResult&gt; deleteById(String id) {
        Query query = Query.query(Criteria.where("id").is(id));
        return mongoTemplate.remove(query, Product.class);
    }
}</code></pre>
<h3 id="813-query-update">8.1.3 Query와 Update 객체</h3>
<p><code>Query</code> 객체는 MongoDB 쿼리 조건을, <code>Update</code> 객체는 수정할 필드와 값을 지정한다.</p>
<pre class="highlight"><code class="language-java">// 특정 필드만 업데이트 (부분 업데이트)
public Mono&lt;UpdateResult&gt; updatePrice(String productId, BigDecimal newPrice) {
    Query query = Query.query(Criteria.where("id").is(productId));
    Update update = new Update()
        .set("price", newPrice)
        .set("updatedAt", LocalDateTime.now());
    return mongoTemplate.updateFirst(query, update, Product.class);
}

// 조건에 맞는 모든 도큐먼트 업데이트
public Mono&lt;UpdateResult&gt; applyDiscount(String category, int discountPercent) {
    Query query = Query.query(Criteria.where("category").is(category));
    Update update = new Update()
        .mul("price", (100 - discountPercent) / 100.0)
        .set("updatedAt", LocalDateTime.now());
    return mongoTemplate.updateMulti(query, update, Product.class);
}</code></pre>
<p><code>Update</code> 객체의 주요 메서드는 다음과 같다.</p>
<table>
<thead>
<tr>
<th>메서드</th>
<th>MongoDB 연산자</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>set(key, value)</code></td>
<td><code>$set</code></td>
<td>필드 값 설정</td>
</tr>
<tr>
<td><code>unset(key)</code></td>
<td><code>$unset</code></td>
<td>필드 제거</td>
</tr>
<tr>
<td><code>inc(key, value)</code></td>
<td><code>$inc</code></td>
<td>숫자 증가/감소</td>
</tr>
<tr>
<td><code>push(key, value)</code></td>
<td><code>$push</code></td>
<td>배열에 요소 추가</td>
</tr>
<tr>
<td><code>pull(key, value)</code></td>
<td><code>$pull</code></td>
<td>배열에서 요소 제거</td>
</tr>
<tr>
<td><code>addToSet(key, value)</code></td>
<td><code>$addToSet</code></td>
<td>배열에 중복 없이 추가</td>
</tr>
<tr>
<td><code>min(key, value)</code> / <code>max(key, value)</code></td>
<td><code>$min</code> / <code>$max</code></td>
<td>현재 값과 비교하여 갱신</td>
</tr>
</tbody>
</table>
<h3 id="814-upsert-findandmodify">8.1.4 Upsert와 findAndModify</h3>
<p><code>upsert</code>는 조건에 맞는 도큐먼트가 있으면 업데이트하고, 없으면 새로 삽입하는 원자적 연산이다. <code>findAndModify()</code>는 도큐먼트를 찾아 수정하고 결과를 반환하는 원자적 연산이다.</p>
<pre class="highlight"><code class="language-java">// Upsert: 조회수 카운터 — 없으면 생성, 있으면 증가
public Mono&lt;UpdateResult&gt; incrementViewCount(String productId) {
    Query query = Query.query(Criteria.where("productId").is(productId));
    Update update = new Update()
        .inc("viewCount", 1)
        .setOnInsert("productId", productId)
        .setOnInsert("createdAt", LocalDateTime.now());
    return mongoTemplate.upsert(query, update, "product_views");
}

// findAndModify: 재고 차감 — 원자적으로 수행하고 수정된 결과 반환
public Mono&lt;Product&gt; decrementStock(String productId, int quantity) {
    Query query = Query.query(
        Criteria.where("id").is(productId).and("stock").gte(quantity)
    );
    Update update = new Update().inc("stock", -quantity);
    FindAndModifyOptions options = FindAndModifyOptions.options()
        .returnNew(true)
        .upsert(false);
    return mongoTemplate.findAndModify(query, update, options, Product.class);
}</code></pre>
<p><code>setOnInsert()</code>는 도큐먼트가 새로 삽입될 때만 적용되는 필드를 지정한다. MongoDB의 <code>$setOnInsert</code> 연산자에 대응한다.</p>
<hr>
<h2 id="82-criteria-api">8.2 커스텀 쿼리와 Criteria API</h2>
<h3 id="821-criteria">8.2.1 Criteria 기본 사용법</h3>
<p><code>Criteria</code>는 MongoDB 쿼리 조건을 빌더 패턴으로 구성하는 클래스다.</p>
<pre class="highlight"><code class="language-java">Criteria.where("category").is("electronics");       // 등호
Criteria.where("price").gte(10000).lte(50000);       // 범위
Criteria.where("description").exists(true);           // 존재 여부
Criteria.where("deletedAt").isNull();                 // null 체크</code></pre>
<p>주요 비교 메서드는 다음과 같다.</p>
<table>
<thead>
<tr>
<th>메서드</th>
<th>MongoDB 연산자</th>
<th>의미</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>is</code> / <code>ne</code></td>
<td><code>$eq</code> / <code>$ne</code></td>
<td>같음 / 같지 않음</td>
</tr>
<tr>
<td><code>gt</code> / <code>gte</code> / <code>lt</code> / <code>lte</code></td>
<td><code>$gt</code> / <code>$gte</code> / <code>$lt</code> / <code>$lte</code></td>
<td>비교 연산</td>
</tr>
<tr>
<td><code>in</code> / <code>nin</code></td>
<td><code>$in</code> / <code>$nin</code></td>
<td>포함 / 미포함</td>
</tr>
<tr>
<td><code>regex(pattern)</code></td>
<td><code>$regex</code></td>
<td>정규표현식 매칭</td>
</tr>
<tr>
<td><code>exists(boolean)</code></td>
<td><code>$exists</code></td>
<td>필드 존재 여부</td>
</tr>
</tbody>
</table>
<h3 id="822-andorinregex">8.2.2 복잡한 조건 조합 (and/or/in/regex)</h3>
<pre class="highlight"><code class="language-java">// AND 조건 — 체이닝
Query query = Query.query(
    Criteria.where("category").is("electronics")
        .and("price").gte(10000).and("stock").gt(0)
);

// OR 조건
Query query = Query.query(
    new Criteria().orOperator(
        Criteria.where("category").is("electronics"),
        Criteria.where("category").is("books")
    )
);

// AND + OR 혼합
Query query = Query.query(
    new Criteria().orOperator(
        new Criteria().andOperator(
            Criteria.where("category").is("electronics"),
            Criteria.where("price").gte(10000)),
        new Criteria().andOperator(
            Criteria.where("category").is("books"),
            Criteria.where("price").gte(5000))
    )
);

// in, regex, elemMatch
Criteria.where("category").in("electronics", "books", "clothing");
Criteria.where("name").regex("갤럭시", "i");  // 대소문자 무시
Criteria.where("tags").elemMatch(
    Criteria.where("name").is("sale").and("active").is(true)
);</code></pre>
<h3 id="823-projection">8.2.3 정렬, 페이징, Projection</h3>
<pre class="highlight"><code class="language-java">// 정렬 + 페이징
public Flux&lt;Product&gt; findWithPaging(String category, int page, int size) {
    Query query = Query.query(Criteria.where("category").is(category))
        .with(Sort.by(Sort.Direction.DESC, "createdAt"))
        .skip((long) page * size)
        .limit(size);
    return mongoTemplate.find(query, Product.class);
}

// 전체 건수 조회 (페이징 UI용)
public Mono&lt;Long&gt; countByCategory(String category) {
    Query query = Query.query(Criteria.where("category").is(category));
    return mongoTemplate.count(query, Product.class);
}

// Projection — 필요한 필드만 선택
public Flux&lt;ProductSummary&gt; findSummaries() {
    Query query = new Query();
    query.fields().include("name").include("price").include("category");
    return mongoTemplate.find(query, ProductSummary.class, "products");
}</code></pre>
<h3 id="824">8.2.4 동적 쿼리 구성</h3>
<p>실무에서는 사용자의 검색 조건에 따라 쿼리를 동적으로 구성해야 하는 경우가 많다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class ProductSearchService {

    private final ReactiveMongoTemplate mongoTemplate;

    public Flux&lt;Product&gt; search(ProductSearchCriteria sc) {
        Query query = new Query();

        if (sc.getCategory() != null) {
            query.addCriteria(Criteria.where("category").is(sc.getCategory()));
        }
        if (sc.getMinPrice() != null || sc.getMaxPrice() != null) {
            Criteria price = Criteria.where("price");
            if (sc.getMinPrice() != null) price = price.gte(sc.getMinPrice());
            if (sc.getMaxPrice() != null) price = price.lte(sc.getMaxPrice());
            query.addCriteria(price);
        }
        if (sc.getKeyword() != null) {
            query.addCriteria(Criteria.where("name").regex(sc.getKeyword(), "i"));
        }
        if (Boolean.TRUE.equals(sc.getInStockOnly())) {
            query.addCriteria(Criteria.where("stock").gt(0));
        }

        query.with(Sort.by(
            Sort.Direction.fromString(
                sc.getSortDirection() != null ? sc.getSortDirection() : "DESC"),
            sc.getSortBy() != null ? sc.getSortBy() : "createdAt"
        ));
        query.skip((long) sc.getPage() * sc.getSize()).limit(sc.getSize());

        return mongoTemplate.find(query, Product.class);
    }
}</code></pre>
<pre class="highlight"><code class="language-java">@Data
@Builder
public class ProductSearchCriteria {
    private String category;
    private BigDecimal minPrice;
    private BigDecimal maxPrice;
    private String keyword;
    private Boolean inStockOnly;
    private String sortBy;
    private String sortDirection;
    @Builder.Default private int page = 0;
    @Builder.Default private int size = 20;
}</code></pre>
<hr>
<h2 id="83-aggregation-pipeline">8.3 Aggregation Pipeline 사용</h2>
<h3 id="831-aggregation-pipeline">8.3.1 Aggregation Pipeline 개념</h3>
<p>MongoDB Aggregation Pipeline은 도큐먼트를 여러 단계(stage)에 걸쳐 변환하고 집계하는 프레임워크다. Spring Data MongoDB는 <code>Aggregation</code> 클래스를 통해 파이프라인을 구성하고, <code>ReactiveMongoTemplate.aggregate()</code>로 실행한다.</p>
<table>
<thead>
<tr>
<th>단계</th>
<th>MongoDB 연산자</th>
<th>Spring Data 메서드</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>Match</td>
<td><code>$match</code></td>
<td><code>Aggregation.match()</code></td>
<td>도큐먼트 필터링</td>
</tr>
<tr>
<td>Group</td>
<td><code>$group</code></td>
<td><code>Aggregation.group()</code></td>
<td>그룹별 집계</td>
</tr>
<tr>
<td>Sort</td>
<td><code>$sort</code></td>
<td><code>Aggregation.sort()</code></td>
<td>결과 정렬</td>
</tr>
<tr>
<td>Project</td>
<td><code>$project</code></td>
<td><code>Aggregation.project()</code></td>
<td>필드 선택/변환</td>
</tr>
<tr>
<td>Unwind</td>
<td><code>$unwind</code></td>
<td><code>Aggregation.unwind()</code></td>
<td>배열 분해</td>
</tr>
<tr>
<td>Lookup</td>
<td><code>$lookup</code></td>
<td><code>Aggregation.lookup()</code></td>
<td>컬렉션 조인</td>
</tr>
</tbody>
</table>
<h3 id="832">8.3.2 기본 집계: 카테고리별 통계</h3>
<pre class="highlight"><code class="language-java">public Flux&lt;CategoryStats&gt; getCategoryStats() {
    Aggregation aggregation = Aggregation.newAggregation(
        Aggregation.match(Criteria.where("active").is(true)),
        Aggregation.group("category")
            .count().as("productCount")
            .avg("price").as("avgPrice")
            .min("price").as("minPrice")
            .max("price").as("maxPrice")
            .sum("stock").as("totalStock"),
        Aggregation.sort(Sort.Direction.DESC, "productCount"),
        Aggregation.project()
            .and("_id").as("category")
            .andInclude("productCount", "avgPrice", "minPrice", "maxPrice", "totalStock")
    );
    return mongoTemplate.aggregate(aggregation, "products", CategoryStats.class);
}</code></pre>
<pre class="highlight"><code class="language-java">@Data
public class CategoryStats {
    private String category;
    private long productCount;
    private double avgPrice;
    private double minPrice;
    private double maxPrice;
    private long totalStock;
}</code></pre>
<h3 id="833-typedaggregation">8.3.3 TypedAggregation</h3>
<p><code>TypedAggregation</code>은 입력 타입을 명시하여 컬렉션 이름을 <code>@Document</code> 어노테이션에서 자동 추론한다. <code>Aggregation.newAggregation(Product.class, ...)</code>처럼 첫 번째 인자로 도메인 클래스를 전달하면, <code>aggregate()</code> 호출 시 컬렉션 이름을 생략할 수 있다.</p>
<h3 id="834-unwind-lookup">8.3.4 Unwind와 Lookup</h3>
<p><strong>Unwind</strong>는 배열 필드를 개별 도큐먼트로 분해한다. <strong>Lookup</strong>은 다른 컬렉션과 조인한다.</p>
<pre class="highlight"><code class="language-java">// 태그별 상품 수 집계 (Unwind)
public Flux&lt;TagStats&gt; getTagStats() {
    Aggregation aggregation = Aggregation.newAggregation(
        Aggregation.unwind("tags"),
        Aggregation.group("tags").count().as("count").avg("price").as("avgPrice"),
        Aggregation.sort(Sort.Direction.DESC, "count"),
        Aggregation.limit(10)
    );
    return mongoTemplate.aggregate(aggregation, "products", TagStats.class);
}

// 주문 + 사용자 조인 (Lookup)
public Flux&lt;OrderWithUser&gt; getOrdersWithUserInfo() {
    Aggregation aggregation = Aggregation.newAggregation(
        Aggregation.lookup("users", "userId", "_id", "userInfo"),
        Aggregation.unwind("userInfo"),
        Aggregation.project()
            .andInclude("orderDate", "totalAmount", "status")
            .and("userInfo.name").as("userName")
            .and("userInfo.email").as("userEmail")
    );
    return mongoTemplate.aggregate(aggregation, "orders", OrderWithUser.class);
}</code></pre>
<h3 id="835-api">8.3.5 실전 통계 API: 일별 매출 집계</h3>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class SalesStatisticsService {

    private final ReactiveMongoTemplate mongoTemplate;

    public Flux&lt;DailySales&gt; getDailySales(LocalDateTime from, LocalDateTime to) {
        Aggregation aggregation = Aggregation.newAggregation(
            Aggregation.match(
                Criteria.where("orderDate").gte(from).lte(to)
                    .and("status").is("COMPLETED")),
            Aggregation.project()
                .andExpression("dateToString('%Y-%m-%d', orderDate)").as("date")
                .andInclude("totalAmount"),
            Aggregation.group("date")
                .sum("totalAmount").as("totalSales")
                .count().as("orderCount")
                .avg("totalAmount").as("avgOrderAmount"),
            Aggregation.sort(Sort.Direction.ASC, "_id"),
            Aggregation.project()
                .and("_id").as("date")
                .andInclude("totalSales", "orderCount", "avgOrderAmount")
        );
        return mongoTemplate.aggregate(aggregation, "orders", DailySales.class);
    }
}</code></pre>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/statistics")
@RequiredArgsConstructor
public class StatisticsController {

    private final SalesStatisticsService salesStatisticsService;

    @GetMapping("/daily-sales")
    public Flux&lt;DailySales&gt; getDailySales(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime from,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime to) {
        return salesStatisticsService.getDailySales(from, to);
    }
}</code></pre>
<hr>
<h2 id="84-change-streams">8.4 변경 스트림(Change Streams) 활용</h2>
<h3 id="841-change-streams">8.4.1 Change Streams 개념</h3>
<p>MongoDB Change Streams는 컬렉션의 데이터 변경(삽입, 수정, 삭제)을 실시간으로 감시하는 기능이다. 내부적으로 oplog를 기반으로 동작하며, <strong>Replica Set 또는 Sharded Cluster 환경에서만 사용할 수 있다</strong>. 실시간 알림, 이벤트 발행, 데이터 동기화, 캐시 무효화 등에 활용된다.</p>
<h3 id="842-reactivemongotemplate-change-streams">8.4.2 ReactiveMongoTemplate으로 Change Streams 구독</h3>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
@Slf4j
public class OrderChangeStreamService {

    private final ReactiveMongoTemplate mongoTemplate;

    // INSERT 이벤트 실시간 감시
    public Flux&lt;ChangeStreamEvent&lt;Order&gt;&gt; watchNewOrders() {
        return mongoTemplate.changeStream("orders",
                ChangeStreamOptions.builder()
                    .filter(Aggregation.newAggregation(
                        Aggregation.match(
                            Criteria.where("operationType").is("insert"))))
                    .build(),
                Order.class)
            .doOnNext(event -&gt; log.info("새 주문 감지: orderId={}",
                event.getBody().getId()));
    }

    // UPDATE 이벤트 감시 (전체 도큐먼트 수신)
    public Flux&lt;ChangeStreamEvent&lt;Order&gt;&gt; watchOrderStatusChanges() {
        return mongoTemplate.changeStream("orders",
                ChangeStreamOptions.builder()
                    .filter(Aggregation.newAggregation(
                        Aggregation.match(
                            Criteria.where("operationType").is("update")
                                .and("updateDescription.updatedFields.status").exists(true))))
                    .returnFullDocumentOnUpdate()
                    .build(),
                Order.class);
    }
}</code></pre>
<p><code>returnFullDocumentOnUpdate()</code>를 호출하면 UPDATE 이벤트 시 전체 도큐먼트를 수신한다. 이 옵션이 없으면 변경된 필드 정보만 포함된다.</p>
<h3 id="843-change-streams-sse">8.4.3 Change Streams + SSE 연동</h3>
<p>Change Streams를 Server-Sent Events와 결합하면 클라이언트에게 실시간 알림을 전달할 수 있다.</p>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/notifications")
@RequiredArgsConstructor
public class NotificationController {

    private final OrderChangeStreamService changeStreamService;

    @GetMapping(value = "/orders", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux&lt;ServerSentEvent&lt;Order&gt;&gt; streamNewOrders() {
        return changeStreamService.watchNewOrders()
            .map(event -&gt; ServerSentEvent.&lt;Order&gt;builder()
                .id(event.getResumeToken().toJson())
                .event("new-order")
                .data(event.getBody())
                .build());
    }
}</code></pre>
<h3 id="844-resume-token">8.4.4 Resume Token을 이용한 재연결</h3>
<p>Change Streams는 <code>resume token</code>을 제공하여 연결이 끊어진 후 마지막 이벤트부터 다시 수신할 수 있다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
@Slf4j
public class ResilientChangeStreamService {

    private final ReactiveMongoTemplate mongoTemplate;
    private final ResumeTokenStore tokenStore;

    public Flux&lt;ChangeStreamEvent&lt;Order&gt;&gt; watchWithResume(String streamId) {
        return tokenStore.getLastToken(streamId)
            .flatMapMany(lastToken -&gt; {
                ChangeStreamOptions.ChangeStreamOptionsBuilder builder =
                    ChangeStreamOptions.builder();
                if (lastToken != null) {
                    builder.resumeAfter(lastToken);
                }
                return mongoTemplate.changeStream("orders", builder.build(), Order.class);
            })
            .doOnNext(event -&gt;
                tokenStore.saveToken(streamId, event.getResumeToken()).subscribe())
            .retryWhen(Retry.backoff(Long.MAX_VALUE, Duration.ofSeconds(1))
                .maxBackoff(Duration.ofMinutes(1))
                .doBeforeRetry(signal -&gt;
                    log.warn("Change Stream 재연결 시도: attempt={}",
                        signal.totalRetries())));
    }
}</code></pre>
<p><code>ResumeTokenStore</code>는 resume token을 MongoDB에 저장/조회하는 컴포넌트로, <code>upsert</code>를 사용하여 구현한다. 이벤트를 처리할 때마다 토큰을 저장해두면 애플리케이션 재시작 후에도 유실 없이 이벤트를 이어서 수신할 수 있다.</p>
<hr>
<h2 id="85-reactivemongotransactionmanager">8.5 트랜잭션 처리 (ReactiveMongoTransactionManager)</h2>
<h3 id="851-mongodb">8.5.1 MongoDB 트랜잭션의 전제 조건</h3>
<p>MongoDB 트랜잭션은 <strong>Replica Set 환경에서만 사용할 수 있다</strong>. Docker Compose로 단일 노드 Replica Set을 구성하면 개발 환경에서도 트랜잭션을 테스트할 수 있다.</p>
<pre class="highlight"><code class="language-yaml"># docker-compose.yml
services:
  mongodb:
    image: mongo:7.0
    ports:
      - "27017:27017"
    command: ["--replSet", "rs0", "--bind_ip_all"]
    healthcheck:
      test: echo "try { rs.status() } catch (err) { rs.initiate() }" | mongosh
      interval: 5s
      timeout: 30s
      retries: 5</code></pre>
<h3 id="852-reactivemongotransactionmanager">8.5.2 ReactiveMongoTransactionManager 설정</h3>
<pre class="highlight"><code class="language-java">@Configuration
public class MongoTransactionConfig {

    @Bean
    public ReactiveMongoTransactionManager transactionManager(
            ReactiveMongoDatabaseFactory dbFactory) {
        return new ReactiveMongoTransactionManager(dbFactory);
    }
}</code></pre>
<h3 id="853-transactional">8.5.3 @Transactional 어노테이션 사용</h3>
<p>서비스 메서드에 <code>@Transactional</code>을 붙이면 리액티브 환경에서도 트랜잭션이 동작한다. 예외 발생 시 모든 연산이 자동 롤백된다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class OrderService {

    private final ReactiveMongoTemplate mongoTemplate;
    private final ProductService productService;

    @Transactional
    public Mono&lt;Order&gt; createOrder(OrderRequest request) {
        return Flux.fromIterable(request.getItems())
            .flatMap(item -&gt;
                productService.decrementStock(item.getProductId(), item.getQuantity())
                    .switchIfEmpty(Mono.error(new InsufficientStockException(
                        "재고 부족: productId=" + item.getProductId()))))
            .collectList()
            .flatMap(products -&gt; {
                Order order = Order.builder()
                    .userId(request.getUserId())
                    .items(request.getItems())
                    .totalAmount(calculateTotal(request.getItems(), products))
                    .status("CREATED")
                    .orderDate(LocalDateTime.now())
                    .build();
                return mongoTemplate.insert(order);
            });
    }
}</code></pre>
<h3 id="854-transactionaloperator">8.5.4 TransactionalOperator 프로그래밍 방식</h3>
<p><code>TransactionalOperator</code>를 사용하면 트랜잭션 경계를 프로그래밍 방식으로 제어할 수 있다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class TransferService {

    private final ReactiveMongoTemplate mongoTemplate;
    private final TransactionalOperator transactionalOperator;

    public Mono&lt;TransferResult&gt; transferPoints(
            String fromUserId, String toUserId, int amount) {

        Mono&lt;TransferResult&gt; transferMono = deductPoints(fromUserId, amount)
            .then(addPoints(toUserId, amount))
            .then(createTransferLog(fromUserId, toUserId, amount))
            .map(log -&gt; new TransferResult("SUCCESS", log.getId()));

        return transactionalOperator.transactional(transferMono);
    }

    private Mono&lt;UpdateResult&gt; deductPoints(String userId, int amount) {
        Query query = Query.query(
            Criteria.where("id").is(userId).and("points").gte(amount));
        Update update = new Update().inc("points", -amount);
        return mongoTemplate.updateFirst(query, update, User.class)
            .flatMap(result -&gt; result.getModifiedCount() == 0
                ? Mono.error(new InsufficientPointsException("포인트 부족"))
                : Mono.just(result));
    }

    private Mono&lt;UpdateResult&gt; addPoints(String userId, int amount) {
        Query query = Query.query(Criteria.where("id").is(userId));
        return mongoTemplate.updateFirst(query, new Update().inc("points", amount), User.class);
    }

    private Mono&lt;TransferLog&gt; createTransferLog(
            String fromUserId, String toUserId, int amount) {
        return mongoTemplate.insert(TransferLog.builder()
            .fromUserId(fromUserId).toUserId(toUserId)
            .amount(amount).transferredAt(LocalDateTime.now()).build());
    }
}</code></pre>
<h3 id="855-transactional-vs-transactionaloperator">8.5.5 @Transactional vs TransactionalOperator 선택 기준</h3>
<table>
<thead>
<tr>
<th>비교 항목</th>
<th>@Transactional</th>
<th>TransactionalOperator</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>사용 방식</strong></td>
<td>선언적 (어노테이션)</td>
<td>프로그래밍 방식</td>
</tr>
<tr>
<td><strong>적합한 곳</strong></td>
<td>서비스 계층 메서드 단위</td>
<td>함수형 엔드포인트, 세밀한 제어</td>
</tr>
<tr>
<td><strong>트랜잭션 범위</strong></td>
<td>메서드 전체</td>
<td><code>transactional()</code> 호출 범위</td>
</tr>
<tr>
<td><strong>유연성</strong></td>
<td>제한적</td>
<td>높음 (조건부 트랜잭션 등)</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="86">8.6 인덱스 관리와 쿼리 성능 최적화</h2>
<h3 id="861-indexed">8.6.1 @Indexed 어노테이션</h3>
<p>Spring Data MongoDB의 <code>@Indexed</code>로 단일 필드 인덱스를 선언한다.</p>
<pre class="highlight"><code class="language-java">@Document(collection = "products")
@Data @Builder @NoArgsConstructor @AllArgsConstructor
public class Product {

    @Id
    private String id;
    private String name;

    @Indexed
    private String category;

    private BigDecimal price;

    @Indexed(unique = true)
    private String sku;

    @Indexed(direction = IndexDirection.DESCENDING)
    private LocalDateTime createdAt;

    private int stock;
    private boolean active;
    private List&lt;String&gt; tags;
}</code></pre>
<blockquote>
<p><strong>주의</strong>: Spring Boot 3.x부터 <code>auto-index-creation</code>이 기본값 <code>false</code>다. <code>@Indexed</code>가 동작하려면 명시적으로 활성화해야 한다.</p>
</blockquote>
<pre class="highlight"><code class="language-yaml">spring:
  data:
    mongodb:
      auto-index-creation: true</code></pre>
<h3 id="862-compoundindex">8.6.2 @CompoundIndex 복합 인덱스</h3>
<p>여러 필드를 조합한 복합 인덱스는 <code>@CompoundIndex</code>로 선언한다.</p>
<pre class="highlight"><code class="language-java">@Document(collection = "products")
@CompoundIndex(name = "category_price_idx", def = "{'category': 1, 'price': -1}")
@CompoundIndex(name = "category_active_created_idx",
               def = "{'category': 1, 'active': 1, 'createdAt': -1}")
public class Product { /* ... */ }</code></pre>
<p>복합 인덱스 필드 순서는 <strong>ESR (Equality, Sort, Range) 규칙</strong>을 따르면 최적이다.</p>
<ol>
<li><strong>Equality</strong>: 등호(<code>=</code>) 조건 필드를 먼저 배치</li>
<li><strong>Sort</strong>: 정렬 필드를 다음에 배치</li>
<li><strong>Range</strong>: 범위 조건(<code>&gt;=</code>, <code>&lt;=</code>) 필드를 마지막에 배치</li>
</ol>
<pre class="highlight"><code class="language-java">// 쿼리: category = ? AND active = ?, 정렬: createdAt DESC, 조건: price &gt;= ?
// 최적 인덱스: { category: 1, active: 1, createdAt: -1, price: 1 }
@CompoundIndex(name = "optimized_search_idx",
               def = "{'category': 1, 'active': 1, 'createdAt': -1, 'price': 1}")</code></pre>
<h3 id="863-ttl">8.6.3 TTL 인덱스</h3>
<p>TTL 인덱스는 지정된 시간이 지나면 도큐먼트를 자동 삭제한다. 세션, 임시 토큰, 로그에 적합하다.</p>
<pre class="highlight"><code class="language-java">@Document(collection = "sessions")
@Data @Builder @NoArgsConstructor @AllArgsConstructor
public class Session {

    @Id
    private String id;
    private String userId;
    private String token;

    @Indexed(expireAfterSeconds = 3600)  // 1시간 후 자동 삭제
    private LocalDateTime createdAt;
}</code></pre>
<p>대상 필드는 반드시 <code>Date</code> 또는 <code>LocalDateTime</code> 타입이어야 한다. MongoDB 백그라운드 태스크가 60초 간격으로 만료 도큐먼트를 삭제하므로, 실제 삭제 시점은 약간의 지연이 있을 수 있다.</p>
<h3 id="864-partial-index">8.6.4 프로그래밍 방식 인덱스 생성과 Partial Index</h3>
<p><code>ReactiveMongoTemplate</code>의 <code>indexOps()</code>를 사용하면 애플리케이션 시작 시 프로그래밍 방식으로 인덱스를 생성할 수 있다. Partial Index는 특정 조건을 만족하는 도큐먼트에만 인덱스를 적용하여 저장 공간과 쓰기 성능을 절약한다.</p>
<pre class="highlight"><code class="language-java">@Component
@RequiredArgsConstructor
@Slf4j
public class IndexInitializer implements ApplicationRunner {

    private final ReactiveMongoTemplate mongoTemplate;

    @Override
    public void run(ApplicationArguments args) {
        ReactiveIndexOperations indexOps = mongoTemplate.indexOps(Product.class);
        Index partialIndex = new Index()
            .on("price", IndexDirection.ASCENDING)
            .named("active_products_price_idx")
            .partial(PartialIndexFilter.of(Criteria.where("active").is(true)));
        indexOps.ensureIndex(partialIndex)
            .doOnSuccess(name -&gt; log.info("인덱스 생성 완료: {}", name))
            .subscribe();
    }
}</code></pre>
<h3 id="865-explain">8.6.5 explain()으로 쿼리 실행 계획 분석</h3>
<p>인덱스가 제대로 활용되는지 확인하려면 <code>explain()</code>으로 실행 계획을 분석한다. <code>ReactiveMongoTemplate</code>에서 네이티브 컬렉션을 가져와 <code>explain()</code>을 호출하고, 결과의 <code>queryPlanner.winningPlan.stage</code>가 <code>IXSCAN</code>(인덱스 스캔)인지 확인한다. <code>COLLSCAN</code>(컬렉션 풀 스캔)이라면 인덱스 추가가 필요하다. 또한 <code>totalDocsExamined</code>와 <code>nReturned</code>가 가까울수록 인덱스 효율이 좋다.</p>
<h3 id="866">8.6.6 인덱스 설계 실무 가이드라인</h3>
<ol>
<li><strong>가장 자주 실행되는 쿼리부터 인덱스를 설계한다.</strong> 모든 필드에 인덱스를 걸 필요는 없다.</li>
<li><strong>복합 인덱스는 ESR 규칙을 따른다.</strong> Equality, Sort, Range 순서로 필드를 배치한다.</li>
<li><strong>인덱스는 쓰기 성능에 영향을 준다.</strong> INSERT/UPDATE마다 인덱스 갱신이 필요하므로 불필요한 인덱스는 제거한다.</li>
<li><strong>Covered Query를 활용한다.</strong> 필요한 모든 필드가 인덱스에 포함되면 도큐먼트를 읽지 않고 결과를 반환한다.</li>
<li><strong>Partial Index로 인덱스 크기를 줄인다.</strong> 조건을 만족하는 도큐먼트에만 인덱스를 적용한다.</li>
</ol>
<hr>
<h2 id="_1">요약</h2>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 내용</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ReactiveMongoTemplate</strong></td>
<td><code>Query</code>/<code>Update</code> 객체로 세밀한 CRUD, 부분 업데이트, Upsert 수행</td>
</tr>
<tr>
<td><strong>Criteria API</strong></td>
<td>동적 쿼리 조합, and/or/in/regex 조건, 정렬/페이징/Projection</td>
</tr>
<tr>
<td><strong>Aggregation Pipeline</strong></td>
<td>match/group/sort/project/unwind/lookup으로 복잡한 집계와 통계 API 구현</td>
</tr>
<tr>
<td><strong>Change Streams</strong></td>
<td>컬렉션 변경을 실시간 감시, resume token으로 재연결 시 이벤트 유실 방지</td>
</tr>
<tr>
<td><strong>트랜잭션</strong></td>
<td>Replica Set 필수, <code>@Transactional</code> 또는 <code>TransactionalOperator</code>로 원자적 연산 보장</td>
</tr>
<tr>
<td><strong>인덱스 최적화</strong></td>
<td><code>@Indexed</code>, <code>@CompoundIndex</code>, TTL 인덱스, ESR 규칙, explain 분석으로 쿼리 성능 개선</td>
</tr>
</tbody>
</table>
<p>다음 장에서는 데이터 검증과 예외 처리를 다루며, Bean Validation, 커스텀 Validator, 글로벌 예외 처리, 에러 응답 표준화 등을 살펴본다.</p>
<hr>
<h1 id="chapter-9">Chapter 9. 데이터 검증과 예외 처리</h1>
<p>Chapter 8에서 MongoDB 데이터 접근을 심화했다면, 이번 장에서는 클라이언트로부터 유입되는 데이터의 <strong>검증</strong>과 애플리케이션 전반의 <strong>예외 처리</strong>를 다룬다. 올바르지 않은 입력은 가능한 한 빨리 걸러내야 하며, 예외가 발생했을 때는 일관된 형식으로 클라이언트에 전달해야 한다. Bean Validation, 커스텀 Validator, <code>@ControllerAdvice</code>, <code>ErrorWebExceptionHandler</code>, 그리고 RFC 7807 기반 Problem Details까지 단계별로 살펴본다.</p>
<hr>
<h2 id="91-bean-validation">9.1 Bean Validation을 활용한 입력 검증</h2>
<h3 id="911">9.1.1 의존성 추가</h3>
<p>Spring Boot에서 Bean Validation을 사용하려면 <code>spring-boot-starter-validation</code> 의존성이 필요하다.</p>
<pre class="highlight"><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<p>이 스타터는 Hibernate Validator를 포함하며, Jakarta Bean Validation 3.0 API(<code>jakarta.validation</code> 패키지)를 제공한다.</p>
<h3 id="912">9.1.2 주요 검증 어노테이션</h3>
<p>자주 사용하는 Bean Validation 어노테이션을 정리한다.</p>
<table>
<thead>
<tr>
<th>어노테이션</th>
<th>설명</th>
<th>적용 대상</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@NotNull</code></td>
<td>null이 아니어야 한다</td>
<td>모든 타입</td>
</tr>
<tr>
<td><code>@NotBlank</code></td>
<td>null이 아니고, 공백을 제외한 길이가 1 이상</td>
<td><code>String</code></td>
</tr>
<tr>
<td><code>@NotEmpty</code></td>
<td>null이 아니고, 비어 있지 않아야 한다</td>
<td><code>String</code>, <code>Collection</code>, <code>Map</code>, 배열</td>
</tr>
<tr>
<td><code>@Size(min, max)</code></td>
<td>길이 또는 크기가 범위 내</td>
<td><code>String</code>, <code>Collection</code>, <code>Map</code>, 배열</td>
</tr>
<tr>
<td><code>@Email</code></td>
<td>이메일 형식이어야 한다</td>
<td><code>String</code></td>
</tr>
<tr>
<td><code>@Pattern(regexp)</code></td>
<td>정규표현식에 매칭되어야 한다</td>
<td><code>String</code></td>
</tr>
<tr>
<td><code>@Min</code> / <code>@Max</code></td>
<td>지정 값 이상 / 이하</td>
<td>숫자 타입</td>
</tr>
<tr>
<td><code>@Positive</code></td>
<td>양수여야 한다</td>
<td>숫자 타입</td>
</tr>
<tr>
<td><code>@Past</code> / <code>@Future</code></td>
<td>과거 / 미래 날짜여야 한다</td>
<td>날짜, 시간 타입</td>
</tr>
</tbody>
</table>
<h3 id="913-dto">9.1.3 DTO에 검증 어노테이션 적용</h3>
<p>Chapter 6에서 사용한 사용자 등록 DTO에 검증 로직을 추가한다.</p>
<pre class="highlight"><code class="language-java">package com.example.webfluxdemo.dto;

import jakarta.validation.constraints.*;
import lombok.*;

@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserCreateRequest {

    @NotBlank(message = "이름은 필수 입력 항목입니다")
    @Size(min = 2, max = 50, message = "이름은 2~50자 사이여야 합니다")
    private String name;

    @NotBlank(message = "이메일은 필수 입력 항목입니다")
    @Email(message = "올바른 이메일 형식이 아닙니다")
    private String email;

    @NotBlank(message = "비밀번호는 필수 입력 항목입니다")
    @Pattern(
        regexp = "^(?=.*[A-Za-z])(?=.*\\d)(?=.*[@$!%*#?&amp;])[A-Za-z\\d@$!%*#?&amp;]{8,20}$",
        message = "비밀번호는 8~20자이며, 영문, 숫자, 특수문자를 포함해야 합니다"
    )
    private String password;
}</code></pre>
<p>상품 생성 DTO에도 동일하게 적용한다.</p>
<pre class="highlight"><code class="language-java">@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductCreateRequest {

    @NotBlank(message = "상품명은 필수 입력 항목입니다")
    @Size(max = 200, message = "상품명은 200자를 초과할 수 없습니다")
    private String name;

    @NotNull(message = "가격은 필수 입력 항목입니다")
    @Positive(message = "가격은 양수여야 합니다")
    private Integer price;

    @Size(max = 1000, message = "설명은 1000자를 초과할 수 없습니다")
    private String description;

    @NotBlank(message = "카테고리는 필수 입력 항목입니다")
    private String category;
}</code></pre>
<h3 id="914-valid">9.1.4 컨트롤러에서 @Valid 적용</h3>
<p>WebFlux 어노테이션 기반 컨트롤러에서는 <code>@Valid</code>를 <code>@RequestBody</code>와 함께 사용한다.</p>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono&lt;UserResponse&gt; createUser(
            @Valid @RequestBody UserCreateRequest request) {
        return userService.createUser(request);
    }

    @PutMapping("/{id}")
    public Mono&lt;UserResponse&gt; updateUser(
            @PathVariable String id,
            @Valid @RequestBody UserUpdateRequest request) {
        return userService.updateUser(id, request);
    }
}</code></pre>
<p><code>@Valid</code>가 선언된 파라미터에서 검증이 실패하면, Spring WebFlux는 <code>WebExchangeBindException</code>을 발생시킨다. 이 예외는 9.3절에서 글로벌 예외 처리기로 가공하여 클라이언트에 반환한다.</p>
<h3 id="915">9.1.5 함수형 엔드포인트에서의 검증</h3>
<p>함수형 엔드포인트에서는 <code>@Valid</code>를 직접 사용할 수 없다. <code>Validator</code>를 주입받아 수동으로 검증을 수행한다.</p>
<pre class="highlight"><code class="language-java">@Component
@RequiredArgsConstructor
public class ProductHandler {

    private final ProductService productService;
    private final Validator validator;

    public Mono&lt;ServerResponse&gt; createProduct(ServerRequest request) {
        return request.bodyToMono(ProductCreateRequest.class)
            .doOnNext(this::validate)
            .flatMap(productService::createProduct)
            .flatMap(product -&gt; ServerResponse
                .created(URI.create("/api/products/" + product.getId()))
                .bodyValue(product));
    }

    private &lt;T&gt; void validate(T body) {
        Set&lt;ConstraintViolation&lt;T&gt;&gt; violations = validator.validate(body);
        if (!violations.isEmpty()) {
            throw new ConstraintViolationException(violations);
        }
    }
}</code></pre>
<p><code>ConstraintViolation</code>이 발견되면 <code>ConstraintViolationException</code>을 던지며, 이 예외도 글로벌 예외 처리기에서 일괄 처리한다.</p>
<hr>
<h2 id="92-validator">9.2 커스텀 Validator 구현</h2>
<h3 id="921">9.2.1 커스텀 어노테이션 정의</h3>
<p>표준 어노테이션으로 표현하기 어려운 비즈니스 규칙은 커스텀 Validator로 구현한다. 허용된 카테고리 값만 받아들이는 검증기를 만들어 보자.</p>
<pre class="highlight"><code class="language-java">@Documented
@Constraint(validatedBy = AllowedCategoryValidator.class)
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
public @interface AllowedCategory {
    String message() default "허용되지 않은 카테고리입니다";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
    String[] values() default {};
}</code></pre>
<h3 id="922-constraintvalidator">9.2.2 ConstraintValidator 구현</h3>
<p><code>ConstraintValidator&lt;A, T&gt;</code> 인터페이스를 구현한다. <code>A</code>는 어노테이션 타입, <code>T</code>는 검증 대상 필드 타입이다.</p>
<pre class="highlight"><code class="language-java">public class AllowedCategoryValidator
        implements ConstraintValidator&lt;AllowedCategory, String&gt; {

    private Set&lt;String&gt; allowedValues;

    @Override
    public void initialize(AllowedCategory annotation) {
        this.allowedValues = Set.of(annotation.values());
    }

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null) {
            return true; // null 검사는 @NotBlank에 위임
        }
        return allowedValues.contains(value);
    }
}</code></pre>
<p>DTO에 적용하면 다음과 같다.</p>
<pre class="highlight"><code class="language-java">@AllowedCategory(
    values = {"ELECTRONICS", "BOOKS", "CLOTHING", "FOOD"},
    message = "카테고리는 ELECTRONICS, BOOKS, CLOTHING, FOOD 중 하나여야 합니다"
)
@NotBlank(message = "카테고리는 필수 입력 항목입니다")
private String category;</code></pre>
<h3 id="923-validator">9.2.3 크로스 필드 검증 (클래스 레벨 Validator)</h3>
<p>비밀번호와 비밀번호 확인이 일치하는지처럼, 두 개 이상의 필드를 함께 검증해야 하는 경우에는 <strong>클래스 레벨 어노테이션</strong>을 사용한다.</p>
<pre class="highlight"><code class="language-java">@Documented
@Constraint(validatedBy = PasswordMatchValidator.class)
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface PasswordMatch {
    String message() default "비밀번호와 비밀번호 확인이 일치하지 않습니다";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}</code></pre>
<p>검증 대상 DTO가 구현할 인터페이스를 먼저 정의한다.</p>
<pre class="highlight"><code class="language-java">public interface PasswordConfirmable {
    String getPassword();
    String getPasswordConfirm();
}</code></pre>
<pre class="highlight"><code class="language-java">public class PasswordMatchValidator
        implements ConstraintValidator&lt;PasswordMatch, PasswordConfirmable&gt; {

    @Override
    public boolean isValid(PasswordConfirmable dto,
                           ConstraintValidatorContext context) {
        if (dto.getPassword() == null || dto.getPasswordConfirm() == null) {
            return true;
        }
        boolean matches = dto.getPassword().equals(dto.getPasswordConfirm());
        if (!matches) {
            context.disableDefaultConstraintViolation();
            context.buildConstraintViolationWithTemplate(
                    "비밀번호와 비밀번호 확인이 일치하지 않습니다")
                .addPropertyNode("passwordConfirm")
                .addConstraintViolation();
        }
        return matches;
    }
}</code></pre>
<p>DTO 클래스에 <code>@PasswordMatch</code>를 선언하면 필드 레벨 검증과 크로스 필드 검증이 모두 수행된다.</p>
<pre class="highlight"><code class="language-java">@PasswordMatch
@Getter @NoArgsConstructor @AllArgsConstructor @Builder
public class SignUpRequest implements PasswordConfirmable {

    @NotBlank(message = "이름은 필수 입력 항목입니다")
    private String name;

    @NotBlank @Email
    private String email;

    @NotBlank
    private String password;

    @NotBlank
    private String passwordConfirm;
}</code></pre>
<hr>
<h2 id="93-controlleradvice">9.3 글로벌 예외 처리 (@ControllerAdvice)</h2>
<h3 id="931">9.3.1 커스텀 예외 클래스 정의</h3>
<p>비즈니스 로직에서 발생하는 예외를 명확하게 구분하기 위해 커스텀 예외 계층을 정의한다.</p>
<pre class="highlight"><code class="language-java">package com.example.webfluxdemo.exception;

import lombok.Getter;

@Getter
public class BusinessException extends RuntimeException {

    private final ErrorCode errorCode;

    public BusinessException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.errorCode = errorCode;
    }

    public BusinessException(ErrorCode errorCode, String detail) {
        super(detail);
        this.errorCode = errorCode;
    }
}</code></pre>
<pre class="highlight"><code class="language-java">public class ResourceNotFoundException extends BusinessException {
    public ResourceNotFoundException(String resourceName, String id) {
        super(ErrorCode.RESOURCE_NOT_FOUND,
              resourceName + "을(를) 찾을 수 없습니다. ID: " + id);
    }
}

public class DuplicateResourceException extends BusinessException {
    public DuplicateResourceException(String resourceName, String field) {
        super(ErrorCode.DUPLICATE_RESOURCE,
              resourceName + "이(가) 이미 존재합니다. 필드: " + field);
    }
}</code></pre>
<h3 id="932-errorcode">9.3.2 ErrorCode 열거형</h3>
<p>에러 코드를 열거형으로 관리하면 에러 종류를 중앙에서 일관되게 유지할 수 있다.</p>
<pre class="highlight"><code class="language-java">package com.example.webfluxdemo.exception;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;

@Getter
@RequiredArgsConstructor
public enum ErrorCode {

    // 공통
    INVALID_INPUT(HttpStatus.BAD_REQUEST, "C001", "잘못된 입력값입니다"),
    RESOURCE_NOT_FOUND(HttpStatus.NOT_FOUND, "C002", "리소스를 찾을 수 없습니다"),
    INTERNAL_ERROR(HttpStatus.INTERNAL_SERVER_ERROR, "C003", "서버 내부 오류"),
    DUPLICATE_RESOURCE(HttpStatus.CONFLICT, "C004", "중복된 리소스입니다"),

    // 사용자
    USER_NOT_FOUND(HttpStatus.NOT_FOUND, "U001", "사용자를 찾을 수 없습니다"),
    EMAIL_ALREADY_EXISTS(HttpStatus.CONFLICT, "U002", "이미 등록된 이메일입니다"),

    // 상품
    PRODUCT_NOT_FOUND(HttpStatus.NOT_FOUND, "P001", "상품을 찾을 수 없습니다"),
    INSUFFICIENT_STOCK(HttpStatus.BAD_REQUEST, "P002", "재고가 부족합니다");

    private final HttpStatus status;
    private final String code;
    private final String message;
}</code></pre>
<h3 id="933-errorresponse-dto">9.3.3 ErrorResponse DTO</h3>
<p>클라이언트에 반환할 에러 응답 형식을 정의한다.</p>
<pre class="highlight"><code class="language-java">package com.example.webfluxdemo.exception;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.*;
import java.time.LocalDateTime;
import java.util.List;

@Getter
@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorResponse {

    private final String code;
    private final String message;
    private final int status;
    private final LocalDateTime timestamp;
    private final List&lt;FieldError&gt; errors;

    @Getter @Builder
    public static class FieldError {
        private final String field;
        private final String value;
        private final String reason;
    }

    public static ErrorResponse of(ErrorCode ec) {
        return of(ec, ec.getMessage(), null);
    }

    public static ErrorResponse of(ErrorCode ec, String message) {
        return of(ec, message, null);
    }

    public static ErrorResponse of(ErrorCode ec, List&lt;FieldError&gt; errors) {
        return of(ec, ec.getMessage(), errors);
    }

    private static ErrorResponse of(ErrorCode ec, String msg,
                                    List&lt;FieldError&gt; errors) {
        return ErrorResponse.builder()
            .code(ec.getCode()).message(msg)
            .status(ec.getStatus().value())
            .timestamp(LocalDateTime.now()).errors(errors)
            .build();
    }
}</code></pre>
<h3 id="934-restcontrolleradvice">9.3.4 @RestControllerAdvice 구현</h3>
<p><code>@RestControllerAdvice</code>는 <code>@ControllerAdvice</code>와 <code>@ResponseBody</code>의 조합이다. 모든 컨트롤러에서 발생하는 예외를 한 곳에서 처리한다.</p>
<pre class="highlight"><code class="language-java">package com.example.webfluxdemo.exception;

import jakarta.validation.ConstraintViolationException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.*;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.bind.support.WebExchangeBindException;
import java.util.List;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(WebExchangeBindException.class)
    public ResponseEntity&lt;ErrorResponse&gt; handleValidation(
            WebExchangeBindException ex) {

        List&lt;ErrorResponse.FieldError&gt; fieldErrors = ex.getFieldErrors()
            .stream()
            .map(e -&gt; ErrorResponse.FieldError.builder()
                .field(e.getField())
                .value(e.getRejectedValue() != null
                    ? e.getRejectedValue().toString() : "")
                .reason(e.getDefaultMessage())
                .build())
            .toList();

        log.warn("Validation failed: {}", fieldErrors);
        return ResponseEntity.badRequest()
            .body(ErrorResponse.of(ErrorCode.INVALID_INPUT, fieldErrors));
    }

    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity&lt;ErrorResponse&gt; handleConstraintViolation(
            ConstraintViolationException ex) {
        List&lt;ErrorResponse.FieldError&gt; fieldErrors = ex.getConstraintViolations()
            .stream()
            .map(v -&gt; ErrorResponse.FieldError.builder()
                .field(v.getPropertyPath().toString())
                .reason(v.getMessage()).build())
            .toList();
        return ResponseEntity.badRequest()
            .body(ErrorResponse.of(ErrorCode.INVALID_INPUT, fieldErrors));
    }

    @ExceptionHandler(BusinessException.class)
    public ResponseEntity&lt;ErrorResponse&gt; handleBusiness(
            BusinessException ex) {

        ErrorCode ec = ex.getErrorCode();
        log.warn("Business exception: [{}] {}", ec.getCode(), ex.getMessage());
        return ResponseEntity.status(ec.getStatus())
            .body(ErrorResponse.of(ec, ex.getMessage()));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity&lt;ErrorResponse&gt; handleException(Exception ex) {

        log.error("Unhandled exception", ex);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(ErrorResponse.of(ErrorCode.INTERNAL_ERROR));
    }
}</code></pre>
<h3 id="935">9.3.5 서비스 계층에서 예외 발생</h3>
<p>리액티브 파이프라인 안에서 <code>switchIfEmpty</code>와 <code>Mono.error</code>를 조합하여 예외를 전파한다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class UserService {

    private final UserRepository userRepository;

    public Mono&lt;UserResponse&gt; findById(String id) {
        return userRepository.findById(id)
            .map(UserResponse::from)
            .switchIfEmpty(Mono.error(
                new ResourceNotFoundException("사용자", id)));
    }

    public Mono&lt;UserResponse&gt; createUser(UserCreateRequest request) {
        return userRepository.findByEmail(request.getEmail())
            .flatMap(existing -&gt; Mono.&lt;User&gt;error(
                new DuplicateResourceException("이메일", request.getEmail())))
            .switchIfEmpty(Mono.defer(() -&gt; {
                User user = User.builder()
                    .name(request.getName())
                    .email(request.getEmail())
                    .password(request.getPassword())
                    .build();
                return userRepository.save(user);
            }))
            .map(UserResponse::from);
    }
}</code></pre>
<p>전파된 예외는 <code>GlobalExceptionHandler</code>가 캐치하여 적절한 HTTP 응답으로 변환한다.</p>
<h3 id="936">9.3.6 에러 응답 예시</h3>
<p>검증 실패 시 클라이언트가 받는 응답은 다음과 같다.</p>
<pre class="highlight"><code class="language-json">{
  "code": "C001",
  "message": "잘못된 입력값입니다",
  "status": 400,
  "timestamp": "2026-02-14T10:30:00",
  "errors": [
    { "field": "name", "value": "", "reason": "이름은 필수 입력 항목입니다" },
    { "field": "email", "value": "invalid", "reason": "올바른 이메일 형식이 아닙니다" }
  ]
}</code></pre>
<p>리소스를 찾지 못한 경우는 다음과 같다.</p>
<pre class="highlight"><code class="language-json">{
  "code": "C002",
  "message": "사용자을(를) 찾을 수 없습니다. ID: 64a1b2c3d4e5f6",
  "status": 404,
  "timestamp": "2026-02-14T10:31:00"
}</code></pre>
<hr>
<h2 id="94-errorwebexceptionhandler">9.4 ErrorWebExceptionHandler를 활용한 함수형 예외 처리</h2>
<h3 id="941-controlleradvice">9.4.1 @ControllerAdvice의 한계</h3>
<p><code>@RestControllerAdvice</code>는 어노테이션 기반 컨트롤러에서 잘 동작하지만, 함수형 엔드포인트(<code>RouterFunction</code>)에서 발생하는 예외는 처리하지 못하는 경우가 있다. 특히 라우팅 전에 발생하는 예외나 필터 단계의 예외는 <code>@ExceptionHandler</code>의 범위 밖이다. WebFlux에서 모든 예외를 통합 처리하려면 <code>ErrorWebExceptionHandler</code>를 사용한다.</p>
<h3 id="942-abstracterrorwebexceptionhandler">9.4.2 AbstractErrorWebExceptionHandler 확장</h3>
<p>Spring Boot의 <code>AbstractErrorWebExceptionHandler</code>를 확장하면 기본 에러 처리를 커스터마이징할 수 있다. 핵심은 <code>getRoutingFunction()</code>을 오버라이드하여 모든 에러 요청을 커스텀 렌더 메서드로 보내는 것이다.</p>
<pre class="highlight"><code class="language-java">@Component
@Order(-2) // 기본 에러 핸들러(-1)보다 높은 우선순위
public class CustomErrorWebExceptionHandler
        extends AbstractErrorWebExceptionHandler {

    public CustomErrorWebExceptionHandler(
            ErrorAttributes errorAttributes, WebProperties webProperties,
            ApplicationContext ctx, ServerCodecConfigurer configurer) {
        super(errorAttributes, webProperties.getResources(), ctx);
        this.setMessageWriters(configurer.getWriters());
    }

    @Override
    protected RouterFunction&lt;ServerResponse&gt; getRoutingFunction(
            ErrorAttributes errorAttributes) {
        return RouterFunctions.route(
            RequestPredicates.all(), this::renderErrorResponse);
    }

    private Mono&lt;ServerResponse&gt; renderErrorResponse(ServerRequest request) {
        Throwable error = getError(request);
        HttpStatus status;
        String code, message;

        if (error instanceof BusinessException bex) {
            status = bex.getErrorCode().getStatus();
            code = bex.getErrorCode().getCode();
            message = bex.getMessage();
        } else if (error instanceof WebExchangeBindException) {
            status = HttpStatus.BAD_REQUEST;
            code = "C001"; message = "잘못된 입력값입니다";
        } else {
            status = HttpStatus.INTERNAL_SERVER_ERROR;
            code = "C003"; message = "서버 내부 오류가 발생했습니다";
        }

        Map&lt;String, Object&gt; body = Map.of(
            "code", code, "message", message,
            "status", status.value(),
            "timestamp", LocalDateTime.now().toString(),
            "path", request.path());

        return ServerResponse.status(status)
            .contentType(MediaType.APPLICATION_JSON)
            .body(BodyInserters.fromValue(body));
    }
}</code></pre>
<h3 id="943-controlleradvice">9.4.3 @ControllerAdvice와의 공존</h3>
<p><code>@Order(-2)</code>를 설정한 이유는 기본 <code>DefaultErrorWebExceptionHandler</code>가 <code>@Order(-1)</code>이기 때문이다. 두 방식을 함께 사용할 수 있으며, 처리 순서는 다음과 같다.</p>
<table>
<thead>
<tr>
<th>단계</th>
<th>처리 주체</th>
<th>대상</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>@ExceptionHandler</code></td>
<td>어노테이션 컨트롤러에서 발생한 예외</td>
</tr>
<tr>
<td>2</td>
<td><code>ErrorWebExceptionHandler</code></td>
<td>1단계에서 처리되지 않은 모든 예외</td>
</tr>
</tbody>
</table>
<p>어노테이션 기반 API에서는 <code>@RestControllerAdvice</code>가 예외를 잡고, 함수형 엔드포인트나 필터에서 발생한 예외는 <code>ErrorWebExceptionHandler</code>가 처리하는 구조를 권장한다. 두 방식의 에러 응답 형식을 반드시 통일해야 한다.</p>
<hr>
<h2 id="95-problem-details">9.5 에러 응답 표준화 (Problem Details)</h2>
<h3 id="951-rfc-7807">9.5.1 RFC 7807이란?</h3>
<p>RFC 7807(Problem Details for HTTP APIs)은 HTTP API에서 에러 응답의 표준 형식을 정의한 규격이다.</p>
<table>
<thead>
<tr>
<th>필드</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>type</code></td>
<td>에러 유형을 식별하는 URI</td>
</tr>
<tr>
<td><code>title</code></td>
<td>에러의 짧은 요약</td>
</tr>
<tr>
<td><code>status</code></td>
<td>HTTP 상태 코드</td>
</tr>
<tr>
<td><code>detail</code></td>
<td>에러의 상세 설명</td>
</tr>
<tr>
<td><code>instance</code></td>
<td>에러가 발생한 구체적 URI</td>
</tr>
</tbody>
</table>
<p>Content-Type은 <code>application/problem+json</code>을 사용한다.</p>
<h3 id="952-spring-framework-6-problemdetail">9.5.2 Spring Framework 6의 ProblemDetail</h3>
<p>Spring Framework 6부터는 <code>ProblemDetail</code> 클래스를 기본 제공한다. <code>setProperty()</code>로 확장 필드를 추가할 수 있다.</p>
<pre class="highlight"><code class="language-java">// ProblemDetail의 주요 구조
public class ProblemDetail {
    private URI type;
    private String title;
    private int status;
    private String detail;
    private URI instance;
    private Map&lt;String, Object&gt; properties; // 확장 필드
}</code></pre>
<h3 id="953-problemdetail">9.5.3 ProblemDetail 기반 글로벌 예외 처리</h3>
<p>9.3절의 <code>GlobalExceptionHandler</code>를 <code>ProblemDetail</code>을 반환하도록 리팩터링한다. 반환 타입을 <code>ResponseEntity&lt;ErrorResponse&gt;</code> 대신 <code>ProblemDetail</code>로 변경하면 된다.</p>
<pre class="highlight"><code class="language-java">package com.example.webfluxdemo.exception;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.*;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.bind.support.WebExchangeBindException;
import java.net.URI;
import java.time.Instant;
import java.util.*;

@Slf4j
@RestControllerAdvice
public class ProblemDetailExceptionHandler {

    private static final String BASE_TYPE = "https://api.example.com/errors/";

    @ExceptionHandler(WebExchangeBindException.class)
    public ProblemDetail handleValidation(WebExchangeBindException ex) {
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(
            HttpStatus.BAD_REQUEST, "입력값 검증에 실패했습니다");
        problem.setType(URI.create(BASE_TYPE + "validation-failed"));
        problem.setTitle("Validation Failed");
        problem.setProperty("errors", ex.getFieldErrors().stream()
            .map(fe -&gt; Map.of("field", fe.getField(),
                "message", Objects.toString(fe.getDefaultMessage(), "")))
            .toList());
        problem.setProperty("timestamp", Instant.now());
        return problem;
    }

    @ExceptionHandler(BusinessException.class)
    public ProblemDetail handleBusiness(BusinessException ex) {
        ErrorCode ec = ex.getErrorCode();
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(
            ec.getStatus(), ex.getMessage());
        problem.setType(URI.create(BASE_TYPE + ec.getCode()));
        problem.setTitle(ec.getMessage());
        problem.setProperty("errorCode", ec.getCode());
        problem.setProperty("timestamp", Instant.now());
        return problem;
    }

    @ExceptionHandler(Exception.class)
    public ProblemDetail handleUnhandled(Exception ex) {
        log.error("Unhandled exception", ex);
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(
            HttpStatus.INTERNAL_SERVER_ERROR, "서버 내부 오류가 발생했습니다");
        problem.setType(URI.create(BASE_TYPE + "internal-error"));
        problem.setTitle("Internal Server Error");
        problem.setProperty("timestamp", Instant.now());
        return problem;
    }
}</code></pre>
<h3 id="954-problemdetail">9.5.4 ProblemDetail 응답 예시</h3>
<p>검증 실패 시 응답은 <code>application/problem+json</code> 타입으로 반환된다.</p>
<pre class="highlight"><code class="language-json">{
  "type": "https://api.example.com/errors/validation-failed",
  "title": "Validation Failed",
  "status": 400,
  "detail": "입력값 검증에 실패했습니다",
  "errors": [
    { "field": "name", "message": "이름은 필수 입력 항목입니다" },
    { "field": "price", "message": "가격은 양수여야 합니다" }
  ],
  "timestamp": "2026-02-14T01:30:00Z"
}</code></pre>
<p>비즈니스 예외 응답은 다음과 같다.</p>
<pre class="highlight"><code class="language-json">{
  "type": "https://api.example.com/errors/U002",
  "title": "이미 등록된 이메일입니다",
  "status": 409,
  "detail": "이메일이(가) 이미 존재합니다. 필드: user@example.com",
  "errorCode": "U002",
  "timestamp": "2026-02-14T01:31:00Z"
}</code></pre>
<h3 id="955-problemdetail">9.5.5 ProblemDetail 활성화 설정</h3>
<p>Spring Boot 3에서 <code>ProblemDetail</code>을 완전히 활성화하려면 <code>application.yml</code>에 다음 설정을 추가한다.</p>
<pre class="highlight"><code class="language-yaml">spring:
  webflux:
    problemdetails:
      enabled: true</code></pre>
<p>이 설정을 활성화하면 Spring이 기본으로 처리하는 예외(404 Not Found, 405 Method Not Allowed 등)도 <code>ProblemDetail</code> 형식으로 반환된다.</p>
<h3 id="956-errorwebexceptionhandler-problemdetail">9.5.6 ErrorWebExceptionHandler에서 ProblemDetail 사용</h3>
<p>9.4절의 <code>ErrorWebExceptionHandler</code>에서도 <code>ProblemDetail</code> 형식을 적용할 수 있다. <code>renderErrorResponse</code> 메서드에서 <code>Map</code> 대신 <code>ProblemDetail</code>을 생성하고, Content-Type을 <code>MediaType.APPLICATION_PROBLEM_JSON</code>으로 설정하면 된다.</p>
<pre class="highlight"><code class="language-java">private Mono&lt;ServerResponse&gt; renderErrorResponse(ServerRequest request) {
    Throwable error = getError(request);
    HttpStatus status = (error instanceof BusinessException bex)
        ? bex.getErrorCode().getStatus()
        : HttpStatus.INTERNAL_SERVER_ERROR;

    ProblemDetail problem = ProblemDetail.forStatusAndDetail(
        status, error.getMessage());
    problem.setInstance(URI.create(request.path()));
    problem.setProperty("timestamp", Instant.now());

    return ServerResponse.status(status)
        .contentType(MediaType.APPLICATION_PROBLEM_JSON)
        .body(BodyInserters.fromValue(problem));
}</code></pre>
<p><code>APPLICATION_PROBLEM_JSON</code>을 사용하면 Content-Type이 <code>application/problem+json</code>으로 설정되어 RFC 7807 표준을 온전히 준수한다.</p>
<hr>
<h2 id="_2">요약</h2>
<p>이번 장에서 다룬 핵심 내용을 정리한다.</p>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 내용</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Bean Validation</strong></td>
<td><code>@NotBlank</code>, <code>@Email</code>, <code>@Pattern</code> 등으로 DTO 필드를 선언적으로 검증, 컨트롤러에서 <code>@Valid</code>로 활성화</td>
</tr>
<tr>
<td><strong>커스텀 Validator</strong></td>
<td><code>ConstraintValidator</code> 구현으로 비즈니스 규칙 검증, 클래스 레벨 어노테이션으로 크로스 필드 검증</td>
</tr>
<tr>
<td><strong>@RestControllerAdvice</strong></td>
<td><code>@ExceptionHandler</code>로 예외 유형별 처리, <code>ErrorResponse</code> DTO로 일관된 응답 반환</td>
</tr>
<tr>
<td><strong>ErrorWebExceptionHandler</strong></td>
<td><code>AbstractErrorWebExceptionHandler</code> 확장으로 함수형 엔드포인트 포함 모든 예외 통합 처리</td>
</tr>
<tr>
<td><strong>Problem Details</strong></td>
<td>RFC 7807 기반 <code>ProblemDetail</code> 클래스로 에러 응답 표준화, <code>application/problem+json</code> 타입 사용</td>
</tr>
</tbody>
</table>
<p>다음 장에서는 WebFlux 필터와 인터셉터를 다루며, <code>WebFilter</code>, <code>HandlerFilterFunction</code>을 활용한 요청/응답 로깅, CORS 설정, 요청 속도 제한 등을 살펴본다.</p>
<hr>
<h1 id="chapter-10-webflux">Chapter 10. WebFlux 필터와 인터셉터</h1>
<p>Chapter 9에서 데이터 검증과 예외 처리를 다루었다. 이번 장에서는 요청과 응답의 <strong>횡단 관심사(cross-cutting concerns)</strong>를 처리하는 필터와 인터셉터를 살펴본다. Spring MVC의 <code>Filter</code>와 <code>HandlerInterceptor</code>에 대응하는 WebFlux의 <code>WebFilter</code>와 <code>HandlerFilterFunction</code>을 구현하고, 로깅, CORS, 속도 제한까지 실전에서 자주 사용하는 패턴을 모두 다룬다.</p>
<hr>
<h2 id="101-webfilter">10.1 WebFilter 구현</h2>
<h3 id="1011-webfilter">10.1.1 WebFilter 인터페이스 이해</h3>
<p><code>WebFilter</code>는 Spring WebFlux에서 모든 HTTP 요청에 대해 공통 로직을 실행할 수 있는 서블릿 필터 대응 인터페이스다. 어노테이션 기반 컨트롤러와 함수형 엔드포인트 모두에 적용된다.</p>
<pre class="highlight"><code class="language-java">public interface WebFilter {
    Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain);
}</code></pre>
<table>
<thead>
<tr>
<th>파라미터</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ServerWebExchange</code></td>
<td>HTTP 요청(<code>ServerHttpRequest</code>)과 응답(<code>ServerHttpResponse</code>)을 모두 담고 있는 컨텍스트 객체</td>
</tr>
<tr>
<td><code>WebFilterChain</code></td>
<td>다음 필터 또는 핸들러로 요청을 전달하는 체인</td>
</tr>
</tbody>
</table>
<p>핵심 원리는 <strong>필터 체인</strong> 패턴이다. 각 필터는 <code>chain.filter(exchange)</code>를 호출하여 다음 단계로 요청을 넘기고, 반환값인 <code>Mono&lt;Void&gt;</code>에 연산자를 체이닝하여 응답 후처리를 수행한다.</p>
<pre class="highlight"><code>[클라이언트] → [WebFilter 1] → [WebFilter 2] → ... → [핸들러]
                                                         ↓
[클라이언트] ← [WebFilter 1] ← [WebFilter 2] ← ... ← [응답]</code></pre>
<h3 id="1012">10.1.2 요청 전후 처리 필터</h3>
<p><code>@Component</code>로 등록하면 스프링이 자동으로 필터 체인에 추가한다. <code>chain.filter()</code> 호출 전후로 코드를 배치하여 요청과 응답 양쪽을 처리할 수 있다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Component
public class RequestTimingFilter implements WebFilter {

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        // === 전처리 ===
        long startTime = System.currentTimeMillis();
        String method = exchange.getRequest().getMethod().name();
        String path = exchange.getRequest().getURI().getPath();

        log.info("&gt;&gt;&gt; 요청 시작: {} {}", method, path);

        return chain.filter(exchange)
            // === 후처리 ===
            .doFinally(signalType -&gt; {
                long duration = System.currentTimeMillis() - startTime;
                log.info("&lt;&lt;&lt; 요청 완료: {} {} - {}ms [{}]",
                    method, path, duration, signalType);
            });
    }
}</code></pre>
<blockquote>
<p><strong>주의</strong>: <code>then(Mono.fromRunnable(...))</code>은 정상 완료 시에만 실행된다. 에러를 포함한 모든 경우를 처리하려면 위 예시처럼 <code>doFinally</code>를 사용해야 한다.</p>
</blockquote>
<h3 id="1013-order">10.1.3 @Order로 필터 실행 순서 지정</h3>
<p>여러 WebFilter가 등록된 경우 <code>@Order</code> 어노테이션으로 실행 순서를 제어한다. 값이 작을수록 먼저 실행된다.</p>
<pre class="highlight"><code class="language-java">@Component
@Order(1)
public class SecurityCheckFilter implements WebFilter { /* 보안 검사 */ }

@Component
@Order(2)
public class LoggingFilter implements WebFilter { /* 로깅 */ }

@Component
@Order(3)
public class MetricsFilter implements WebFilter { /* 메트릭 수집 */ }</code></pre>
<p><code>Ordered</code> 인터페이스를 구현하는 방법도 있다.</p>
<pre class="highlight"><code class="language-java">@Component
public class HighPriorityFilter implements WebFilter, Ordered {
    @Override
    public int getOrder() { return Ordered.HIGHEST_PRECEDENCE; }

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        return chain.filter(exchange);
    }
}</code></pre>
<h3 id="1014">10.1.4 조건부 필터 적용과 요청 차단</h3>
<p>WebFilter는 기본적으로 <strong>모든 요청</strong>에 적용된다. 특정 경로에만 필터를 적용하려면 내부에서 경로를 확인하고, 요청을 차단하려면 <code>chain.filter()</code>를 호출하지 않고 응답을 즉시 완료한다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Component
@Order(1)
public class ApiKeyFilter implements WebFilter {

    private static final String API_KEY_HEADER = "X-API-Key";
    private static final String VALID_API_KEY = "my-secret-api-key";

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        String path = exchange.getRequest().getURI().getPath();

        // /api/** 경로에만 필터 적용
        if (!path.startsWith("/api/")) {
            return chain.filter(exchange);
        }

        String apiKey = exchange.getRequest().getHeaders().getFirst(API_KEY_HEADER);
        if (VALID_API_KEY.equals(apiKey)) {
            return chain.filter(exchange);
        }

        // 요청 차단: chain.filter()를 호출하지 않고 응답 완료
        log.warn("유효하지 않은 API Key 요청: {}", path);
        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
        return exchange.getResponse().setComplete();
    }
}</code></pre>
<h3 id="1015-attribute">10.1.5 요청 속성(Attribute) 전달</h3>
<p>필터에서 설정한 데이터를 다운스트림 핸들러로 전달할 때 <code>ServerWebExchange</code>의 속성을 활용한다.</p>
<pre class="highlight"><code class="language-java">@Component
@Order(0)
public class RequestContextFilter implements WebFilter {
    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        String requestId = UUID.randomUUID().toString().substring(0, 8);
        exchange.getAttributes().put("requestId", requestId);
        exchange.getResponse().getHeaders().add("X-Request-Id", requestId);
        return chain.filter(exchange);
    }
}

// 컨트롤러에서 속성 사용
@GetMapping("/api/products")
public Mono&lt;ResponseEntity&lt;List&lt;Product&gt;&gt;&gt; getProducts(ServerWebExchange exchange) {
    String requestId = exchange.getAttribute("requestId");
    log.info("[{}] 상품 목록 조회 요청", requestId);
    // ...
}</code></pre>
<hr>
<h2 id="102-handlerfilterfunction">10.2 HandlerFilterFunction 활용</h2>
<h3 id="1021-webfilter-handlerfilterfunction">10.2.1 WebFilter와 HandlerFilterFunction 비교</h3>
<p><code>HandlerFilterFunction</code>은 <strong>함수형 엔드포인트(RouterFunction)</strong> 전용 필터다.</p>
<pre class="highlight"><code class="language-java">@FunctionalInterface
public interface HandlerFilterFunction&lt;T extends ServerResponse, R extends ServerResponse&gt; {
    Mono&lt;R&gt; filter(ServerRequest request, HandlerFunction&lt;T&gt; next);
}</code></pre>
<table>
<thead>
<tr>
<th>항목</th>
<th>WebFilter</th>
<th>HandlerFilterFunction</th>
</tr>
</thead>
<tbody>
<tr>
<td>적용 대상</td>
<td>모든 요청 (어노테이션 + 함수형)</td>
<td>함수형 엔드포인트만</td>
</tr>
<tr>
<td>적용 범위</td>
<td>글로벌</td>
<td>특정 RouterFunction</td>
</tr>
<tr>
<td>접근 객체</td>
<td><code>ServerWebExchange</code></td>
<td><code>ServerRequest</code> / <code>ServerResponse</code></td>
</tr>
<tr>
<td>등록 방법</td>
<td><code>@Component</code> 자동 등록</td>
<td><code>RouterFunction.filter()</code></td>
</tr>
</tbody>
</table>
<h3 id="1022">10.2.2 기본 사용법</h3>
<p><code>RouterFunction</code>의 <code>filter()</code> 메서드에 람다로 필터를 전달한다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class ProductRouter {
    @Bean
    public RouterFunction&lt;ServerResponse&gt; productRoutes(ProductHandler handler) {
        return nest(path("/api/products"),
            route(GET(""), handler::getAll)
            .andRoute(POST(""), handler::create)
            .andRoute(PUT("/{id}"), handler::update)
            .andRoute(DELETE("/{id}"), handler::delete)
        )
        .filter((request, next) -&gt; {
            log.info("Product API 요청: {} {}", request.method(), request.path());
            return next.handle(request);
        });
    }
}</code></pre>
<h3 id="1023">10.2.3 인증 필터 구현</h3>
<p>실제 프로젝트에서 자주 사용하는 인증 필터를 <code>HandlerFilterFunction</code>으로 구현한다.</p>
<pre class="highlight"><code class="language-java">public class AuthFilterFunction
        implements HandlerFilterFunction&lt;ServerResponse, ServerResponse&gt; {

    private final TokenValidator tokenValidator;

    public AuthFilterFunction(TokenValidator tokenValidator) {
        this.tokenValidator = tokenValidator;
    }

    @Override
    public Mono&lt;ServerResponse&gt; filter(ServerRequest request,
                                       HandlerFunction&lt;ServerResponse&gt; next) {
        String authHeader = request.headers().firstHeader("Authorization");

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            return ServerResponse.status(HttpStatus.UNAUTHORIZED)
                .bodyValue(Map.of("error", "Authorization 헤더가 필요합니다."));
        }

        String token = authHeader.substring(7);

        return tokenValidator.validate(token)
            .flatMap(userId -&gt; {
                ServerRequest modifiedRequest = ServerRequest.from(request)
                    .attribute("userId", userId)
                    .build();
                return next.handle(modifiedRequest);
            })
            .onErrorResume(InvalidTokenException.class, e -&gt;
                ServerResponse.status(HttpStatus.UNAUTHORIZED)
                    .bodyValue(Map.of("error", e.getMessage()))
            );
    }
}</code></pre>
<p>라우터에서 공개 API와 보호된 API를 분리하여 인증 필터를 선택적으로 적용한다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class AppRouter {

    private final TokenValidator tokenValidator;

    public AppRouter(TokenValidator tokenValidator) {
        this.tokenValidator = tokenValidator;
    }

    @Bean
    public RouterFunction&lt;ServerResponse&gt; routes(
            ProductHandler productHandler, AuthHandler authHandler) {

        // 인증 불필요: 공개 API
        RouterFunction&lt;ServerResponse&gt; publicRoutes = route(
            POST("/api/auth/login"), authHandler::login
        ).andRoute(
            POST("/api/auth/register"), authHandler::register
        );

        // 인증 필요: 보호된 API
        RouterFunction&lt;ServerResponse&gt; protectedRoutes = nest(path("/api/products"),
            route(GET(""), productHandler::getAll)
            .andRoute(POST(""), productHandler::create)
            .andRoute(DELETE("/{id}"), productHandler::delete)
        ).filter(new AuthFilterFunction(tokenValidator));

        return publicRoutes.and(protectedRoutes);
    }
}</code></pre>
<h3 id="1024">10.2.4 역할 기반 접근 제어 필터</h3>
<p>인증 필터를 확장하여 역할(Role) 기반 인가 필터도 구현할 수 있다. 여러 필터를 체이닝하면 인증 -&gt; 인가 순서로 적용된다.</p>
<pre class="highlight"><code class="language-java">public class RoleFilterFunction
        implements HandlerFilterFunction&lt;ServerResponse, ServerResponse&gt; {

    private final Set&lt;String&gt; allowedRoles;

    public RoleFilterFunction(String... roles) {
        this.allowedRoles = Set.of(roles);
    }

    @Override
    public Mono&lt;ServerResponse&gt; filter(ServerRequest request,
                                       HandlerFunction&lt;ServerResponse&gt; next) {
        String userRole = request.attribute("userRole")
            .map(Object::toString).orElse("");

        if (allowedRoles.contains(userRole)) {
            return next.handle(request);
        }
        return ServerResponse.status(HttpStatus.FORBIDDEN)
            .bodyValue(Map.of("error", "접근 권한이 없습니다."));
    }
}

// 관리자 전용 API에 인증 + 역할 필터 체이닝
RouterFunction&lt;ServerResponse&gt; adminRoutes = nest(path("/api/admin"),
    route(GET("/users"), adminHandler::getAllUsers)
    .andRoute(DELETE("/users/{id}"), adminHandler::deleteUser)
)
.filter(new AuthFilterFunction(tokenValidator))
.filter(new RoleFilterFunction("ADMIN"));</code></pre>
<hr>
<h2 id="103">10.3 요청/응답 로깅</h2>
<h3 id="1031">10.3.1 요청 로깅 필터</h3>
<p>운영 환경에서 요청 정보를 체계적으로 기록하는 로깅 필터를 구현한다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
public class RequestLoggingFilter implements WebFilter {

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String requestId = UUID.randomUUID().toString().substring(0, 8);
        String method = request.getMethod().name();
        String path = request.getURI().getPath();
        String clientIp = extractClientIp(request);

        log.info("[{}] &gt;&gt;&gt; {} {} ip={}", requestId, method, path, clientIp);

        long startTime = System.nanoTime();
        exchange.getResponse().getHeaders().add("X-Request-Id", requestId);
        exchange.getAttributes().put("requestId", requestId);

        return chain.filter(exchange)
            .doFinally(signalType -&gt; {
                long durationMs = (System.nanoTime() - startTime) / 1_000_000;
                HttpStatusCode status = exchange.getResponse().getStatusCode();
                log.info("[{}] &lt;&lt;&lt; {} {} -&gt; {} ({}ms)",
                    requestId, method, path, status, durationMs);
            });
    }

    private String extractClientIp(ServerHttpRequest request) {
        String xff = request.getHeaders().getFirst("X-Forwarded-For");
        if (xff != null &amp;&amp; !xff.isEmpty()) {
            return xff.split(",")[0].trim();
        }
        return Optional.ofNullable(request.getRemoteAddress())
            .map(addr -&gt; addr.getAddress().getHostAddress())
            .orElse("unknown");
    }
}</code></pre>
<h3 id="1032-serverhttpresponsedecorator">10.3.2 응답 바디 로깅 (ServerHttpResponseDecorator)</h3>
<p>응답 바디는 스트림 형태이므로 직접 읽을 수 없다. <code>ServerHttpResponseDecorator</code>로 <code>writeWith</code>를 오버라이드하여 쓰기 시점에 바이트를 가로채 기록한다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Component
@Order(Ordered.HIGHEST_PRECEDENCE + 1)
public class ResponseBodyLoggingFilter implements WebFilter {

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        if (!log.isDebugEnabled()) return chain.filter(exchange);

        String requestId = exchange.getAttribute("requestId");
        ServerHttpResponse original = exchange.getResponse();

        ServerHttpResponseDecorator decorated = new ServerHttpResponseDecorator(original) {
            @Override
            public Mono&lt;Void&gt; writeWith(Publisher&lt;? extends DataBuffer&gt; body) {
                if (body instanceof Flux&lt;? extends DataBuffer&gt; fluxBody) {
                    return super.writeWith(fluxBody.buffer().map(dataBuffers -&gt; {
                        DataBuffer joined = original.bufferFactory().join(dataBuffers);
                        byte[] content = new byte[joined.readableByteCount()];
                        joined.read(content);
                        DataBufferUtils.release(joined);
                        log.debug("[{}] 응답 바디: {}", requestId,
                            new String(content, StandardCharsets.UTF_8));
                        return original.bufferFactory().wrap(content);
                    }));
                }
                return super.writeWith(body);
            }
        };
        return chain.filter(exchange.mutate().response(decorated).build());
    }
}</code></pre>
<blockquote>
<p><strong>주의</strong>: 응답 바디 로깅은 메모리와 성능에 영향을 미친다. 반드시 디버그 레벨에서만 활성화하고, 대용량 응답에서는 크기 제한 로직을 추가해야 한다.</p>
</blockquote>
<h3 id="1033-id-reactor-context">10.3.3 요청 추적 ID와 Reactor Context</h3>
<p>리액티브 환경에서는 스레드가 수시로 전환되므로 기존 <code>MDC</code>가 정상 작동하지 않는다. Reactor의 <strong>Context</strong>를 활용하여 추적 ID를 전파한다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
public class TraceIdFilter implements WebFilter {

    private static final String TRACE_ID_KEY = "traceId";

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        String traceId = Optional.ofNullable(
                exchange.getRequest().getHeaders().getFirst("X-Trace-Id")
            ).orElse(UUID.randomUUID().toString());

        exchange.getResponse().getHeaders().add("X-Trace-Id", traceId);

        return chain.filter(exchange)
            .contextWrite(Context.of(TRACE_ID_KEY, traceId));
    }
}</code></pre>
<p>서비스 계층에서 Context의 추적 ID를 활용한다.</p>
<pre class="highlight"><code class="language-java">@Service
@Slf4j
public class ProductService {
    public Mono&lt;Product&gt; findById(String id) {
        return Mono.deferContextual(ctx -&gt; {
            String traceId = ctx.getOrDefault("traceId", "N/A");
            log.info("[{}] 상품 조회: id={}", traceId, id);
            return productRepository.findById(id);
        });
    }
}</code></pre>
<p>Spring Boot 3.x에서는 Micrometer <strong>Context Propagation</strong>을 사용하면 MDC 자동 전파를 구성할 수 있다.</p>
<pre class="highlight"><code class="language-yaml">spring:
  reactor:
    context-propagation: auto</code></pre>
<hr>
<h2 id="104-cors">10.4 CORS 설정</h2>
<h3 id="1041-cors">10.4.1 CORS 개요</h3>
<p>브라우저는 <strong>동일 출처 정책(Same-Origin Policy)</strong>을 적용한다. 프런트엔드(<code>http://localhost:3000</code>)에서 백엔드(<code>http://localhost:8080</code>)를 호출하면 출처가 다르므로 CORS 에러가 발생한다. 서버에서 적절한 CORS 헤더를 응답에 포함해야 한다.</p>
<table>
<thead>
<tr>
<th>CORS 헤더</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Access-Control-Allow-Origin</code></td>
<td>허용할 출처</td>
</tr>
<tr>
<td><code>Access-Control-Allow-Methods</code></td>
<td>허용할 HTTP 메서드</td>
</tr>
<tr>
<td><code>Access-Control-Allow-Headers</code></td>
<td>허용할 요청 헤더</td>
</tr>
<tr>
<td><code>Access-Control-Allow-Credentials</code></td>
<td>쿠키/인증 정보 포함 허용 여부</td>
</tr>
<tr>
<td><code>Access-Control-Max-Age</code></td>
<td>Preflight 요청 캐시 시간(초)</td>
</tr>
</tbody>
</table>
<h3 id="1042-webfluxconfigurer">10.4.2 WebFluxConfigurer를 이용한 글로벌 설정</h3>
<p>가장 권장되는 방법으로, 모든 엔드포인트에 일괄 적용된다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class CorsConfig implements WebFluxConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
            .allowedOrigins("http://localhost:3000", "https://myapp.example.com")
            .allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS")
            .allowedHeaders("*")
            .exposedHeaders("X-Request-Id", "X-Trace-Id")
            .allowCredentials(true)
            .maxAge(3600);
    }
}</code></pre>
<h3 id="1043-crossorigin">10.4.3 @CrossOrigin 어노테이션</h3>
<p>컨트롤러 또는 개별 메서드 레벨에서 세밀하게 CORS를 설정할 수 있다. 클래스 레벨과 메서드 레벨 설정이 동시에 존재하면 <strong>병합</strong>된다.</p>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/products")
@CrossOrigin(origins = "http://localhost:3000", maxAge = 3600)
public class ProductController {

    @CrossOrigin(origins = "https://partner.example.com")
    @GetMapping("/{id}")
    public Mono&lt;Product&gt; getById(@PathVariable String id) {
        return productService.findById(id);
    }
}</code></pre>
<h3 id="1044-corswebfilter">10.4.4 CorsWebFilter (프로그래밍 방식)</h3>
<p>함수형 엔드포인트에는 <code>@CrossOrigin</code>을 사용할 수 없다. <code>CorsWebFilter</code>를 빈으로 등록하면 어노테이션 기반과 함수형 모두에 적용된다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class CorsFilterConfig {

    @Bean
    public CorsWebFilter corsWebFilter() {
        CorsConfiguration config = new CorsConfiguration();
        config.addAllowedOrigin("http://localhost:3000");
        config.addAllowedOrigin("https://myapp.example.com");
        config.addAllowedMethod("*");
        config.addAllowedHeader("*");
        config.addExposedHeader("X-Request-Id");
        config.setAllowCredentials(true);
        config.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/api/**", config);
        return new CorsWebFilter(source);
    }
}</code></pre>
<h3 id="1045-cors">10.4.5 환경별 CORS 설정</h3>
<p>개발과 운영 환경마다 허용 출처가 다른 경우 <code>application.yml</code> 프로파일과 <code>@Value</code>를 조합한다.</p>
<pre class="highlight"><code class="language-yaml"># application.yml             → app.cors.allowed-origins: "http://localhost:3000"
# application-prod.yml        → app.cors.allowed-origins: "https://myapp.example.com"</code></pre>
<pre class="highlight"><code class="language-java">@Configuration
public class CorsConfig implements WebFluxConfigurer {

    @Value("${app.cors.allowed-origins}")
    private String[] allowedOrigins;

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
            .allowedOrigins(allowedOrigins)
            .allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH")
            .allowedHeaders("*")
            .allowCredentials(true)
            .maxAge(3600);
    }
}</code></pre>
<hr>
<h2 id="105-rate-limiting">10.5 요청 속도 제한(Rate Limiting)</h2>
<h3 id="1051">10.5.1 토큰 버킷 알고리즘</h3>
<p>가장 널리 사용되는 속도 제한 알고리즘이다.</p>
<ol>
<li><strong>버킷</strong>에 토큰이 일정 속도로 채워진다.</li>
<li>요청이 들어오면 버킷에서 토큰 1개를 소비한다.</li>
<li>토큰이 없으면 요청을 거부한다(429 Too Many Requests).</li>
<li>버킷 크기가 고정되어 순간적인 버스트(burst)를 일정 수준까지 허용한다.</li>
</ol>
<pre class="highlight"><code>[토큰 생성기] ---(초당 10개)---&gt; [버킷 (최대 20개)]
                                       ↓
                                 요청 -&gt; 토큰 1개 소비
                                 토큰 부족 -&gt; 429 응답</code></pre>
<h3 id="1052-bucket4j">10.5.2 Bucket4j 의존성</h3>
<p><strong>Bucket4j</strong>는 토큰 버킷 알고리즘의 Java 구현체로, 스레드 안전하며 성능이 뛰어나다. <code>build.gradle.kts</code>에 의존성을 추가한다: <code>implementation("com.bucket4j:bucket4j-core:8.10.1")</code></p>
<h3 id="1053-ip">10.5.3 IP 기반 속도 제한 필터</h3>
<p>클라이언트 IP별로 독립적인 버킷을 관리하는 필터를 구현한다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Component
public class RateLimitFilter implements WebFilter {

    private final Map&lt;String, Bucket&gt; bucketCache = new ConcurrentHashMap&lt;&gt;();

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        String path = exchange.getRequest().getURI().getPath();
        if (!path.startsWith("/api/")) {
            return chain.filter(exchange);
        }

        String clientIp = extractClientIp(exchange);
        Bucket bucket = bucketCache.computeIfAbsent(clientIp, this::createBucket);
        ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);

        if (probe.isConsumed()) {
            exchange.getResponse().getHeaders()
                .add("X-RateLimit-Remaining",
                    String.valueOf(probe.getRemainingTokens()));
            return chain.filter(exchange);
        }

        // 속도 제한 초과 -&gt; 429 응답
        long waitSeconds = probe.getNanosToWaitForRefill() / 1_000_000_000;
        log.warn("속도 제한 초과: IP={}, 재시도까지 {}초", clientIp, waitSeconds);

        exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
        exchange.getResponse().getHeaders().setContentType(MediaType.APPLICATION_JSON);
        exchange.getResponse().getHeaders().add("Retry-After", String.valueOf(waitSeconds));

        String errorBody = """
            {
              "error": "TOO_MANY_REQUESTS",
              "message": "요청 속도 제한을 초과했습니다.",
              "retryAfterSeconds": %d
            }
            """.formatted(waitSeconds);

        return exchange.getResponse().writeWith(
            Mono.just(exchange.getResponse().bufferFactory()
                .wrap(errorBody.getBytes()))
        );
    }

    private Bucket createBucket(String key) {
        Bandwidth limit = Bandwidth.classic(
            10,                                      // 버킷 용량 (버스트)
            Refill.greedy(60, Duration.ofMinutes(1)) // 분당 60개 보충
        );
        return Bucket.builder().addLimit(limit).build();
    }

    private String extractClientIp(ServerWebExchange exchange) {
        String xff = exchange.getRequest().getHeaders().getFirst("X-Forwarded-For");
        if (xff != null &amp;&amp; !xff.isEmpty()) return xff.split(",")[0].trim();
        return Optional.ofNullable(exchange.getRequest().getRemoteAddress())
            .map(addr -&gt; addr.getAddress().getHostAddress()).orElse("unknown");
    }
}</code></pre>
<h3 id="1054">10.5.4 사용자 등급별 차등 속도 제한</h3>
<p>인증된 사용자별로 등급(plan)에 따라 다른 제한을 적용한다. 핵심은 <code>Plan</code> enum으로 등급별 정책을 정의하고, 사용자 ID와 등급을 조합한 키로 버킷을 관리하는 것이다.</p>
<pre class="highlight"><code class="language-java">@Slf4j
@Component
@Order(10)  // 인증 필터 이후에 실행
public class UserRateLimitFilter implements WebFilter {

    private final Map&lt;String, Bucket&gt; bucketCache = new ConcurrentHashMap&lt;&gt;();

    enum Plan {
        FREE(20, Duration.ofMinutes(1)),       // 무료: 분당 20건
        BASIC(100, Duration.ofMinutes(1)),      // 기본: 분당 100건
        PREMIUM(1000, Duration.ofMinutes(1));   // 프리미엄: 분당 1000건

        final int capacity;
        final Duration period;
        Plan(int capacity, Duration period) {
            this.capacity = capacity;
            this.period = period;
        }
    }

    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
        String userId = exchange.getAttribute("userId");
        if (userId == null || !exchange.getRequest().getURI()
                .getPath().startsWith("/api/")) {
            return chain.filter(exchange);
        }

        String userPlan = exchange.getAttribute("userPlan");
        Plan plan = resolvePlan(userPlan);
        Bucket bucket = bucketCache.computeIfAbsent(
            userId + ":" + plan.name(), k -&gt; createBucket(plan));

        ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);

        // 남은 호출 횟수를 헤더로 전달
        exchange.getResponse().getHeaders()
            .add("X-RateLimit-Limit", String.valueOf(plan.capacity));
        exchange.getResponse().getHeaders()
            .add("X-RateLimit-Remaining", String.valueOf(probe.getRemainingTokens()));

        if (probe.isConsumed()) return chain.filter(exchange);

        // 429 응답 (IP 기반 필터와 동일한 패턴)
        exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
        String body = """
            {"error":"TOO_MANY_REQUESTS","plan":"%s","limit":%d}
            """.formatted(plan.name(), plan.capacity);
        return exchange.getResponse().writeWith(
            Mono.just(exchange.getResponse().bufferFactory().wrap(body.getBytes())));
    }

    private Plan resolvePlan(String planStr) {
        try { return Plan.valueOf(planStr.toUpperCase()); }
        catch (Exception e) { return Plan.FREE; }
    }

    private Bucket createBucket(Plan plan) {
        return Bucket.builder().addLimit(Bandwidth.classic(
            plan.capacity, Refill.greedy(plan.capacity, plan.period))).build();
    }
}</code></pre>
<h3 id="1055">10.5.5 엔드포인트별 차등 속도 제한</h3>
<p>로그인 API처럼 브루트포스 공격에 취약한 엔드포인트에는 <code>HandlerFilterFunction</code>으로 더 엄격한 제한을 적용한다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class RateLimitConfig {

    @Bean
    public RouterFunction&lt;ServerResponse&gt; rateLimitedAuthRoutes(AuthHandler handler) {
        return route(POST("/api/auth/login"), handler::login)
            .filter(createRateLimitFilter(5, Duration.ofMinutes(1)))   // 분당 5회
            .andRoute(POST("/api/auth/register"), handler::register)
            .filter(createRateLimitFilter(3, Duration.ofHours(1)));    // 시간당 3회
    }

    private HandlerFilterFunction&lt;ServerResponse, ServerResponse&gt;
            createRateLimitFilter(int capacity, Duration period) {
        Map&lt;String, Bucket&gt; buckets = new ConcurrentHashMap&lt;&gt;();
        return (request, next) -&gt; {
            String ip = request.remoteAddress()
                .map(a -&gt; a.getAddress().getHostAddress()).orElse("unknown");
            Bucket bucket = buckets.computeIfAbsent(ip, k -&gt;
                Bucket.builder().addLimit(
                    Bandwidth.classic(capacity, Refill.greedy(capacity, period))
                ).build());

            if (bucket.tryConsume(1)) return next.handle(request);

            return ServerResponse.status(HttpStatus.TOO_MANY_REQUESTS)
                .bodyValue(Map.of("error", "요청이 너무 많습니다."));
        };
    }
}</code></pre>
<h3 id="1056">10.5.6 버킷 캐시 메모리 관리</h3>
<p><code>ConcurrentHashMap</code>에 IP별 버킷이 무한히 쌓이면 메모리 누수가 발생한다. Caffeine 캐시를 사용하면 자동 만료를 쉽게 구현할 수 있다.</p>
<pre class="highlight"><code class="language-kotlin">dependencies {
    implementation("com.github.ben-manes.caffeine:caffeine:3.1.8")
}</code></pre>
<pre class="highlight"><code class="language-java">private final Cache&lt;String, Bucket&gt; bucketCache = Caffeine.newBuilder()
    .maximumSize(100_000)
    .expireAfterAccess(Duration.ofMinutes(10))
    .build();

// 사용: bucketCache.get(clientIp, this::createBucket)</code></pre>
<hr>
<h2 id="106">10.6 정리</h2>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 기술</th>
<th>적용 범위</th>
</tr>
</thead>
<tbody>
<tr>
<td>WebFilter</td>
<td><code>WebFilter</code> 인터페이스, <code>@Order</code></td>
<td>모든 요청 (글로벌)</td>
</tr>
<tr>
<td>HandlerFilterFunction</td>
<td><code>RouterFunction.filter()</code></td>
<td>함수형 엔드포인트 (선택적)</td>
</tr>
<tr>
<td>요청/응답 로깅</td>
<td><code>ServerHttpResponseDecorator</code>, Reactor Context</td>
<td>전역 로깅, 추적 ID</td>
</tr>
<tr>
<td>CORS</td>
<td><code>WebFluxConfigurer</code>, <code>@CrossOrigin</code>, <code>CorsWebFilter</code></td>
<td>API 전체 또는 개별 엔드포인트</td>
</tr>
<tr>
<td>속도 제한</td>
<td>Bucket4j, 토큰 버킷 알고리즘</td>
<td>IP별, 사용자별, 엔드포인트별</td>
</tr>
</tbody>
</table>
<p><strong>설계 원칙</strong>:
- <strong>글로벌 관심사</strong>(로깅, 추적 ID, CORS)에는 <code>WebFilter</code>를 사용한다.
- <strong>특정 API 그룹에만 적용할 로직</strong>(인증, 인가, 속도 제한)에는 <code>HandlerFilterFunction</code>을 사용한다.
- 필터 순서(<code>@Order</code>)는 명시적으로 관리하여 의도하지 않은 동작을 방지한다.
- 응답 바디 로깅처럼 성능에 영향을 주는 필터는 조건부로 활성화한다.</p>
<p>다음 Chapter 11에서는 <strong>Spring Security WebFlux</strong>를 활용하여 본격적인 인증과 인가를 구현한다. 이번 장에서 직접 구현한 인증 필터가 Spring Security의 <code>SecurityWebFilterChain</code>으로 어떻게 대체되고 확장되는지 비교해 볼 것이다.</p>
<hr>
<h1 id="chapter-11-spring-security-webflux">Chapter 11. 리액티브 보안 (Spring Security WebFlux)</h1>
<p>Spring WebFlux 기반 애플리케이션에서 보안은 서블릿 기반의 Spring Security와 다른 아키텍처로 동작한다. 이번 장에서는 리액티브 환경에 맞는 Spring Security 설정, 인증/인가 구현, JWT 기반 인증, SecurityContext 관리, 그리고 OAuth2 연동까지 단계별로 다룬다.</p>
<hr>
<h2 id="111-spring-security-reactive">11.1 Spring Security Reactive 설정</h2>
<h3 id="1111">11.1.1 의존성 추가</h3>
<p><code>build.gradle</code>에 Spring Security 의존성을 추가한다.</p>
<pre class="highlight"><code class="language-groovy">dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-data-mongodb-reactive'

    // JWT (11.4절), OAuth2 (11.6절)
    implementation 'io.jsonwebtoken:jjwt-api:0.12.6'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.12.6'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.12.6'
    implementation 'org.springframework.boot:spring-boot-starter-oauth2-client'
    implementation 'org.springframework.boot:spring-boot-starter-oauth2-resource-server'

    testImplementation 'org.springframework.security:spring-security-test'
}</code></pre>
<p>의존성을 추가하는 것만으로 Spring Security가 활성화되며, 모든 엔드포인트에 기본 인증이 적용된다.</p>
<h3 id="1112">11.1.2 서블릿 기반과의 차이</h3>
<table>
<thead>
<tr>
<th>구분</th>
<th>Servlet (Spring MVC)</th>
<th>Reactive (Spring WebFlux)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>필터 체인</strong></td>
<td><code>SecurityFilterChain</code></td>
<td><code>SecurityWebFilterChain</code> (<code>WebFilter</code>)</td>
</tr>
<tr>
<td><strong>설정 빌더</strong></td>
<td><code>HttpSecurity</code></td>
<td><code>ServerHttpSecurity</code></td>
</tr>
<tr>
<td><strong>인증 저장소</strong></td>
<td><code>SecurityContextHolder</code> (ThreadLocal)</td>
<td><code>ReactiveSecurityContextHolder</code> (Reactor Context)</td>
</tr>
<tr>
<td><strong>UserDetailsService</strong></td>
<td><code>UserDetailsService</code></td>
<td><code>ReactiveUserDetailsService</code></td>
</tr>
<tr>
<td><strong>인증 매니저</strong></td>
<td><code>AuthenticationManager</code></td>
<td><code>ReactiveAuthenticationManager</code></td>
</tr>
<tr>
<td><strong>메서드 보안</strong></td>
<td><code>@EnableMethodSecurity</code></td>
<td><code>@EnableReactiveMethodSecurity</code></td>
</tr>
</tbody>
</table>
<p>가장 중요한 차이는 <strong>SecurityContext 저장 방식</strong>이다. 서블릿 환경에서는 <code>ThreadLocal</code>에 인증 정보를 저장하지만, 리액티브 환경에서는 하나의 요청이 여러 스레드에서 처리될 수 있으므로 <strong>Reactor의 Context</strong>를 사용한다.</p>
<h3 id="1113">11.1.3 기본 보안 설정 클래스</h3>
<p><code>@EnableWebFluxSecurity</code>로 리액티브 보안을 활성화하고, <code>SecurityWebFilterChain</code> 빈을 정의한다.</p>
<pre class="highlight"><code class="language-java">@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        return http
            .authorizeExchange(exchanges -&gt; exchanges
                .anyExchange().authenticated()
            )
            .httpBasic(Customizer.withDefaults())
            .formLogin(Customizer.withDefaults())
            .build();
    }
}</code></pre>
<p><code>Customizer.withDefaults()</code>는 Spring Security 6.1부터 권장되는 설정 방식이다.</p>
<hr>
<h2 id="112-securitywebfilterchain">11.2 SecurityWebFilterChain 구성</h2>
<h3 id="1121-serverhttpsecurity">11.2.1 ServerHttpSecurity 주요 설정</h3>
<p><code>ServerHttpSecurity</code>는 리액티브 보안 설정의 빌더 역할을 한다.</p>
<pre class="highlight"><code class="language-java">@Bean
public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
    return http
        .authorizeExchange(exchanges -&gt; exchanges
            .pathMatchers(HttpMethod.GET, "/api/products/**").permitAll()
            .pathMatchers(HttpMethod.POST, "/api/products/**").hasRole("ADMIN")
            .pathMatchers("/api/admin/**").hasRole("ADMIN")
            .pathMatchers("/api/users/signup", "/api/users/login").permitAll()
            .anyExchange().authenticated()
        )
        .httpBasic(Customizer.withDefaults())
        .csrf(csrf -&gt; csrf.disable())
        .cors(cors -&gt; cors.configurationSource(corsConfigurationSource()))
        .formLogin(formLogin -&gt; formLogin.disable())
        .build();
}</code></pre>
<h3 id="1122-authorizeexchange">11.2.2 authorizeExchange 상세 설정</h3>
<p><code>authorizeExchange</code>에서 사용할 수 있는 다양한 매처와 접근 규칙을 정리한다.</p>
<pre class="highlight"><code class="language-java">.authorizeExchange(exchanges -&gt; exchanges
    // HTTP 메서드 + 경로 조합
    .pathMatchers(HttpMethod.GET, "/api/products/**").permitAll()
    .pathMatchers(HttpMethod.DELETE, "/api/**").hasRole("ADMIN")

    // 역할/권한 기반 인가
    .pathMatchers("/api/manager/**").hasAnyRole("ADMIN", "MANAGER")
    .pathMatchers("/api/reports/**").hasAuthority("REPORT_READ")

    // 커스텀 인가 로직
    .pathMatchers("/api/users/{userId}/**")
        .access((authentication, context) -&gt; {
            String userId = context.getVariables().get("userId");
            return authentication
                .map(auth -&gt; auth.getName().equals(userId))
                .map(AuthorizationDecision::new);
        })

    .anyExchange().authenticated()
)</code></pre>
<h3 id="1123-csrf-cors">11.2.3 CSRF와 CORS 설정</h3>
<p>REST API 서버에서는 일반적으로 CSRF를 비활성화한다. 브라우저 기반 애플리케이션에서는 쿠키 기반 CSRF 토큰을 사용한다.</p>
<pre class="highlight"><code class="language-java">// REST API: CSRF 비활성화
.csrf(csrf -&gt; csrf.disable())

// 브라우저 기반: 쿠키 CSRF 토큰
.csrf(csrf -&gt; csrf
    .csrfTokenRepository(CookieServerCsrfTokenRepository.withHttpOnlyFalse()))</code></pre>
<p>CORS는 <code>CorsConfigurationSource</code> 빈으로 설정한다.</p>
<pre class="highlight"><code class="language-java">@Bean
public CorsConfigurationSource corsConfigurationSource() {
    CorsConfiguration config = new CorsConfiguration();
    config.setAllowedOrigins(List.of("http://localhost:3000"));
    config.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
    config.setAllowedHeaders(List.of("*"));
    config.setAllowCredentials(true);

    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/api/**", config);
    return source;
}</code></pre>
<hr>
<h2 id="113">11.3 인증과 인가 구현</h2>
<h3 id="1131-reactiveuserdetailsservice">11.3.1 ReactiveUserDetailsService</h3>
<p>리액티브 환경에서는 <code>ReactiveUserDetailsService</code>를 구현한다. <code>findByUsername()</code>이 <code>Mono&lt;UserDetails&gt;</code>를 반환한다. 먼저 사용자 도메인 모델과 리포지토리를 정의한다.</p>
<pre class="highlight"><code class="language-java">@Document(collection = "users")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User {
    @Id
    private String id;
    private String username;
    private String password;
    private String email;
    private List&lt;String&gt; roles;
    private boolean enabled;
    private LocalDateTime createdAt;
}</code></pre>
<pre class="highlight"><code class="language-java">public interface UserRepository extends ReactiveMongoRepository&lt;User, String&gt; {
    Mono&lt;User&gt; findByUsername(String username);
    Mono&lt;Boolean&gt; existsByUsername(String username);
}</code></pre>
<p>MongoDB 기반 <code>ReactiveUserDetailsService</code> 구현체를 작성한다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class MongoUserDetailsService implements ReactiveUserDetailsService {

    private final UserRepository userRepository;

    @Override
    public Mono&lt;UserDetails&gt; findByUsername(String username) {
        return userRepository.findByUsername(username)
            .map(user -&gt; org.springframework.security.core.userdetails.User.builder()
                .username(user.getUsername())
                .password(user.getPassword())
                .roles(user.getRoles().toArray(new String[0]))
                .disabled(!user.isEnabled())
                .build()
            )
            .switchIfEmpty(Mono.error(
                new UsernameNotFoundException("사용자를 찾을 수 없습니다: " + username)
            ));
    }
}</code></pre>
<h3 id="1132-passwordencoder">11.3.2 PasswordEncoder와 회원가입</h3>
<p>비밀번호는 BCrypt로 해시하여 저장한다.</p>
<pre class="highlight"><code class="language-java">@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}</code></pre>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class UserService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    public Mono&lt;User&gt; signup(SignupRequest request) {
        return userRepository.existsByUsername(request.getUsername())
            .flatMap(exists -&gt; {
                if (exists) {
                    return Mono.error(new DuplicateException("이미 사용 중인 사용자명입니다."));
                }
                User user = User.builder()
                    .username(request.getUsername())
                    .password(passwordEncoder.encode(request.getPassword()))
                    .email(request.getEmail())
                    .roles(List.of("USER"))
                    .enabled(true)
                    .createdAt(LocalDateTime.now())
                    .build();
                return userRepository.save(user);
            });
    }
}</code></pre>
<h3 id="1133-preauthorize">11.3.3 @PreAuthorize 메서드 보안</h3>
<p><code>@EnableReactiveMethodSecurity</code>를 활성화하면 서비스 계층에서 메서드 단위 보안을 적용할 수 있다.</p>
<pre class="highlight"><code class="language-java">@Configuration
@EnableWebFluxSecurity
@EnableReactiveMethodSecurity
public class SecurityConfig {
    // SecurityWebFilterChain 빈 정의
}</code></pre>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class ProductService {

    private final ProductRepository productRepository;

    @PreAuthorize("hasRole('ADMIN')")
    public Mono&lt;Product&gt; create(Product product) {
        product.setCreatedAt(LocalDateTime.now());
        return productRepository.save(product);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public Mono&lt;Product&gt; update(String id, Product product) {
        return productRepository.findById(id)
            .map(existing -&gt; {
                existing.setName(product.getName());
                existing.setPrice(product.getPrice());
                existing.setUpdatedAt(LocalDateTime.now());
                return existing;
            })
            .flatMap(productRepository::save);
    }

    // 현재 사용자 본인의 데이터만 조회 허용
    @PreAuthorize("#username == authentication.name or hasRole('ADMIN')")
    public Mono&lt;User&gt; findByUsername(String username) {
        return userRepository.findByUsername(username);
    }
}</code></pre>
<p>리액티브 환경에서 <code>@PreAuthorize</code>는 <code>Mono</code>/<code>Flux</code> 반환 타입과 함께 동작하며, 인가 실패 시 <code>AccessDeniedException</code>이 발생한다.</p>
<hr>
<h2 id="114-jwt">11.4 JWT 기반 인증 구현</h2>
<p>REST API 환경에서는 세션 대신 JWT(JSON Web Token)를 사용하여 무상태(stateless) 인증을 구현하는 것이 일반적이다. JWT는 Header(알고리즘, 타입), Payload(클레임), Signature(서명) 세 부분으로 구성된다.</p>
<h3 id="1141-jwt">11.4.1 JWT 유틸리티 클래스</h3>
<p>jjwt 라이브러리를 사용하여 토큰 생성, 검증, 파싱을 담당하는 클래스를 구현한다.</p>
<pre class="highlight"><code class="language-java">@Component
public class JwtTokenProvider {

    @Value("${jwt.secret}")
    private String secretKey;

    @Value("${jwt.access-token-expiration}")
    private long accessTokenExpiration;

    @Value("${jwt.refresh-token-expiration}")
    private long refreshTokenExpiration;

    private SecretKey key;

    @PostConstruct
    public void init() {
        this.key = Keys.hmacShaKeyFor(Decoders.BASE64.decode(secretKey));
    }

    public String generateAccessToken(UserDetails userDetails) {
        Map&lt;String, Object&gt; claims = Map.of("roles",
            userDetails.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority).toList());
        return createToken(claims, userDetails.getUsername(), accessTokenExpiration);
    }

    public String generateRefreshToken(UserDetails userDetails) {
        return createToken(Map.of(), userDetails.getUsername(), refreshTokenExpiration);
    }

    private String createToken(Map&lt;String, Object&gt; claims, String subject,
                               long expiration) {
        Date now = new Date();
        return Jwts.builder()
            .claims(claims).subject(subject).issuedAt(now)
            .expiration(new Date(now.getTime() + expiration))
            .signWith(key).compact();
    }

    public String getUsernameFromToken(String token) {
        return getClaims(token).getSubject();
    }

    @SuppressWarnings("unchecked")
    public List&lt;String&gt; getRolesFromToken(String token) {
        return getClaims(token).get("roles", List.class);
    }

    public boolean validateToken(String token) {
        try { getClaims(token); return true; }
        catch (JwtException | IllegalArgumentException e) { return false; }
    }

    private Claims getClaims(String token) {
        return Jwts.parser().verifyWith(key).build()
            .parseSignedClaims(token).getPayload();
    }
}</code></pre>
<p><code>application.yml</code> 설정을 추가한다.</p>
<pre class="highlight"><code class="language-yaml">jwt:
  secret: "dGhpcyBpcyBhIHZlcnkgbG9uZyBzZWNyZXQga2V5IGZvciBIUzI1NiBhbGdvcml0aG0="
  access-token-expiration: 3600000     # 1시간
  refresh-token-expiration: 604800000  # 7일</code></pre>
<h3 id="1142-jwt">11.4.2 JWT 인증 필터</h3>
<p>JWT 토큰에서 <code>Authentication</code> 객체를 생성하는 컨버터와 <code>ReactiveAuthenticationManager</code>를 구현한다.</p>
<pre class="highlight"><code class="language-java">@Component
@RequiredArgsConstructor
public class JwtAuthenticationConverter implements ServerAuthenticationConverter {

    private final JwtTokenProvider jwtTokenProvider;

    @Override
    public Mono&lt;Authentication&gt; convert(ServerWebExchange exchange) {
        return Mono.justOrEmpty(
                exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION))
            .filter(header -&gt; header.startsWith("Bearer "))
            .map(header -&gt; header.substring(7))
            .filter(jwtTokenProvider::validateToken)
            .map(token -&gt; {
                String username = jwtTokenProvider.getUsernameFromToken(token);
                List&lt;GrantedAuthority&gt; authorities = jwtTokenProvider
                    .getRolesFromToken(token).stream()
                    .map(SimpleGrantedAuthority::new)
                    .collect(Collectors.toList());
                return new UsernamePasswordAuthenticationToken(
                    username, null, authorities);
            });
    }
}</code></pre>
<pre class="highlight"><code class="language-java">@Component
@RequiredArgsConstructor
public class JwtReactiveAuthenticationManager implements ReactiveAuthenticationManager {

    private final ReactiveUserDetailsService userDetailsService;

    @Override
    public Mono&lt;Authentication&gt; authenticate(Authentication authentication) {
        return userDetailsService.findByUsername(authentication.getName())
            .map(userDetails -&gt; new UsernamePasswordAuthenticationToken(
                userDetails, null, authentication.getAuthorities()));
    }
}</code></pre>
<h3 id="1143-jwt-securitywebfilterchain">11.4.3 JWT SecurityWebFilterChain 구성</h3>
<p>JWT 기반 인증을 위한 전체 보안 설정을 구성한다.</p>
<pre class="highlight"><code class="language-java">@Configuration
@EnableWebFluxSecurity
@EnableReactiveMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtReactiveAuthenticationManager authenticationManager;
    private final JwtAuthenticationConverter authenticationConverter;

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        AuthenticationWebFilter jwtFilter =
            new AuthenticationWebFilter(authenticationManager);
        jwtFilter.setServerAuthenticationConverter(authenticationConverter);

        return http
            .authorizeExchange(exchanges -&gt; exchanges
                .pathMatchers("/api/auth/**").permitAll()
                .pathMatchers(HttpMethod.GET, "/api/products/**").permitAll()
                .pathMatchers("/api/admin/**").hasRole("ADMIN")
                .anyExchange().authenticated()
            )
            .addFilterAt(jwtFilter, SecurityWebFiltersOrder.AUTHENTICATION)
            .httpBasic(httpBasic -&gt; httpBasic.disable())
            .formLogin(formLogin -&gt; formLogin.disable())
            .csrf(csrf -&gt; csrf.disable())
            .exceptionHandling(ex -&gt; ex
                .authenticationEntryPoint((exchange, e) -&gt; Mono.fromRunnable(
                    () -&gt; exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED)))
                .accessDeniedHandler((exchange, denied) -&gt; Mono.fromRunnable(
                    () -&gt; exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN)))
            )
            .securityContextRepository(NoOpServerSecurityContextRepository.getInstance())
            .build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}</code></pre>
<p><code>NoOpServerSecurityContextRepository</code>를 설정하여 서버 측 세션을 생성하지 않는 완전한 무상태 구조를 만든다.</p>
<h3 id="1144">11.4.4 인증 컨트롤러</h3>
<p>로그인, 토큰 갱신, 회원가입 엔드포인트를 구현한다.</p>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {

    private final UserService userService;
    private final ReactiveUserDetailsService userDetailsService;
    private final PasswordEncoder passwordEncoder;
    private final JwtTokenProvider jwtTokenProvider;

    @PostMapping("/signup")
    @ResponseStatus(HttpStatus.CREATED)
    public Mono&lt;UserResponse&gt; signup(@Valid @RequestBody SignupRequest request) {
        return userService.signup(request).map(UserResponse::from);
    }

    @PostMapping("/login")
    public Mono&lt;TokenResponse&gt; login(@Valid @RequestBody LoginRequest request) {
        return userDetailsService.findByUsername(request.getUsername())
            .filter(ud -&gt; passwordEncoder.matches(
                request.getPassword(), ud.getPassword()))
            .map(ud -&gt; new TokenResponse(
                jwtTokenProvider.generateAccessToken(ud),
                jwtTokenProvider.generateRefreshToken(ud)))
            .switchIfEmpty(Mono.error(
                new BadCredentialsException("잘못된 사용자명 또는 비밀번호입니다.")));
    }

    @PostMapping("/refresh")
    public Mono&lt;TokenResponse&gt; refresh(@RequestBody RefreshTokenRequest request) {
        String refreshToken = request.getRefreshToken();
        if (!jwtTokenProvider.validateToken(refreshToken)) {
            return Mono.error(
                new BadCredentialsException("유효하지 않은 리프레시 토큰입니다."));
        }
        String username = jwtTokenProvider.getUsernameFromToken(refreshToken);
        return userDetailsService.findByUsername(username)
            .map(ud -&gt; new TokenResponse(
                jwtTokenProvider.generateAccessToken(ud), refreshToken));
    }
}</code></pre>
<p>요청/응답 DTO를 정의한다.</p>
<pre class="highlight"><code class="language-java">@Data
public class LoginRequest {
    @NotBlank private String username;
    @NotBlank private String password;
}

@Data
public class RefreshTokenRequest {
    @NotBlank private String refreshToken;
}

@Data
@AllArgsConstructor
public class TokenResponse {
    private String accessToken;
    private String refreshToken;
}</code></pre>
<h3 id="1145">11.4.5 전체 인증 흐름</h3>
<p>JWT 기반 인증의 전체 흐름을 정리한다.</p>
<ol>
<li><strong>회원가입</strong>: <code>POST /api/auth/signup</code> -- 비밀번호 BCrypt 인코딩 후 MongoDB 저장</li>
<li><strong>로그인</strong>: <code>POST /api/auth/login</code> -- 비밀번호 검증 후 Access Token + Refresh Token 발급</li>
<li><strong>인증된 API 호출</strong>: <code>Authorization: Bearer &lt;accessToken&gt;</code> 헤더 전송 -- <code>JwtAuthenticationConverter</code>가 토큰 추출/검증 후 <code>Authentication</code> 객체 생성</li>
<li><strong>토큰 갱신</strong>: <code>POST /api/auth/refresh</code> -- Refresh Token 검증 후 새 Access Token 발급</li>
</ol>
<hr>
<h2 id="115-securitycontext">11.5 리액티브 환경에서의 SecurityContext 관리</h2>
<h3 id="1151-reactivesecuritycontextholder">11.5.1 ReactiveSecurityContextHolder</h3>
<p>서블릿 환경의 <code>SecurityContextHolder.getContext()</code>는 <code>ThreadLocal</code> 기반이므로 리액티브 환경에서 사용할 수 없다.</p>
<pre class="highlight"><code class="language-java">// 리액티브 환경에서의 올바른 방식
Mono&lt;String&gt; username = ReactiveSecurityContextHolder.getContext()
    .map(SecurityContext::getAuthentication)
    .map(Authentication::getName);</code></pre>
<h3 id="1152">11.5.2 현재 사용자 정보 가져오기</h3>
<p>서비스 계층에서 현재 인증된 사용자 정보를 활용하는 패턴을 살펴본다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class OrderService {

    private final OrderRepository orderRepository;

    public Flux&lt;Order&gt; getMyOrders() {
        return ReactiveSecurityContextHolder.getContext()
            .map(ctx -&gt; ctx.getAuthentication().getName())
            .flatMapMany(orderRepository::findByUsername);
    }

    public Mono&lt;Order&gt; createOrder(OrderRequest request) {
        return ReactiveSecurityContextHolder.getContext()
            .map(ctx -&gt; ctx.getAuthentication().getName())
            .flatMap(username -&gt; {
                Order order = Order.builder()
                    .username(username)
                    .items(request.getItems())
                    .totalAmount(request.getTotalAmount())
                    .createdAt(LocalDateTime.now())
                    .build();
                return orderRepository.save(order);
            });
    }
}</code></pre>
<h3 id="1153">11.5.3 컨트롤러에서 인증 정보 접근</h3>
<p>어노테이션 기반 컨트롤러에서는 <code>@AuthenticationPrincipal</code>이나 <code>Mono&lt;Principal&gt;</code>을 파라미터로 주입받을 수 있다.</p>
<pre class="highlight"><code class="language-java">@GetMapping("/me")
public Mono&lt;UserResponse&gt; getMyProfile(
        @AuthenticationPrincipal Mono&lt;UserDetails&gt; principal) {
    return principal
        .flatMap(user -&gt; userService.findByUsername(user.getUsername()))
        .map(UserResponse::from);
}

@GetMapping("/me/orders")
public Flux&lt;Order&gt; getMyOrders(Mono&lt;Principal&gt; principal) {
    return principal.map(Principal::getName)
        .flatMapMany(orderService::findByUsername);
}</code></pre>
<h3 id="1154-securitycontext">11.5.4 SecurityContext 주의사항</h3>
<p><code>ReactiveSecurityContextHolder.getContext()</code>의 반환값은 반드시 리액티브 체인 안에서 <code>map</code>/<code>flatMap</code>으로 연결해야 한다. Reactor의 <code>Context</code>는 구독 시점에 전파되므로, 체인이 끊기면 <code>SecurityContext</code>를 읽을 수 없다.</p>
<pre class="highlight"><code class="language-java">// 잘못된 사용: context를 구독하지 않으므로 SecurityContext 접근 불가
Mono&lt;SecurityContext&gt; context = ReactiveSecurityContextHolder.getContext();
return orderRepository.save(order);

// 올바른 사용: 체인 내부에서 연결
return ReactiveSecurityContextHolder.getContext()
    .map(ctx -&gt; ctx.getAuthentication().getName())
    .flatMap(username -&gt; orderRepository.save(buildOrder(request, username)));</code></pre>
<hr>
<h2 id="116-oauth2-openid-connect">11.6 OAuth2 / OpenID Connect 연동</h2>
<h3 id="1161-oauth2-login">11.6.1 OAuth2 Login 설정</h3>
<p><code>application.yml</code>에 OAuth2 클라이언트를 등록한다.</p>
<pre class="highlight"><code class="language-yaml">spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: ${GOOGLE_CLIENT_ID}
            client-secret: ${GOOGLE_CLIENT_SECRET}
            scope: openid, profile, email
          github:
            client-id: ${GITHUB_CLIENT_ID}
            client-secret: ${GITHUB_CLIENT_SECRET}
            scope: read:user, user:email
        provider:
          github:
            user-name-attribute: login</code></pre>
<p>Google은 OpenID Connect를 지원하므로 <code>provider</code> 설정이 자동 적용된다. GitHub은 <code>user-name-attribute</code>를 수동 지정해야 한다.</p>
<h3 id="1162-oauth2-securitywebfilterchain">11.6.2 OAuth2 SecurityWebFilterChain 설정</h3>
<pre class="highlight"><code class="language-java">@Configuration
@EnableWebFluxSecurity
public class OAuth2SecurityConfig {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        return http
            .authorizeExchange(exchanges -&gt; exchanges
                .pathMatchers("/", "/login/**", "/oauth2/**").permitAll()
                .anyExchange().authenticated()
            )
            .oauth2Login(Customizer.withDefaults())
            .csrf(csrf -&gt; csrf.disable())
            .build();
    }
}</code></pre>
<p><code>oauth2Login(Customizer.withDefaults())</code>만으로 <code>/oauth2/authorization/{registrationId}</code> 엔드포인트와 콜백 URL이 자동 설정된다.</p>
<h3 id="1163-oauth2">11.6.3 OAuth2 사용자 정보 커스터마이징</h3>
<p>소셜 로그인 후 사용자 정보를 MongoDB에 저장하려면 <code>ReactiveOAuth2UserService</code>를 커스터마이징한다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class CustomOAuth2UserService
        implements ReactiveOAuth2UserService&lt;OidcUserRequest, OidcUser&gt; {

    private final UserRepository userRepository;
    private final ReactiveOidcUserService delegate = new ReactiveOidcUserService();

    @Override
    public Mono&lt;OidcUser&gt; loadUser(OidcUserRequest userRequest) {
        return delegate.loadUser(userRequest)
            .flatMap(oidcUser -&gt; {
                String email = oidcUser.getEmail();
                String provider = userRequest.getClientRegistration()
                    .getRegistrationId();
                return userRepository.findByEmail(email)
                    .switchIfEmpty(createOAuth2User(email, oidcUser.getFullName(),
                                                     provider))
                    .thenReturn(oidcUser);
            });
    }

    private Mono&lt;User&gt; createOAuth2User(String email, String name, String provider) {
        User user = User.builder()
            .username(email).email(email).password("")
            .roles(List.of("USER")).enabled(true)
            .createdAt(LocalDateTime.now()).build();
        return userRepository.save(user);
    }
}</code></pre>
<h3 id="1164-resource-server">11.6.4 Resource Server 설정</h3>
<p>외부 인증 서버(Keycloak, Auth0 등)에서 발급한 JWT를 검증하는 Resource Server 설정이다.</p>
<pre class="highlight"><code class="language-yaml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://auth.example.com/realms/my-realm</code></pre>
<pre class="highlight"><code class="language-java">@Configuration
@EnableWebFluxSecurity
public class ResourceServerConfig {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        return http
            .authorizeExchange(exchanges -&gt; exchanges
                .pathMatchers(HttpMethod.GET, "/api/products/**").permitAll()
                .pathMatchers("/api/admin/**").hasAuthority("SCOPE_admin")
                .anyExchange().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2.jwt(Customizer.withDefaults()))
            .csrf(csrf -&gt; csrf.disable())
            .build();
    }

    @Bean
    public ReactiveJwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter =
            new JwtGrantedAuthoritiesConverter();
        grantedAuthoritiesConverter.setAuthorityPrefix("ROLE_");
        grantedAuthoritiesConverter.setAuthoritiesClaimName("roles");

        ReactiveJwtAuthenticationConverter converter =
            new ReactiveJwtAuthenticationConverter();
        converter.setJwtGrantedAuthoritiesConverter(
            new ReactiveJwtGrantedAuthoritiesConverterAdapter(
                grantedAuthoritiesConverter));
        return converter;
    }
}</code></pre>
<h3 id="1165-jwt-oauth2">11.6.5 JWT와 OAuth2의 선택 기준</h3>
<table>
<thead>
<tr>
<th>시나리오</th>
<th>권장 방식</th>
</tr>
</thead>
<tbody>
<tr>
<td>단일 애플리케이션, 자체 인증</td>
<td>JWT 자체 발급 (11.4)</td>
</tr>
<tr>
<td>마이크로서비스, 중앙 인증 서버 존재</td>
<td>OAuth2 Resource Server</td>
</tr>
<tr>
<td>소셜 로그인이 필요한 웹 애플리케이션</td>
<td>OAuth2 Login</td>
</tr>
<tr>
<td>SPA + API 서버 분리 구조</td>
<td>JWT 자체 발급 또는 OAuth2 + PKCE</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="_3">요약</h2>
<p>이번 장에서 다룬 핵심 내용을 정리한다.</p>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 내용</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>리액티브 보안 설정</strong></td>
<td><code>@EnableWebFluxSecurity</code>, <code>SecurityWebFilterChain</code>, 서블릿 방식과의 차이</td>
</tr>
<tr>
<td><strong>SecurityWebFilterChain</strong></td>
<td><code>ServerHttpSecurity</code>로 경로별 인가, CSRF, CORS, 인증 방식 설정</td>
</tr>
<tr>
<td><strong>인증과 인가</strong></td>
<td><code>ReactiveUserDetailsService</code>, <code>PasswordEncoder</code>, <code>@PreAuthorize</code> 메서드 보안</td>
</tr>
<tr>
<td><strong>JWT 인증</strong></td>
<td><code>JwtTokenProvider</code>로 토큰 생성/검증, <code>AuthenticationWebFilter</code>로 필터 체인 통합</td>
</tr>
<tr>
<td><strong>SecurityContext</strong></td>
<td><code>ReactiveSecurityContextHolder</code>로 인증 정보 접근, 리액티브 체인 내부에서만 사용</td>
</tr>
<tr>
<td><strong>OAuth2 연동</strong></td>
<td>OAuth2 Login(소셜 로그인), Resource Server(외부 JWT 검증), 사용자 정보 커스터마이징</td>
</tr>
</tbody>
</table>
<p>다음 장에서는 Server-Sent Events(SSE)를 활용한 실시간 데이터 스트리밍을 다룬다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>