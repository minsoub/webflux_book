<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 9. 데이터 검증과 예외 처리 | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="ch08.html">&larr; Chapter 8. MongoDB 리액티브 데이터 접근 심화</a>
    <a href="../index.html">목차</a>
    <a href="ch10.html">Chapter 10. WebFlux 필터와 인터셉터 &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-9">Chapter 9. 데이터 검증과 예외 처리</h1>
<p>MongoDB 데이터 접근을 심화한 Chapter 8을 마쳤다면, 이제 실무에서 가장 중요한 부분을 다룬다: 클라이언트로부터 들어오는 데이터가 제대로 된 형식인지 검증하고, 문제가 발생했을 때 일관성 있게 처리하는 방법이다.</p>
<p>실제 프로젝트에서는 "쓰레기 데이터는 빨리 걸러낼수록 좋다"가 기본 원칙이다. 부정확한 입력을 초반에 차단하면 나중에 뒤에서 처리하는 복잡한 로직을 피할 수 있고, 예외가 발생했을 때는 클라이언트가 이해하기 쉬운 일관된 형식으로 알려줘야 한다. 필자의 경험상, 이 부분을 제대로 구성하면 버그 신고와 지원 비용이 크게 줄어든다.</p>
<p>이 장에서는 Bean Validation으로 입력을 선언적으로 검증하는 방법부터 시작해서, 복잡한 비즈니스 규칙을 처리하는 커스텀 Validator, 그리고 <code>@ControllerAdvice</code>, <code>ErrorWebExceptionHandler</code> 같은 글로벌 예외 처리기까지 실용적인 패턴을 차례로 살펴본다. 마지막으로 RFC 7807 Problem Details 표준도 알아본다.</p>
<hr>
<h2 id="91-bean-validation">9.1 Bean Validation을 활용한 입력 검증</h2>
<h3 id="911">9.1.1 의존성 추가</h3>
<p>Spring Boot에서 Bean Validation을 쓰려면 먼저 의존성을 선언해야 한다. 다행히 <code>spring-boot-starter-validation</code>이 모든 것을 담고 있어서 추가만 하면 바로 사용할 수 있다.</p>
<p><code>xml
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
&lt;/dependency&gt;</code></p>
<p>이 스타터 안에는 Hibernate Validator가 포함되어 있고, Jakarta Bean Validation 3.0 API(<code>jakarta.validation</code> 패키지)도 함께 제공된다.</p>
<h3 id="912">9.1.2 주요 검증 어노테이션</h3>
<p>실무에서 가장 자주 쓰이는 검증 어노테이션들을 정리해봤다.</p>
<table>
<thead>
<tr>
<th>어노테이션</th>
<th>설명</th>
<th>적용 대상</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@NotNull</code></td>
<td>null이 아니어야 한다</td>
<td>모든 타입</td>
</tr>
<tr>
<td><code>@NotBlank</code></td>
<td>null이 아니고, 공백을 제외한 길이가 1 이상</td>
<td><code>String</code></td>
</tr>
<tr>
<td><code>@NotEmpty</code></td>
<td>null이 아니고, 비어 있지 않아야 한다</td>
<td><code>String</code>, <code>Collection</code>, <code>Map</code>, 배열</td>
</tr>
<tr>
<td><code>@Size(min, max)</code></td>
<td>길이 또는 크기가 범위 내</td>
<td><code>String</code>, <code>Collection</code>, <code>Map</code>, 배열</td>
</tr>
<tr>
<td><code>@Email</code></td>
<td>이메일 형식이어야 한다</td>
<td><code>String</code></td>
</tr>
<tr>
<td><code>@Pattern(regexp)</code></td>
<td>정규표현식에 매칭되어야 한다</td>
<td><code>String</code></td>
</tr>
<tr>
<td><code>@Min</code> / <code>@Max</code></td>
<td>지정 값 이상 / 이하</td>
<td>숫자 타입</td>
</tr>
<tr>
<td><code>@Positive</code></td>
<td>양수여야 한다</td>
<td>숫자 타입</td>
</tr>
<tr>
<td><code>@Past</code> / <code>@Future</code></td>
<td>과거 / 미래 날짜여야 한다</td>
<td>날짜, 시간 타입</td>
</tr>
</tbody>
</table>
<h3 id="913-dto">9.1.3 DTO에 검증 어노테이션 적용</h3>
<p>이제 Chapter 6에서 만들었던 사용자 등록 DTO에 검증 규칙을 붙여보자. 이렇게 하면 클라이언트의 요청이 들어올 때 자동으로 검증된다.</p>
<p>```java
package com.example.webfluxdemo.dto;</p>
<p>import jakarta.validation.constraints.<em>;
import lombok.</em>;</p>
<p>@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserCreateRequest {</p>
<pre><code>@NotBlank(message = "이름은 필수 입력 항목입니다")
@Size(min = 2, max = 50, message = "이름은 2~50자 사이여야 합니다")
private String name;

@NotBlank(message = "이메일은 필수 입력 항목입니다")
@Email(message = "올바른 이메일 형식이 아닙니다")
private String email;

@NotBlank(message = "비밀번호는 필수 입력 항목입니다")
@Pattern(
    regexp = "^(?=.*[A-Za-z])(?=.*\\d)(?=.*[@$!%*#?&amp;])[A-Za-z\\d@$!%*#?&amp;]{8,20}$",
    message = "비밀번호는 8~20자이며, 영문, 숫자, 특수문자를 포함해야 합니다"
)
private String password;
</code></pre>
<p>}
```</p>
<p>상품 생성 DTO에도 비슷한 방식으로 검증을 추가할 수 있다.</p>
<p>```java
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductCreateRequest {</p>
<pre><code>@NotBlank(message = "상품명은 필수 입력 항목입니다")
@Size(max = 200, message = "상품명은 200자를 초과할 수 없습니다")
private String name;

@NotNull(message = "가격은 필수 입력 항목입니다")
@Positive(message = "가격은 양수여야 합니다")
private Integer price;

@Size(max = 1000, message = "설명은 1000자를 초과할 수 없습니다")
private String description;

@NotBlank(message = "카테고리는 필수 입력 항목입니다")
private String category;
</code></pre>
<p>}
```</p>
<h3 id="914-valid">9.1.4 컨트롤러에서 @Valid 적용</h3>
<p>WebFlux를 쓸 때 어노테이션 기반 컨트롤러라면, <code>@Valid</code>를 <code>@RequestBody</code>와 함께 붙이기만 하면 자동으로 검증이 시작된다.</p>
<p>```java
@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
public class UserController {</p>
<pre><code>private final UserService userService;

@PostMapping
@ResponseStatus(HttpStatus.CREATED)
public Mono&lt;UserResponse&gt; createUser(
        @Valid @RequestBody UserCreateRequest request) {
    return userService.createUser(request);
}

@PutMapping("/{id}")
public Mono&lt;UserResponse&gt; updateUser(
        @PathVariable String id,
        @Valid @RequestBody UserUpdateRequest request) {
    return userService.updateUser(id, request);
}
</code></pre>
<p>}
```</p>
<p>만약 <code>@Valid</code>가 붙은 파라미터의 검증이 실패하면 어떻게 될까? Spring WebFlux가 <code>WebExchangeBindException</code>을 던지는데, 이건 9.3절에서 만들 글로벌 예외 처리기가 받아서 깔끔한 형식으로 클라이언트에 전달해준다.</p>
<h3 id="915">9.1.5 함수형 엔드포인트에서의 검증</h3>
<p>함수형 엔드포인트는 어노테이션 없이 라우팅을 정의하는 방식이라, 검증도 직접 손으로 해줘야 한다. <code>Validator</code>를 주입받아서 명시적으로 검증하는 방식이다.</p>
<p>```java
@Component
@RequiredArgsConstructor
public class ProductHandler {</p>
<pre><code>private final ProductService productService;
private final Validator validator;

public Mono&lt;ServerResponse&gt; createProduct(ServerRequest request) {
    return request.bodyToMono(ProductCreateRequest.class)
        .doOnNext(this::validate)
        .flatMap(productService::createProduct)
        .flatMap(product -&gt; ServerResponse
            .created(URI.create("/api/products/" + product.getId()))
            .bodyValue(product));
}

private &lt;T&gt; void validate(T body) {
    Set&lt;ConstraintViolation&lt;T&gt;&gt; violations = validator.validate(body);
    if (!violations.isEmpty()) {
        throw new ConstraintViolationException(violations);
    }
}
</code></pre>
<p>}
```</p>
<p>검증에서 문제가 발견되면 <code>ConstraintViolationException</code>을 던져버리면 되는데, 이것도 나중에 만들 글로벌 예외 처리기가 받아서 깔끔하게 정리해준다.</p>
<hr>
<h2 id="92-validator">9.2 커스텀 Validator 구현</h2>
<h3 id="921">9.2.1 커스텀 어노테이션 정의</h3>
<p>Bean Validation의 표준 어노테이션만으로는 표현하기 어려운 비즈니스 규칙들이 있다. 예를 들어, 특정한 카테고리 값들만 허용하는 경우 같은 경우 말이다. 이럴 때는 자신만의 검증 어노테이션을 만드는 게 깔끔하다.</p>
<p><code>java
@Documented
@Constraint(validatedBy = AllowedCategoryValidator.class)
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
public @interface AllowedCategory {
    String message() default "허용되지 않은 카테고리입니다";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
    String[] values() default {};
}</code></p>
<h3 id="922-constraintvalidator">9.2.2 ConstraintValidator 구현</h3>
<p>이제 실제로 검증 로직을 구현할 차례다. <code>ConstraintValidator&lt;A, T&gt;</code> 인터페이스를 구현하면 되는데, <code>A</code>는 어노테이션 타입이고 <code>T</code>는 검증할 필드의 타입이다.</p>
<p>```java
public class AllowedCategoryValidator
        implements ConstraintValidator<AllowedCategory, String> {</p>
<pre><code>private Set&lt;String&gt; allowedValues;

@Override
public void initialize(AllowedCategory annotation) {
    this.allowedValues = Set.of(annotation.values());
}

@Override
public boolean isValid(String value, ConstraintValidatorContext context) {
    if (value == null) {
        return true; // null 검사는 @NotBlank에 위임
    }
    return allowedValues.contains(value);
}
</code></pre>
<p>}
```</p>
<p>이제 DTO의 필드에 이 커스텀 어노테이션을 붙이면 된다.</p>
<p><code>java
@AllowedCategory(
    values = {"ELECTRONICS", "BOOKS", "CLOTHING", "FOOD"},
    message = "카테고리는 ELECTRONICS, BOOKS, CLOTHING, FOOD 중 하나여야 합니다"
)
@NotBlank(message = "카테고리는 필수 입력 항목입니다")
private String category;</code></p>
<h3 id="923-validator">9.2.3 크로스 필드 검증 (클래스 레벨 Validator)</h3>
<p>이번엔 좀 더 복잡한 경우를 생각해보자. 비밀번호와 비밀번호 확인 필드가 일치해야 한다거나, 여러 필드를 함께 검증해야 하는 상황 말이다. 이럴 때는 <strong>클래스 레벨 어노테이션</strong>으로 처리한다.</p>
<p><code>java
@Documented
@Constraint(validatedBy = PasswordMatchValidator.class)
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface PasswordMatch {
    String message() default "비밀번호와 비밀번호 확인이 일치하지 않습니다";
    Class&lt;?&gt;[] groups() default {};
    Class&lt;? extends Payload&gt;[] payload() default {};
}</code></p>
<p>그 다음 검증 대상이 될 DTO가 따를 인터페이스를 정의한다.</p>
<p><code>java
public interface PasswordConfirmable {
    String getPassword();
    String getPasswordConfirm();
}</code></p>
<p>```java
public class PasswordMatchValidator
        implements ConstraintValidator<PasswordMatch, PasswordConfirmable> {</p>
<pre><code>@Override
public boolean isValid(PasswordConfirmable dto,
                       ConstraintValidatorContext context) {
    if (dto.getPassword() == null || dto.getPasswordConfirm() == null) {
        return true;
    }
    boolean matches = dto.getPassword().equals(dto.getPasswordConfirm());
    if (!matches) {
        context.disableDefaultConstraintViolation();
        context.buildConstraintViolationWithTemplate(
                "비밀번호와 비밀번호 확인이 일치하지 않습니다")
            .addPropertyNode("passwordConfirm")
            .addConstraintViolation();
    }
    return matches;
}
</code></pre>
<p>}
```</p>
<p>필자의 경험상, 이런 식으로 <code>@PasswordMatch</code>를 DTO 클래스에 붙이면 필드별 검증과 크로스 필드 검증이 깔끔하게 함께 실행된다.</p>
<p>```java
@PasswordMatch
@Getter @NoArgsConstructor @AllArgsConstructor @Builder
public class SignUpRequest implements PasswordConfirmable {</p>
<pre><code>@NotBlank(message = "이름은 필수 입력 항목입니다")
private String name;

@NotBlank @Email
private String email;

@NotBlank
private String password;

@NotBlank
private String passwordConfirm;
</code></pre>
<p>}
```</p>
<hr>
<h2 id="93-controlleradvice">9.3 글로벌 예외 처리 (@ControllerAdvice)</h2>
<h3 id="931">9.3.1 커스텀 예외 클래스 정의</h3>
<p>지금부터 예외 처리 전략을 짠다. 비즈니스 로직에서 터지는 예외들을 타입별로 구분해서 관리하면, 나중에 처리하기도 편하고 에러 메시지도 일관되게 만들 수 있다.</p>
<p>```java
package com.example.webfluxdemo.exception;</p>
<p>import lombok.Getter;</p>
<p>@Getter
public class BusinessException extends RuntimeException {</p>
<pre><code>private final ErrorCode errorCode;

public BusinessException(ErrorCode errorCode) {
    super(errorCode.getMessage());
    this.errorCode = errorCode;
}

public BusinessException(ErrorCode errorCode, String detail) {
    super(detail);
    this.errorCode = errorCode;
}
</code></pre>
<p>}
```</p>
<p>```java
public class ResourceNotFoundException extends BusinessException {
    public ResourceNotFoundException(String resourceName, String id) {
        super(ErrorCode.RESOURCE_NOT_FOUND,
              resourceName + "을(를) 찾을 수 없습니다. ID: " + id);
    }
}</p>
<p>public class DuplicateResourceException extends BusinessException {
    public DuplicateResourceException(String resourceName, String field) {
        super(ErrorCode.DUPLICATE_RESOURCE,
              resourceName + "이(가) 이미 존재합니다. 필드: " + field);
    }
}
```</p>
<h3 id="932-errorcode">9.3.2 ErrorCode 열거형</h3>
<p>에러 코드를 열거형으로 관리하는 건 간단하면서도 강력한 패턴이다. 에러의 종류를 한곳에서 정의해두면 코드 전체에서 일관성을 유지할 수 있다.</p>
<p>```java
package com.example.webfluxdemo.exception;</p>
<p>import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;</p>
<p>@Getter
@RequiredArgsConstructor
public enum ErrorCode {</p>
<pre><code>// 공통
INVALID_INPUT(HttpStatus.BAD_REQUEST, "C001", "잘못된 입력값입니다"),
RESOURCE_NOT_FOUND(HttpStatus.NOT_FOUND, "C002", "리소스를 찾을 수 없습니다"),
INTERNAL_ERROR(HttpStatus.INTERNAL_SERVER_ERROR, "C003", "서버 내부 오류"),
DUPLICATE_RESOURCE(HttpStatus.CONFLICT, "C004", "중복된 리소스입니다"),

// 사용자
USER_NOT_FOUND(HttpStatus.NOT_FOUND, "U001", "사용자를 찾을 수 없습니다"),
EMAIL_ALREADY_EXISTS(HttpStatus.CONFLICT, "U002", "이미 등록된 이메일입니다"),

// 상품
PRODUCT_NOT_FOUND(HttpStatus.NOT_FOUND, "P001", "상품을 찾을 수 없습니다"),
INSUFFICIENT_STOCK(HttpStatus.BAD_REQUEST, "P002", "재고가 부족합니다");

private final HttpStatus status;
private final String code;
private final String message;
</code></pre>
<p>}
```</p>
<h3 id="933-errorresponse-dto">9.3.3 ErrorResponse DTO</h3>
<p>이제 클라이언트에 어떤 형식으로 에러를 알려줄지 정의해보자.</p>
<p>```java
package com.example.webfluxdemo.exception;</p>
<p>import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.*;
import java.time.LocalDateTime;
import java.util.List;</p>
<p>@Getter
@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorResponse {</p>
<pre><code>private final String code;
private final String message;
private final int status;
private final LocalDateTime timestamp;
private final List&lt;FieldError&gt; errors;

@Getter @Builder
public static class FieldError {
    private final String field;
    private final String value;
    private final String reason;
}

public static ErrorResponse of(ErrorCode ec) {
    return of(ec, ec.getMessage(), null);
}

public static ErrorResponse of(ErrorCode ec, String message) {
    return of(ec, message, null);
}

public static ErrorResponse of(ErrorCode ec, List&lt;FieldError&gt; errors) {
    return of(ec, ec.getMessage(), errors);
}

private static ErrorResponse of(ErrorCode ec, String msg,
                                List&lt;FieldError&gt; errors) {
    return ErrorResponse.builder()
        .code(ec.getCode()).message(msg)
        .status(ec.getStatus().value())
        .timestamp(LocalDateTime.now()).errors(errors)
        .build();
}
</code></pre>
<p>}
```</p>
<h3 id="934-restcontrolleradvice">9.3.4 @RestControllerAdvice 구현</h3>
<p>드디어 예외를 처리하는 핵심 부분이다. <code>@RestControllerAdvice</code>는 <code>@ControllerAdvice</code>와 <code>@ResponseBody</code>를 합친 거고, 모든 컨트롤러에서 터지는 예외를 한곳에서 받아서 처리하는 역할을 한다.</p>
<p>```java
package com.example.webfluxdemo.exception;</p>
<p>import jakarta.validation.ConstraintViolationException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.<em>;
import org.springframework.web.bind.annotation.</em>;
import org.springframework.web.bind.support.WebExchangeBindException;
import java.util.List;</p>
<p>@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {</p>
<pre><code>@ExceptionHandler(WebExchangeBindException.class)
public ResponseEntity&lt;ErrorResponse&gt; handleValidation(
        WebExchangeBindException ex) {

    List&lt;ErrorResponse.FieldError&gt; fieldErrors = ex.getFieldErrors()
        .stream()
        .map(e -&gt; ErrorResponse.FieldError.builder()
            .field(e.getField())
            .value(e.getRejectedValue() != null
                ? e.getRejectedValue().toString() : "")
            .reason(e.getDefaultMessage())
            .build())
        .toList();

    log.warn("Validation failed: {}", fieldErrors);
    return ResponseEntity.badRequest()
        .body(ErrorResponse.of(ErrorCode.INVALID_INPUT, fieldErrors));
}

@ExceptionHandler(ConstraintViolationException.class)
public ResponseEntity&lt;ErrorResponse&gt; handleConstraintViolation(
        ConstraintViolationException ex) {
    List&lt;ErrorResponse.FieldError&gt; fieldErrors = ex.getConstraintViolations()
        .stream()
        .map(v -&gt; ErrorResponse.FieldError.builder()
            .field(v.getPropertyPath().toString())
            .reason(v.getMessage()).build())
        .toList();
    return ResponseEntity.badRequest()
        .body(ErrorResponse.of(ErrorCode.INVALID_INPUT, fieldErrors));
}

@ExceptionHandler(BusinessException.class)
public ResponseEntity&lt;ErrorResponse&gt; handleBusiness(
        BusinessException ex) {

    ErrorCode ec = ex.getErrorCode();
    log.warn("Business exception: [{}] {}", ec.getCode(), ex.getMessage());
    return ResponseEntity.status(ec.getStatus())
        .body(ErrorResponse.of(ec, ex.getMessage()));
}

@ExceptionHandler(Exception.class)
public ResponseEntity&lt;ErrorResponse&gt; handleException(Exception ex) {

    log.error("Unhandled exception", ex);
    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
        .body(ErrorResponse.of(ErrorCode.INTERNAL_ERROR));
}
</code></pre>
<p>}
```</p>
<h3 id="935">9.3.5 서비스 계층에서 예외 발생</h3>
<p>이제 서비스 계층에서는 어떻게 예외를 던질까? 리액티브 파이프라인 안에서는 <code>switchIfEmpty</code>와 <code>Mono.error</code>를 조합해서 처리한다.</p>
<p>```java
@Service
@RequiredArgsConstructor
public class UserService {</p>
<pre><code>private final UserRepository userRepository;

public Mono&lt;UserResponse&gt; findById(String id) {
    return userRepository.findById(id)
        .map(UserResponse::from)
        .switchIfEmpty(Mono.error(
            new ResourceNotFoundException("사용자", id)));
}

public Mono&lt;UserResponse&gt; createUser(UserCreateRequest request) {
    return userRepository.findByEmail(request.getEmail())
        .flatMap(existing -&gt; Mono.&lt;User&gt;error(
            new DuplicateResourceException("이메일", request.getEmail())))
        .switchIfEmpty(Mono.defer(() -&gt; {
            User user = User.builder()
                .name(request.getName())
                .email(request.getEmail())
                .password(request.getPassword())
                .build();
            return userRepository.save(user);
        }))
        .map(UserResponse::from);
}
</code></pre>
<p>}
```</p>
<p>서비스에서 던진 예외는 <code>GlobalExceptionHandler</code>가 받아서 깔끔한 HTTP 응답으로 변환해준다.</p>
<h3 id="936">9.3.6 에러 응답 예시</h3>
<p>실제로 클라이언트가 받는 응답이 어떻게 생겼는지 몇 가지 예를 보자.</p>
<p><code>json
{
  "code": "C001",
  "message": "잘못된 입력값입니다",
  "status": 400,
  "timestamp": "2026-02-14T10:30:00",
  "errors": [
    { "field": "name", "value": "", "reason": "이름은 필수 입력 항목입니다" },
    { "field": "email", "value": "invalid", "reason": "올바른 이메일 형식이 아닙니다" }
  ]
}</code></p>
<p>리소스를 찾을 수 없는 경우는 어떨까?</p>
<p><code>json
{
  "code": "C002",
  "message": "사용자을(를) 찾을 수 없습니다. ID: 64a1b2c3d4e5f6",
  "status": 404,
  "timestamp": "2026-02-14T10:31:00"
}</code></p>
<hr>
<h2 id="94-errorwebexceptionhandler">9.4 ErrorWebExceptionHandler를 활용한 함수형 예외 처리</h2>
<h3 id="941-controlleradvice">9.4.1 @ControllerAdvice의 한계</h3>
<p>지금까지 <code>@RestControllerAdvice</code>를 다뤘는데, 이건 어노테이션 기반 컨트롤러에서만 완벽하게 작동한다는 걸 알아야 한다. 함수형 엔드포인트(<code>RouterFunction</code>)에서 발생하는 예외 중에는 <code>@ExceptionHandler</code>가 잡지 못하는 게 있다. 특히 라우팅 전이나 필터 단계에서 터지는 예외 말이다. 이런 경우를 대비하려면 <code>ErrorWebExceptionHandler</code>를 사용해야 한다.</p>
<h3 id="942-abstracterrorwebexceptionhandler">9.4.2 AbstractErrorWebExceptionHandler 확장</h3>
<p>Spring Boot에서 제공하는 <code>AbstractErrorWebExceptionHandler</code>를 상속받으면 에러 처리를 맘대로 커스터마이징할 수 있다. 핵심은 <code>getRoutingFunction()</code>을 오버라이드해서 모든 에러 요청이 우리가 정의한 렌더 메서드로 가도록 하는 것이다.</p>
<p>```java
@Component
@Order(-2) // 기본 에러 핸들러(-1)보다 높은 우선순위
public class CustomErrorWebExceptionHandler
        extends AbstractErrorWebExceptionHandler {</p>
<pre><code>public CustomErrorWebExceptionHandler(
        ErrorAttributes errorAttributes, WebProperties webProperties,
        ApplicationContext ctx, ServerCodecConfigurer configurer) {
    super(errorAttributes, webProperties.getResources(), ctx);
    this.setMessageWriters(configurer.getWriters());
}

@Override
protected RouterFunction&lt;ServerResponse&gt; getRoutingFunction(
        ErrorAttributes errorAttributes) {
    return RouterFunctions.route(
        RequestPredicates.all(), this::renderErrorResponse);
}

private Mono&lt;ServerResponse&gt; renderErrorResponse(ServerRequest request) {
    Throwable error = getError(request);
    HttpStatus status;
    String code, message;

    if (error instanceof BusinessException bex) {
        status = bex.getErrorCode().getStatus();
        code = bex.getErrorCode().getCode();
        message = bex.getMessage();
    } else if (error instanceof WebExchangeBindException) {
        status = HttpStatus.BAD_REQUEST;
        code = "C001"; message = "잘못된 입력값입니다";
    } else {
        status = HttpStatus.INTERNAL_SERVER_ERROR;
        code = "C003"; message = "서버 내부 오류가 발생했습니다";
    }

    Map&lt;String, Object&gt; body = Map.of(
        "code", code, "message", message,
        "status", status.value(),
        "timestamp", LocalDateTime.now().toString(),
        "path", request.path());

    return ServerResponse.status(status)
        .contentType(MediaType.APPLICATION_JSON)
        .body(BodyInserters.fromValue(body));
}
</code></pre>
<p>}
```</p>
<h3 id="943-controlleradvice">9.4.3 @ControllerAdvice와의 공존</h3>
<p><code>@Order(-2)</code>를 붙인 이유가 뭘까? Spring이 기본으로 제공하는 <code>DefaultErrorWebExceptionHandler</code>가 <code>-1</code>의 우선순위를 가지고 있어서, 우리의 커스텀 핸들러가 먼저 실행되도록 한 것이다. 둘을 동시에 사용할 수 있는데, 처리 순서는 이렇다.</p>
<table>
<thead>
<tr>
<th>단계</th>
<th>처리 주체</th>
<th>대상</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>@ExceptionHandler</code></td>
<td>어노테이션 컨트롤러에서 발생한 예외</td>
</tr>
<tr>
<td>2</td>
<td><code>ErrorWebExceptionHandler</code></td>
<td>1단계에서 처리되지 않은 모든 예외</td>
</tr>
</tbody>
</table>
<p>실무에서 권장하는 패턴은 이렇다: 어노테이션 기반 API에서는 <code>@RestControllerAdvice</code>가 예외를 받고, 함수형 엔드포인트나 필터에서 발생한 예외는 <code>ErrorWebExceptionHandler</code>가 처리하는 구조다. 단, 중요한 건 두 방식이 같은 형식의 에러 응답을 돌려줘야 한다는 점이다.</p>
<hr>
<h2 id="95-problem-details">9.5 에러 응답 표준화 (Problem Details)</h2>
<h3 id="951-rfc-7807">9.5.1 RFC 7807이란?</h3>
<p>지금까지는 우리만의 에러 응답 형식을 만들었는데, 사실 업계에 표준이 있다. RFC 7807(Problem Details for HTTP APIs)이라고 불리는데, HTTP API에서 에러를 어떻게 표현할지를 정한 규격이다.</p>
<table>
<thead>
<tr>
<th>필드</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>type</code></td>
<td>에러 유형을 식별하는 URI</td>
</tr>
<tr>
<td><code>title</code></td>
<td>에러의 짧은 요약</td>
</tr>
<tr>
<td><code>status</code></td>
<td>HTTP 상태 코드</td>
</tr>
<tr>
<td><code>detail</code></td>
<td>에러의 상세 설명</td>
</tr>
<tr>
<td><code>instance</code></td>
<td>에러가 발생한 구체적 URI</td>
</tr>
</tbody>
</table>
<p>Content-Type은 <code>application/problem+json</code>을 사용한다.</p>
<h3 id="952-spring-framework-6-problemdetail">9.5.2 Spring Framework 6의 ProblemDetail</h3>
<p>좋은 소식은 Spring Framework 6부터는 이 표준을 구현한 <code>ProblemDetail</code> 클래스를 기본으로 제공한다는 거다. <code>setProperty()</code>로 맞춤 필드도 추가할 수 있다.</p>
<p><code>java
// ProblemDetail의 주요 구조
public class ProblemDetail {
    private URI type;
    private String title;
    private int status;
    private String detail;
    private URI instance;
    private Map&lt;String, Object&gt; properties; // 확장 필드
}</code></p>
<h3 id="953-problemdetail">9.5.3 ProblemDetail 기반 글로벌 예외 처리</h3>
<p>이제 9.3절의 <code>GlobalExceptionHandler</code>를 <code>ProblemDetail</code>을 사용하도록 개선해보자. 반환 타입을 <code>ResponseEntity&lt;ErrorResponse&gt;</code> 대신 <code>ProblemDetail</code>로 바꾸기만 하면 된다.</p>
<p>```java
package com.example.webfluxdemo.exception;</p>
<p>import lombok.extern.slf4j.Slf4j;
import org.springframework.http.<em>;
import org.springframework.web.bind.annotation.</em>;
import org.springframework.web.bind.support.WebExchangeBindException;
import java.net.URI;
import java.time.Instant;
import java.util.*;</p>
<p>@Slf4j
@RestControllerAdvice
public class ProblemDetailExceptionHandler {</p>
<pre><code>private static final String BASE_TYPE = "https://api.example.com/errors/";

@ExceptionHandler(WebExchangeBindException.class)
public ProblemDetail handleValidation(WebExchangeBindException ex) {
    ProblemDetail problem = ProblemDetail.forStatusAndDetail(
        HttpStatus.BAD_REQUEST, "입력값 검증에 실패했습니다");
    problem.setType(URI.create(BASE_TYPE + "validation-failed"));
    problem.setTitle("Validation Failed");
    problem.setProperty("errors", ex.getFieldErrors().stream()
        .map(fe -&gt; Map.of("field", fe.getField(),
            "message", Objects.toString(fe.getDefaultMessage(), "")))
        .toList());
    problem.setProperty("timestamp", Instant.now());
    return problem;
}

@ExceptionHandler(BusinessException.class)
public ProblemDetail handleBusiness(BusinessException ex) {
    ErrorCode ec = ex.getErrorCode();
    ProblemDetail problem = ProblemDetail.forStatusAndDetail(
        ec.getStatus(), ex.getMessage());
    problem.setType(URI.create(BASE_TYPE + ec.getCode()));
    problem.setTitle(ec.getMessage());
    problem.setProperty("errorCode", ec.getCode());
    problem.setProperty("timestamp", Instant.now());
    return problem;
}

@ExceptionHandler(Exception.class)
public ProblemDetail handleUnhandled(Exception ex) {
    log.error("Unhandled exception", ex);
    ProblemDetail problem = ProblemDetail.forStatusAndDetail(
        HttpStatus.INTERNAL_SERVER_ERROR, "서버 내부 오류가 발생했습니다");
    problem.setType(URI.create(BASE_TYPE + "internal-error"));
    problem.setTitle("Internal Server Error");
    problem.setProperty("timestamp", Instant.now());
    return problem;
}
</code></pre>
<p>}
```</p>
<h3 id="954-problemdetail">9.5.4 ProblemDetail 응답 예시</h3>
<p>이제 실제로 어떻게 응답이 달라지는지 보자. 검증 실패 때는 <code>application/problem+json</code> 타입으로 반환된다.</p>
<p><code>json
{
  "type": "https://api.example.com/errors/validation-failed",
  "title": "Validation Failed",
  "status": 400,
  "detail": "입력값 검증에 실패했습니다",
  "errors": [
    { "field": "name", "message": "이름은 필수 입력 항목입니다" },
    { "field": "price", "message": "가격은 양수여야 합니다" }
  ],
  "timestamp": "2026-02-14T01:30:00Z"
}</code></p>
<p>비즈니스 로직에서 터진 예외는 어떨까?</p>
<p><code>json
{
  "type": "https://api.example.com/errors/U002",
  "title": "이미 등록된 이메일입니다",
  "status": 409,
  "detail": "이메일이(가) 이미 존재합니다. 필드: user@example.com",
  "errorCode": "U002",
  "timestamp": "2026-02-14T01:31:00Z"
}</code></p>
<h3 id="955-problemdetail">9.5.5 ProblemDetail 활성화 설정</h3>
<p>Spring Boot 3에서 이 기능을 전면적으로 활성화하려면 설정 파일에 한두 줄을 추가하면 된다.</p>
<p><code>yaml
spring:
  webflux:
    problemdetails:
      enabled: true</code></p>
<p>필자의 경험상, 이 설정을 켜두면 Spring이 자체적으로 처리하는 예외들(404 Not Found, 405 Method Not Allowed 등)도 모두 <code>ProblemDetail</code> 형식으로 통일되어서 관리가 훨씬 깔끔해진다.</p>
<h3 id="956-errorwebexceptionhandler-problemdetail">9.5.6 ErrorWebExceptionHandler에서 ProblemDetail 사용</h3>
<p>9.4절에서 만들었던 함수형 엔드포인트용 <code>ErrorWebExceptionHandler</code>도 당연히 <code>ProblemDetail</code> 형식을 써야 한다. <code>renderErrorResponse</code> 메서드에서 <code>Map</code> 대신 <code>ProblemDetail</code>을 만들고, Content-Type을 <code>MediaType.APPLICATION_PROBLEM_JSON</code>으로 설정하기만 하면 된다.</p>
<p>```java
private Mono<ServerResponse> renderErrorResponse(ServerRequest request) {
    Throwable error = getError(request);
    HttpStatus status = (error instanceof BusinessException bex)
        ? bex.getErrorCode().getStatus()
        : HttpStatus.INTERNAL_SERVER_ERROR;</p>
<pre><code>ProblemDetail problem = ProblemDetail.forStatusAndDetail(
    status, error.getMessage());
problem.setInstance(URI.create(request.path()));
problem.setProperty("timestamp", Instant.now());

return ServerResponse.status(status)
    .contentType(MediaType.APPLICATION_PROBLEM_JSON)
    .body(BodyInserters.fromValue(problem));
</code></pre>
<p>}
```</p>
<p><code>APPLICATION_PROBLEM_JSON</code>을 설정하면 Content-Type이 정확히 <code>application/problem+json</code>으로 들어가서 RFC 7807 표준을 완벽히 따르게 된다.</p>
<hr>
<h2 id="_1">요약</h2>
<p>이 장에서 배운 내용들을 간단히 정리해보자.</p>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 내용</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Bean Validation</strong></td>
<td><code>@NotBlank</code>, <code>@Email</code>, <code>@Pattern</code> 등으로 DTO 필드를 선언적으로 검증, 컨트롤러에서 <code>@Valid</code>로 활성화</td>
</tr>
<tr>
<td><strong>커스텀 Validator</strong></td>
<td><code>ConstraintValidator</code> 구현으로 비즈니스 규칙 검증, 클래스 레벨 어노테이션으로 크로스 필드 검증</td>
</tr>
<tr>
<td><strong>@RestControllerAdvice</strong></td>
<td><code>@ExceptionHandler</code>로 예외 유형별 처리, <code>ErrorResponse</code> DTO로 일관된 응답 반환</td>
</tr>
<tr>
<td><strong>ErrorWebExceptionHandler</strong></td>
<td><code>AbstractErrorWebExceptionHandler</code> 확장으로 함수형 엔드포인트 포함 모든 예외 통합 처리</td>
</tr>
<tr>
<td><strong>Problem Details</strong></td>
<td>RFC 7807 기반 <code>ProblemDetail</code> 클래스로 에러 응답 표준화, <code>application/problem+json</code> 타입 사용</td>
</tr>
</tbody>
</table>
<p>다음 장에서는 WebFlux의 필터와 인터셉터로 넘어간다. <code>WebFilter</code>와 <code>HandlerFilterFunction</code>을 가지고 요청과 응답을 로깅하고, CORS를 설정하고, API 속도 제한을 구현하는 방법들을 차례로 배워본다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>