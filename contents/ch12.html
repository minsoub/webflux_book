<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 12. Server-Sent Events (SSE) | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="ch11.html">&larr; Chapter 11. 리액티브 보안</a>
    <a href="../index.html">목차</a>
    <a href="ch13.html">Chapter 13. WebSocket &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-12-server-sent-events-sse">Chapter 12. Server-Sent Events (SSE)</h1>
<p>웹 애플리케이션을 개발하다 보면 서버에서 클라이언트에게 실시간으로 데이터를 보내야 하는 상황이 자주 나온다. 주식 시세 업데이트, 사용자 알림, 라이브 피드, 대시보드 변경 감지 같은 기능들이 좋은 예시다. 이 장에서는 이런 요구사항을 해결하는 Server-Sent Events(SSE) 기술을 깊이 있게 살펴본다. SSE 프로토콜의 동작 원리부터 시작해서, Spring WebFlux의 <code>Flux</code>를 이용한 SSE 엔드포인트 구현, 실시간 알림 시스템을 Sinks로 만드는 방법, 그리고 MongoDB Change Streams와 SSE를 조합하여 데이터 변경을 실시간으로 감지하고 전달하는 기법까지 실무에서 바로 활용할 수 있는 패턴들을 다룬다.</p>
<hr>
<h2 id="121-sse">12.1 SSE란 무엇인가?</h2>
<h3 id="1211-sse">12.1.1 SSE 프로토콜 개요</h3>
<p>Server-Sent Events(SSE)는 HTTP 위에서 서버가 클라이언트로 단방향 실시간 데이터를 보내는 표준 프로토콜이다. W3C에서 HTML5 표준으로 정의했고, 모던 브라우저들이 <code>EventSource</code> API를 통해 기본 지원하고 있다.</p>
<p>SSE를 이해하기 위해 몇 가지 특징을 짚고 넘어가자.</p>
<ul>
<li><strong>단방향 통신</strong>: 서버에서 클라이언트로만 데이터를 전송한다. 클라이언트가 서버로 데이터를 보내려면 별도의 HTTP 요청을 사용한다.</li>
<li><strong>HTTP 기반</strong>: 일반 HTTP/1.1 또는 HTTP/2 위에서 동작하므로 별도의 프로토콜이 필요 없다.</li>
<li><strong>자동 재연결</strong>: 연결이 끊어지면 브라우저가 자동으로 재연결을 시도한다.</li>
<li><strong>이벤트 ID 지원</strong>: 마지막으로 수신한 이벤트 ID를 기억하여, 재연결 시 놓친 이벤트를 복구할 수 있다.</li>
<li><strong>텍스트 기반</strong>: <code>text/event-stream</code> MIME 타입을 사용하며, UTF-8 인코딩 텍스트로 데이터를 전송한다.</li>
</ul>
<h3 id="1212-sse">12.1.2 SSE 메시지 형식</h3>
<p>SSE 메시지 형식은 매우 간단하다. 텍스트 줄들로 이루어져 있고, 각 필드는 콜론으로 분리된다.</p>
<p>```
id: 1
event: notification
data: {"message": "새 댓글이 등록되었습니다.", "postId": "abc123"}
retry: 5000</p>
<p>```</p>
<p>각 필드가 무엇을 하는지 살펴보면 이렇다.</p>
<table>
<thead>
<tr>
<th>필드</th>
<th>설명</th>
<th>기본값</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>id</code></td>
<td>이벤트 고유 식별자. 재연결 시 <code>Last-Event-ID</code> 헤더로 전송됨</td>
<td>없음</td>
</tr>
<tr>
<td><code>event</code></td>
<td>이벤트 타입. 클라이언트에서 <code>addEventListener</code>로 특정 타입만 수신 가능</td>
<td><code>message</code></td>
</tr>
<tr>
<td><code>data</code></td>
<td>실제 전송 데이터. 여러 줄 가능 (각 줄마다 <code>data:</code> 접두사 필요)</td>
<td>없음</td>
</tr>
<tr>
<td><code>retry</code></td>
<td>재연결 대기 시간(밀리초). 서버가 클라이언트의 재연결 간격을 제어</td>
<td>브라우저 기본값</td>
</tr>
<tr>
<td><code>:</code> (주석)</td>
<td>콜론으로 시작하는 줄은 주석으로 처리됨. 연결 유지(keep-alive)에 활용</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>메시지는 빈 줄(<code>\n\n</code>)로 구분되는데, 이것이 SSE에서 하나의 메시지 경계를 나타낸다.</p>
<h3 id="1213-sse-vs-websocket-vs">12.1.3 SSE vs WebSocket vs 폴링 비교</h3>
<table>
<thead>
<tr>
<th>구분</th>
<th>SSE</th>
<th>WebSocket</th>
<th>폴링 (Polling)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>통신 방향</strong></td>
<td>단방향 (서버 -&gt; 클라이언트)</td>
<td>양방향</td>
<td>단방향 (클라이언트 요청 기반)</td>
</tr>
<tr>
<td><strong>프로토콜</strong></td>
<td>HTTP</td>
<td>WS (WebSocket 프로토콜)</td>
<td>HTTP</td>
</tr>
<tr>
<td><strong>연결 유지</strong></td>
<td>지속 연결</td>
<td>지속 연결</td>
<td>매 요청마다 연결/해제</td>
</tr>
<tr>
<td><strong>자동 재연결</strong></td>
<td>브라우저 기본 지원</td>
<td>직접 구현 필요</td>
<td>해당 없음</td>
</tr>
<tr>
<td><strong>데이터 형식</strong></td>
<td>텍스트 (UTF-8)</td>
<td>텍스트 + 바이너리</td>
<td>제한 없음</td>
</tr>
<tr>
<td><strong>방화벽/프록시</strong></td>
<td>HTTP이므로 통과 용이</td>
<td>차단될 수 있음</td>
<td>문제 없음</td>
</tr>
<tr>
<td><strong>HTTP/2 호환</strong></td>
<td>멀티플렉싱 활용 가능</td>
<td>별도 연결 필요</td>
<td>해당 없음</td>
</tr>
<tr>
<td><strong>서버 부하</strong></td>
<td>낮음</td>
<td>낮음</td>
<td>높음 (반복 요청)</td>
</tr>
</tbody>
</table>
<p>SSE는 알림, 뉴스 피드, 주식 시세, 진행률 표시 같은 <strong>서버에서 클라이언트로의 단방향 스트리밍</strong> 시나리오에서 빛난다. 기존 HTTP 인프라(로드밸런서, 프록시, 인증)를 그대로 활용할 수 있다는 점이 큰 장점이고, 브라우저가 자동으로 재연결을 처리해주니 구현 복잡도도 낮다. 필자의 경험상 단순한 알림 시스템에서는 WebSocket보다 SSE를 선택하는 것이 훨씬 운영하기 편하다. 다만 채팅이나 게임처럼 양방향 실시간 통신이 필요하거나 바이너리 데이터를 자주 주고받아야 한다면 WebSocket이 더 나은 선택이다.</p>
<h3 id="1214-eventsource-api">12.1.4 클라이언트 측 EventSource API</h3>
<p>클라이언트 쪽에서 SSE를 수신하는 JavaScript 코드를 보자. 정말 간단하다.</p>
<p>```javascript
const eventSource = new EventSource('/api/notifications/stream');</p>
<p>// 기본 message 이벤트 수신
eventSource.onmessage = (event) =&gt; {
    const data = JSON.parse(event.data);
    console.log('수신:', data);
};</p>
<p>// 특정 이벤트 타입 수신
eventSource.addEventListener('notification', (event) =&gt; {
    const notification = JSON.parse(event.data);
    showNotification(notification);
});</p>
<p>// 에러 처리 및 연결 종료
eventSource.onerror = (error) =&gt; {
    console.error('SSE 연결 오류:', error);
    if (eventSource.readyState === EventSource.CLOSED) {
        console.log('연결이 종료되었습니다.');
    }
};
```</p>
<p><code>EventSource</code>는 한 가지 놀라운 기능이 있는데, 연결이 떨어지면 자동으로 재연결을 시도한다는 것이다. 개발자가 따로 구현할 필요가 없다. <code>readyState</code> 속성으로 연결 상태를 확인할 수 있으며, 세 가지 상태(<code>CONNECTING(0)</code>, <code>OPEN(1)</code>, <code>CLOSED(2)</code>)를 가진다.</p>
<hr>
<h2 id="122-flux-sse">12.2 Flux를 활용한 SSE 엔드포인트 구현</h2>
<h3 id="1221-text_event_stream">12.2.1 TEXT_EVENT_STREAM 미디어 타입</h3>
<p>다행히 Spring WebFlux에는 SSE 지원이 이미 내장되어 있어서 추가 라이브러리를 설치할 필요가 없다. SSE 엔드포인트를 구현하는 가장 직관적인 방법은 컨트롤러 메서드에서 <code>Flux</code>를 반환하고 <code>produces</code> 속성에 <code>text/event-stream</code> 미디어 타입을 지정하는 것이다. 보기보다 간단하다.</p>
<p>```java
@RestController
@RequestMapping("/api/sse")
public class SseController {</p>
<pre><code>@GetMapping(value = "/time", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;String&gt; streamTime() {
    return Flux.interval(Duration.ofSeconds(1))
        .map(sequence -&gt; "현재 시각: " + LocalDateTime.now()
            .format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
}
</code></pre>
<p>}
```</p>
<p>보면 알겠지만, <code>MediaType.TEXT_EVENT_STREAM_VALUE</code>는 단순히 <code>"text/event-stream"</code> 문자열을 상수로 정의한 것이다. 이것만 설정하면 Spring WebFlux가 나머지를 다 처리해준다. <code>Flux</code>의 각 요소가 자동으로 SSE 메시지 형식(<code>data:</code> 필드)으로 변환되어 클라이언트에 흘러간다.</p>
<h3 id="1222-serversentevent">12.2.2 ServerSentEvent 클래스 활용</h3>
<p>하지만 <code>data</code> 필드만으로는 부족한 경우가 많다. <code>id</code>, <code>event</code>, <code>retry</code> 같은 필드들도 제어하고 싶으면 <code>ServerSentEvent&lt;T&gt;</code> 제네릭 클래스를 사용하면 된다.</p>
<p><code>java
@GetMapping(value = "/events", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;ServerSentEvent&lt;String&gt;&gt; streamEvents() {
    return Flux.interval(Duration.ofSeconds(2))
        .map(sequence -&gt; ServerSentEvent.&lt;String&gt;builder()
            .id(String.valueOf(sequence))
            .event("heartbeat")
            .data("서버 상태: 정상 (seq=" + sequence + ")")
            .retry(Duration.ofSeconds(10))
            .comment("keep-alive")
            .build());
}</code></p>
<p>흥미로운 점은 <code>ServerSentEvent</code>를 반환 타입으로 사용할 때는 <code>produces</code> 속성을 생략해도 된다는 것이다. Spring WebFlux가 반환 타입을 분석해서 자동으로 <code>text/event-stream</code>을 적용해버린다.</p>
<p><code>java
// produces 생략 가능 - ServerSentEvent 반환 시 자동 적용
@GetMapping("/events-auto")
public Flux&lt;ServerSentEvent&lt;Map&lt;String, Object&gt;&gt;&gt; streamEventsAuto() {
    return Flux.interval(Duration.ofSeconds(3))
        .map(seq -&gt; ServerSentEvent.&lt;Map&lt;String, Object&gt;&gt;builder()
            .id(String.valueOf(seq))
            .event("status-update")
            .data(Map.of("sequence", seq, "timestamp", Instant.now().toString()))
            .build());
}</code></p>
<h3 id="1223-fluxinterval">12.2.3 Flux.interval을 활용한 주기적 데이터 전송</h3>
<p>실제 SSE 구현에서는 타이머 같은 구조가 자주 나온다. <code>Flux.interval()</code>이 바로 그 도구다. 지정된 간격으로 0부터 시작하는 <code>Long</code> 값을 계속 내보내는 Hot Publisher다. 주기적으로 데이터를 보내야 하는 SSE 엔드포인트에 딱 맞다.</p>
<p>```java
@RestController
@RequestMapping("/api/sse")
@RequiredArgsConstructor
public class DashboardSseController {</p>
<pre><code>private final SystemMetricsService metricsService;

@GetMapping(value = "/dashboard", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;ServerSentEvent&lt;DashboardData&gt;&gt; streamDashboard() {
    return Flux.interval(Duration.ofSeconds(5))
        .flatMap(tick -&gt; metricsService.collectMetrics())
        .map(metrics -&gt; ServerSentEvent.&lt;DashboardData&gt;builder()
            .event("dashboard-update")
            .data(metrics)
            .build())
        .doOnCancel(() -&gt; log.info("대시보드 SSE 연결 해제"));
}
</code></pre>
<p>}
```</p>
<p><code>java
@Data
@Builder
public class DashboardData {
    private double cpuUsage;
    private long memoryUsed;
    private long memoryTotal;
    private int activeThreads;
    private Instant timestamp;
}</code></p>
<h3 id="1224-fluxmerge">12.2.4 이벤트 타입 혼합과 Flux.merge</h3>
<p>실무에서는 한 가지 이벤트만 보내는 경우보다 여러 종류의 이벤트를 섞어서 보내야 할 때가 많다. 시스템 상태, 통계, 하트비트 같은 것들이 동시에 흘러가야 하는 상황 말이다. <code>Flux.merge</code>를 사용하면 여러 스트림을 하나로 합칠 수 있고, 클라이언트는 <code>addEventListener</code>로 필요한 이벤트만 골라서 받을 수 있다.</p>
<p>```java
@GetMapping(value = "/mixed", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;ServerSentEvent&lt;?&gt;&gt; streamMixedEvents() {
    Flux&lt;ServerSentEvent&lt;?&gt;&gt; statusStream = Flux.interval(Duration.ofSeconds(5))
        .map(tick -&gt; ServerSentEvent.builder()
            .event("system-status")
            .data(Map.of("status", "healthy", "uptime", tick * 5))
            .build());</p>
<pre><code>Flux&lt;ServerSentEvent&lt;?&gt;&gt; statsStream = Flux.interval(Duration.ofSeconds(10))
    .map(tick -&gt; ServerSentEvent.builder()
        .event("statistics")
        .data(Map.of("activeUsers", 42 + tick, "requestsPerSec", 150))
        .build());

// 30초마다 주석 기반 하트비트 전송 (연결 유지용)
Flux&lt;ServerSentEvent&lt;?&gt;&gt; heartbeat = Flux.interval(Duration.ofSeconds(30))
    .map(tick -&gt; ServerSentEvent.builder().comment("heartbeat").build());

return Flux.merge(statusStream, statsStream, heartbeat);
</code></pre>
<p>}
```</p>
<h3 id="1225-sse">12.2.5 함수형 라우터에서 SSE 구현</h3>
<p>컨트롤러 방식 대신 Router Functions를 선호한다면 그쪽으로도 SSE를 구현할 수 있다.</p>
<p>```java
@Configuration
public class SseRouterConfig {</p>
<pre><code>@Bean
public RouterFunction&lt;ServerResponse&gt; sseRoutes(SseHandler handler) {
    return RouterFunctions.route()
        .GET("/api/sse/stream", handler::stream)
        .build();
}
</code></pre>
<p>}</p>
<p>@Component
public class SseHandler {</p>
<pre><code>public Mono&lt;ServerResponse&gt; stream(ServerRequest request) {
    Flux&lt;ServerSentEvent&lt;String&gt;&gt; events = Flux.interval(Duration.ofSeconds(1))
        .map(seq -&gt; ServerSentEvent.&lt;String&gt;builder()
            .id(String.valueOf(seq))
            .data("tick " + seq)
            .build());

    return ServerResponse.ok()
        .contentType(MediaType.TEXT_EVENT_STREAM)
        .body(events, ServerSentEvent.class);
}
</code></pre>
<p>}
```</p>
<hr>
<h2 id="123">12.3 실시간 알림 시스템 구축</h2>
<h3 id="1231-sinks">12.3.1 Sinks를 활용한 이벤트 브로드캐스팅</h3>
<p><code>Flux.interval()</code>로 주기적으로 데이터를 보내는 것만으로는 실무 서비스를 만들 수 없다. 댓글이 달리거나 특정 이벤트가 발생할 때 연결된 모든 클라이언트에게 즉각적으로 알려줘야 하니까. 바로 이런 상황에서 Reactor의 <code>Sinks</code>가 활용된다. 프로그래밍 방식으로 이벤트를 발행할 수 있는 Hot Publisher이기 때문에 이 목적에 완벽하다.</p>
<p>```java
@Service
@Slf4j
public class NotificationBroadcaster {</p>
<pre><code>private final Sinks.Many&lt;Notification&gt; sink =
    Sinks.many().multicast().onBackpressureBuffer(256);

public void publish(Notification notification) {
    Sinks.EmitResult result = sink.tryEmitNext(notification);
    if (result.isFailure()) {
        log.warn("알림 발행 실패: {}, result={}", notification.getId(), result);
    }
}

public Flux&lt;Notification&gt; subscribe() {
    return sink.asFlux();
}
</code></pre>
<p>}
```</p>
<p>Sinks의 종류를 이해하려면 각 팩토리 메서드의 차이를 알아야 한다.</p>
<table>
<thead>
<tr>
<th>메서드</th>
<th>설명</th>
<th>사용 시나리오</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Sinks.many().multicast()</code></td>
<td>여러 구독자에게 동일 이벤트를 전달. 구독 전 발행된 이벤트는 수신 불가</td>
<td>실시간 알림, 라이브 피드</td>
</tr>
<tr>
<td><code>Sinks.many().replay()</code></td>
<td>과거 이벤트를 새 구독자에게 재전송 가능</td>
<td>최근 N건의 이벤트 보여주기</td>
</tr>
<tr>
<td><code>Sinks.many().unicast()</code></td>
<td>단일 구독자만 허용</td>
<td>1:1 전용 스트림</td>
</tr>
</tbody>
</table>
<h3 id="1232">12.3.2 알림 도메인 모델</h3>
<p><code>java
@Document(collection = "notifications")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Notification {
    @Id
    private String id;
    private String userId;       // 수신 대상 사용자
    private String type;         // COMMENT, LIKE, FOLLOW, SYSTEM 등
    private String title;
    private String message;
    private Map&lt;String, Object&gt; metadata;  // 추가 정보 (postId, commentId 등)
    private boolean read;
    private LocalDateTime createdAt;
}</code></p>
<p><code>java
public interface NotificationRepository
        extends ReactiveMongoRepository&lt;Notification, String&gt; {
    Flux&lt;Notification&gt; findByUserIdOrderByCreatedAtDesc(String userId);
    Flux&lt;Notification&gt; findByUserIdAndReadFalse(String userId);
    Mono&lt;Long&gt; countByUserIdAndReadFalse(String userId);
}</code></p>
<h3 id="1233">12.3.3 사용자별 알림 구독 관리</h3>
<p>모든 알림을 모든 사용자에게 보낼 수는 없다. 각 사용자마다 독립적인 구독을 관리해야 하고, 해당 사용자에게만 알림을 전달해야 한다. 이것이 실무에서 많이 쓰이는 패턴인데, 살펴보자.</p>
<p>```java
@Service
@Slf4j
public class NotificationService {</p>
<pre><code>private final NotificationRepository notificationRepository;
private final ConcurrentHashMap&lt;String, Sinks.Many&lt;Notification&gt;&gt; userSinks =
    new ConcurrentHashMap&lt;&gt;();

public NotificationService(NotificationRepository notificationRepository) {
    this.notificationRepository = notificationRepository;
}

/**
 * 사용자별 알림 스트림을 구독한다.
 */
public Flux&lt;ServerSentEvent&lt;Notification&gt;&gt; subscribe(String userId) {
    Sinks.Many&lt;Notification&gt; userSink = userSinks.computeIfAbsent(userId,
        key -&gt; {
            log.info("사용자 {} 알림 구독 생성", key);
            return Sinks.many().multicast().onBackpressureBuffer(128);
        });

    return userSink.asFlux()
        .map(notification -&gt; ServerSentEvent.&lt;Notification&gt;builder()
            .id(notification.getId())
            .event(notification.getType())
            .data(notification)
            .build());
}

/**
 * 특정 사용자에게 알림을 전송한다.
 * MongoDB에 저장하고, 접속 중이면 SSE로 실시간 전달한다.
 */
public Mono&lt;Notification&gt; sendNotification(Notification notification) {
    notification.setCreatedAt(LocalDateTime.now());
    notification.setRead(false);

    return notificationRepository.save(notification)
        .doOnSuccess(saved -&gt; {
            Sinks.Many&lt;Notification&gt; userSink =
                userSinks.get(saved.getUserId());
            if (userSink != null) {
                Sinks.EmitResult result = userSink.tryEmitNext(saved);
                if (result.isFailure()) {
                    log.warn("사용자 {} 알림 전송 실패: {}",
                        saved.getUserId(), result);
                }
            } else {
                log.debug("사용자 {} 미접속 상태, 알림은 DB에만 저장됨",
                    saved.getUserId());
            }
        });
}

public Mono&lt;Long&gt; getUnreadCount(String userId) {
    return notificationRepository.countByUserIdAndReadFalse(userId);
}

public Mono&lt;Notification&gt; markAsRead(String notificationId) {
    return notificationRepository.findById(notificationId)
        .map(notification -&gt; {
            notification.setRead(true);
            return notification;
        })
        .flatMap(notificationRepository::save);
}

/**
 * 사용자의 SSE 연결이 해제될 때 호출된다.
 */
public void removeSubscription(String userId) {
    Sinks.Many&lt;Notification&gt; removed = userSinks.remove(userId);
    if (removed != null) {
        removed.tryEmitComplete();
        log.info("사용자 {} 알림 구독 해제", userId);
    }
}
</code></pre>
<p>}
```</p>
<h3 id="1234-sse">12.3.4 알림 SSE 컨트롤러</h3>
<p>```java
@RestController
@RequestMapping("/api/notifications")
@RequiredArgsConstructor
@Slf4j
public class NotificationController {</p>
<pre><code>private final NotificationService notificationService;

@GetMapping(value = "/stream/{userId}",
            produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;ServerSentEvent&lt;Notification&gt;&gt; streamNotifications(
        @PathVariable String userId) {

    log.info("SSE 연결: userId={}", userId);

    // 실시간 알림 스트림
    Flux&lt;ServerSentEvent&lt;Notification&gt;&gt; notificationStream =
        notificationService.subscribe(userId);

    // 30초마다 하트비트 전송 (프록시/로드밸런서 타임아웃 방지)
    Flux&lt;ServerSentEvent&lt;Notification&gt;&gt; heartbeat =
        Flux.interval(Duration.ofSeconds(30))
            .map(tick -&gt; ServerSentEvent.&lt;Notification&gt;builder()
                .comment("heartbeat")
                .build());

    return Flux.merge(notificationStream, heartbeat)
        .doOnCancel(() -&gt; {
            log.info("SSE 연결 해제: userId={}", userId);
            notificationService.removeSubscription(userId);
        });
}

@PostMapping
@ResponseStatus(HttpStatus.CREATED)
public Mono&lt;Notification&gt; sendNotification(
        @RequestBody Notification notification) {
    return notificationService.sendNotification(notification);
}

@PatchMapping("/{notificationId}/read")
public Mono&lt;Notification&gt; markAsRead(
        @PathVariable String notificationId) {
    return notificationService.markAsRead(notificationId);
}
</code></pre>
<p>}
```</p>
<h3 id="1235">12.3.5 연결 해제 처리와 리소스 정리</h3>
<p>SSE 연결이 끊어지는 상황은 여러 가지가 있다. 정리해보면 이렇다.</p>
<ol>
<li><strong>클라이언트가 연결을 닫는 경우</strong>: <code>EventSource.close()</code> 호출 또는 브라우저 탭 닫기</li>
<li><strong>서버에서 스트림을 완료하는 경우</strong>: <code>Flux</code>가 <code>onComplete</code> 또는 <code>onError</code> 신호를 발생</li>
<li><strong>네트워크 문제</strong>: 예기치 않게 연결이 끊어지는 경우</li>
<li><strong>프록시/로드밸런서 타임아웃</strong>: 일정 시간 동안 데이터가 흐르지 않으면 자동으로 연결 종료</li>
</ol>
<p>모든 상황을 통일되게 처리하려면 <code>doFinally</code>를 사용하면 된다. 이 메서드는 <code>onComplete</code>, <code>onError</code>, <code>cancel</code> 모든 종료 신호를 감지하기 때문에, 리소스를 안전하게 정리하는 데 이상적이다.</p>
<p>```java
@GetMapping(value = "/stream/{userId}",
            produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux<ServerSentEvent\<Notification>> streamWithCleanup(
        @PathVariable String userId) {</p>
<pre><code>return notificationService.subscribe(userId)
    .timeout(Duration.ofHours(1))
    .onErrorResume(TimeoutException.class, e -&gt; {
        log.info("SSE 타임아웃: userId={}", userId);
        return Flux.empty();
    })
    .doFinally(signalType -&gt; {
        log.info("SSE 스트림 종료: userId={}, signal={}", userId, signalType);
        notificationService.removeSubscription(userId);
    });
</code></pre>
<p>}
```</p>
<h3 id="1236">12.3.6 알림 발행 연동 예제</h3>
<p>여기까지 배운 것들을 실제로 조합해보자. 게시글에 댓글이 달릴 때 게시글 작성자에게 알림을 보내는 상황을 구현해보면 이렇게 된다.</p>
<p>```java
@Service
@RequiredArgsConstructor
public class CommentService {</p>
<pre><code>private final CommentRepository commentRepository;
private final PostRepository postRepository;
private final NotificationService notificationService;

public Mono&lt;Comment&gt; addComment(String postId, CommentRequest request) {
    Comment comment = Comment.builder()
        .postId(postId)
        .authorId(request.getAuthorId())
        .authorName(request.getAuthorName())
        .content(request.getContent())
        .createdAt(LocalDateTime.now())
        .build();

    return commentRepository.save(comment)
        .flatMap(saved -&gt; postRepository.findById(postId)
            .flatMap(post -&gt; {
                if (!post.getAuthorId().equals(request.getAuthorId())) {
                    Notification notification = Notification.builder()
                        .userId(post.getAuthorId())
                        .type("COMMENT")
                        .title("새 댓글")
                        .message(request.getAuthorName() + "님이 '"
                            + post.getTitle() + "'에 댓글을 남겼습니다.")
                        .metadata(Map.of(
                            "postId", postId,
                            "commentId", saved.getId()))
                        .build();
                    return notificationService.sendNotification(notification)
                        .thenReturn(saved);
                }
                return Mono.just(saved);
            }));
}
</code></pre>
<p>}
```</p>
<p>참고로, 11장에서 배운 JWT 인증을 이 시스템과 함께 사용하면 <code>ReactiveSecurityContextHolder</code>에서 현재 사용자를 가져와서 인증된 사용자 전용 SSE 구독을 만들 수 있다. 필자의 경험상 이렇게 조합하면 보안이 훨씬 단단해진다.</p>
<p><code>java
@GetMapping(value = "/stream/me",
            produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;ServerSentEvent&lt;Notification&gt;&gt; streamMyNotifications() {
    return ReactiveSecurityContextHolder.getContext()
        .map(ctx -&gt; ctx.getAuthentication().getName())
        .flatMapMany(username -&gt; notificationService.subscribe(username)
            .doFinally(signal -&gt;
                notificationService.removeSubscription(username)));
}</code></p>
<hr>
<h2 id="124-mongodb-change-streams-sse">12.4 MongoDB Change Streams + SSE 연동</h2>
<h3 id="1241-change-streams">12.4.1 Change Streams 개요</h3>
<p>MongoDB의 Change Streams 기능은 컬렉션, 데이터베이스, 또는 클러스터 전체의 데이터 변경을 실시간으로 감시한다. 8장에서 기초를 다루었지만, 이번에는 이 기능을 SSE와 결합해서 클라이언트에게 데이터 변경을 즉시 알리는 방법을 중점적으로 살펴본다.</p>
<ul>
<li><strong>이벤트 타입</strong>: <code>insert</code>, <code>update</code>, <code>replace</code>, <code>delete</code>, <code>invalidate</code></li>
<li><strong>Resume Token</strong>: 연결이 끊어진 지점부터 이벤트를 다시 수신할 수 있다</li>
<li><strong>필터링</strong>: Aggregation Pipeline을 사용하여 관심 있는 변경만 수신 가능</li>
<li><strong>요구사항</strong>: Replica Set 또는 Sharded Cluster 환경에서만 작동한다. 단일 노드 MongoDB에서는 쓸 수 없다는 점을 기억해두자</li>
</ul>
<h3 id="1242-reactivemongotemplate-changestream">12.4.2 ReactiveMongoTemplate의 changeStream()</h3>
<p>Spring Data MongoDB에서 제공하는 <code>ReactiveMongoTemplate</code>은 <code>changeStream()</code> 메서드로 MongoDB의 Change Streams를 <code>Flux</code>로 변환해준다. 간단하지만 강력한 도구다.</p>
<p>```java
@Service
@RequiredArgsConstructor
@Slf4j
public class ProductChangeStreamService {</p>
<pre><code>private final ReactiveMongoTemplate mongoTemplate;

public Flux&lt;ChangeStreamEvent&lt;Product&gt;&gt; watchProducts() {
    return mongoTemplate.changeStream("products",
            ChangeStreamOptions.builder()
                .filter(Aggregation.newAggregation(
                    Aggregation.match(Criteria.where("operationType")
                        .in("insert", "update", "replace"))))
                .build(),
            Product.class)
        .doOnNext(event -&gt; log.info("변경 감지: type={}, id={}",
            event.getOperationType(), event.getBody()));
}

public Flux&lt;ChangeStreamEvent&lt;Product&gt;&gt; watchProductsByCategory(
        String category) {
    return mongoTemplate.changeStream("products",
            ChangeStreamOptions.builder()
                .filter(Aggregation.newAggregation(
                    Aggregation.match(Criteria.where("operationType")
                        .in("insert", "update", "replace")
                        .and("fullDocument.category").is(category))))
                .build(),
            Product.class);
}
</code></pre>
<p>}
```</p>
<h3 id="1243-change-streams-sse">12.4.3 Change Streams를 SSE로 전달</h3>
<p>MongoDB의 Change Streams 이벤트를 받아서 SSE로 클라이언트에게 보내는 컨트롤러를 만들어보자.</p>
<p><code>java
@Data
@Builder
public class ProductChangeEvent {
    private String operationType;
    private Product product;
    private Instant timestamp;
}</code></p>
<p>```java
@RestController
@RequestMapping("/api/products")
@RequiredArgsConstructor
@Slf4j
public class ProductSseController {</p>
<pre><code>private final ProductChangeStreamService changeStreamService;

@GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;ServerSentEvent&lt;ProductChangeEvent&gt;&gt; streamProductChanges() {

    Flux&lt;ServerSentEvent&lt;ProductChangeEvent&gt;&gt; changeStream =
        changeStreamService.watchProducts()
            .map(event -&gt; {
                ProductChangeEvent payload = ProductChangeEvent.builder()
                    .operationType(event.getOperationType().getValue())
                    .product(event.getBody())
                    .timestamp(Instant.now())
                    .build();

                return ServerSentEvent.&lt;ProductChangeEvent&gt;builder()
                    .id(event.getResumeToken() != null
                        ? event.getResumeToken().toJson() : null)
                    .event("product-" + event.getOperationType().getValue())
                    .data(payload)
                    .build();
            });

    Flux&lt;ServerSentEvent&lt;ProductChangeEvent&gt;&gt; heartbeat =
        Flux.interval(Duration.ofSeconds(30))
            .map(tick -&gt; ServerSentEvent.&lt;ProductChangeEvent&gt;builder()
                .comment("heartbeat")
                .build());

    return Flux.merge(changeStream, heartbeat)
        .doOnCancel(() -&gt; log.info("상품 변경 SSE 연결 해제"));
}
</code></pre>
<p>}
```</p>
<h3 id="1244-resume-token">12.4.4 Resume Token을 활용한 이벤트 복구</h3>
<p>네트워크가 끊어지거나 클라이언트가 재연결할 때 이전에 받던 이벤트들을 빠뜨리지 않으려면 Resume Token을 활용해야 한다. SSE의 <code>id</code> 필드에 Resume Token을 넣어두면, 브라우저가 자동으로 재연결 시 <code>Last-Event-ID</code> 헤더에 담아서 보낸다. 매우 우아한 설계다.</p>
<p>```java
@Service
@RequiredArgsConstructor
@Slf4j
public class ResumableChangeStreamService {</p>
<pre><code>private final ReactiveMongoTemplate mongoTemplate;

public Flux&lt;ChangeStreamEvent&lt;Product&gt;&gt; watchProducts(String resumeToken) {
    ChangeStreamOptions.ChangeStreamOptionsBuilder optionsBuilder =
        ChangeStreamOptions.builder()
            .filter(Aggregation.newAggregation(
                Aggregation.match(Criteria.where("operationType")
                    .in("insert", "update", "replace"))));

    if (resumeToken != null &amp;&amp; !resumeToken.isEmpty()) {
        try {
            BsonDocument token = BsonDocument.parse(resumeToken);
            optionsBuilder.resumeAfter(token);
            log.info("Resume Token으로 변경 스트림 재개");
        } catch (Exception e) {
            log.warn("유효하지 않은 Resume Token, 처음부터 시작");
        }
    }

    return mongoTemplate.changeStream("products",
        optionsBuilder.build(), Product.class);
}
</code></pre>
<p>}
```</p>
<p>```java
@GetMapping(value = "/stream/resumable",
            produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux<ServerSentEvent\<ProductChangeEvent>> streamResumable(
        @RequestHeader(value = "Last-Event-ID", required = false)
        String lastEventId) {</p>
<pre><code>return resumableChangeStreamService.watchProducts(lastEventId)
    .map(event -&gt; {
        String tokenJson = event.getResumeToken() != null
            ? event.getResumeToken().toJson() : null;

        ProductChangeEvent payload = ProductChangeEvent.builder()
            .operationType(event.getOperationType().getValue())
            .product(event.getBody())
            .timestamp(Instant.now())
            .build();

        return ServerSentEvent.&lt;ProductChangeEvent&gt;builder()
            .id(tokenJson)
            .event("product-change")
            .data(payload)
            .build();
    });
</code></pre>
<p>}
```</p>
<p>클라이언트 쪽에서는 특별히 할 일이 없다. <code>EventSource</code>가 알아서 재연결할 때 <code>Last-Event-ID</code>를 보내니까.</p>
<p><code>javascript
const es = new EventSource('/api/products/stream/resumable');
es.addEventListener('product-change', (e) =&gt; {
    console.log('이벤트 ID:', e.lastEventId);
    const change = JSON.parse(e.data);
    applyChange(change);
});</code></p>
<h3 id="1245">12.4.5 실시간 데이터 동기화 패턴</h3>
<p>Change Streams와 SSE를 조합하면 여러 브라우저 탭이나 사용자 간에 데이터를 실시간으로 동기화할 수 있다. 한 사용자가 상품 정보를 수정하면, 같은 상품을 보고 있는 다른 사용자의 화면에 즉시 반영되는 그런 경험을 만들 수 있다는 뜻이다. 필자의 경험상 이 패턴을 구현할 때 핵심은 이렇다.</p>
<ol>
<li><strong><code>@PostConstruct</code>에서 Change Stream 시작</strong>: 애플리케이션 기동 시 감시할 컬렉션에 대해 Change Stream을 구독한다.</li>
<li><strong>세션별 Sink 관리</strong>: <code>ConcurrentHashMap&lt;String, Sinks.Many&lt;ChangeEvent&gt;&gt;</code>로 세션마다 독립적인 Sink를 생성한다.</li>
<li><strong>이벤트 분배</strong>: Change Stream에서 수신한 이벤트를 해당 컬렉션을 구독 중인 모든 세션의 Sink에 <code>tryEmitNext</code>로 전달한다.</li>
<li><strong>SSE 엔드포인트</strong>: <code>GET /api/sync/stream/{collection}?sessionId=xxx</code> 형태로 클라이언트가 특정 컬렉션의 변경 사항을 구독한다.</li>
</ol>
<p>이 패턴은 12.3절의 사용자별 알림 구독과 동일한 <code>ConcurrentHashMap</code> + <code>Sinks</code> 구조를 컬렉션 단위로 확장한 것이다.</p>
<h3 id="1246">12.4.6 프로덕션 환경 고려사항</h3>
<p>개발 환경에서는 잘 작동하는 SSE도 프로덕션에 올리면 문제가 생기는 경우가 많다. 미리 알아둬야 할 사항들을 정리했다.</p>
<p><strong>1. 연결 수 관리</strong></p>
<p>SSE는 HTTP 연결을 계속 열어놓기 때문에, 동시 연결 수가 늘어나면 서버 메모리와 파일 디스크립터가 빠르게 소진된다. <code>AtomicInteger</code>로 활성 연결 수를 세어두고 최대 한계를 설정해둔다. 너무 많은 연결을 받지 않도록 선제적으로 차단하는 것이 좋다.</p>
<p><strong>2. 프록시/로드밸런서 설정</strong></p>
<p>Nginx 같은 리버스 프록시가 앞단에 있으면, SSE 연결이 조기에 끊어지는 문제가 자주 생긴다. 이를 방지하려면 프록시에서 버퍼링을 끄고 타임아웃을 충분히 길게 설정해야 한다.</p>
<p><code>nginx
location /api/sse/ {
    proxy_pass http://backend;
    proxy_http_version 1.1;
    proxy_set_header Connection '';
    proxy_buffering off;
    proxy_cache off;
    proxy_read_timeout 86400s;
    chunked_transfer_encoding off;
}</code></p>
<p><strong>3. 하트비트</strong></p>
<p>프록시 타임아웃으로 연결이 끊어지는 것을 방지하려면 주기적으로 하트비트를 보내면 된다. SSE의 주석 문법(<code>:</code> 접두사)을 활용하면 클라이언트 쪽 이벤트 핸들러를 건드리지 않으면서도 연결을 살려둘 수 있다.</p>
<p><strong>4. 에러 복구 전략</strong></p>
<p>Change Stream이 갑자기 끊어질 수 있다. 데이터베이스가 재시작되거나 네트워크 문제가 생길 때 말이다. 이럴 때 자동으로 재시도하는 로직이 있으면 훨씬 안정적이다. <code>retryWhen</code>에 지수 백오프를 걸어두면 일시적 장애에서 우아하게 복구할 수 있다.</p>
<p><code>java
private void watchCollectionWithRetry(String collectionName) {
    mongoTemplate.changeStream(collectionName,
            ChangeStreamOptions.empty(), Document.class)
        .doOnError(e -&gt; log.error("{} Change Stream 오류", collectionName, e))
        .retryWhen(Retry.backoff(Long.MAX_VALUE, Duration.ofSeconds(1))
            .maxBackoff(Duration.ofMinutes(1))
            .doBeforeRetry(signal -&gt; log.warn("{} Change Stream 재시도 #{}",
                collectionName, signal.totalRetries())))
        .subscribe(this::processChangeEvent);
}</code></p>
<hr>
<h2 id="_1">요약</h2>
<p>이번 장에서 배운 내용의 핵심을 다시 한 번 정리해보자.</p>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 내용</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SSE 프로토콜</strong></td>
<td>서버에서 클라이언트로의 단방향 HTTP 기반 실시간 스트리밍, 자동 재연결, 이벤트 ID 지원</td>
</tr>
<tr>
<td><strong>SSE vs WebSocket</strong></td>
<td>SSE는 단방향/HTTP 기반으로 인프라 호환성이 높고, WebSocket은 양방향/바이너리 지원</td>
</tr>
<tr>
<td><strong>Flux + SSE</strong></td>
<td><code>TEXT_EVENT_STREAM</code> 미디어 타입과 <code>ServerSentEvent&lt;T&gt;</code> 클래스로 SSE 엔드포인트 구현</td>
</tr>
<tr>
<td><strong>Sinks 브로드캐스팅</strong></td>
<td><code>Sinks.many().multicast()</code>로 이벤트를 발행하고 여러 SSE 구독자에게 실시간 전달</td>
</tr>
<tr>
<td><strong>사용자별 알림</strong></td>
<td><code>ConcurrentHashMap</code>으로 사용자별 Sink를 관리하여 개인화된 알림 스트림 구현</td>
</tr>
<tr>
<td><strong>연결 해제 처리</strong></td>
<td><code>doOnCancel</code>, <code>doFinally</code>로 SSE 연결 종료 시 리소스 정리</td>
</tr>
<tr>
<td><strong>Change Streams + SSE</strong></td>
<td>MongoDB 데이터 변경을 감지하여 SSE로 실시간 전달, Resume Token으로 이벤트 복구</td>
</tr>
<tr>
<td><strong>실시간 데이터 동기화</strong></td>
<td>Change Streams + Sinks + SSE를 조합하여 여러 클라이언트 간 데이터 동기화</td>
</tr>
</tbody>
</table>
<p>다음 장은 WebSocket으로 나아간다. 양방향 실시간 통신이 필요한 채팅 애플리케이션을 어떻게 만드는지 알아볼 것이다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>