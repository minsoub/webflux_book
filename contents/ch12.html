<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 12. Server-Sent Events (SSE) | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="ch11.html">&larr; Chapter 11. 리액티브 보안</a>
    <a href="../index.html">목차</a>
    <a href="ch13.html">Chapter 13. WebSocket &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="chapter-12-server-sent-events-sse">Chapter 12. Server-Sent Events (SSE)</h1>
<p>웹 애플리케이션에서 서버가 클라이언트에게 실시간으로 데이터를 전달해야 하는 상황은 매우 흔하다. 주식 시세, 알림, 라이브 피드, 대시보드 업데이트 등이 대표적인 사례다. 이번 장에서는 Server-Sent Events(SSE) 프로토콜의 개념과 Spring WebFlux에서 <code>Flux</code>를 활용한 SSE 엔드포인트 구현, Sinks 기반의 실시간 알림 시스템 구축, 그리고 MongoDB Change Streams와 SSE를 연동하여 데이터 변경 사항을 실시간으로 전달하는 방법까지 단계별로 다룬다.</p>
<hr>
<h2 id="121-sse">12.1 SSE란 무엇인가?</h2>
<h3 id="1211-sse">12.1.1 SSE 프로토콜 개요</h3>
<p>Server-Sent Events(SSE)는 서버에서 클라이언트로 단방향 실시간 데이터를 전송하기 위한 HTTP 기반 표준 프로토콜이다. W3C에 의해 HTML5 사양의 일부로 표준화되었으며, <code>EventSource</code> API를 통해 브라우저에서 기본적으로 지원한다.</p>
<p>SSE의 핵심 특징은 다음과 같다.</p>
<ul>
<li><strong>단방향 통신</strong>: 서버에서 클라이언트로만 데이터를 전송한다. 클라이언트가 서버로 데이터를 보내려면 별도의 HTTP 요청을 사용한다.</li>
<li><strong>HTTP 기반</strong>: 일반 HTTP/1.1 또는 HTTP/2 위에서 동작하므로 별도의 프로토콜이 필요 없다.</li>
<li><strong>자동 재연결</strong>: 연결이 끊어지면 브라우저가 자동으로 재연결을 시도한다.</li>
<li><strong>이벤트 ID 지원</strong>: 마지막으로 수신한 이벤트 ID를 기억하여, 재연결 시 놓친 이벤트를 복구할 수 있다.</li>
<li><strong>텍스트 기반</strong>: <code>text/event-stream</code> MIME 타입을 사용하며, UTF-8 인코딩 텍스트로 데이터를 전송한다.</li>
</ul>
<h3 id="1212-sse">12.1.2 SSE 메시지 형식</h3>
<p>SSE 메시지는 텍스트 줄로 구성되며, 각 필드는 콜론으로 구분된다.</p>
<pre class="highlight"><code>id: 1
event: notification
data: {"message": "새 댓글이 등록되었습니다.", "postId": "abc123"}
retry: 5000
</code></pre>
<p>각 필드의 의미는 다음과 같다.</p>
<table>
<thead>
<tr>
<th>필드</th>
<th>설명</th>
<th>기본값</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>id</code></td>
<td>이벤트 고유 식별자. 재연결 시 <code>Last-Event-ID</code> 헤더로 전송됨</td>
<td>없음</td>
</tr>
<tr>
<td><code>event</code></td>
<td>이벤트 타입. 클라이언트에서 <code>addEventListener</code>로 특정 타입만 수신 가능</td>
<td><code>message</code></td>
</tr>
<tr>
<td><code>data</code></td>
<td>실제 전송 데이터. 여러 줄 가능 (각 줄마다 <code>data:</code> 접두사 필요)</td>
<td>없음</td>
</tr>
<tr>
<td><code>retry</code></td>
<td>재연결 대기 시간(밀리초). 서버가 클라이언트의 재연결 간격을 제어</td>
<td>브라우저 기본값</td>
</tr>
<tr>
<td><code>:</code> (주석)</td>
<td>콜론으로 시작하는 줄은 주석으로 처리됨. 연결 유지(keep-alive)에 활용</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>메시지와 메시지 사이는 빈 줄(<code>\n\n</code>)로 구분한다.</p>
<h3 id="1213-sse-vs-websocket-vs">12.1.3 SSE vs WebSocket vs 폴링 비교</h3>
<table>
<thead>
<tr>
<th>구분</th>
<th>SSE</th>
<th>WebSocket</th>
<th>폴링 (Polling)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>통신 방향</strong></td>
<td>단방향 (서버 -&gt; 클라이언트)</td>
<td>양방향</td>
<td>단방향 (클라이언트 요청 기반)</td>
</tr>
<tr>
<td><strong>프로토콜</strong></td>
<td>HTTP</td>
<td>WS (WebSocket 프로토콜)</td>
<td>HTTP</td>
</tr>
<tr>
<td><strong>연결 유지</strong></td>
<td>지속 연결</td>
<td>지속 연결</td>
<td>매 요청마다 연결/해제</td>
</tr>
<tr>
<td><strong>자동 재연결</strong></td>
<td>브라우저 기본 지원</td>
<td>직접 구현 필요</td>
<td>해당 없음</td>
</tr>
<tr>
<td><strong>데이터 형식</strong></td>
<td>텍스트 (UTF-8)</td>
<td>텍스트 + 바이너리</td>
<td>제한 없음</td>
</tr>
<tr>
<td><strong>방화벽/프록시</strong></td>
<td>HTTP이므로 통과 용이</td>
<td>차단될 수 있음</td>
<td>문제 없음</td>
</tr>
<tr>
<td><strong>HTTP/2 호환</strong></td>
<td>멀티플렉싱 활용 가능</td>
<td>별도 연결 필요</td>
<td>해당 없음</td>
</tr>
<tr>
<td><strong>서버 부하</strong></td>
<td>낮음</td>
<td>낮음</td>
<td>높음 (반복 요청)</td>
</tr>
</tbody>
</table>
<p>SSE가 적합한 시나리오는 알림, 뉴스 피드, 주식 시세, 진행률 업데이트 등 <strong>서버에서 클라이언트로의 단방향 스트리밍</strong>이다. 기존 HTTP 인프라(로드밸런서, 프록시, 인증)를 그대로 활용할 수 있고, 브라우저가 자동으로 재연결을 처리하므로 구현이 간단하다. 반면, 양방향 실시간 통신(채팅, 게임)이나 바이너리 데이터 전송이 필요한 경우에는 WebSocket이 더 적합하다.</p>
<h3 id="1214-eventsource-api">12.1.4 클라이언트 측 EventSource API</h3>
<p>브라우저에서 SSE를 수신하는 JavaScript 코드는 매우 간결하다.</p>
<pre class="highlight"><code class="language-javascript">const eventSource = new EventSource('/api/notifications/stream');

// 기본 message 이벤트 수신
eventSource.onmessage = (event) =&gt; {
    const data = JSON.parse(event.data);
    console.log('수신:', data);
};

// 특정 이벤트 타입 수신
eventSource.addEventListener('notification', (event) =&gt; {
    const notification = JSON.parse(event.data);
    showNotification(notification);
});

// 에러 처리 및 연결 종료
eventSource.onerror = (error) =&gt; {
    console.error('SSE 연결 오류:', error);
    if (eventSource.readyState === EventSource.CLOSED) {
        console.log('연결이 종료되었습니다.');
    }
};</code></pre>
<p><code>EventSource</code>는 연결이 끊어지면 자동으로 재연결을 시도한다. <code>readyState</code>는 <code>CONNECTING(0)</code>, <code>OPEN(1)</code>, <code>CLOSED(2)</code> 세 가지 상태를 가진다.</p>
<hr>
<h2 id="122-flux-sse">12.2 Flux를 활용한 SSE 엔드포인트 구현</h2>
<h3 id="1221-text_event_stream">12.2.1 TEXT_EVENT_STREAM 미디어 타입</h3>
<p>SSE는 Spring WebFlux에 기본 내장되어 있으므로 추가 의존성이 필요 없다. SSE 엔드포인트를 만드는 가장 간단한 방법은 컨트롤러 메서드에서 <code>Flux</code>를 반환하면서 <code>produces</code>에 <code>text/event-stream</code> 미디어 타입을 지정하는 것이다.</p>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/sse")
public class SseController {

    @GetMapping(value = "/time", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux&lt;String&gt; streamTime() {
        return Flux.interval(Duration.ofSeconds(1))
            .map(sequence -&gt; "현재 시각: " + LocalDateTime.now()
                .format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
    }
}</code></pre>
<p><code>MediaType.TEXT_EVENT_STREAM_VALUE</code>는 <code>"text/event-stream"</code> 문자열 상수다. 이 설정만으로 Spring WebFlux는 <code>Flux</code>의 각 요소를 SSE 메시지 형식(<code>data:</code> 필드)으로 변환하여 클라이언트에 전송한다.</p>
<h3 id="1222-serversentevent">12.2.2 ServerSentEvent 클래스 활용</h3>
<p>단순 <code>data</code> 필드만이 아니라 <code>id</code>, <code>event</code>, <code>retry</code> 등 SSE 메시지의 모든 필드를 제어하려면 <code>ServerSentEvent&lt;T&gt;</code> 제네릭 클래스를 사용한다.</p>
<pre class="highlight"><code class="language-java">@GetMapping(value = "/events", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;ServerSentEvent&lt;String&gt;&gt; streamEvents() {
    return Flux.interval(Duration.ofSeconds(2))
        .map(sequence -&gt; ServerSentEvent.&lt;String&gt;builder()
            .id(String.valueOf(sequence))
            .event("heartbeat")
            .data("서버 상태: 정상 (seq=" + sequence + ")")
            .retry(Duration.ofSeconds(10))
            .comment("keep-alive")
            .build());
}</code></pre>
<p><code>ServerSentEvent</code>를 반환 타입으로 사용하면 <code>produces</code> 속성을 생략해도 된다. Spring WebFlux가 반환 타입을 보고 자동으로 <code>text/event-stream</code>으로 설정한다.</p>
<pre class="highlight"><code class="language-java">// produces 생략 가능 - ServerSentEvent 반환 시 자동 적용
@GetMapping("/events-auto")
public Flux&lt;ServerSentEvent&lt;Map&lt;String, Object&gt;&gt;&gt; streamEventsAuto() {
    return Flux.interval(Duration.ofSeconds(3))
        .map(seq -&gt; ServerSentEvent.&lt;Map&lt;String, Object&gt;&gt;builder()
            .id(String.valueOf(seq))
            .event("status-update")
            .data(Map.of("sequence", seq, "timestamp", Instant.now().toString()))
            .build());
}</code></pre>
<h3 id="1223-fluxinterval">12.2.3 Flux.interval을 활용한 주기적 데이터 전송</h3>
<p><code>Flux.interval()</code>은 지정된 간격으로 0부터 시작하는 <code>Long</code> 값을 방출하는 Hot Publisher다. 주기적으로 데이터를 전송하는 SSE 엔드포인트에 적합하다.</p>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/sse")
@RequiredArgsConstructor
public class DashboardSseController {

    private final SystemMetricsService metricsService;

    @GetMapping(value = "/dashboard", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux&lt;ServerSentEvent&lt;DashboardData&gt;&gt; streamDashboard() {
        return Flux.interval(Duration.ofSeconds(5))
            .flatMap(tick -&gt; metricsService.collectMetrics())
            .map(metrics -&gt; ServerSentEvent.&lt;DashboardData&gt;builder()
                .event("dashboard-update")
                .data(metrics)
                .build())
            .doOnCancel(() -&gt; log.info("대시보드 SSE 연결 해제"));
    }
}</code></pre>
<pre class="highlight"><code class="language-java">@Data
@Builder
public class DashboardData {
    private double cpuUsage;
    private long memoryUsed;
    private long memoryTotal;
    private int activeThreads;
    private Instant timestamp;
}</code></pre>
<h3 id="1224-fluxmerge">12.2.4 이벤트 타입 혼합과 Flux.merge</h3>
<p>서로 다른 이벤트 타입을 하나의 SSE 스트림에 혼합하여 전송할 수 있다. <code>Flux.merge</code>로 여러 스트림을 결합하고, 클라이언트는 <code>addEventListener</code>로 관심 있는 이벤트만 선택적으로 수신한다.</p>
<pre class="highlight"><code class="language-java">@GetMapping(value = "/mixed", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;ServerSentEvent&lt;?&gt;&gt; streamMixedEvents() {
    Flux&lt;ServerSentEvent&lt;?&gt;&gt; statusStream = Flux.interval(Duration.ofSeconds(5))
        .map(tick -&gt; ServerSentEvent.builder()
            .event("system-status")
            .data(Map.of("status", "healthy", "uptime", tick * 5))
            .build());

    Flux&lt;ServerSentEvent&lt;?&gt;&gt; statsStream = Flux.interval(Duration.ofSeconds(10))
        .map(tick -&gt; ServerSentEvent.builder()
            .event("statistics")
            .data(Map.of("activeUsers", 42 + tick, "requestsPerSec", 150))
            .build());

    // 30초마다 주석 기반 하트비트 전송 (연결 유지용)
    Flux&lt;ServerSentEvent&lt;?&gt;&gt; heartbeat = Flux.interval(Duration.ofSeconds(30))
        .map(tick -&gt; ServerSentEvent.builder().comment("heartbeat").build());

    return Flux.merge(statusStream, statsStream, heartbeat);
}</code></pre>
<h3 id="1225-sse">12.2.5 함수형 라우터에서 SSE 구현</h3>
<p>Router Functions 스타일로도 SSE 엔드포인트를 구현할 수 있다.</p>
<pre class="highlight"><code class="language-java">@Configuration
public class SseRouterConfig {

    @Bean
    public RouterFunction&lt;ServerResponse&gt; sseRoutes(SseHandler handler) {
        return RouterFunctions.route()
            .GET("/api/sse/stream", handler::stream)
            .build();
    }
}

@Component
public class SseHandler {

    public Mono&lt;ServerResponse&gt; stream(ServerRequest request) {
        Flux&lt;ServerSentEvent&lt;String&gt;&gt; events = Flux.interval(Duration.ofSeconds(1))
            .map(seq -&gt; ServerSentEvent.&lt;String&gt;builder()
                .id(String.valueOf(seq))
                .data("tick " + seq)
                .build());

        return ServerResponse.ok()
            .contentType(MediaType.TEXT_EVENT_STREAM)
            .body(events, ServerSentEvent.class);
    }
}</code></pre>
<hr>
<h2 id="123">12.3 실시간 알림 시스템 구축</h2>
<h3 id="1231-sinks">12.3.1 Sinks를 활용한 이벤트 브로드캐스팅</h3>
<p>실제 서비스에서 SSE는 단순 타이머가 아니라 특정 이벤트 발생 시 연결된 클라이언트들에게 즉시 데이터를 전달해야 한다. Reactor의 <code>Sinks</code>는 프로그래밍 방식으로 이벤트를 발행할 수 있는 Hot Publisher로, 이 용도에 적합하다.</p>
<pre class="highlight"><code class="language-java">@Service
@Slf4j
public class NotificationBroadcaster {

    private final Sinks.Many&lt;Notification&gt; sink =
        Sinks.many().multicast().onBackpressureBuffer(256);

    public void publish(Notification notification) {
        Sinks.EmitResult result = sink.tryEmitNext(notification);
        if (result.isFailure()) {
            log.warn("알림 발행 실패: {}, result={}", notification.getId(), result);
        }
    }

    public Flux&lt;Notification&gt; subscribe() {
        return sink.asFlux();
    }
}</code></pre>
<p>Sinks의 주요 팩토리 메서드를 비교하면 다음과 같다.</p>
<table>
<thead>
<tr>
<th>메서드</th>
<th>설명</th>
<th>사용 시나리오</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Sinks.many().multicast()</code></td>
<td>여러 구독자에게 동일 이벤트를 전달. 구독 전 발행된 이벤트는 수신 불가</td>
<td>실시간 알림, 라이브 피드</td>
</tr>
<tr>
<td><code>Sinks.many().replay()</code></td>
<td>과거 이벤트를 새 구독자에게 재전송 가능</td>
<td>최근 N건의 이벤트 보여주기</td>
</tr>
<tr>
<td><code>Sinks.many().unicast()</code></td>
<td>단일 구독자만 허용</td>
<td>1:1 전용 스트림</td>
</tr>
</tbody>
</table>
<h3 id="1232">12.3.2 알림 도메인 모델</h3>
<pre class="highlight"><code class="language-java">@Document(collection = "notifications")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Notification {
    @Id
    private String id;
    private String userId;       // 수신 대상 사용자
    private String type;         // COMMENT, LIKE, FOLLOW, SYSTEM 등
    private String title;
    private String message;
    private Map&lt;String, Object&gt; metadata;  // 추가 정보 (postId, commentId 등)
    private boolean read;
    private LocalDateTime createdAt;
}</code></pre>
<pre class="highlight"><code class="language-java">public interface NotificationRepository
        extends ReactiveMongoRepository&lt;Notification, String&gt; {
    Flux&lt;Notification&gt; findByUserIdOrderByCreatedAtDesc(String userId);
    Flux&lt;Notification&gt; findByUserIdAndReadFalse(String userId);
    Mono&lt;Long&gt; countByUserIdAndReadFalse(String userId);
}</code></pre>
<h3 id="1233">12.3.3 사용자별 알림 구독 관리</h3>
<p>실제 서비스에서는 모든 알림을 모든 사용자에게 브로드캐스팅하지 않는다. 사용자별로 구독을 관리하고, 해당 사용자에게만 알림을 전달해야 한다.</p>
<pre class="highlight"><code class="language-java">@Service
@Slf4j
public class NotificationService {

    private final NotificationRepository notificationRepository;
    private final ConcurrentHashMap&lt;String, Sinks.Many&lt;Notification&gt;&gt; userSinks =
        new ConcurrentHashMap&lt;&gt;();

    public NotificationService(NotificationRepository notificationRepository) {
        this.notificationRepository = notificationRepository;
    }

    /**
     * 사용자별 알림 스트림을 구독한다.
     */
    public Flux&lt;ServerSentEvent&lt;Notification&gt;&gt; subscribe(String userId) {
        Sinks.Many&lt;Notification&gt; userSink = userSinks.computeIfAbsent(userId,
            key -&gt; {
                log.info("사용자 {} 알림 구독 생성", key);
                return Sinks.many().multicast().onBackpressureBuffer(128);
            });

        return userSink.asFlux()
            .map(notification -&gt; ServerSentEvent.&lt;Notification&gt;builder()
                .id(notification.getId())
                .event(notification.getType())
                .data(notification)
                .build());
    }

    /**
     * 특정 사용자에게 알림을 전송한다.
     * MongoDB에 저장하고, 접속 중이면 SSE로 실시간 전달한다.
     */
    public Mono&lt;Notification&gt; sendNotification(Notification notification) {
        notification.setCreatedAt(LocalDateTime.now());
        notification.setRead(false);

        return notificationRepository.save(notification)
            .doOnSuccess(saved -&gt; {
                Sinks.Many&lt;Notification&gt; userSink =
                    userSinks.get(saved.getUserId());
                if (userSink != null) {
                    Sinks.EmitResult result = userSink.tryEmitNext(saved);
                    if (result.isFailure()) {
                        log.warn("사용자 {} 알림 전송 실패: {}",
                            saved.getUserId(), result);
                    }
                } else {
                    log.debug("사용자 {} 미접속 상태, 알림은 DB에만 저장됨",
                        saved.getUserId());
                }
            });
    }

    public Mono&lt;Long&gt; getUnreadCount(String userId) {
        return notificationRepository.countByUserIdAndReadFalse(userId);
    }

    public Mono&lt;Notification&gt; markAsRead(String notificationId) {
        return notificationRepository.findById(notificationId)
            .map(notification -&gt; {
                notification.setRead(true);
                return notification;
            })
            .flatMap(notificationRepository::save);
    }

    /**
     * 사용자의 SSE 연결이 해제될 때 호출된다.
     */
    public void removeSubscription(String userId) {
        Sinks.Many&lt;Notification&gt; removed = userSinks.remove(userId);
        if (removed != null) {
            removed.tryEmitComplete();
            log.info("사용자 {} 알림 구독 해제", userId);
        }
    }
}</code></pre>
<h3 id="1234-sse">12.3.4 알림 SSE 컨트롤러</h3>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/notifications")
@RequiredArgsConstructor
@Slf4j
public class NotificationController {

    private final NotificationService notificationService;

    @GetMapping(value = "/stream/{userId}",
                produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux&lt;ServerSentEvent&lt;Notification&gt;&gt; streamNotifications(
            @PathVariable String userId) {

        log.info("SSE 연결: userId={}", userId);

        // 실시간 알림 스트림
        Flux&lt;ServerSentEvent&lt;Notification&gt;&gt; notificationStream =
            notificationService.subscribe(userId);

        // 30초마다 하트비트 전송 (프록시/로드밸런서 타임아웃 방지)
        Flux&lt;ServerSentEvent&lt;Notification&gt;&gt; heartbeat =
            Flux.interval(Duration.ofSeconds(30))
                .map(tick -&gt; ServerSentEvent.&lt;Notification&gt;builder()
                    .comment("heartbeat")
                    .build());

        return Flux.merge(notificationStream, heartbeat)
            .doOnCancel(() -&gt; {
                log.info("SSE 연결 해제: userId={}", userId);
                notificationService.removeSubscription(userId);
            });
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono&lt;Notification&gt; sendNotification(
            @RequestBody Notification notification) {
        return notificationService.sendNotification(notification);
    }

    @PatchMapping("/{notificationId}/read")
    public Mono&lt;Notification&gt; markAsRead(
            @PathVariable String notificationId) {
        return notificationService.markAsRead(notificationId);
    }
}</code></pre>
<h3 id="1235">12.3.5 연결 해제 처리와 리소스 정리</h3>
<p>SSE 연결이 종료되는 경우는 다음과 같다.</p>
<ol>
<li><strong>클라이언트가 연결을 닫는 경우</strong>: <code>EventSource.close()</code> 호출 또는 브라우저 탭 닫기</li>
<li><strong>서버에서 스트림을 완료하는 경우</strong>: <code>Flux</code>가 <code>onComplete</code> 또는 <code>onError</code> 신호를 발생</li>
<li><strong>네트워크 문제</strong>: 연결이 예기치 않게 끊어지는 경우</li>
<li><strong>프록시/로드밸런서 타임아웃</strong>: 일정 시간 동안 데이터가 전송되지 않으면 연결이 종료</li>
</ol>
<p>각 상황에 대한 처리는 <code>doFinally</code>를 활용한다. <code>doFinally</code>는 <code>onComplete</code>, <code>onError</code>, <code>cancel</code> 모든 종료 신호에 대해 실행되므로, 리소스 정리에 가장 적합하다.</p>
<pre class="highlight"><code class="language-java">@GetMapping(value = "/stream/{userId}",
            produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;ServerSentEvent&lt;Notification&gt;&gt; streamWithCleanup(
        @PathVariable String userId) {

    return notificationService.subscribe(userId)
        .timeout(Duration.ofHours(1))
        .onErrorResume(TimeoutException.class, e -&gt; {
            log.info("SSE 타임아웃: userId={}", userId);
            return Flux.empty();
        })
        .doFinally(signalType -&gt; {
            log.info("SSE 스트림 종료: userId={}, signal={}", userId, signalType);
            notificationService.removeSubscription(userId);
        });
}</code></pre>
<h3 id="1236">12.3.6 알림 발행 연동 예제</h3>
<p>게시글에 댓글이 달릴 때 알림을 전송하는 시나리오를 구현한다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
public class CommentService {

    private final CommentRepository commentRepository;
    private final PostRepository postRepository;
    private final NotificationService notificationService;

    public Mono&lt;Comment&gt; addComment(String postId, CommentRequest request) {
        Comment comment = Comment.builder()
            .postId(postId)
            .authorId(request.getAuthorId())
            .authorName(request.getAuthorName())
            .content(request.getContent())
            .createdAt(LocalDateTime.now())
            .build();

        return commentRepository.save(comment)
            .flatMap(saved -&gt; postRepository.findById(postId)
                .flatMap(post -&gt; {
                    if (!post.getAuthorId().equals(request.getAuthorId())) {
                        Notification notification = Notification.builder()
                            .userId(post.getAuthorId())
                            .type("COMMENT")
                            .title("새 댓글")
                            .message(request.getAuthorName() + "님이 '"
                                + post.getTitle() + "'에 댓글을 남겼습니다.")
                            .metadata(Map.of(
                                "postId", postId,
                                "commentId", saved.getId()))
                            .build();
                        return notificationService.sendNotification(notification)
                            .thenReturn(saved);
                    }
                    return Mono.just(saved);
                }));
    }
}</code></pre>
<p>11장에서 다룬 JWT 인증과 연동하면, <code>ReactiveSecurityContextHolder</code>에서 현재 사용자를 꺼내어 인증된 사용자 전용 SSE 구독을 구현할 수도 있다.</p>
<pre class="highlight"><code class="language-java">@GetMapping(value = "/stream/me",
            produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;ServerSentEvent&lt;Notification&gt;&gt; streamMyNotifications() {
    return ReactiveSecurityContextHolder.getContext()
        .map(ctx -&gt; ctx.getAuthentication().getName())
        .flatMapMany(username -&gt; notificationService.subscribe(username)
            .doFinally(signal -&gt;
                notificationService.removeSubscription(username)));
}</code></pre>
<hr>
<h2 id="124-mongodb-change-streams-sse">12.4 MongoDB Change Streams + SSE 연동</h2>
<h3 id="1241-change-streams">12.4.1 Change Streams 개요</h3>
<p>MongoDB Change Streams는 컬렉션, 데이터베이스, 또는 전체 클러스터의 데이터 변경 사항을 실시간으로 감시하는 기능이다. 8장에서 기본 개념을 다루었으며, 이번 절에서는 이를 SSE와 연동하여 데이터 변경 사항을 클라이언트에 실시간으로 전달하는 방법에 초점을 맞춘다.</p>
<ul>
<li><strong>이벤트 타입</strong>: <code>insert</code>, <code>update</code>, <code>replace</code>, <code>delete</code>, <code>invalidate</code></li>
<li><strong>Resume Token</strong>: 연결이 끊어진 지점부터 이벤트를 다시 수신할 수 있다</li>
<li><strong>필터링</strong>: Aggregation Pipeline을 사용하여 관심 있는 변경만 수신 가능</li>
<li><strong>요구사항</strong>: Replica Set 또는 Sharded Cluster 환경에서만 동작한다</li>
</ul>
<h3 id="1242-reactivemongotemplate-changestream">12.4.2 ReactiveMongoTemplate의 changeStream()</h3>
<p>Spring Data MongoDB의 <code>ReactiveMongoTemplate</code>은 <code>changeStream()</code> 메서드를 통해 Change Streams를 <code>Flux</code>로 변환한다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
@Slf4j
public class ProductChangeStreamService {

    private final ReactiveMongoTemplate mongoTemplate;

    public Flux&lt;ChangeStreamEvent&lt;Product&gt;&gt; watchProducts() {
        return mongoTemplate.changeStream("products",
                ChangeStreamOptions.builder()
                    .filter(Aggregation.newAggregation(
                        Aggregation.match(Criteria.where("operationType")
                            .in("insert", "update", "replace"))))
                    .build(),
                Product.class)
            .doOnNext(event -&gt; log.info("변경 감지: type={}, id={}",
                event.getOperationType(), event.getBody()));
    }

    public Flux&lt;ChangeStreamEvent&lt;Product&gt;&gt; watchProductsByCategory(
            String category) {
        return mongoTemplate.changeStream("products",
                ChangeStreamOptions.builder()
                    .filter(Aggregation.newAggregation(
                        Aggregation.match(Criteria.where("operationType")
                            .in("insert", "update", "replace")
                            .and("fullDocument.category").is(category))))
                    .build(),
                Product.class);
    }
}</code></pre>
<h3 id="1243-change-streams-sse">12.4.3 Change Streams를 SSE로 전달</h3>
<p>Change Streams에서 수신한 이벤트를 SSE를 통해 클라이언트에 전달하는 컨트롤러를 구현한다.</p>
<pre class="highlight"><code class="language-java">@Data
@Builder
public class ProductChangeEvent {
    private String operationType;
    private Product product;
    private Instant timestamp;
}</code></pre>
<pre class="highlight"><code class="language-java">@RestController
@RequestMapping("/api/products")
@RequiredArgsConstructor
@Slf4j
public class ProductSseController {

    private final ProductChangeStreamService changeStreamService;

    @GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux&lt;ServerSentEvent&lt;ProductChangeEvent&gt;&gt; streamProductChanges() {

        Flux&lt;ServerSentEvent&lt;ProductChangeEvent&gt;&gt; changeStream =
            changeStreamService.watchProducts()
                .map(event -&gt; {
                    ProductChangeEvent payload = ProductChangeEvent.builder()
                        .operationType(event.getOperationType().getValue())
                        .product(event.getBody())
                        .timestamp(Instant.now())
                        .build();

                    return ServerSentEvent.&lt;ProductChangeEvent&gt;builder()
                        .id(event.getResumeToken() != null
                            ? event.getResumeToken().toJson() : null)
                        .event("product-" + event.getOperationType().getValue())
                        .data(payload)
                        .build();
                });

        Flux&lt;ServerSentEvent&lt;ProductChangeEvent&gt;&gt; heartbeat =
            Flux.interval(Duration.ofSeconds(30))
                .map(tick -&gt; ServerSentEvent.&lt;ProductChangeEvent&gt;builder()
                    .comment("heartbeat")
                    .build());

        return Flux.merge(changeStream, heartbeat)
            .doOnCancel(() -&gt; log.info("상품 변경 SSE 연결 해제"));
    }
}</code></pre>
<h3 id="1244-resume-token">12.4.4 Resume Token을 활용한 이벤트 복구</h3>
<p>클라이언트가 재연결할 때 놓친 이벤트를 복구하려면 Resume Token을 활용한다. SSE의 <code>id</code> 필드에 Resume Token을 설정하면, 브라우저가 재연결 시 <code>Last-Event-ID</code> 헤더로 자동 전송한다.</p>
<pre class="highlight"><code class="language-java">@Service
@RequiredArgsConstructor
@Slf4j
public class ResumableChangeStreamService {

    private final ReactiveMongoTemplate mongoTemplate;

    public Flux&lt;ChangeStreamEvent&lt;Product&gt;&gt; watchProducts(String resumeToken) {
        ChangeStreamOptions.ChangeStreamOptionsBuilder optionsBuilder =
            ChangeStreamOptions.builder()
                .filter(Aggregation.newAggregation(
                    Aggregation.match(Criteria.where("operationType")
                        .in("insert", "update", "replace"))));

        if (resumeToken != null &amp;&amp; !resumeToken.isEmpty()) {
            try {
                BsonDocument token = BsonDocument.parse(resumeToken);
                optionsBuilder.resumeAfter(token);
                log.info("Resume Token으로 변경 스트림 재개");
            } catch (Exception e) {
                log.warn("유효하지 않은 Resume Token, 처음부터 시작");
            }
        }

        return mongoTemplate.changeStream("products",
            optionsBuilder.build(), Product.class);
    }
}</code></pre>
<pre class="highlight"><code class="language-java">@GetMapping(value = "/stream/resumable",
            produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux&lt;ServerSentEvent&lt;ProductChangeEvent&gt;&gt; streamResumable(
        @RequestHeader(value = "Last-Event-ID", required = false)
        String lastEventId) {

    return resumableChangeStreamService.watchProducts(lastEventId)
        .map(event -&gt; {
            String tokenJson = event.getResumeToken() != null
                ? event.getResumeToken().toJson() : null;

            ProductChangeEvent payload = ProductChangeEvent.builder()
                .operationType(event.getOperationType().getValue())
                .product(event.getBody())
                .timestamp(Instant.now())
                .build();

            return ServerSentEvent.&lt;ProductChangeEvent&gt;builder()
                .id(tokenJson)
                .event("product-change")
                .data(payload)
                .build();
        });
}</code></pre>
<p>클라이언트에서는 별도 처리 없이 <code>EventSource</code>가 재연결 시 <code>Last-Event-ID</code>를 자동 전송한다.</p>
<pre class="highlight"><code class="language-javascript">const es = new EventSource('/api/products/stream/resumable');
es.addEventListener('product-change', (e) =&gt; {
    console.log('이벤트 ID:', e.lastEventId);
    const change = JSON.parse(e.data);
    applyChange(change);
});</code></pre>
<h3 id="1245">12.4.5 실시간 데이터 동기화 패턴</h3>
<p>Change Streams + SSE를 조합하면 여러 클라이언트 간의 실시간 데이터 동기화를 구현할 수 있다. 한 사용자가 데이터를 수정하면, 같은 화면을 보고 있는 다른 사용자에게 즉시 변경 사항이 반영되는 구조다. 구현의 핵심은 다음과 같다.</p>
<ol>
<li><strong><code>@PostConstruct</code>에서 Change Stream 시작</strong>: 애플리케이션 기동 시 감시할 컬렉션에 대해 Change Stream을 구독한다.</li>
<li><strong>세션별 Sink 관리</strong>: <code>ConcurrentHashMap&lt;String, Sinks.Many&lt;ChangeEvent&gt;&gt;</code>로 세션마다 독립적인 Sink를 생성한다.</li>
<li><strong>이벤트 분배</strong>: Change Stream에서 수신한 이벤트를 해당 컬렉션을 구독 중인 모든 세션의 Sink에 <code>tryEmitNext</code>로 전달한다.</li>
<li><strong>SSE 엔드포인트</strong>: <code>GET /api/sync/stream/{collection}?sessionId=xxx</code> 형태로 클라이언트가 특정 컬렉션의 변경 사항을 구독한다.</li>
</ol>
<p>이 패턴은 12.3절의 사용자별 알림 구독과 동일한 <code>ConcurrentHashMap</code> + <code>Sinks</code> 구조를 컬렉션 단위로 확장한 것이다.</p>
<h3 id="1246">12.4.6 프로덕션 환경 고려사항</h3>
<p>SSE를 프로덕션 환경에서 운영할 때 반드시 고려해야 할 사항들을 정리한다.</p>
<p><strong>1. 연결 수 관리</strong></p>
<p>SSE는 HTTP 연결을 지속적으로 유지하므로, 동시 연결 수가 많아지면 서버 리소스가 소진될 수 있다. <code>AtomicInteger</code>로 활성 연결 수를 추적하고 최대치를 제한하는 것이 좋다.</p>
<p><strong>2. 프록시/로드밸런서 설정</strong></p>
<p>Nginx 등의 리버스 프록시를 사용할 경우, SSE 연결이 조기에 종료되지 않도록 버퍼링을 비활성화하고 타임아웃을 늘려야 한다.</p>
<pre class="highlight"><code class="language-nginx">location /api/sse/ {
    proxy_pass http://backend;
    proxy_http_version 1.1;
    proxy_set_header Connection '';
    proxy_buffering off;
    proxy_cache off;
    proxy_read_timeout 86400s;
    chunked_transfer_encoding off;
}</code></pre>
<p><strong>3. 하트비트</strong></p>
<p>프록시의 유휴 타임아웃을 방지하기 위해 주기적으로 하트비트를 전송한다. SSE의 주석(<code>:</code> 접두사)을 사용하면 클라이언트 측 이벤트 핸들러가 트리거되지 않는다.</p>
<p><strong>4. 에러 복구 전략</strong></p>
<p>Change Stream이 중단되었을 때 자동으로 재시작하는 전략이 필요하다. <code>retryWhen</code>에 지수 백오프를 적용하면 일시적 장애에서 안정적으로 복구할 수 있다.</p>
<pre class="highlight"><code class="language-java">private void watchCollectionWithRetry(String collectionName) {
    mongoTemplate.changeStream(collectionName,
            ChangeStreamOptions.empty(), Document.class)
        .doOnError(e -&gt; log.error("{} Change Stream 오류", collectionName, e))
        .retryWhen(Retry.backoff(Long.MAX_VALUE, Duration.ofSeconds(1))
            .maxBackoff(Duration.ofMinutes(1))
            .doBeforeRetry(signal -&gt; log.warn("{} Change Stream 재시도 #{}",
                collectionName, signal.totalRetries())))
        .subscribe(this::processChangeEvent);
}</code></pre>
<hr>
<h2 id="_1">요약</h2>
<p>이번 장에서 다룬 핵심 내용을 정리한다.</p>
<table>
<thead>
<tr>
<th>주제</th>
<th>핵심 내용</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SSE 프로토콜</strong></td>
<td>서버에서 클라이언트로의 단방향 HTTP 기반 실시간 스트리밍, 자동 재연결, 이벤트 ID 지원</td>
</tr>
<tr>
<td><strong>SSE vs WebSocket</strong></td>
<td>SSE는 단방향/HTTP 기반으로 인프라 호환성이 높고, WebSocket은 양방향/바이너리 지원</td>
</tr>
<tr>
<td><strong>Flux + SSE</strong></td>
<td><code>TEXT_EVENT_STREAM</code> 미디어 타입과 <code>ServerSentEvent&lt;T&gt;</code> 클래스로 SSE 엔드포인트 구현</td>
</tr>
<tr>
<td><strong>Sinks 브로드캐스팅</strong></td>
<td><code>Sinks.many().multicast()</code>로 이벤트를 발행하고 여러 SSE 구독자에게 실시간 전달</td>
</tr>
<tr>
<td><strong>사용자별 알림</strong></td>
<td><code>ConcurrentHashMap</code>으로 사용자별 Sink를 관리하여 개인화된 알림 스트림 구현</td>
</tr>
<tr>
<td><strong>연결 해제 처리</strong></td>
<td><code>doOnCancel</code>, <code>doFinally</code>로 SSE 연결 종료 시 리소스 정리</td>
</tr>
<tr>
<td><strong>Change Streams + SSE</strong></td>
<td>MongoDB 데이터 변경을 감지하여 SSE로 실시간 전달, Resume Token으로 이벤트 복구</td>
</tr>
<tr>
<td><strong>실시간 데이터 동기화</strong></td>
<td>Change Streams + Sinks + SSE를 조합하여 여러 클라이언트 간 데이터 동기화</td>
</tr>
</tbody>
</table>
<p>다음 장에서는 WebSocket을 활용한 양방향 실시간 통신과 채팅 애플리케이션 구현을 다룬다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>