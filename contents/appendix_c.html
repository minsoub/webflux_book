<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>부록 C. 자주 발생하는 문제와 해결 방법 (FAQ) | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="appendix_b.html">&larr; 부록 B. MongoDB 쿼리 연산자 정리</a>
    <a href="../index.html">목차</a>
    <a href="appendix_d.html">부록 D. 참고 자료 및 추천 학습 경로 &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="c-faq">부록 C. 자주 발생하는 문제와 해결 방법 (FAQ)</h1>
<p>Spring WebFlux와 MongoDB 리액티브 스택을 사용하며 프로젝트를 진행하다 보면, 명령형 프로그래밍에서는 경험하지 못했던 새로운 종류의 이슈들과 마주하게 된다. 필자의 경험상 이런 문제들은 대부분 리액티브의 핵심 개념—특히 스레드 모델과 Context 전파 메커니즘—을 명확히 이해하면 자연스럽게 해결된다.</p>
<p>이 부록에서는 실무에서 가장 자주 발생하는 15가지 문제를 모았다. 각 항목마다 증상을 먼저 보여주고, 왜 그런 일이 생기는지 원인을 분석한 뒤, 어떻게 대처할 수 있을지 구체적인 해결책을 제시했다.</p>
<hr>
<h2 id="faq-1-blockblockfirstblocklast-are-blocking">FAQ 1. "block()/blockFirst()/blockLast() are blocking" 에러</h2>
<p><strong>증상</strong>: 리액티브 파이프라인 내부에서 <code>block()</code>을 호출하면 <code>IllegalStateException</code>이 튀어나온다.</p>
<p><strong>원인 분석</strong>: Netty의 이벤트 루프 스레드에서 <code>block()</code>을 부르면 그 스레드가 대기 상태(blocking)로 빠진다. 이벤트 루프 스레드가 멈추는 순간 다른 모든 요청들의 처리가 중단되어 버린다. Reactor는 이 위험한 상황을 미리 감지하고 예외를 던져서 문제를 드러낸다.</p>
<p><strong>해결 방법</strong>: <code>block()</code> 대신 <code>flatMap</code>, <code>zip</code>, <code>then</code> 같은 리액티브 연산자로 흐름을 이어가자.</p>
<pre class="highlight"><code class="language-java">// 잘못된 코드
User user = userRepository.findById(userId).block(); // 예외 발생!

// 올바른 코드
return userRepository.findById(userId)
    .flatMap(user -&gt; profileRepository.findByUser(user));</code></pre>
<p>혹시 레거시 코드를 호출해야 하거나, 부득이하게 블로킹 호출이 필요하다면 <code>Schedulers.boundedElastic()</code>으로 스레드를 전환해서 처리한다.</p>
<pre class="highlight"><code class="language-java">Mono.fromCallable(() -&gt; legacyBlockingService.call())
    .subscribeOn(Schedulers.boundedElastic());</code></pre>
<hr>
<h2 id="faq-2-scheduler-was-blocked-blockhound">FAQ 2. "Scheduler was blocked" 에러와 BlockHound</h2>
<p><strong>증상</strong>: BlockHound를 켜면 갑자기 <code>BlockingOperationError: Blocking call!</code> 같은 에러가 날아온다.</p>
<p><strong>원인 분석</strong>: BlockHound는 개발/테스트 단계에서 코드의 블로킹 호출(파일 I/O, <code>Thread.sleep</code> 등)을 런타임에 적발하는 도구다. 의도하지 않은 블로킹이 발견되는데, 특히 서드파티 라이브러리나 드라이버에 숨어 있는 경우가 많다.</p>
<p><strong>해결 방법</strong>: BlockHound를 테스트 의존성으로 등록한 후, 불가피한 블로킹 호출들을 화이트리스트에 추가해서 허용한다.</p>
<pre class="highlight"><code class="language-java">BlockHound.install(builder -&gt; builder
    .allowBlockingCallsInside(
        "com.mongodb.internal.connection.DefaultServerMonitor", "run")
    .allowBlockingCallsInside(
        "io.netty.resolver.dns.DnsServerAddressStreamProviders",
        "unixResolverEnabled")
);</code></pre>
<hr>
<h2 id="faq-3-mongodb">FAQ 3. MongoDB 연결 실패 및 타임아웃 문제</h2>
<p><strong>증상</strong>: 운영 중에 갑자기 <code>MongoTimeoutException: Timed out after 30000 ms while waiting for a server</code> 같은 에러가 터진다.</p>
<p><strong>원인 분석</strong>: 원인은 여러 가지일 수 있다. 커넥션 풀이 꽉 찬 경우, 네트워크 지연이 심한 경우, MongoDB 레플리카 셋 구성이 변경된 경우, DNS 조회가 지연되는 경우 등 다양한 시나리오가 있다.</p>
<p><strong>해결 방법</strong>: <code>MongoClientSettings</code>를 적절하게 구성해서 커넥션 풀 크기와 타임아웃 값들을 직접 조정해 보자.</p>
<pre class="highlight"><code class="language-java">@Override
protected void configureClientSettings(MongoClientSettings.Builder builder) {
    builder.applyToConnectionPoolSettings(pool -&gt; pool
            .maxSize(50)
            .minSize(10)
            .maxWaitTime(5, TimeUnit.SECONDS)
            .maxConnectionIdleTime(30, TimeUnit.SECONDS))
        .applyToSocketSettings(socket -&gt; socket
            .connectTimeout(5, TimeUnit.SECONDS)
            .readTimeout(10, TimeUnit.SECONDS))
        .applyToServerSettings(server -&gt; server
            .heartbeatFrequency(10, TimeUnit.SECONDS));
}</code></pre>
<hr>
<h2 id="faq-4-reactivesecuritycontext-null">FAQ 4. ReactiveSecurityContext에서 인증 정보가 null인 경우</h2>
<p><strong>증상</strong>: <code>ReactiveSecurityContextHolder.getContext()</code>를 호출했는데 빈 <code>Mono</code>만 돌아온다.</p>
<p><strong>원인 분석</strong>: Spring Security의 리액티브 구현은 전통적인 <code>ThreadLocal</code> 방식이 아니라 Reactor Context를 기반으로 동작한다. 리액티브 체인이 끊어지거나 맥락을 잃으면, 보안 정보도 함께 사라진다.</p>
<p><strong>해결 방법</strong>: 가장 좋은 방법은 리액티브 체인을 계속 유지하는 것이고, 그것이 어렵다면 컨트롤러의 메서드 파라미터로 직접 주입받자.</p>
<pre class="highlight"><code class="language-java">// 올바른 코드: 체인 유지
return ReactiveSecurityContextHolder.getContext()
    .map(ctx -&gt; ctx.getAuthentication().getName())
    .map(name -&gt; "prefix_" + name);

// 더 나은 방법: 컨트롤러 파라미터로 전달
@GetMapping("/me")
public Mono&lt;UserDto&gt; getMyInfo(@AuthenticationPrincipal Mono&lt;UserDetails&gt; principal) {
    return principal.flatMap(user -&gt; userService.findByUsername(user.getUsername()));
}</code></pre>
<hr>
<h2 id="faq-5-webflux-transactional">FAQ 5. WebFlux에서 @Transactional이 작동하지 않는 경우</h2>
<p><strong>증상</strong>: <code>@Transactional</code> 어노테이션을 달았는데 MongoDB 작업이 트랜잭션으로 처리되지 않는 것처럼 보인다.</p>
<p><strong>원인 분석</strong>: MongoDB 트랜잭션을 지원하려면 먼저 레플리카 셋(Replica Set) 구성이 있어야 한다. 추가로 Spring이 제공하는 <code>ReactiveMongoTransactionManager</code> 빈이 정확히 등록되어 있어야 작동한다.</p>
<p><strong>해결 방법</strong>: MongoDB를 레플리카 셋으로 초기화하고, Spring 설정에서 트랜잭션 매니저를 명시적으로 빈으로 등록한다.</p>
<pre class="highlight"><code class="language-bash">mongosh --eval "rs.initiate({_id:'rs0', members:[{_id:0, host:'localhost:27017'}]})"</code></pre>
<pre class="highlight"><code class="language-java">@Bean
ReactiveMongoTransactionManager transactionManager(ReactiveMongoDatabaseFactory factory) {
    return new ReactiveMongoTransactionManager(factory);
}</code></pre>
<hr>
<h2 id="faq-6-flux-cold-vs-hot">FAQ 6. Flux 데이터가 중복으로 발행되는 경우 (Cold vs Hot)</h2>
<p><strong>증상</strong>: 같은 <code>Flux</code>를 여러 군데서 구독하면, DB 쿼리가 구독할 때마다 중복 실행된다.</p>
<p><strong>원인 분석</strong>: Reactor의 <code>Flux</code>와 <code>Mono</code>는 기본적으로 Cold Publisher 패턴으로 설계되어 있다. 즉, 새로운 구독자가 나타날 때마다 데이터 생성 로직이 처음부터 독립적으로 시작되므로, 데이터베이스 쿼리도 반복해서 실행되는 것이다.</p>
<p><strong>해결 방법</strong>: 상황에 맞춰 <code>cache()</code> 또는 <code>share()</code>를 사용해서 Hot Publisher 특성으로 변환하자.</p>
<pre class="highlight"><code class="language-java">Flux&lt;Product&gt; products = productRepository.findAll().cache(); // 결과 캐싱</code></pre>
<table>
<thead>
<tr>
<th>연산자</th>
<th>동작</th>
<th>용도</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cache()</code></td>
<td>모든 데이터를 버퍼링, 새 구독자에게 재전송</td>
<td>변하지 않는 결과 조회</td>
</tr>
<tr>
<td><code>cache(Duration)</code></td>
<td>TTL이 지나면 소스를 재구독</td>
<td>일정 시간 캐싱</td>
</tr>
<tr>
<td><code>share()</code></td>
<td>진행 중인 스트림을 공유, 이전 데이터 유실</td>
<td>실시간 이벤트 스트림</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="faq-7-webclient-databufferlimitexception">FAQ 7. WebClient에서 DataBufferLimitException 발생</h2>
<p><strong>증상</strong>: 서버에서 큰 파일이나 응답을 받으려고 하면 <code>Exceeded limit on max bytes to buffer : 262144</code> 같은 에러가 뜬다.</p>
<p><strong>원인 분석</strong>: WebClient는 기본값으로 응답 전체를 메모리에 버퍼링할 때 256KB 제한을 두고 있다. 그 이상의 데이터를 받으려고 하면 자동으로 차단한다.</p>
<p><strong>해결 방법</strong>: 버퍼 크기를 늘리거나, 대용량 응답은 스트리밍 방식으로 처리한다.</p>
<pre class="highlight"><code class="language-java">// 방법 1: 버퍼 크기 확장
WebClient.builder()
    .codecs(c -&gt; c.defaultCodecs().maxInMemorySize(10 * 1024 * 1024))
    .build();

// 방법 2: 스트리밍 처리 (권장)
webClient.get().uri("/api/products/export")
    .accept(MediaType.APPLICATION_NDJSON)
    .retrieve()
    .bodyToFlux(Product.class);</code></pre>
<hr>
<h2 id="faq-8-threadlocalmdc">FAQ 8. 리액티브 환경에서 ThreadLocal/MDC 사용 문제</h2>
<p><strong>증상</strong>: MDC에 넣어놓은 <code>traceId</code> 값이 리액티브 파이프라인을 거치면서 어느 순간 <code>null</code>이 되어 있다.</p>
<p><strong>원인 분석</strong>: MDC는 <code>ThreadLocal</code> 메커니즘에 의존한다. 한 번의 요청이 여러 스레드를 거쳐 처리되는 리액티브 환경에서는, 스레드가 바뀔 때마다 MDC 값이 전달되지 않는다.</p>
<p><strong>해결 방법</strong>: Micrometer Context Propagation 라이브러리를 사용하면, Context 값이 자동으로 동기화되도록 할 수 있다.</p>
<pre class="highlight"><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.micrometer&lt;/groupId&gt;
    &lt;artifactId&gt;context-propagation&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<pre class="highlight"><code class="language-java">// 애플리케이션 시작 시 Hook 등록
Hooks.enableAutomaticContextPropagation();

// WebFilter에서 Reactor Context에 값 저장
@Override
public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
    String traceId = Optional.ofNullable(
            exchange.getRequest().getHeaders().getFirst("X-Trace-Id"))
        .orElse(UUID.randomUUID().toString().substring(0, 8));
    return chain.filter(exchange)
        .contextWrite(ctx -&gt; ctx.put("traceId", traceId));
}</code></pre>
<hr>
<h2 id="faq-9-mongodb-change-streams">FAQ 9. MongoDB Change Streams 연결 끊김 처리</h2>
<p><strong>증상</strong>: Change Streams로 변경 이벤트를 수신하다가 MongoDB 장애나 네트워크 단절이 발생하면 스트림이 완전히 끊어져 버린다.</p>
<p><strong>원인 분석</strong>: 네트워크가 끊기거나 MongoDB 레플리카 셋의 프라이머리가 바뀌면 자동으로 롱 커넥션이 종료된다. 이때 자동 재연결 및 재시작 로직이 없으면, 애플리케이션은 이벤트를 받을 수 없는 상태에 빠진다.</p>
<p><strong>해결 방법</strong>: <code>retryWhen</code>으로 재시도 로직을 구성하고, Resume Token을 저장했다가 활용하면 끊긴 지점부터 다시 받을 수 있다.</p>
<pre class="highlight"><code class="language-java">private volatile BsonDocument lastResumeToken;

public Flux&lt;Order&gt; watchOrders() {
    return createChangeStream()
        .doOnNext(event -&gt; lastResumeToken =
            event.getRaw().getResumeToken())
        .map(ChangeStreamEvent::getBody)
        .retryWhen(Retry.backoff(Long.MAX_VALUE, Duration.ofSeconds(1))
            .maxBackoff(Duration.ofMinutes(1)));
}

private Flux&lt;ChangeStreamEvent&lt;Order&gt;&gt; createChangeStream() {
    var builder = ChangeStreamOptions.builder()
        .filter(Aggregation.newAggregation(
            Aggregation.match(Criteria.where("operationType")
                .in("insert", "update"))));
    if (lastResumeToken != null) {
        builder.resumeAfter(lastResumeToken);
    }
    return mongoTemplate.changeStream("orders", builder.build(), Order.class);
}</code></pre>
<hr>
<h2 id="faq-10-stepverifier">FAQ 10. 테스트에서 StepVerifier가 타임아웃되는 경우</h2>
<p><strong>증상</strong>: <code>StepVerifier</code> 테스트를 실행했는데 기본 타임아웃인 10초를 넘기고 <code>AssertionError</code>로 실패한다.</p>
<p><strong>원인 분석</strong>: 테스트하는 코드가 완료 신호(<code>onComplete</code>)를 발행하지 않으면, <code>StepVerifier</code>는 계속 대기한다. 빈 결과가 나오거나, 구독이 제대로 안 되었거나, 의도하지 않은 무한 스트림이 있는 경우들이 원인이다.</p>
<p><strong>해결 방법</strong>: 테스트 상황에 맞춰 적절한 검증 메서드를 선택해서 사용한다.</p>
<pre class="highlight"><code class="language-java">// 빈 Mono: verifyComplete()
StepVerifier.create(userRepository.findById("nonexistent"))
    .verifyComplete();

// 무한 스트림: thenCancel()
StepVerifier.create(eventService.streamEvents())
    .expectNextCount(3)
    .thenCancel()
    .verify();

// 시간 지연: withVirtualTime()
StepVerifier.withVirtualTime(() -&gt;
        Mono.error(new RuntimeException("fail"))
            .retryWhen(Retry.fixedDelay(3, Duration.ofSeconds(10))))
    .expectSubscription()
    .thenAwait(Duration.ofSeconds(30))
    .expectError()
    .verify();</code></pre>
<hr>
<h2 id="faq-11-native-image">FAQ 11. Native Image 빌드 시 리플렉션 관련 에러</h2>
<p><strong>증상</strong>: GraalVM Native Image로 빌드한 후 실행하면 <code>ClassNotFoundException</code>이 터진다.</p>
<p><strong>원인 분석</strong>: Native Image는 빌드 당시의 정적 분석만으로 어떤 클래스들이 필요한지 판단한다. 런타임에 리플렉션으로 동적으로 로드하는 클래스들은 빌드 결과에 포함되지 않을 가능성이 높다.</p>
<p><strong>해결 방법</strong>: Spring Boot 3.x부터 제공하는 AOT(Ahead-of-Time) 기능을 활용하고, 필요한 클래스들을 힌트로 명시한다.</p>
<pre class="highlight"><code class="language-java">@Configuration
@ImportRuntimeHints(MongoModelHints.class)
public class NativeConfig { }

public class MongoModelHints implements RuntimeHintsRegistrar {
    @Override
    public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
        hints.reflection()
            .registerType(User.class, MemberCategory.values())
            .registerType(Order.class, MemberCategory.values());
    }
}</code></pre>
<hr>
<h2 id="faq-12-cors">FAQ 12. CORS 관련 문제 해결</h2>
<p><strong>증상</strong>: 프론트엔드 애플리케이션에서 백엔드 API를 호출했는데 브라우저 콘솔에 CORS 에러가 떠 있다.</p>
<p><strong>원인 분석</strong>: 브라우저는 보안상 다른 도메인이나 포트로의 요청을 차단하는 정책을 기본으로 가지고 있다. Spring Security를 사용하는 경우, WebFlux 레벨의 CORS 설정만으로는 부족하고 보안 필터 레벨에서도 별도로 설정해야 한다.</p>
<p><strong>해결 방법</strong>: WebFlux 설정과 Security 설정 두 곳 모두에서 CORS를 제대로 구성해야 한다.</p>
<pre class="highlight"><code class="language-java">// WebFlux CORS 설정
@Override
public void addCorsMappings(CorsRegistry registry) {
    registry.addMapping("/api/**")
        .allowedOrigins("http://localhost:3000")
        .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
        .allowCredentials(true).maxAge(3600);
}

// Security CORS 설정 (Security 사용 시 필수)
@Bean
SecurityWebFilterChain securityFilterChain(ServerHttpSecurity http) {
    return http
        .cors(cors -&gt; cors.configurationSource(corsConfigurationSource()))
        .csrf(ServerHttpSecurity.CsrfSpec::disable)
        .build();
}</code></pre>
<hr>
<h2 id="faq-13-websocket">FAQ 13. WebSocket 연결이 끊어지는 경우</h2>
<p><strong>증상</strong>: WebSocket 연결을 맺은 후 한동안 놔두면 일정 시간이 지나서 자동으로 끊어진다.</p>
<p><strong>원인 분석</strong>: 필자의 경험상 이것은 대부분 중간의 프록시나 로드밸런서의 유휴 타임아웃 때문이다. Nginx는 기본으로 60초 동안 활동이 없는 연결을 종료한다.</p>
<p><strong>해결 방법</strong>: WebSocket 연결을 주기적으로 ping/pong 메시지로 살려두면 타임아웃을 피할 수 있다.</p>
<pre class="highlight"><code class="language-java">@Override
public Mono&lt;Void&gt; handle(WebSocketSession session) {
    Flux&lt;WebSocketMessage&gt; pingFlux = Flux.interval(Duration.ofSeconds(30))
        .map(tick -&gt; session.pingMessage(factory -&gt;
            factory.wrap(ByteBuffer.wrap("ping".getBytes()))));
    Flux&lt;WebSocketMessage&gt; messageFlux = session.receive()
        .filter(msg -&gt; msg.getType() == WebSocketMessage.Type.TEXT)
        .flatMap(msg -&gt; processMessage(msg, session));
    return session.send(pingFlux.mergeWith(messageFlux));
}</code></pre>
<p>Nginx 설정에서 <code>proxy_read_timeout</code>을 충분히 큰 값으로 늘려주는 것도 좋은 방법이다(예: <code>3600s</code>).</p>
<hr>
<h2 id="faq-14">FAQ 14. 메모리 누수 (구독 해제 미처리)</h2>
<p><strong>증상</strong>: 애플리케이션이 오래 실행될수록 힙 메모리가 계속 증가해서 결국 <code>OutOfMemoryError</code>가 난다.</p>
<p><strong>원인 분석</strong>: <code>interval</code>, SSE, WebSocket 등으로 만든 무한 <code>Flux</code>를 구독한 후 제대로 종료하지 않으면, 구독 객체와 내부 버퍼들이 GC의 대상이 되지 않아 메모리에 계속 쌓인다.</p>
<p><strong>해결 방법</strong>: <code>Disposable</code> 객체를 적절히 관리하고, 애플리케이션이나 컴포넌트의 생명주기에 맞춰 제때 해제해야 한다.</p>
<pre class="highlight"><code class="language-java">@Service
public class EventMonitorService implements DisposableBean {
    private final Disposable subscription;

    public EventMonitorService(EventPublisher publisher) {
        this.subscription = publisher.events()
            .subscribe(this::process, e -&gt; log.error("처리 실패", e));
    }

    @Override
    public void destroy() {
        if (subscription != null &amp;&amp; !subscription.isDisposed()) {
            subscription.dispose();
        }
    }
}</code></pre>
<p>SSE 엔드포인트의 경우, <code>doOnCancel()</code> 콜백으로 클라이언트 연결이 끊어지는 순간을 감지해서 필요한 리소스를 즉시 정리하는 것이 좋은 패턴이다.</p>
<hr>
<h2 id="faq-15-reactor-context">FAQ 15. Reactor Context 전파 문제</h2>
<p><strong>증상</strong>: <code>contextWrite()</code>로 값을 저장하고 <code>deferContextual()</code>로 읽으려 하는데 값이 없다고 나온다.</p>
<p><strong>원인 분석</strong>: Reactor Context는 구독자 쪽에서 발행자 쪽으로(즉, 아래에서 위로) 향해 전파된다. 만약 <code>contextWrite()</code>가 체인의 상류에 있으면, 그 아래의 연산자들은 해당 Context를 볼 수 없다.</p>
<p><strong>해결 방법</strong>: <code>contextWrite()</code>를 체인의 하류(구독자가 있는 쪽)에 배치해야 값이 제대로 전파된다.</p>
<pre class="highlight"><code class="language-java">// 잘못된 코드: contextWrite가 상류에 위치
Mono.just("data")
    .contextWrite(ctx -&gt; ctx.put("key", "value"))
    .flatMap(data -&gt; Mono.deferContextual(ctx -&gt;
        Mono.just(ctx.getOrDefault("key", "없음")))); // "없음" 반환

// 올바른 코드: contextWrite를 하류에 배치
Mono.just("data")
    .flatMap(data -&gt; Mono.deferContextual(ctx -&gt;
        Mono.just(ctx.get("key"))))  // "value" 정상 반환
    .contextWrite(ctx -&gt; ctx.put("key", "value"));</code></pre>
<p>실무에서는 여러 레이어를 거치는 Context를 일관되게 전파하려면, <code>WebFilter</code>에서 한 번에 설정하는 방식이 가장 깔끔하다.</p>
<pre class="highlight"><code class="language-java">@Override
public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
    String tenantId = exchange.getRequest().getHeaders().getFirst("X-Tenant-Id");
    return chain.filter(exchange)
        .contextWrite(ctx -&gt; ctx.put("tenantId",
            tenantId != null ? tenantId : "default"));
}</code></pre>
<hr>
<h2 id="_1">정리</h2>
<p>15가지 문제를 훑어본 결과, 리액티브 프로그래밍에서 발생하는 대부분의 이슈는 근본적으로 다음 세 가지 원칙과 맞닿아 있음을 알 수 있다.</p>
<ol>
<li>
<p><strong>체인을 끊지 마라</strong>: 리액티브 파이프라인은 연속된 하나의 체인으로 유지되어야 한다. <code>block()</code> 호출, 새로운 구독 시점 추가, 중간에 변수로 빼내기 등으로 체인을 끊으면, Context 전파가 끊어지고 에러 처리와 백프레셔가 제대로 작동하지 않는다.</p>
</li>
<li>
<p><strong>스레드를 가정하지 마라</strong>: 리액티브 코드는 어떤 스레드에서 실행될지 예측할 수 없다. 따라서 <code>ThreadLocal</code>, <code>synchronized</code> 블록, 특정 스레드에 고정된 가변 상태 같은 것은 피해야 한다.</p>
</li>
<li>
<p><strong>구독 생명주기를 관리하라</strong>: 모든 구독은 정상적으로 완료되거나 명시적으로 해제되어야 한다. 특히 무한 스트림(<code>interval</code>, SSE, WebSocket 등)을 구독할 때는 반드시 해제 로직을 함께 작성해야 한다.</p>
</li>
</ol>
<p>이 세 가지 원칙을 머릿속에 새기고 개발한다면, 이 부록에서 다룬 거의 모든 문제를 미리 방지할 수 있을 것이다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>