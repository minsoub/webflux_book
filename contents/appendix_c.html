<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>부록 C. 자주 발생하는 문제와 해결 방법 (FAQ) | Spring Boot + WebFlux + JPA (MongoDB)</title>
  <link rel="stylesheet" href="../css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <h1><a href="../index.html">Spring Boot + WebFlux + JPA (MongoDB)</a></h1>
  </header>
    <nav class="nav-bar">
    <a href="appendix_b.html">&larr; 부록 B. MongoDB 쿼리 연산자 정리</a>
    <a href="../index.html">목차</a>
    <a href="appendix_d.html">부록 D. 참고 자료 및 추천 학습 경로 &rarr;</a>
  </nav>
  <div class="wrapper">
    <main class="content">
      <h1 id="c-faq">부록 C. 자주 발생하는 문제와 해결 방법 (FAQ)</h1>
<p>Spring WebFlux와 MongoDB 리액티브 스택으로 개발하다 보면 명령형 프로그래밍에서는 만나지 못했던 새로운 유형의 문제들을 마주하게 된다. 이 부록에서는 실무에서 빈번하게 발생하는 15가지 문제를 선별하여, 증상 파악부터 원인 분석, 해결 방법까지 체계적으로 정리한다.</p>
<hr>
<h2 id="faq-1-blockblockfirstblocklast-are-blocking">FAQ 1. "block()/blockFirst()/blockLast() are blocking" 에러</h2>
<p><strong>증상</strong>: 리액티브 파이프라인 내부에서 <code>block()</code>을 호출하면 <code>IllegalStateException</code>이 발생한다.</p>
<p><strong>원인 분석</strong>: Netty의 이벤트 루프 스레드에서 <code>block()</code>을 호출하면 해당 스레드가 차단된다. 이벤트 루프가 멈추면 모든 요청 처리가 중단되므로, Reactor는 이를 감지하고 예외를 던진다.</p>
<p><strong>해결 방법</strong>: <code>block()</code> 대신 <code>flatMap</code>, <code>zip</code>, <code>then</code> 등 리액티브 연산자로 체이닝한다.</p>
<pre class="highlight"><code class="language-java">// 잘못된 코드
User user = userRepository.findById(userId).block(); // 예외 발생!

// 올바른 코드
return userRepository.findById(userId)
    .flatMap(user -&gt; profileRepository.findByUser(user));</code></pre>
<p>부득이하게 블로킹 코드를 호출해야 한다면 <code>Schedulers.boundedElastic()</code>으로 전환한다.</p>
<pre class="highlight"><code class="language-java">Mono.fromCallable(() -&gt; legacyBlockingService.call())
    .subscribeOn(Schedulers.boundedElastic());</code></pre>
<hr>
<h2 id="faq-2-scheduler-was-blocked-blockhound">FAQ 2. "Scheduler was blocked" 에러와 BlockHound</h2>
<p><strong>증상</strong>: BlockHound 활성화 후 <code>BlockingOperationError: Blocking call!</code> 에러가 발생한다.</p>
<p><strong>원인 분석</strong>: BlockHound는 논블로킹 스레드에서 발생하는 블로킹 호출(파일 I/O, <code>Thread.sleep</code> 등)을 런타임에 감지한다. 서드파티 라이브러리에 숨어 있는 블로킹 지점이 원인인 경우가 많다.</p>
<p><strong>해결 방법</strong>: BlockHound를 테스트 의존성으로 추가하고, 허용 가능한 블로킹 호출은 화이트리스트에 등록한다.</p>
<pre class="highlight"><code class="language-java">BlockHound.install(builder -&gt; builder
    .allowBlockingCallsInside(
        "com.mongodb.internal.connection.DefaultServerMonitor", "run")
    .allowBlockingCallsInside(
        "io.netty.resolver.dns.DnsServerAddressStreamProviders",
        "unixResolverEnabled")
);</code></pre>
<hr>
<h2 id="faq-3-mongodb">FAQ 3. MongoDB 연결 실패 및 타임아웃 문제</h2>
<p><strong>증상</strong>: <code>MongoTimeoutException: Timed out after 30000 ms while waiting for a server</code>가 발생한다.</p>
<p><strong>원인 분석</strong>: 커넥션 풀 크기 부족, 네트워크 지연, 레플리카 셋 구성 변경, DNS 해석 지연 등이 원인이다.</p>
<p><strong>해결 방법</strong>: <code>MongoClientSettings</code>를 직접 구성하여 커넥션 풀과 타임아웃을 조정한다.</p>
<pre class="highlight"><code class="language-java">@Override
protected void configureClientSettings(MongoClientSettings.Builder builder) {
    builder.applyToConnectionPoolSettings(pool -&gt; pool
            .maxSize(50)
            .minSize(10)
            .maxWaitTime(5, TimeUnit.SECONDS)
            .maxConnectionIdleTime(30, TimeUnit.SECONDS))
        .applyToSocketSettings(socket -&gt; socket
            .connectTimeout(5, TimeUnit.SECONDS)
            .readTimeout(10, TimeUnit.SECONDS))
        .applyToServerSettings(server -&gt; server
            .heartbeatFrequency(10, TimeUnit.SECONDS));
}</code></pre>
<hr>
<h2 id="faq-4-reactivesecuritycontext-null">FAQ 4. ReactiveSecurityContext에서 인증 정보가 null인 경우</h2>
<p><strong>증상</strong>: <code>ReactiveSecurityContextHolder.getContext()</code>가 빈 <code>Mono</code>를 반환한다.</p>
<p><strong>원인 분석</strong>: Spring Security 리액티브 구현은 <code>ThreadLocal</code>이 아닌 Reactor Context를 통해 <code>SecurityContext</code>를 전파한다. 파이프라인이 끊기면 Context가 전파되지 않아 인증 정보가 사라진다.</p>
<p><strong>해결 방법</strong>: 리액티브 체인을 끊지 않고 유지하거나, 컨트롤러에서 파라미터로 전달한다.</p>
<pre class="highlight"><code class="language-java">// 올바른 코드: 체인 유지
return ReactiveSecurityContextHolder.getContext()
    .map(ctx -&gt; ctx.getAuthentication().getName())
    .map(name -&gt; "prefix_" + name);

// 더 나은 방법: 컨트롤러 파라미터로 전달
@GetMapping("/me")
public Mono&lt;UserDto&gt; getMyInfo(@AuthenticationPrincipal Mono&lt;UserDetails&gt; principal) {
    return principal.flatMap(user -&gt; userService.findByUsername(user.getUsername()));
}</code></pre>
<hr>
<h2 id="faq-5-webflux-transactional">FAQ 5. WebFlux에서 @Transactional이 작동하지 않는 경우</h2>
<p><strong>증상</strong>: <code>@Transactional</code>을 선언했는데 MongoDB 작업이 트랜잭션으로 묶이지 않는다.</p>
<p><strong>원인 분석</strong>: MongoDB 트랜잭션은 레플리카 셋(Replica Set) 구성이 필수다. 또한 <code>ReactiveMongoTransactionManager</code> 빈이 등록되어 있어야 한다.</p>
<p><strong>해결 방법</strong>: 레플리카 셋을 구성하고 트랜잭션 매니저를 등록한다.</p>
<pre class="highlight"><code class="language-bash">mongosh --eval "rs.initiate({_id:'rs0', members:[{_id:0, host:'localhost:27017'}]})"</code></pre>
<pre class="highlight"><code class="language-java">@Bean
ReactiveMongoTransactionManager transactionManager(ReactiveMongoDatabaseFactory factory) {
    return new ReactiveMongoTransactionManager(factory);
}</code></pre>
<hr>
<h2 id="faq-6-flux-cold-vs-hot">FAQ 6. Flux 데이터가 중복으로 발행되는 경우 (Cold vs Hot)</h2>
<p><strong>증상</strong>: 하나의 <code>Flux</code>를 여러 곳에서 구독하면 DB 쿼리가 구독 횟수만큼 반복 실행된다.</p>
<p><strong>원인 분석</strong>: Reactor의 <code>Flux</code>/<code>Mono</code>는 기본적으로 Cold Publisher다. 각 구독자에 대해 독립적으로 데이터 생성을 시작하므로 소스 작업이 중복 실행된다.</p>
<p><strong>해결 방법</strong>: <code>cache()</code> 또는 <code>share()</code>로 Hot Publisher로 변환한다.</p>
<pre class="highlight"><code class="language-java">Flux&lt;Product&gt; products = productRepository.findAll().cache(); // 결과 캐싱</code></pre>
<table>
<thead>
<tr>
<th>연산자</th>
<th>동작</th>
<th>용도</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cache()</code></td>
<td>모든 데이터를 버퍼링, 새 구독자에게 재전송</td>
<td>변하지 않는 결과 조회</td>
</tr>
<tr>
<td><code>cache(Duration)</code></td>
<td>TTL이 지나면 소스를 재구독</td>
<td>일정 시간 캐싱</td>
</tr>
<tr>
<td><code>share()</code></td>
<td>진행 중인 스트림을 공유, 이전 데이터 유실</td>
<td>실시간 이벤트 스트림</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="faq-7-webclient-databufferlimitexception">FAQ 7. WebClient에서 DataBufferLimitException 발생</h2>
<p><strong>증상</strong>: 대용량 응답 수신 시 <code>Exceeded limit on max bytes to buffer : 262144</code> 에러가 발생한다.</p>
<p><strong>원인 분석</strong>: WebClient는 기본적으로 응답 본문을 최대 256KB까지만 버퍼링한다.</p>
<p><strong>해결 방법</strong>: 버퍼 크기를 조정하거나, 스트리밍으로 처리한다.</p>
<pre class="highlight"><code class="language-java">// 방법 1: 버퍼 크기 확장
WebClient.builder()
    .codecs(c -&gt; c.defaultCodecs().maxInMemorySize(10 * 1024 * 1024))
    .build();

// 방법 2: 스트리밍 처리 (권장)
webClient.get().uri("/api/products/export")
    .accept(MediaType.APPLICATION_NDJSON)
    .retrieve()
    .bodyToFlux(Product.class);</code></pre>
<hr>
<h2 id="faq-8-threadlocalmdc">FAQ 8. 리액티브 환경에서 ThreadLocal/MDC 사용 문제</h2>
<p><strong>증상</strong>: MDC에 설정한 <code>traceId</code>가 리액티브 파이프라인을 타면서 <code>null</code>로 나타난다.</p>
<p><strong>원인 분석</strong>: MDC는 <code>ThreadLocal</code> 기반이므로, 하나의 요청이 여러 스레드를 오가는 리액티브 환경에서는 스레드 전환 시 MDC 값이 사라진다.</p>
<p><strong>해결 방법</strong>: Micrometer Context Propagation을 활용하여 자동 동기화한다.</p>
<pre class="highlight"><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.micrometer&lt;/groupId&gt;
    &lt;artifactId&gt;context-propagation&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
<pre class="highlight"><code class="language-java">// 애플리케이션 시작 시 Hook 등록
Hooks.enableAutomaticContextPropagation();

// WebFilter에서 Reactor Context에 값 저장
@Override
public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
    String traceId = Optional.ofNullable(
            exchange.getRequest().getHeaders().getFirst("X-Trace-Id"))
        .orElse(UUID.randomUUID().toString().substring(0, 8));
    return chain.filter(exchange)
        .contextWrite(ctx -&gt; ctx.put("traceId", traceId));
}</code></pre>
<hr>
<h2 id="faq-9-mongodb-change-streams">FAQ 9. MongoDB Change Streams 연결 끊김 처리</h2>
<p><strong>증상</strong>: Change Streams 수신 중 MongoDB 장애나 네트워크 단절 시 스트림이 영구적으로 끊어진다.</p>
<p><strong>원인 분석</strong>: 네트워크 단절이나 프라이머리 전환 시 롱 커넥션이 끊기며, 자동 재연결 로직이 없으면 이벤트 수신이 중단된다.</p>
<p><strong>해결 방법</strong>: <code>retryWhen</code>과 Resume Token을 활용하여 끊긴 지점부터 재수신한다.</p>
<pre class="highlight"><code class="language-java">private volatile BsonValue lastResumeToken;

public Flux&lt;Order&gt; watchOrders() {
    return createChangeStream()
        .doOnNext(event -&gt; lastResumeToken =
            event.getRaw().getResumeToken().get("_data"))
        .map(ChangeStreamEvent::getBody)
        .retryWhen(Retry.backoff(Long.MAX_VALUE, Duration.ofSeconds(1))
            .maxBackoff(Duration.ofMinutes(1)));
}

private Flux&lt;ChangeStreamEvent&lt;Order&gt;&gt; createChangeStream() {
    var builder = ChangeStreamOptions.builder()
        .filter(Aggregation.newAggregation(
            Aggregation.match(Criteria.where("operationType")
                .in("insert", "update"))));
    if (lastResumeToken != null) {
        builder.resumeAfter(new BsonDocument("_data", lastResumeToken));
    }
    return mongoTemplate.changeStream("orders", builder.build(), Order.class);
}</code></pre>
<hr>
<h2 id="faq-10-stepverifier">FAQ 10. 테스트에서 StepVerifier가 타임아웃되는 경우</h2>
<p><strong>증상</strong>: <code>StepVerifier</code> 테스트가 기본 타임아웃(10초) 이후 <code>AssertionError</code>로 실패한다.</p>
<p><strong>원인 분석</strong>: 테스트 대상이 완료 신호(<code>onComplete</code>)를 발행하지 않으면 <code>StepVerifier</code>가 무한 대기한다. 빈 결과, 누락된 구독, 무한 스트림이 원인이다.</p>
<p><strong>해결 방법</strong>: 상황에 맞는 검증 전략을 선택한다.</p>
<pre class="highlight"><code class="language-java">// 빈 Mono: verifyComplete()
StepVerifier.create(userRepository.findById("nonexistent"))
    .verifyComplete();

// 무한 스트림: thenCancel()
StepVerifier.create(eventService.streamEvents())
    .expectNextCount(3)
    .thenCancel()
    .verify();

// 시간 지연: withVirtualTime()
StepVerifier.withVirtualTime(() -&gt;
        Mono.error(new RuntimeException("fail"))
            .retryWhen(Retry.fixedDelay(3, Duration.ofSeconds(10))))
    .expectSubscription()
    .thenAwait(Duration.ofSeconds(30))
    .expectError()
    .verify();</code></pre>
<hr>
<h2 id="faq-11-native-image">FAQ 11. Native Image 빌드 시 리플렉션 관련 에러</h2>
<p><strong>증상</strong>: GraalVM Native Image 빌드 후 런타임에 <code>ClassNotFoundException</code>이 발생한다.</p>
<p><strong>원인 분석</strong>: Native Image는 빌드 시점에 정적 분석으로 클래스를 판별하므로, 리플렉션으로 접근하는 클래스가 바이너리에 포함되지 않을 수 있다.</p>
<p><strong>해결 방법</strong>: Spring Boot 3.x의 AOT 기능을 활용하고, 커스텀 리플렉션은 힌트를 등록한다.</p>
<pre class="highlight"><code class="language-java">@Configuration
@ImportRuntimeHints(MongoModelHints.class)
public class NativeConfig { }

public class MongoModelHints implements RuntimeHintsRegistrar {
    @Override
    public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
        hints.reflection()
            .registerType(User.class, MemberCategory.values())
            .registerType(Order.class, MemberCategory.values());
    }
}</code></pre>
<hr>
<h2 id="faq-12-cors">FAQ 12. CORS 관련 문제 해결</h2>
<p><strong>증상</strong>: 프론트엔드에서 API 호출 시 브라우저 콘솔에 CORS 에러가 표시된다.</p>
<p><strong>원인 분석</strong>: 브라우저의 동일 출처 정책에 의해 다른 도메인/포트의 요청이 차단된다. Spring Security를 함께 쓸 경우 보안 필터에서도 CORS를 설정해야 한다.</p>
<p><strong>해결 방법</strong>: WebFlux 설정과 Security 설정 양쪽에서 CORS를 구성한다.</p>
<pre class="highlight"><code class="language-java">// WebFlux CORS 설정
@Override
public void addCorsMappings(CorsRegistry registry) {
    registry.addMapping("/api/**")
        .allowedOrigins("http://localhost:3000")
        .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
        .allowCredentials(true).maxAge(3600);
}

// Security CORS 설정 (Security 사용 시 필수)
@Bean
SecurityWebFilterChain securityFilterChain(ServerHttpSecurity http) {
    return http
        .cors(cors -&gt; cors.configurationSource(corsConfigurationSource()))
        .csrf(ServerHttpSecurity.CsrfSpec::disable)
        .build();
}</code></pre>
<hr>
<h2 id="faq-13-websocket">FAQ 13. WebSocket 연결이 끊어지는 경우</h2>
<p><strong>증상</strong>: WebSocket 연결이 일정 시간 후 끊어지며 <code>onClose</code> 이벤트가 발생한다.</p>
<p><strong>원인 분석</strong>: 프록시/로드밸런서의 유휴 타임아웃(Nginx 기본 60초)이 주요 원인이다.</p>
<p><strong>해결 방법</strong>: 핑/퐁 메커니즘으로 연결을 유지한다.</p>
<pre class="highlight"><code class="language-java">@Override
public Mono&lt;Void&gt; handle(WebSocketSession session) {
    Flux&lt;WebSocketMessage&gt; pingFlux = Flux.interval(Duration.ofSeconds(30))
        .map(tick -&gt; session.pingMessage(factory -&gt;
            factory.wrap(ByteBuffer.wrap("ping".getBytes()))));
    Flux&lt;WebSocketMessage&gt; messageFlux = session.receive()
        .filter(msg -&gt; msg.getType() == WebSocketMessage.Type.TEXT)
        .flatMap(msg -&gt; processMessage(msg, session));
    return session.send(pingFlux.mergeWith(messageFlux));
}</code></pre>
<p>Nginx에서는 <code>proxy_read_timeout</code>을 충분히 늘려야 한다(예: <code>3600s</code>).</p>
<hr>
<h2 id="faq-14">FAQ 14. 메모리 누수 (구독 해제 미처리)</h2>
<p><strong>증상</strong>: 가동 시간이 길어질수록 힙 메모리가 지속 증가하며 <code>OutOfMemoryError</code>가 발생한다.</p>
<p><strong>원인 분석</strong>: 무한 <code>Flux</code>(<code>interval</code>, SSE, WebSocket 등)를 구독한 후 해제하지 않으면, 구독 객체와 내부 버퍼가 GC 대상이 되지 않아 메모리가 누적된다.</p>
<p><strong>해결 방법</strong>: <code>Disposable</code>을 관리하고 라이프사이클에 맞춰 해제한다.</p>
<pre class="highlight"><code class="language-java">@Service
public class EventMonitorService implements DisposableBean {
    private final Disposable subscription;

    public EventMonitorService(EventPublisher publisher) {
        this.subscription = publisher.events()
            .subscribe(this::process, e -&gt; log.error("처리 실패", e));
    }

    @Override
    public void destroy() {
        if (subscription != null &amp;&amp; !subscription.isDisposed()) {
            subscription.dispose();
        }
    }
}</code></pre>
<p>SSE 엔드포인트에서는 <code>doOnCancel()</code>로 클라이언트 연결 종료를 감지하여 리소스를 정리한다.</p>
<hr>
<h2 id="faq-15-reactor-context">FAQ 15. Reactor Context 전파 문제</h2>
<p><strong>증상</strong>: <code>contextWrite()</code>로 저장한 값을 <code>deferContextual()</code>로 읽으면 값이 존재하지 않는다.</p>
<p><strong>원인 분석</strong>: Reactor Context는 구독자에서 발행자 방향(아래에서 위)으로 전파된다. <code>contextWrite()</code>가 체인의 상류에 위치하면 하류의 연산자가 해당 Context를 참조할 수 없다.</p>
<p><strong>해결 방법</strong>: <code>contextWrite()</code>를 체인의 하류(구독자 쪽)에 배치한다.</p>
<pre class="highlight"><code class="language-java">// 잘못된 코드: contextWrite가 상류에 위치
Mono.just("data")
    .contextWrite(ctx -&gt; ctx.put("key", "value"))
    .flatMap(data -&gt; Mono.deferContextual(ctx -&gt;
        Mono.just(ctx.getOrDefault("key", "없음")))); // "없음" 반환

// 올바른 코드: contextWrite를 하류에 배치
Mono.just("data")
    .flatMap(data -&gt; Mono.deferContextual(ctx -&gt;
        Mono.just(ctx.get("key"))))  // "value" 정상 반환
    .contextWrite(ctx -&gt; ctx.put("key", "value"));</code></pre>
<p>여러 레이어에 걸쳐 Context를 전파하려면 <code>WebFilter</code>에서 설정하면 전체 파이프라인에서 접근 가능하다.</p>
<pre class="highlight"><code class="language-java">@Override
public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) {
    String tenantId = exchange.getRequest().getHeaders().getFirst("X-Tenant-Id");
    return chain.filter(exchange)
        .contextWrite(ctx -&gt; ctx.put("tenantId",
            tenantId != null ? tenantId : "default"));
}</code></pre>
<hr>
<h2 id="_1">정리</h2>
<p>리액티브 프로그래밍에서 발생하는 대부분의 문제는 다음 세 가지 원칙을 이해하면 예방할 수 있다.</p>
<ol>
<li>
<p><strong>체인을 끊지 마라</strong>: 리액티브 파이프라인은 하나의 연속된 체인이어야 한다. <code>block()</code>, 새로운 구독, 중간 변수 할당 등으로 체인이 끊기면 Context 전파, 에러 처리, 백프레셔 등이 제대로 작동하지 않는다.</p>
</li>
<li>
<p><strong>스레드를 가정하지 마라</strong>: 리액티브 코드는 어떤 스레드에서든 실행될 수 있다. <code>ThreadLocal</code>, <code>synchronized</code>, 가변 상태 등 특정 스레드에 의존하는 패턴은 피해야 한다.</p>
</li>
<li>
<p><strong>구독 생명주기를 관리하라</strong>: 모든 구독은 반드시 완료되거나 명시적으로 해제되어야 한다. 무한 스트림을 구독할 때는 반드시 해제 로직을 함께 작성한다.</p>
</li>
</ol>
<p>이 세 가지 원칙을 기억하며 개발한다면, 이 부록에서 다룬 문제 대부분을 사전에 방지할 수 있을 것이다.</p>
    </main>
    <footer class="site-footer">
      &copy; 2024 Spring Boot + WebFlux + JPA (MongoDB) Book
    </footer>
  </div>
</body>
</html>