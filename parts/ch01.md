# Chapter 1. 리액티브 프로그래밍 소개

현대 소프트웨어 시스템은 수백만 사용자의 동시 요청, 밀리초 단위의 응답 시간, 무중단 운영을 요구한다. 전통적인 명령형 프로그래밍 모델로는 이러한 요구사항을 충족하기 어렵다. 이 장에서는 리액티브 프로그래밍의 핵심 개념을 살펴보고, 왜 Spring WebFlux가 이 패러다임을 채택했는지 이해한다.

---

## 1.1 리액티브 프로그래밍이란?

### 1.1.1 정의와 핵심 원칙

리액티브 프로그래밍(Reactive Programming)은 **데이터 스트림과 변화의 전파**에 초점을 맞춘 프로그래밍 패러다임이다. 기존의 명령형 프로그래밍이 "이 값을 가져와서 이렇게 처리하라"라고 지시하는 방식이라면, 리액티브 프로그래밍은 "데이터가 흘러오면 이렇게 반응하라"라고 선언하는 방식이다.

스프레드시트를 떠올려 보자. 셀 A1에 10, B1에 20이 있고, C1에 `=A1+B1`이라는 수식을 넣으면 C1은 30이 된다. 이후 A1의 값을 50으로 바꾸면 C1은 자동으로 70으로 갱신된다. 이것이 리액티브 프로그래밍의 본질이다. C1은 A1과 B1의 **변화에 반응**한다.

리액티브 프로그래밍의 핵심 원칙은 다음과 같다.

- **비동기 데이터 스트림**: 모든 데이터를 시간에 따라 흐르는 스트림으로 모델링한다.
- **변화의 전파**: 상류(upstream)의 변화가 하류(downstream)로 자동 전파된다.
- **선언적 구성**: 데이터를 어떻게(how) 처리할지가 아니라, 무엇을(what) 할지 선언한다.
- **논블로킹 실행**: 스레드를 차단하지 않고 비동기적으로 작업을 수행한다.

### 1.1.2 리액티브 선언문 (Reactive Manifesto)

2014년에 발표된 리액티브 선언문은 리액티브 시스템이 갖추어야 할 네 가지 속성을 정의한다.

| 속성 | 설명 |
|------|------|
| **응답성(Responsive)** | 시스템이 가능한 한 즉각적으로 응답한다. 응답성은 사용자 경험의 핵심이다. |
| **탄력성(Resilient)** | 장애가 발생해도 시스템이 응답성을 유지한다. 장애는 각 컴포넌트 내부에 격리된다. |
| **유연성(Elastic)** | 작업 부하가 변화해도 시스템이 응답성을 유지한다. 리소스를 동적으로 확장/축소한다. |
| **메시지 기반(Message Driven)** | 비동기 메시지 전달을 통해 컴포넌트 간 느슨한 결합을 달성한다. |

이 네 가지 속성은 독립적이지 않다. 메시지 기반 아키텍처가 토대가 되고, 그 위에 유연성과 탄력성이 구현되며, 최종적으로 응답성이 확보된다.

### 1.1.3 데이터 스트림과 변화의 전파

리액티브 프로그래밍에서 모든 것은 스트림이다. 사용자 클릭 이벤트, HTTP 요청, 데이터베이스 쿼리 결과, 센서 데이터 등 모든 데이터가 시간축 위에 놓인 스트림으로 표현된다.

스트림은 세 가지 신호를 발행할 수 있다.

1. **onNext(item)**: 다음 데이터 항목을 전달한다.
2. **onError(error)**: 오류가 발생했음을 알린다. 스트림이 종료된다.
3. **onComplete()**: 더 이상 전달할 데이터가 없음을 알린다. 스트림이 종료된다.

```
시간 →
──[item1]──[item2]──[item3]──|──>   (정상 완료: | = onComplete)
──[item1]──[item2]──X──>            (오류 발생: X = onError)
```

### 1.1.4 옵저버 패턴과의 관계

리액티브 프로그래밍은 GoF 디자인 패턴의 옵저버 패턴(Observer Pattern)을 확장한 것이다. 옵저버 패턴에서는 Subject가 상태 변화를 Observer에게 통지한다.

```java
// 전통적인 옵저버 패턴
public interface Observer {
    void update(String event);
}

public class EventSource {
    private final List<Observer> observers = new ArrayList<>();

    public void addObserver(Observer observer) {
        observers.add(observer);
    }

    public void notifyAll(String event) {
        observers.forEach(o -> o.update(event));
    }
}
```

리액티브 프로그래밍은 이 옵저버 패턴에 다음 세 가지를 추가한다.

- **완료 신호**: 데이터 발행이 끝났음을 구독자에게 알릴 수 있다.
- **오류 처리**: 오류를 스트림의 일부로 다루어 체계적으로 처리한다.
- **배압(Backpressure)**: 구독자가 처리할 수 있는 속도에 맞춰 데이터 발행 속도를 조절한다.

---

## 1.2 명령형 프로그래밍 vs 리액티브 프로그래밍

### 1.2.1 명령형 방식의 코드 예시

사용자 목록에서 활성 사용자를 필터링하고, 이름을 대문자로 변환하여 정렬하는 로직을 명령형으로 작성하면 다음과 같다.

```java
// 명령형 방식: 단계별로 "어떻게" 처리할지 기술
public List<String> getActiveUserNames(List<User> users) {
    List<String> activeUserNames = new ArrayList<>();

    for (User user : users) {
        if (user.isActive()) {
            String upperName = user.getName().toUpperCase();
            activeUserNames.add(upperName);
        }
    }

    Collections.sort(activeUserNames);
    return activeUserNames;
}
```

이 코드는 직관적이지만, 모든 데이터가 메모리에 준비되어 있어야 하고, 처리가 끝날 때까지 호출 스레드가 차단된다.

### 1.2.2 같은 로직의 리액티브 코드 예시

같은 로직을 Project Reactor를 사용한 리액티브 방식으로 작성하면 다음과 같다.

```java
// 리액티브 방식: "무엇을" 할지 선언적으로 기술
public Flux<String> getActiveUserNames(Flux<User> users) {
    return users
            .filter(User::isActive)
            .map(user -> user.getName().toUpperCase())
            .sort();
}
```

리액티브 코드는 데이터가 도착할 때마다 파이프라인을 통해 처리된다. 전체 데이터가 메모리에 있을 필요가 없으며, 호출 스레드를 차단하지 않는다.

### 1.2.3 동기 vs 비동기, 블로킹 vs 논블로킹

이 두 쌍의 개념은 자주 혼동되지만 서로 다른 차원의 개념이다.

**동기(Synchronous) vs 비동기(Asynchronous)**는 호출자가 결과를 기다리는 방식에 관한 것이다.

- 동기: 호출자가 결과가 반환될 때까지 기다린다.
- 비동기: 호출자가 결과를 기다리지 않고, 결과가 준비되면 콜백이나 이벤트로 통지받는다.

**블로킹(Blocking) vs 논블로킹(Non-blocking)**은 호출된 함수가 스레드를 점유하는 방식에 관한 것이다.

- 블로킹: 호출된 함수가 작업을 완료할 때까지 스레드를 점유한다.
- 논블로킹: 호출된 함수가 즉시 반환하고, 스레드를 다른 작업에 활용할 수 있다.

```java
// 동기 + 블로킹: 스레드가 응답을 받을 때까지 멈춘다
User user = userRepository.findById(1L);  // 블로킹 호출

// 비동기 + 논블로킹: 스레드가 즉시 반환되고, 데이터가 준비되면 처리된다
Mono<User> user = userRepository.findById(1L);  // 논블로킹 호출
user.subscribe(u -> System.out.println(u.getName()));
```

### 1.2.4 장단점 비교

| 구분 | 명령형 | 리액티브 |
|------|--------|----------|
| **코드 가독성** | 직관적이고 이해하기 쉬움 | 학습 곡선이 존재함 |
| **디버깅** | 스택 트레이스가 명확함 | 비동기 스택 트레이스 추적이 어려움 |
| **리소스 활용** | 스레드 차단으로 비효율적 | 적은 스레드로 높은 처리량 달성 |
| **확장성** | 스레드 수에 비례하여 제한적 | 이벤트 루프 기반으로 높은 확장성 |
| **에러 처리** | try-catch로 직관적 | 연산자 체인에서 처리 |
| **적합한 상황** | CPU 집약적, 단순한 CRUD | I/O 집약적, 대규모 동시 연결 |

---

## 1.3 리액티브 스트림(Reactive Streams) 표준

### 1.3.1 개요

리액티브 스트림은 비동기 스트림 처리를 위한 표준 인터페이스 명세이다. Netflix, Lightbend, Pivotal 등이 공동으로 개발했으며, Java 9부터 `java.util.concurrent.Flow` 클래스로 JDK에 포함되었다.

이 표준은 단 4개의 인터페이스로 구성된다.

### 1.3.2 Publisher

데이터를 생산하는 주체이다. 구독자의 요청에 따라 데이터를 발행한다.

```java
public interface Publisher<T> {
    void subscribe(Subscriber<? super T> subscriber);
}
```

`subscribe()` 메서드는 구독자를 등록한다. 호출되면 Publisher는 `Subscriber.onSubscribe()`를 호출하여 Subscription 객체를 전달한다.

### 1.3.3 Subscriber

데이터를 소비하는 주체이다. Publisher로부터 데이터를 수신하고 처리한다.

```java
public interface Subscriber<T> {
    void onSubscribe(Subscription subscription);
    void onNext(T item);
    void onError(Throwable throwable);
    void onComplete();
}
```

| 메서드 | 호출 시점 | 역할 |
|--------|----------|------|
| `onSubscribe` | 구독 시작 시 | Subscription을 수신하여 데이터 요청 시작 |
| `onNext` | 데이터 발행 시 | 각 데이터 항목을 처리 |
| `onError` | 오류 발생 시 | 오류를 처리하고 스트림 종료 |
| `onComplete` | 발행 완료 시 | 정상 종료 처리 |

### 1.3.4 Subscription

Publisher와 Subscriber 사이의 연결을 나타낸다. 배압 제어의 핵심이다.

```java
public interface Subscription {
    void request(long n);
    void cancel();
}
```

- `request(n)`: Publisher에게 n개의 데이터를 요청한다. 이것이 배압의 핵심 메커니즘이다.
- `cancel()`: 구독을 취소한다. 더 이상 데이터를 수신하지 않는다.

### 1.3.5 Processor

Publisher와 Subscriber를 동시에 구현한다. 데이터를 수신하여 변환한 뒤 다시 발행하는 중간 처리 단계이다.

```java
public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {
}
```

### 1.3.6 상호작용 흐름

네 인터페이스의 상호작용을 순서대로 정리하면 다음과 같다.

```
Subscriber                    Publisher
    |                             |
    |--- subscribe(subscriber) -->|
    |                             |
    |<-- onSubscribe(subscription)|
    |                             |
    |--- request(3) ------------->|   (3개 요청)
    |                             |
    |<-- onNext(item1) -----------|
    |<-- onNext(item2) -----------|
    |<-- onNext(item3) -----------|
    |                             |
    |--- request(2) ------------->|   (2개 추가 요청)
    |                             |
    |<-- onNext(item4) -----------|
    |<-- onComplete() ------------|   (발행 완료)
```

### 1.3.7 Java 코드로 보는 전체 흐름

```java
import java.util.concurrent.Flow.*;

public class SimpleReactiveExample {

    public static void main(String[] args) {
        // Publisher: 1~5를 발행
        SubmissionPublisher<Integer> publisher = new SubmissionPublisher<>();

        // Subscriber: 데이터를 수신하여 출력
        Subscriber<Integer> subscriber = new Subscriber<>() {
            private Subscription subscription;

            @Override
            public void onSubscribe(Subscription subscription) {
                this.subscription = subscription;
                subscription.request(1); // 첫 번째 항목 요청
            }

            @Override
            public void onNext(Integer item) {
                System.out.println("수신: " + item);
                subscription.request(1); // 다음 항목 요청
            }

            @Override
            public void onError(Throwable throwable) {
                System.err.println("오류: " + throwable.getMessage());
            }

            @Override
            public void onComplete() {
                System.out.println("완료");
            }
        };

        publisher.subscribe(subscriber);

        // 데이터 발행
        for (int i = 1; i <= 5; i++) {
            publisher.submit(i);
        }
        publisher.close();
    }
}
```

### 1.3.8 주요 구현체

| 구현체 | 개발 주체 | 특징 |
|--------|----------|------|
| **Project Reactor** | Pivotal (VMware) | Spring WebFlux의 기본 구현체. Mono/Flux 제공 |
| **RxJava** | Netflix | 가장 오래된 리액티브 라이브러리. Observable/Flowable 제공 |
| **Akka Streams** | Lightbend | Akka 액터 모델 기반. Source/Flow/Sink 제공 |
| **Mutiny** | Red Hat | Quarkus 프레임워크의 기본 구현체. Uni/Multi 제공 |

이 책에서는 Spring WebFlux의 기본 구현체인 **Project Reactor**를 사용한다.

---

## 1.4 배압(Backpressure)의 개념

### 1.4.1 배압이 필요한 이유

배압은 데이터 소비자가 생산자에게 "속도를 늦춰 달라"고 요청하는 메커니즘이다.

일상적인 비유로 설명하면, 컨베이어 벨트 위의 물건을 포장하는 작업자를 생각해 보자. 벨트가 너무 빨리 움직이면 물건이 쌓이고 바닥에 떨어진다. 작업자가 "속도를 줄여 주세요"라고 요청할 수 있어야 한다. 이것이 배압이다.

소프트웨어 시스템에서 배압이 없으면 다음 문제가 발생한다.

- **메모리 초과(OOM)**: 처리하지 못한 데이터가 버퍼에 무한히 쌓인다.
- **응답 지연**: 과부하된 컴포넌트의 처리 속도가 급격히 저하된다.
- **시스템 장애**: 한 컴포넌트의 과부하가 전체 시스템으로 전파된다.

### 1.4.2 배압 전략

Project Reactor는 다양한 배압 전략을 제공한다.

| 전략 | 설명 | 사용 시나리오 |
|------|------|-------------|
| **BUFFER** | 소비되지 못한 항목을 버퍼에 저장 | 데이터 손실이 허용되지 않을 때 |
| **DROP** | 소비자가 준비되지 않으면 새 항목을 버림 | 최신 데이터만 중요할 때 |
| **LATEST** | 가장 최근 항목만 유지하고 나머지 버림 | 센서 데이터 등 최신 값만 필요할 때 |
| **ERROR** | 소비자가 감당할 수 없으면 오류 발생 | 엄격한 흐름 제어가 필요할 때 |

### 1.4.3 코드로 보는 배압 처리

```java
import reactor.core.publisher.Flux;
import reactor.core.scheduler.Schedulers;
import java.time.Duration;

public class BackpressureExample {

    public static void main(String[] args) throws InterruptedException {

        // 빠른 생산자: 1ms 간격으로 데이터 발행
        Flux<Long> fastProducer = Flux.interval(Duration.ofMillis(1));

        // onBackpressureDrop: 소비자가 처리 못하면 버림
        fastProducer
            .onBackpressureDrop(dropped ->
                System.out.println("버려진 항목: " + dropped))
            .publishOn(Schedulers.boundedElastic())
            .subscribe(item -> {
                // 느린 소비자: 100ms 걸림
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                System.out.println("처리: " + item);
            });

        Thread.sleep(5000);
    }
}
```

request를 사용하여 명시적으로 배압을 제어하는 예시도 살펴보자.

```java
import reactor.core.publisher.Flux;
import org.reactivestreams.Subscription;
import reactor.core.publisher.BaseSubscriber;

public class ExplicitBackpressure {

    public static void main(String[] args) {

        Flux<Integer> numbers = Flux.range(1, 100);

        numbers.subscribe(new BaseSubscriber<>() {
            private int count = 0;
            private final int BATCH_SIZE = 10;

            @Override
            protected void hookOnSubscribe(Subscription subscription) {
                // 처음에 10개만 요청
                request(BATCH_SIZE);
            }

            @Override
            protected void hookOnNext(Integer value) {
                System.out.println("처리: " + value);
                count++;
                if (count % BATCH_SIZE == 0) {
                    System.out.println("--- 배치 완료, 다음 " + BATCH_SIZE + "개 요청 ---");
                    request(BATCH_SIZE);
                }
            }

            @Override
            protected void hookOnComplete() {
                System.out.println("모든 데이터 처리 완료");
            }
        });
    }
}
```

위 코드에서 구독자는 한 번에 10개씩만 요청하여 처리 속도를 제어한다. `request(BATCH_SIZE)` 호출이 배압의 핵심이다.

### 1.4.4 Reactor의 배압 연산자 요약

```java
// 1. onBackpressureBuffer: 버퍼에 저장 (크기 제한 가능)
flux.onBackpressureBuffer(100)              // 최대 100개 버퍼
    .subscribe(...);

// 2. onBackpressureDrop: 초과분 버림
flux.onBackpressureDrop()
    .subscribe(...);

// 3. onBackpressureLatest: 최신 항목만 유지
flux.onBackpressureLatest()
    .subscribe(...);

// 4. onBackpressureError: 오류 발생
flux.onBackpressureError()
    .subscribe(...);

// 5. limitRate: 프리페치 크기 제한
flux.limitRate(50)                          // 한 번에 50개씩만 요청
    .subscribe(...);
```

---

## 1.5 왜 리액티브가 필요한가?

### 1.5.1 Thread-per-request 모델의 한계

전통적인 서블릿 기반 웹 애플리케이션은 하나의 HTTP 요청마다 하나의 스레드를 할당하는 thread-per-request 모델을 사용한다.

```
[요청 1] → [스레드 1] → DB 호출 (200ms 대기) → 응답
[요청 2] → [스레드 2] → API 호출 (300ms 대기) → 응답
[요청 3] → [스레드 3] → DB 호출 (200ms 대기) → 응답
  ...
[요청 201] → 스레드 풀 고갈 → 대기열에서 대기
```

이 모델의 문제점은 명확하다.

- **스레드 풀 크기 제한**: Tomcat 기본 스레드 풀은 200개다. 201번째 요청은 대기해야 한다.
- **I/O 대기 중 자원 낭비**: 스레드가 DB 응답을 기다리는 동안 아무 일도 하지 않지만 메모리(약 1MB/스레드)를 점유한다.
- **컨텍스트 스위칭 비용**: 스레드 수가 늘어나면 OS의 컨텍스트 스위칭 비용이 증가한다.

### 1.5.2 리소스 효율성 비교

같은 하드웨어에서 10,000개의 동시 연결을 처리하는 시나리오를 비교해 보자.

**thread-per-request 모델 (Spring MVC + Tomcat)**

```
필요 스레드: 10,000개
스레드당 메모리: ~1MB
총 메모리: ~10GB (스레드 스택만)
실제 CPU 작업: 약 5% (나머지 95%는 I/O 대기)
```

**이벤트 루프 모델 (Spring WebFlux + Netty)**

```
필요 스레드: CPU 코어 수 (예: 8개)
스레드당 메모리: ~1MB
총 메모리: ~8MB (스레드 스택)
실제 CPU 작업: 동일하지만 I/O 대기 없이 다른 요청 처리
```

```java
// Spring MVC: 블로킹 방식
@RestController
public class UserController {

    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        // 스레드가 DB 응답을 기다리며 차단됨
        User user = userRepository.findById(id);

        // 스레드가 외부 API 응답을 기다리며 차단됨
        UserProfile profile = profileClient.getProfile(user.getProfileId());

        user.setProfile(profile);
        return user;
    }
}

// Spring WebFlux: 논블로킹 방식
@RestController
public class UserController {

    @GetMapping("/users/{id}")
    public Mono<User> getUser(@PathVariable Long id) {
        // 스레드가 차단되지 않음 - 콜백으로 연결
        return userRepository.findById(id)
            .flatMap(user ->
                profileClient.getProfile(user.getProfileId())
                    .map(profile -> {
                        user.setProfile(profile);
                        return user;
                    })
            );
    }
}
```

### 1.5.3 리액티브가 적합한 유즈케이스

리액티브가 모든 상황에서 최선의 선택은 아니다. 다음은 리액티브가 적합한 경우와 그렇지 않은 경우이다.

**리액티브가 적합한 경우**

- **높은 동시 연결 수**: 채팅, 알림, 실시간 대시보드 등 수천~수만 개의 동시 연결이 필요한 경우
- **I/O 집약적 워크로드**: 다수의 외부 API 호출, 데이터베이스 쿼리가 주를 이루는 경우
- **스트리밍 데이터**: IoT 센서 데이터, 실시간 로그 처리, 주식 시세 등 연속적인 데이터 흐름
- **마이크로서비스 간 통신**: 서비스 간 비동기 메시지 교환이 빈번한 경우
- **Server-Sent Events / WebSocket**: 서버에서 클라이언트로 실시간 데이터를 푸시하는 경우

**리액티브가 적합하지 않은 경우**

- **CPU 집약적 작업**: 이미지 처리, 복잡한 수학 연산 등 CPU를 오래 사용하는 작업
- **단순한 CRUD 애플리케이션**: 동시 사용자가 적고 복잡한 비동기 흐름이 불필요한 경우
- **팀의 경험 부족**: 리액티브 프로그래밍의 학습 곡선과 디버깅 난이도를 감당하기 어려운 경우

### 1.5.4 성능 벤치마크 참고

아래는 동시 연결 수에 따른 처리량 변화를 개념적으로 나타낸 것이다.

```
처리량(req/s)
  ^
  |
  |         ╱ WebFlux (논블로킹)
  |       ╱
  |     ╱───────────────────
  |   ╱
  | ╱   ╱── MVC (블로킹)
  |╱  ╱
  | ╱
  |╱──────────
  +────────────────────────> 동시 연결 수
     100  500 1000  5000 10000
```

동시 연결 수가 적을 때는 Spring MVC와 WebFlux의 성능 차이가 거의 없다. 오히려 MVC가 약간 빠를 수도 있다. 하지만 동시 연결 수가 증가하면 MVC의 처리량은 스레드 풀 크기에 의해 제한되는 반면, WebFlux는 적은 스레드로도 높은 처리량을 유지한다.

---

## 정리

이 장에서 다룬 핵심 내용을 정리하면 다음과 같다.

| 주제 | 핵심 내용 |
|------|----------|
| 리액티브 프로그래밍 | 데이터 스트림과 변화의 전파에 초점을 맞춘 비동기 프로그래밍 패러다임 |
| 리액티브 선언문 | 응답성, 탄력성, 유연성, 메시지 기반의 네 가지 속성 |
| 명령형 vs 리액티브 | 명령형은 "어떻게", 리액티브는 "무엇을" 선언. 각각의 장단점이 존재 |
| 리액티브 스트림 | Publisher, Subscriber, Subscription, Processor 4개 인터페이스로 구성된 표준 |
| 배압 | 소비자가 생산자에게 속도 조절을 요청하는 메커니즘 |
| 리액티브의 필요성 | I/O 집약적이고 높은 동시성이 요구되는 시스템에 적합 |

다음 장에서는 이 개념들의 구체적인 구현체인 **Project Reactor**를 깊이 살펴본다. Mono와 Flux의 사용법, 주요 연산자, 그리고 실전 패턴을 다룬다.
