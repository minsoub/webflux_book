# Chapter 6. 어노테이션 기반 REST API 구현

Chapter 5에서 프로젝트 구조와 개발 환경을 갖추었다. 이번 장에서는 본격적으로 도메인 모델을 정의하고, 리포지토리, 서비스, 컨트롤러 계층을 순서대로 구축하여 완전한 CRUD REST API를 완성한다. 모든 계층에서 `Mono`와 `Flux`를 반환하며, 요청부터 응답, 데이터베이스 접근까지 논블로킹으로 동작하는 리액티브 파이프라인을 구성한다.

---

## 6.1 도메인 모델(Document) 정의

### 6.1.1 주요 어노테이션 정리

Spring Data MongoDB는 Java 객체를 MongoDB 도큐먼트에 매핑하기 위한 다양한 어노테이션을 제공한다.

| 어노테이션 | 설명 |
|-----------|------|
| `@Document` | 클래스를 MongoDB 컬렉션에 매핑한다. `collection` 속성으로 컬렉션 이름을 지정한다. |
| `@Id` | 필드를 MongoDB의 `_id`에 매핑한다. `String` 타입이면 자동으로 `ObjectId`가 생성된다. |
| `@Field` | 필드명을 MongoDB 도큐먼트의 키 이름과 다르게 매핑할 때 사용한다. |
| `@Indexed` | 해당 필드에 인덱스를 생성한다. `unique`, `direction` 등의 속성을 지원한다. |
| `@CreatedDate` | 도큐먼트 최초 저장 시 자동으로 현재 시각을 기록한다. |
| `@LastModifiedDate` | 도큐먼트 수정 시 자동으로 현재 시각을 갱신한다. |
| `@Version` | 낙관적 잠금(Optimistic Locking)을 위한 버전 필드를 지정한다. |
| `@Transient` | 해당 필드를 MongoDB에 저장하지 않는다. |

### 6.1.2 User 도메인 모델

```java
package com.example.webfluxdemo.domain;

import lombok.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.annotation.Version;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.mapping.Field;

import java.time.LocalDateTime;

@Document(collection = "users")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Builder
@ToString
public class User {

    @Id
    private String id;

    @Field("name")
    private String name;

    @Indexed(unique = true)
    private String email;

    private String password;

    @Builder.Default
    private String role = "USER";

    @CreatedDate
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;

    @Version
    private Long version;

    public void updateProfile(String name, String email) {
        this.name = name;
        this.email = email;
    }

    public void changePassword(String password) {
        this.password = password;
    }
}
```

`@Version` 필드를 추가하면 동시 수정 시 `OptimisticLockingFailureException`이 발생하여 데이터 정합성을 보호한다.

### 6.1.3 Post 도메인 모델

```java
package com.example.webfluxdemo.domain;

import lombok.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.mongodb.core.index.CompoundIndex;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Document(collection = "posts")
@CompoundIndex(name = "author_created", def = "{'authorId': 1, 'createdAt': -1}")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Builder
@ToString
public class Post {

    @Id
    private String id;

    private String title;

    private String content;

    @Indexed
    private String authorId;

    @Builder.Default
    private List<String> tags = new ArrayList<>();

    @Builder.Default
    private int viewCount = 0;

    @CreatedDate
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;

    public void update(String title, String content, List<String> tags) {
        this.title = title;
        this.content = content;
        this.tags = tags != null ? tags : this.tags;
    }

    public void incrementViewCount() {
        this.viewCount++;
    }
}
```

`@CompoundIndex`로 `authorId` 오름차순 + `createdAt` 내림차순 복합 인덱스를 생성하여, 특정 작성자의 최신 게시글 조회 쿼리를 최적화한다.

### 6.1.4 Auditing 설정

`@CreatedDate`, `@LastModifiedDate`가 동작하려면 Auditing 기능을 활성화해야 한다.

```java
package com.example.webfluxdemo.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.mongodb.config.EnableReactiveMongoAuditing;

@Configuration
@EnableReactiveMongoAuditing
public class MongoConfig {
}
```

리액티브 환경에서는 반드시 `EnableReactiveMongoAuditing`을 사용해야 하며, 일반 `@EnableMongoAuditing`은 동작하지 않는다. 자동 인덱스 생성을 활성화하려면 `application.yml`에 다음 설정을 추가한다.

```yaml
spring:
  data:
    mongodb:
      uri: mongodb://admin:secret1234@localhost:27017/webflux_demo?authSource=admin
      auto-index-creation: true
```

> **주의**: `auto-index-creation`은 개발 환경에서는 편리하지만, 운영 환경에서는 수동 인덱스 관리를 권장한다. 대규모 컬렉션에서 인덱스 자동 생성은 서비스 시작 시간을 지연시킬 수 있다.

---

## 6.2 ReactiveMongoRepository 활용

### 6.2.1 UserRepository 정의

```java
public interface UserRepository extends ReactiveMongoRepository<User, String> {

    // 메서드 이름 기반 쿼리 자동 생성
    Mono<User> findByEmail(String email);

    Flux<User> findByName(String name);

    Flux<User> findByRole(String role);

    Mono<Boolean> existsByEmail(String email);

    // @Query: MongoDB JSON 쿼리 직접 작성
    @Query("{ 'name': { $regex: ?0, $options: 'i' } }")
    Flux<User> searchByName(String keyword);

    // 특정 필드만 조회 (fields 속성)
    @Query(value = "{ 'role': ?0 }", fields = "{ 'name': 1, 'email': 1 }")
    Flux<User> findNameAndEmailByRole(String role);
}
```

`ReactiveMongoRepository<T, ID>`는 `ReactiveCrudRepository`를 확장하며, 다음 메서드를 기본으로 제공한다.

| 메서드 | 반환 타입 | 설명 |
|--------|----------|------|
| `save(T entity)` | `Mono<T>` | 삽입 또는 수정 |
| `findById(ID id)` | `Mono<T>` | ID로 조회 |
| `findAll()` | `Flux<T>` | 전체 조회 |
| `deleteById(ID id)` | `Mono<Void>` | ID로 삭제 |
| `count()` | `Mono<Long>` | 전체 개수 |
| `existsById(ID id)` | `Mono<Boolean>` | 존재 여부 확인 |

### 6.2.2 PostRepository 정의

```java
public interface PostRepository extends ReactiveMongoRepository<Post, String> {

    Flux<Post> findByAuthorId(String authorId);

    Flux<Post> findByTagsContaining(String tag);

    Flux<Post> findByTitleContainingIgnoreCase(String keyword);

    // 페이징: Pageable 파라미터를 전달
    Flux<Post> findByAuthorId(String authorId, Pageable pageable);

    Mono<Long> countByAuthorId(String authorId);

    // 복잡한 쿼리: 제목 또는 내용에 키워드가 포함된 게시글 검색
    @Query("{ $or: [ " +
           "  { 'title': { $regex: ?0, $options: 'i' } }, " +
           "  { 'content': { $regex: ?0, $options: 'i' } } " +
           "] }")
    Flux<Post> searchByKeyword(String keyword);

    // 정렬: 메서드 이름에 OrderBy 포함
    Flux<Post> findByAuthorIdOrderByCreatedAtDesc(String authorId);
}
```

### 6.2.3 쿼리 메서드 이름 규칙

Spring Data는 메서드 이름을 파싱하여 쿼리를 자동 생성한다. 주요 키워드:

| 키워드 | 예시 | 생성 쿼리 |
|--------|-----|-----------|
| `Is` / `Equals` | `findByName(String)` | `{ 'name': ?0 }` |
| `Between` | `findByAgeBetween(int, int)` | `{ 'age': { $gte: ?0, $lte: ?1 } }` |
| `Containing` | `findByTitleContaining(String)` | `{ 'title': { $regex: ?0 } }` |
| `In` | `findByRoleIn(List)` | `{ 'role': { $in: ?0 } }` |
| `OrderBy` | `findByAuthorIdOrderByCreatedAtDesc` | 정렬 추가 |
| `IgnoreCase` | `findByNameIgnoreCase(String)` | 대소문자 무시 |

### 6.2.4 페이징 처리

리액티브 환경에서의 페이징은 `Pageable`을 파라미터로 전달하고, 별도로 총 개수를 조회한다.

```java
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;

// 0번째 페이지, 10개씩, 생성일 내림차순
Pageable pageable = PageRequest.of(0, 10, Sort.by(Sort.Direction.DESC, "createdAt"));

Flux<Post> posts = postRepository.findByAuthorId("user123", pageable);
Mono<Long> totalCount = postRepository.countByAuthorId("user123");
```

> **참고**: Spring Data Reactive에는 `Page<T>` 반환 타입이 없다. `Page`는 전체 개수를 동기적으로 계산해야 하므로 리액티브 모델과 맞지 않기 때문이다. 대신 `Flux<T>`와 `Mono<Long>`을 조합하여 페이징 정보를 구성한다.

---

## 6.3 서비스 계층 구현

### 6.3.1 커스텀 예외 정의

먼저 서비스 계층에서 사용할 커스텀 예외를 정의한다.

```java
@Getter
public class ResourceNotFoundException extends RuntimeException {
    private final String resourceName;
    private final String fieldName;
    private final String fieldValue;

    public ResourceNotFoundException(String resourceName, String fieldName,
                                     String fieldValue) {
        super(String.format("%s not found with %s: '%s'",
                resourceName, fieldName, fieldValue));
        this.resourceName = resourceName;
        this.fieldName = fieldName;
        this.fieldValue = fieldValue;
    }
}

public class DuplicateResourceException extends RuntimeException {
    public DuplicateResourceException(String message) { super(message); }
}
```

### 6.3.2 UserService 구현체

인터페이스에서 `Mono<User> createUser(User)`, `Mono<User> getUserById(String)`, `Flux<User> getAllUsers()` 등의 CRUD 메서드를 정의하고, 구현체를 작성한다.

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;

    @Override
    public Mono<User> createUser(User user) {
        return userRepository.existsByEmail(user.getEmail())
                .flatMap(exists -> {
                    if (exists) {
                        return Mono.error(new DuplicateResourceException(
                                "Email already exists: " + user.getEmail()));
                    }
                    return userRepository.save(user);
                })
                .doOnSuccess(saved -> log.info("User created: {}", saved.getId()));
    }

    @Override
    public Mono<User> getUserById(String id) {
        return userRepository.findById(id)
                .switchIfEmpty(Mono.error(
                        new ResourceNotFoundException("User", "id", id)));
    }

    @Override
    public Flux<User> getAllUsers() { return userRepository.findAll(); }

    @Override
    public Flux<User> searchUsers(String keyword) {
        return userRepository.searchByName(keyword);
    }

    @Override
    public Mono<User> updateUser(String id, User user) {
        return userRepository.findById(id)
                .switchIfEmpty(Mono.error(
                        new ResourceNotFoundException("User", "id", id)))
                .flatMap(existingUser -> {
                    existingUser.updateProfile(user.getName(), user.getEmail());
                    return userRepository.save(existingUser);
                })
                .doOnSuccess(updated -> log.info("User updated: {}", updated.getId()));
    }

    @Override
    public Mono<Void> deleteUser(String id) {
        return userRepository.findById(id)
                .switchIfEmpty(Mono.error(
                        new ResourceNotFoundException("User", "id", id)))
                .flatMap(userRepository::delete)
                .doOnSuccess(v -> log.info("User deleted: {}", id));
    }
}
```

핵심 패턴: `switchIfEmpty`는 리액티브에서 `null` 검사를 대체하고, `flatMap`은 비동기 연산을 체이닝하며, `doOnSuccess`는 로깅 등 사이드 이펙트를 수행한다.

### 6.3.3 PostService 구현체

`PostService`도 동일한 패턴을 따른다. 핵심 메서드만 발췌한다.

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class PostService {

    private final PostRepository postRepository;

    public Mono<Post> createPost(Post post) {
        return postRepository.save(post)
                .doOnSuccess(saved -> log.info("Post created: {}", saved.getId()));
    }

    public Mono<Post> getPostById(String id) {
        return postRepository.findById(id)
                .switchIfEmpty(Mono.error(
                        new ResourceNotFoundException("Post", "id", id)));
    }

    public Flux<Post> getPostsByAuthor(String authorId, int page, int size) {
        PageRequest pageable = PageRequest.of(page, size,
                Sort.by(Sort.Direction.DESC, "createdAt"));
        return postRepository.findByAuthorId(authorId, pageable);
    }

    public Mono<Long> countPostsByAuthor(String authorId) { return postRepository.countByAuthorId(authorId); }

    public Mono<Post> updatePost(String id, Post post) {
        return postRepository.findById(id)
                .switchIfEmpty(Mono.error(
                        new ResourceNotFoundException("Post", "id", id)))
                .flatMap(existing -> {
                    existing.update(post.getTitle(), post.getContent(), post.getTags());
                    return postRepository.save(existing);
                });
    }

    public Mono<Void> deletePost(String id) {
        return postRepository.findById(id)
                .switchIfEmpty(Mono.error(
                        new ResourceNotFoundException("Post", "id", id)))
                .flatMap(postRepository::delete);
    }
}
```

---

## 6.4 @RestController로 CRUD API 만들기

### 6.4.1 UserController

```java
@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono<UserResponse> createUser(@RequestBody CreateUserRequest request) {
        User user = User.builder()
                .name(request.name())
                .email(request.email())
                .password(request.password())
                .build();
        return userService.createUser(user)
                .map(UserResponse::from);
    }

    @GetMapping("/{id}")
    public Mono<ResponseEntity<UserResponse>> getUserById(@PathVariable String id) {
        return userService.getUserById(id)
                .map(UserResponse::from)
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping
    public Flux<UserResponse> getAllUsers() {
        return userService.getAllUsers()
                .map(UserResponse::from);
    }

    @GetMapping("/search")
    public Flux<UserResponse> searchUsers(@RequestParam String keyword) {
        return userService.searchUsers(keyword)
                .map(UserResponse::from);
    }

    @PutMapping("/{id}")
    public Mono<ResponseEntity<UserResponse>> updateUser(
            @PathVariable String id,
            @RequestBody UpdateUserRequest request) {
        User user = User.builder()
                .name(request.name())
                .email(request.email())
                .build();
        return userService.updateUser(id, user)
                .map(UserResponse::from)
                .map(ResponseEntity::ok);
    }

    @DeleteMapping("/{id}")
    public Mono<ResponseEntity<Void>> deleteUser(@PathVariable String id) {
        return userService.deleteUser(id)
                .then(Mono.just(ResponseEntity.noContent().<Void>build()));
    }
}
```

컨트롤러의 핵심 패턴은 다음과 같다.

- **`@ResponseStatus`**: `ResponseEntity` 없이 상태 코드를 간편하게 지정한다.
- **`ResponseEntity`를 `Mono`로 감싸기**: `map(ResponseEntity::ok)`로 200 응답, `defaultIfEmpty(ResponseEntity.notFound().build())`로 404를 반환한다.
- **`then()`**: `Mono<Void>` 완료 후 새로운 값을 발행한다. 삭제 후 204 응답에 활용한다.

### 6.4.2 PostController

`PostController`는 `UserController`와 동일한 패턴을 따른다. 페이징 조회 부분만 발췌한다.

```java
@RestController
@RequestMapping("/api/posts")
@RequiredArgsConstructor
public class PostController {

    private final PostService postService;

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono<PostResponse> createPost(@RequestBody CreatePostRequest request) {
        Post post = Post.builder()
                .title(request.title())
                .content(request.content())
                .authorId(request.authorId())
                .tags(request.tags())
                .build();
        return postService.createPost(post).map(PostResponse::from);
    }

    @GetMapping("/{id}")
    public Mono<ResponseEntity<PostResponse>> getPostById(@PathVariable String id) {
        return postService.getPostById(id)
                .map(PostResponse::from)
                .map(ResponseEntity::ok);
    }

    @GetMapping("/author/{authorId}")
    public Flux<PostResponse> getPostsByAuthor(
            @PathVariable String authorId,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        return postService.getPostsByAuthor(authorId, page, size)
                .map(PostResponse::from);
    }

    @PutMapping("/{id}")
    public Mono<ResponseEntity<PostResponse>> updatePost(
            @PathVariable String id, @RequestBody UpdatePostRequest request) {
        Post post = Post.builder()
                .title(request.title()).content(request.content())
                .tags(request.tags()).build();
        return postService.updatePost(id, post)
                .map(PostResponse::from).map(ResponseEntity::ok);
    }

    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public Mono<Void> deletePost(@PathVariable String id) {
        return postService.deletePost(id);
    }
}
```

### 6.4.3 완성된 API 엔드포인트 정리

| 메서드 | URI | 상태 코드 |
|--------|-----|----------|
| `POST` | `/api/users` | 201 |
| `GET` | `/api/users`, `/api/users/{id}`, `/api/users/search?keyword=` | 200 |
| `PUT` | `/api/users/{id}` | 200 |
| `DELETE` | `/api/users/{id}` | 204 |
| `POST` | `/api/posts` | 201 |
| `GET` | `/api/posts`, `/api/posts/{id}`, `/api/posts/author/{authorId}?page=&size=` | 200 |
| `PUT` | `/api/posts/{id}` | 200 |
| `DELETE` | `/api/posts/{id}` | 204 |

---

## 6.5 요청/응답 DTO 설계

### 6.5.1 Java record를 활용한 DTO

Java 16부터 도입된 `record` 클래스는 불변 데이터 캐리어에 적합하다. 생성자, `equals()`, `hashCode()`, `toString()`을 자동으로 생성하므로 DTO로 사용하기에 이상적이다.

**User 관련 DTO**

```java
public record CreateUserRequest(String name, String email, String password) {}

public record UpdateUserRequest(String name, String email) {}

public record UserResponse(
        String id, String name, String email, String role,
        LocalDateTime createdAt, LocalDateTime updatedAt
) {
    // 도메인 -> DTO 변환 정적 팩토리 메서드
    public static UserResponse from(User user) {
        return new UserResponse(user.getId(), user.getName(), user.getEmail(),
                user.getRole(), user.getCreatedAt(), user.getUpdatedAt());
    }
}
```

**Post 관련 DTO**

Post DTO도 동일한 패턴이다. `PostResponse`의 `from()` 정적 팩토리 메서드만 발췌한다.

```java
public record CreatePostRequest(String title, String content,
                                 String authorId, List<String> tags) {}

public record UpdatePostRequest(String title, String content, List<String> tags) {}

public record PostResponse(
        String id, String title, String content, String authorId,
        List<String> tags, int viewCount,
        LocalDateTime createdAt, LocalDateTime updatedAt
) {
    public static PostResponse from(Post post) {
        return new PostResponse(
                post.getId(), post.getTitle(), post.getContent(),
                post.getAuthorId(), post.getTags(), post.getViewCount(),
                post.getCreatedAt(), post.getUpdatedAt());
    }
}
```

### 6.5.2 DTO 사용의 이점

도메인 모델을 직접 API 응답으로 노출하지 않고 DTO를 사용하는 이유: (1) `password`, `version` 등 내부 필드 노출 방지(**보안**), (2) 도메인 변경이 API 계약에 영향을 주지 않음(**안정성**), (3) 용도별 다른 DTO 제공 가능(**유연성**), (4) Bean Validation 적용 가능(**검증**, Chapter 9에서 상세히 다룬다).

### 6.5.3 페이징 응답 DTO

페이징 결과를 감싸는 범용 DTO를 만들면 클라이언트에 페이징 메타 정보를 함께 전달할 수 있다.

```java
package com.example.webfluxdemo.dto;

import java.util.List;

public record PageResponse<T>(
        List<T> content,
        int page,
        int size,
        long totalElements,
        int totalPages
) {
    public static <T> PageResponse<T> of(List<T> content, int page,
                                          int size, long totalElements) {
        int totalPages = (int) Math.ceil((double) totalElements / size);
        return new PageResponse<>(content, page, size, totalElements, totalPages);
    }
}
```

컨트롤러에서 페이징 응답을 구성하는 예시:

```java
@GetMapping("/author/{authorId}")
public Mono<PageResponse<PostResponse>> getPostsByAuthorPaged(
        @PathVariable String authorId,
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "10") int size) {

    Mono<List<PostResponse>> contentMono = postService
            .getPostsByAuthor(authorId, page, size)
            .map(PostResponse::from)
            .collectList();

    Mono<Long> countMono = postService.countPostsByAuthor(authorId);

    return Mono.zip(contentMono, countMono)
            .map(tuple -> PageResponse.of(tuple.getT1(), page, size, tuple.getT2()));
}
```

`Mono.zip`으로 콘텐츠 조회와 총 개수 조회를 **동시에** 실행하고, 두 결과를 `PageResponse`로 조합한다. 리액티브 병렬 처리의 관용적 패턴이다.

---

## 6.6 API 테스트

애플리케이션을 실행한 후, 다양한 도구로 API를 호출하여 동작을 검증한다.

```bash
# 애플리케이션 실행
./gradlew bootRun
```

### 6.6.1 cURL 테스트

**사용자 생성 (POST)**

```bash
curl -X POST http://localhost:8080/api/users \
  -H "Content-Type: application/json" \
  -d '{
    "name": "홍길동",
    "email": "hong@example.com",
    "password": "securePass123"
  }'
```

응답 예시:

```json
{
  "id": "65f1a2b3c4d5e6f7a8b9c0d1",
  "name": "홍길동",
  "email": "hong@example.com",
  "role": "USER",
  "createdAt": "2025-06-15T10:30:00",
  "updatedAt": "2025-06-15T10:30:00"
}
```

**사용자 조회 (GET)**

```bash
# 전체 조회
curl http://localhost:8080/api/users

# 단건 조회
curl http://localhost:8080/api/users/65f1a2b3c4d5e6f7a8b9c0d1
```

**수정 / 삭제 / 게시글**

```bash
# 사용자 수정
curl -X PUT http://localhost:8080/api/users/65f1a2b3c4d5e6f7a8b9c0d1 \
  -H "Content-Type: application/json" \
  -d '{ "name": "홍길동(수정)", "email": "hong-updated@example.com" }'

# 사용자 삭제
curl -X DELETE http://localhost:8080/api/users/65f1a2b3c4d5e6f7a8b9c0d1 -v

# 게시글 생성
curl -X POST http://localhost:8080/api/posts \
  -H "Content-Type: application/json" \
  -d '{ "title": "WebFlux 첫 글", "content": "리액티브 API 구현",
        "authorId": "65f1a2b3c4d5e6f7a8b9c0d1", "tags": ["spring","webflux"] }'

# 게시글 검색
curl "http://localhost:8080/api/posts/search?keyword=WebFlux"

# 작성자별 페이징 조회
curl "http://localhost:8080/api/posts/author/65f1a2b3c4d5e6f7a8b9c0d1?page=0&size=5"
```

### 6.6.2 HTTPie 테스트

HTTPie는 cURL보다 직관적인 문법을 제공하는 HTTP 클라이언트다.

```bash
# 사용자 생성 — JSON 필드를 key=value 형식으로 전달
http POST localhost:8080/api/users \
  name="김철수" email="kim@example.com" password="pass1234"

# 조회
http localhost:8080/api/users

# 게시글 생성 — JSON 배열은 := 연산자로 전달
http POST localhost:8080/api/posts \
  title="HTTPie 테스트" content="HTTPie로 API를 테스트합니다." \
  authorId="65f1a2b3c4d5e6f7a8b9c0d1" tags:='["test", "httpie"]'
```

> **팁**: HTTPie에서 `=`는 문자열, `:=`는 JSON 리터럴(숫자, 배열, 객체, boolean)을 전달한다.

### 6.6.3 IntelliJ HTTP Client

IntelliJ IDEA에 내장된 HTTP Client를 사용하면 `.http` 파일로 요청을 관리할 수 있다. 프로젝트 루트에 `.http` 파일을 작성한다.

```http
### 사용자 생성
POST http://localhost:8080/api/users
Content-Type: application/json

{
  "name": "이영희",
  "email": "lee@example.com",
  "password": "myPassword456"
}

### 전체 사용자 조회
GET http://localhost:8080/api/users

### 사용자 수정
PUT http://localhost:8080/api/users/{{userId}}
Content-Type: application/json

{
  "name": "이영희(수정)",
  "email": "lee-updated@example.com"
}

### 사용자 삭제
DELETE http://localhost:8080/api/users/{{userId}}
```

`{{userId}}`와 같은 변수는 `http-client.env.json` 파일에서 환경별로 관리한다. `.http` 파일을 Git으로 관리하면 팀원과 API 테스트를 공유할 수 있다는 것이 큰 장점이다.

---

## 6장 정리

이번 장에서 다룬 핵심 내용을 정리한다.

| 주제 | 핵심 요약 |
|------|----------|
| 도메인 모델 | `@Document`, `@Id`, `@Indexed`, `@CompoundIndex`로 도큐먼트 매핑. Auditing으로 생성/수정 시각 자동 관리 |
| 리포지토리 | `ReactiveMongoRepository`로 기본 CRUD 자동 제공. 쿼리 메서드 이름 규칙, `@Query`, 페이징 지원 |
| 서비스 계층 | `switchIfEmpty`로 존재 여부 검증, `flatMap`으로 비동기 체이닝, 커스텀 예외로 의미 있는 에러 전달 |
| 컨트롤러 | `@RestController`로 CRUD 엔드포인트 구성. `ResponseEntity`로 상태 코드 제어, `Mono`/`Flux` 반환 |
| DTO 설계 | Java `record`로 불변 DTO 정의. 도메인과 API 계약을 분리하여 보안과 유지보수성 확보 |
| API 테스트 | cURL, HTTPie, IntelliJ HTTP Client로 엔드포인트 검증 |

다음 Chapter 7에서는 어노테이션 방식 대신 **함수형 엔드포인트(Router Functions)** 를 사용하여 동일한 API를 구현하고, 두 방식의 차이점과 장단점을 비교한다.
