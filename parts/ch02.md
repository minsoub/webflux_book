# Chapter 2. Spring WebFlux 개요

Spring WebFlux는 Spring Framework 5에서 도입된 리액티브 웹 프레임워크다. 기존 Spring MVC가 서블릿 기반의 동기/블로킹 모델 위에 구축되었다면, WebFlux는 논블로킹 I/O와 리액티브 스트림을 기반으로 설계되었다. 이 장에서는 WebFlux의 전체적인 아키텍처, 내부 동작 원리, 그리고 언제 WebFlux를 선택해야 하는지에 대해 살펴본다.

---

## 2.1 Spring MVC와 Spring WebFlux 비교

### 2.1.1 아키텍처 차이: 서블릿 스택 vs 리액티브 스택

Spring MVC는 Java Servlet API 위에 구축된다. 클라이언트 요청이 들어오면 서블릿 컨테이너(Tomcat, Jetty 등)가 스레드 풀에서 하나의 스레드를 할당하고, 해당 스레드가 요청의 시작부터 끝까지 전체 처리를 담당한다. 이를 **thread-per-request** 모델이라 한다.

```
[Spring MVC 스택]
┌─────────────────────┐
│   Servlet Container  │  (Tomcat, Jetty)
│   ┌───────────────┐  │
│   │ DispatcherServlet │
│   │   ┌─────────┐ │  │
│   │   │ Handler  │ │  │
│   │   │ Mapping  │ │  │
│   │   └─────────┘ │  │
│   │   ┌─────────┐ │  │
│   │   │Controller│ │  │
│   │   └─────────┘ │  │
│   └───────────────┘  │
│   Servlet API        │
│   (Blocking I/O)     │
└─────────────────────┘
```

반면 Spring WebFlux는 리액티브 스택 위에 구축된다. 서블릿 API에 의존하지 않으며, 기본적으로 Netty를 런타임으로 사용한다. 소수의 이벤트 루프 스레드가 다수의 요청을 논블로킹 방식으로 처리한다.

```
[Spring WebFlux 스택]
┌─────────────────────┐
│   Reactive Runtime   │  (Netty, Undertow)
│   ┌───────────────┐  │
│   │DispatcherHandler│
│   │   ┌─────────┐ │  │
│   │   │ Handler  │ │  │
│   │   │ Mapping  │ │  │
│   │   └─────────┘ │  │
│   │   ┌─────────┐ │  │
│   │   │Controller│ │  │
│   │   │   or     │ │  │
│   │   │RouterFunc│ │  │
│   │   └─────────┘ │  │
│   └───────────────┘  │
│   Reactive Streams   │
│   (Non-Blocking I/O) │
└─────────────────────┘
```

### 2.1.2 스레드 모델 차이

**Spring MVC**의 스레드 모델은 직관적이다. 동시에 200개의 요청을 처리하려면 최소 200개의 스레드가 필요하다. 각 스레드는 데이터베이스 응답을 기다리는 동안에도 점유된 상태로 남는다.

```
[Spring MVC - Thread-per-Request]

요청 A ──▶ Thread-1: [수신]──[처리]──[DB 대기...]──[응답]──▶ 완료
요청 B ──▶ Thread-2: [수신]──[처리]──[DB 대기...]──[응답]──▶ 완료
요청 C ──▶ Thread-3: [수신]──[처리]──[DB 대기...]──[응답]──▶ 완료
  ...
요청 N ──▶ Thread-N: (스레드 풀 고갈 → 대기 큐에서 대기)
```

**Spring WebFlux**는 이벤트 루프 기반이다. CPU 코어 수만큼의 소수 스레드(기본적으로 코어 수 x 1)가 모든 요청을 논블로킹으로 처리한다. I/O 대기 시간 동안 스레드가 다른 요청을 처리할 수 있다.

```
[Spring WebFlux - Event Loop]

EventLoop-1: [요청A 수신]─[요청B 수신]─[요청A DB콜백]─[요청C 수신]─[요청B DB콜백]─...
EventLoop-2: [요청D 수신]─[요청E 수신]─[요청D DB콜백]─[요청F 수신]─[요청E DB콜백]─...
```

**처리량과 지연 시간 비교**

| 항목 | Spring MVC | Spring WebFlux |
|------|-----------|---------------|
| 동시 연결 수 | 스레드 풀 크기에 제한 (보통 200~500) | 수만 개 이상 동시 연결 가능 |
| 스레드 수 | 요청 수에 비례 | CPU 코어 수에 비례 (고정) |
| 메모리 사용 | 스레드당 약 512KB~1MB 스택 | 적은 스레드로 메모리 효율적 |
| I/O 바운드 작업 | 대기 중 스레드 낭비 | 대기 중 다른 작업 처리 |
| CPU 바운드 작업 | 효율적 | 이점 없음 (오히려 복잡성 증가) |
| 지연 시간 | 부하 낮을 때 약간 유리 | 부하 높을 때 안정적 |
| 최대 처리량 | 스레드 풀 포화 시 급감 | 일정하게 유지 |

### 2.1.3 코드 스타일 비교

동일한 사용자 조회 API를 두 방식으로 구현하여 비교해보자.

**Spring MVC 방식:**

```java
@RestController
@RequestMapping("/api/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable String id) {
        User user = userService.findById(id);  // 블로킹 호출
        if (user == null) {
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity.ok(user);
    }

    @GetMapping
    public ResponseEntity<List<User>> getAllUsers() {
        List<User> users = userService.findAll();  // 블로킹 호출
        return ResponseEntity.ok(users);
    }

    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        User saved = userService.save(user);  // 블로킹 호출
        return ResponseEntity
                .created(URI.create("/api/users/" + saved.getId()))
                .body(saved);
    }
}
```

**Spring WebFlux 방식:**

```java
@RestController
@RequestMapping("/api/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping("/{id}")
    public Mono<ResponseEntity<User>> getUser(@PathVariable String id) {
        return userService.findById(id)                    // 논블로킹 호출
                .map(user -> ResponseEntity.ok(user))
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping
    public Flux<User> getAllUsers() {
        return userService.findAll();  // 논블로킹, 스트리밍 가능
    }

    @PostMapping
    public Mono<ResponseEntity<User>> createUser(@RequestBody User user) {
        return userService.save(user)                      // 논블로킹 호출
                .map(saved -> ResponseEntity
                        .created(URI.create("/api/users/" + saved.getId()))
                        .body(saved));
    }
}
```

핵심적인 차이점을 정리하면 다음과 같다.

| 구분 | Spring MVC | Spring WebFlux |
|------|-----------|---------------|
| 반환 타입 | `User`, `List<User>` | `Mono<User>`, `Flux<User>` |
| 실행 방식 | 메서드 호출 시 즉시 실행 | 구독(subscribe) 시 실행 |
| 데이터 흐름 | 동기적, 순차적 | 비동기적, 이벤트 기반 |
| 에러 처리 | try-catch | `onErrorResume`, `onErrorReturn` |
| 기본 서버 | Tomcat | Netty |

---

## 2.2 WebFlux의 내부 구조와 Netty

### 2.2.1 Netty란 무엇인가

Netty는 JVM 위에서 동작하는 비동기 이벤트 기반 네트워크 프레임워크다. 고성능 프로토콜 서버와 클라이언트를 빠르게 개발할 수 있도록 설계되었으며, HTTP, WebSocket, TCP, UDP 등 다양한 프로토콜을 지원한다.

Spring WebFlux가 Netty를 기본 런타임으로 선택한 이유는 다음과 같다.

- **논블로킹 I/O**: Java NIO 기반으로 소수 스레드로 대량의 동시 연결 처리
- **이벤트 루프 모델**: 효율적인 리소스 활용과 높은 동시성
- **검증된 안정성**: Discord, Apple, Netflix 등 대규모 서비스에서 검증
- **풍부한 프로토콜 지원**: HTTP/1.1, HTTP/2, WebSocket 기본 지원

### 2.2.2 이벤트 루프(Event Loop) 모델

Netty의 이벤트 루프는 하나의 스레드가 **셀렉터(Selector)**를 통해 여러 채널(연결)의 I/O 이벤트를 감시하고 처리하는 구조다.

```
[Netty 이벤트 루프 구조]

                  ┌──────────────────────────────┐
                  │       EventLoopGroup          │
                  │  (Boss Group - 연결 수락)      │
                  │  ┌────────────────────────┐   │
                  │  │ EventLoop (Thread-1)   │   │
                  │  │  → 새 연결 수락(accept)  │   │
                  │  └────────────────────────┘   │
                  └──────────┬───────────────────┘
                             │ 연결을 Worker에 등록
                  ┌──────────▼───────────────────┐
                  │       EventLoopGroup          │
                  │  (Worker Group - I/O 처리)     │
                  │  ┌────────────────────────┐   │
                  │  │ EventLoop-1 (Thread)   │   │
                  │  │  채널 A, D, G 담당      │   │
                  │  └────────────────────────┘   │
                  │  ┌────────────────────────┐   │
                  │  │ EventLoop-2 (Thread)   │   │
                  │  │  채널 B, E, H 담당      │   │
                  │  └────────────────────────┘   │
                  │  ┌────────────────────────┐   │
                  │  │ EventLoop-N (Thread)   │   │
                  │  │  채널 C, F, I 담당      │   │
                  │  └────────────────────────┘   │
                  └──────────────────────────────┘
```

각 이벤트 루프 스레드는 다음 과정을 무한 반복한다.

1. **Selector로 I/O 이벤트 대기**: 등록된 채널 중 읽기/쓰기 가능한 채널이 있는지 확인
2. **이벤트 처리**: 준비된 채널의 데이터를 읽거나 쓰기
3. **태스크 큐 처리**: 예약된 작업(스케줄된 태스크) 실행

이 모델의 핵심 규칙은 **하나의 채널은 항상 같은 이벤트 루프에 바인딩**된다는 것이다. 이로 인해 동기화 없이도 스레드 안전성이 보장된다.

### 2.2.3 HttpHandler, WebHandler, DispatcherHandler 파이프라인

Spring WebFlux는 내부적으로 계층화된 핸들러 파이프라인을 구성한다.

```
[요청 처리 파이프라인]

HTTP 요청
   │
   ▼
┌──────────────┐
│  HttpHandler │  ← 서버 API와 리액티브 스트림의 연결점
│  (최하위 계층) │     Netty, Undertow 등 서버별 어댑터 제공
└──────┬───────┘
       ▼
┌──────────────────┐
│  WebHttpHandler  │  ← HttpHandler를 감싸는 데코레이터
│  Build           │     세션, 코덱, 로케일 등 웹 기능 통합
└──────┬───────────┘
       ▼
┌──────────────────┐
│   WebFilter 체인  │  ← 요청/응답을 가로채는 필터 (인증, 로깅 등)
└──────┬───────────┘
       ▼
┌──────────────────┐
│ WebExceptionHandler │  ← 예외 처리
└──────┬───────────┘
       ▼
┌──────────────────┐
│ DispatcherHandler │  ← 핵심 디스패처 (MVC의 DispatcherServlet 역할)
│  ┌─────────────┐ │
│  │HandlerMapping│ │  → 요청 URL을 핸들러에 매핑
│  └──────┬──────┘ │
│  ┌──────▼──────┐ │
│  │HandlerAdapter│ │  → 핸들러 실행
│  └──────┬──────┘ │
│  ┌──────▼──────┐ │
│  │ResultHandler │ │  → 결과를 HTTP 응답으로 변환
│  └─────────────┘ │
└──────────────────┘
```

**HttpHandler**는 가장 낮은 수준의 계약이다. 단일 메서드 `handle(ServerHttpRequest, ServerHttpResponse)`를 정의하며, Netty, Undertow, Tomcat(서블릿 3.1+) 등의 서버별 어댑터가 이를 구현한다.

```java
public interface HttpHandler {
    Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response);
}
```

**DispatcherHandler**는 Spring MVC의 `DispatcherServlet`에 해당하는 중앙 디스패처다. 세 단계로 요청을 처리한다.

```java
// DispatcherHandler의 핵심 로직 (간략화)
public Mono<Void> handle(ServerWebExchange exchange) {
    return Flux.fromIterable(this.handlerMappings)       // 1. 핸들러 매핑 탐색
            .concatMap(mapping -> mapping.getHandler(exchange))
            .next()
            .flatMap(handler -> invokeHandler(exchange, handler))  // 2. 핸들러 실행
            .flatMap(result -> handleResult(exchange, result));    // 3. 결과 처리
}
```

### 2.2.4 요청 처리 흐름

클라이언트의 HTTP 요청이 WebFlux 애플리케이션에 도달하여 응답이 반환되기까지의 전체 흐름을 정리하면 다음과 같다.

1. **Netty가 TCP 연결을 수락**하고 HTTP 요청을 파싱한다.
2. **HttpHandler 어댑터**가 Netty의 요청/응답 객체를 `ServerHttpRequest`, `ServerHttpResponse`로 변환한다.
3. **WebHttpHandlerBuilder**가 구성한 필터 체인(`WebFilter`)이 순서대로 실행된다.
4. **DispatcherHandler**가 `HandlerMapping`을 통해 적절한 핸들러를 찾는다.
   - `RequestMappingHandlerMapping`: 어노테이션 기반 핸들러
   - `RouterFunctionMapping`: 함수형 라우터
5. **HandlerAdapter**가 핸들러를 실행하고 `Mono<HandlerResult>`를 반환한다.
6. **HandlerResultHandler**가 결과를 HTTP 응답으로 변환하여 클라이언트에 전송한다.

모든 단계가 `Mono`와 `Flux`로 연결되어 있어 전체 파이프라인이 논블로킹으로 동작한다. 어느 한 단계에서도 스레드를 블로킹하지 않는다는 것이 핵심이다.

---

## 2.3 논블로킹 I/O의 원리

### 2.3.1 블로킹 I/O vs 논블로킹 I/O

**블로킹 I/O**에서는 `read()` 또는 `write()` 호출 시 데이터가 준비될 때까지 호출한 스레드가 대기 상태에 들어간다. 스레드는 아무 일도 하지 못하면서 시스템 리소스를 점유한다.

```java
// 블로킹 I/O 예시 (java.io)
try (Socket socket = new Socket("example.com", 80);
     InputStream in = socket.getInputStream()) {

    byte[] buffer = new byte[1024];
    int bytesRead = in.read(buffer);  // ← 데이터가 올 때까지 스레드 블로킹
    // 이 줄은 데이터를 읽을 때까지 실행되지 않는다
    processData(buffer, bytesRead);
}
```

```
[블로킹 I/O 타임라인]

Thread-1: ──[read() 호출]──────[대기중...]──────[데이터 수신]──[처리]──▶
                               ↑
                         스레드가 아무 일도 못함
```

**논블로킹 I/O**에서는 `read()` 호출이 즉시 반환된다. 데이터가 아직 없으면 "아직 없다"는 결과를 반환하고, 스레드는 다른 작업을 수행할 수 있다.

```java
// 논블로킹 I/O 예시 (java.nio)
SocketChannel channel = SocketChannel.open();
channel.configureBlocking(false);  // 논블로킹 모드 설정
channel.connect(new InetSocketAddress("example.com", 80));

ByteBuffer buffer = ByteBuffer.allocate(1024);
int bytesRead = channel.read(buffer);  // ← 즉시 반환 (데이터 없으면 0 또는 -1)
// 스레드가 블로킹되지 않으므로 바로 다음 줄 실행
```

```
[논블로킹 I/O 타임라인]

Thread-1: ──[read()→0]──[다른작업]──[read()→0]──[다른작업]──[read()→데이터]──[처리]──▶
              ↑             ↑           ↑           ↑
         즉시 반환      유용한 작업   즉시 반환    유용한 작업
```

### 2.3.2 Java NIO와 Selector

Java NIO(New I/O)의 핵심 컴포넌트인 **Selector**는 하나의 스레드가 여러 채널의 I/O 이벤트를 효율적으로 감시할 수 있게 한다. 운영체제의 `epoll`(Linux), `kqueue`(macOS) 시스템 콜을 활용한다.

```java
// Java NIO Selector 사용 예시
Selector selector = Selector.open();

// 여러 채널을 셀렉터에 등록
ServerSocketChannel serverChannel = ServerSocketChannel.open();
serverChannel.configureBlocking(false);
serverChannel.bind(new InetSocketAddress(8080));
serverChannel.register(selector, SelectionKey.OP_ACCEPT);

while (true) {
    // I/O 이벤트가 있을 때까지 대기 (효율적인 대기)
    selector.select();

    Set<SelectionKey> selectedKeys = selector.selectedKeys();
    Iterator<SelectionKey> iter = selectedKeys.iterator();

    while (iter.hasNext()) {
        SelectionKey key = iter.next();

        if (key.isAcceptable()) {
            // 새 연결 수락
            SocketChannel client = serverChannel.accept();
            client.configureBlocking(false);
            client.register(selector, SelectionKey.OP_READ);
        } else if (key.isReadable()) {
            // 데이터 읽기 가능
            SocketChannel client = (SocketChannel) key.channel();
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            client.read(buffer);
            // 데이터 처리...
        }

        iter.remove();
    }
}
```

```
[Selector 동작 원리]

                    ┌───────────────┐
                    │   Selector    │
                    │   (Thread-1)  │
                    └───┬───┬───┬───┘
                        │   │   │
            ┌───────────┘   │   └───────────┐
            ▼               ▼               ▼
       ┌─────────┐   ┌─────────┐   ┌─────────┐
       │Channel A│   │Channel B│   │Channel C│
       │ (READ)  │   │ (WRITE) │   │ (READ)  │
       └─────────┘   └─────────┘   └─────────┘

  하나의 스레드가 select()를 호출하면:
  → 운영체제가 준비된 채널만 알려줌 (예: A와 C)
  → 스레드가 A와 C만 처리 (불필요한 폴링 없음)
```

### 2.3.3 이벤트 루프의 동작 방식

Netty의 이벤트 루프는 Java NIO의 Selector를 기반으로 하되, 더 정교한 태스크 스케줄링과 파이프라인 처리를 추가한 것이다.

이벤트 루프의 한 사이클(iteration)은 다음과 같다.

```
[이벤트 루프 사이클]

┌─────────────────────────────────────────────┐
│                Event Loop                    │
│                                              │
│  1. select()  ─── I/O 이벤트 감지            │
│       │                                      │
│       ▼                                      │
│  2. processSelectedKeys() ─── I/O 처리       │
│       │    (데이터 읽기/쓰기, 연결 수락)       │
│       ▼                                      │
│  3. runAllTasks() ─── 태스크 큐 처리          │
│       │    (사용자가 제출한 작업, 타이머 등)    │
│       │                                      │
│       └──────── 반복 ────────────────────────│
└─────────────────────────────────────────────┘
```

중요한 원칙: **이벤트 루프 스레드에서 블로킹 작업을 절대 수행하면 안 된다.** 하나의 이벤트 루프가 수천 개의 연결을 담당하므로, 해당 스레드가 블로킹되면 수천 개의 연결이 동시에 지연된다.

```java
// 절대 하면 안 되는 코드 (이벤트 루프에서 블로킹)
@GetMapping("/bad-example")
public Mono<String> badExample() {
    Thread.sleep(1000);  // 이벤트 루프 스레드를 1초간 블로킹!
    return Mono.just("이렇게 하면 안 됩니다");
}

// 올바른 코드 (논블로킹)
@GetMapping("/good-example")
public Mono<String> goodExample() {
    return Mono.delay(Duration.ofSeconds(1))  // 논블로킹 대기
            .then(Mono.just("논블로킹으로 1초 후 응답"));
}
```

블로킹이 불가피한 경우에는 별도의 스케줄러로 작업을 위임해야 한다.

```java
// 블로킹이 불가피한 경우 - 별도 스케줄러 사용
@GetMapping("/blocking-needed")
public Mono<String> blockingNeeded() {
    return Mono.fromCallable(() -> {
                // 블로킹 API 호출 (예: 레거시 JDBC)
                return legacyService.queryDatabase();
            })
            .subscribeOn(Schedulers.boundedElastic());  // 블로킹 전용 스레드 풀
}
```

---

## 2.4 WebFlux를 선택해야 하는 경우와 그렇지 않은 경우

### 2.4.1 WebFlux가 적합한 시나리오

**1. 높은 동시성이 요구되는 I/O 바운드 애플리케이션**

마이크로서비스 게이트웨이, API 중개 서비스처럼 다수의 외부 서비스를 호출하고 결과를 조합하는 경우에 WebFlux가 빛을 발한다.

```java
// 여러 외부 서비스를 동시에 호출하여 결과 조합
public Mono<DashboardData> getDashboard(String userId) {
    Mono<UserProfile> profile = userService.getProfile(userId);
    Mono<List<Order>> orders = orderService.getOrders(userId);
    Mono<List<Notification>> notifications = notificationService.get(userId);

    return Mono.zip(profile, orders, notifications)
            .map(tuple -> new DashboardData(
                    tuple.getT1(),
                    tuple.getT2(),
                    tuple.getT3()
            ));
    // 세 호출이 동시에 실행되어 전체 응답 시간 단축
}
```

**2. 실시간 스트리밍 애플리케이션**

SSE(Server-Sent Events), WebSocket을 활용한 실시간 데이터 스트리밍에 WebFlux의 `Flux`가 자연스럽게 대응한다.

```java
// 실시간 주가 스트리밍
@GetMapping(value = "/stocks/{symbol}/stream",
            produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux<StockPrice> streamStockPrice(@PathVariable String symbol) {
    return stockService.getPriceStream(symbol);  // 무한 스트림
}
```

**3. 대량의 동시 연결을 유지해야 하는 경우**

채팅 서비스, 알림 시스템처럼 수천~수만 개의 커넥션을 장시간 유지해야 하는 경우, 스레드-퍼-리퀘스트 모델은 메모리 한계에 금방 도달한다.

**4. 전체 파이프라인이 리액티브인 경우**

데이터베이스(MongoDB Reactive, R2DBC), 메시지 브로커(Reactor Kafka, Reactor RabbitMQ), HTTP 클라이언트(WebClient) 모두 리액티브 드라이버를 사용할 수 있을 때 WebFlux의 이점이 극대화된다.

### 2.4.2 WebFlux가 부적합한 시나리오

**1. JDBC/JPA(관계형 DB) 블로킹 드라이버를 사용하는 경우**

전통적인 JDBC나 Spring Data JPA는 블로킹 API다. WebFlux 위에서 사용하면 이벤트 루프를 블로킹하게 되어 오히려 성능이 저하된다. R2DBC가 대안이지만, JPA의 풍부한 기능(지연 로딩, 캐시 등)을 포기해야 한다.

**2. CPU 집약적인 작업이 대부분인 경우**

이미지 처리, 복잡한 계산, 암호화 등 CPU를 장시간 사용하는 작업에서는 논블로킹 I/O의 이점이 없다. 오히려 리액티브 프로그래밍의 복잡성만 추가된다.

**3. 팀의 리액티브 프로그래밍 경험이 부족한 경우**

리액티브 프로그래밍은 학습 곡선이 가파르다. 디버깅이 어렵고, 기존의 명령형 사고방식과 근본적으로 다른 접근이 필요하다. 팀 전체가 충분히 준비되지 않은 상태에서 도입하면 생산성이 크게 떨어질 수 있다.

**4. 동시 요청 수가 적은 내부 관리 도구**

동시 사용자가 수십 명 수준인 백오피스 시스템에서는 Spring MVC가 충분하며, WebFlux를 도입할 이유가 없다.

### 2.4.3 의사결정 기준

다음 체크리스트를 통해 WebFlux 도입 여부를 판단할 수 있다.

```
[WebFlux 도입 의사결정 흐름]

높은 동시성(수천 이상)이 필요한가?
  ├── 아니오 → Spring MVC 사용
  └── 예
       │
       전체 I/O 파이프라인이 논블로킹 가능한가?
       (DB, 메시지 큐, 외부 API 등)
         ├── 아니오 → Spring MVC 사용 (또는 부분적 리액티브)
         └── 예
              │
              팀이 리액티브 프로그래밍에 익숙한가?
                ├── 아니오 → 학습 기간 확보 후 도입 검토
                └── 예 → Spring WebFlux 사용
```

---

## 2.5 WebFlux의 두 가지 프로그래밍 모델

Spring WebFlux는 두 가지 프로그래밍 모델을 제공한다. 어노테이션 기반 모델과 함수형 엔드포인트 모델이다. 두 모델은 동일한 리액티브 런타임 위에서 동작하며, 하나의 애플리케이션 내에서 혼용할 수도 있다.

### 2.5.1 어노테이션 기반 모델

Spring MVC를 사용해본 개발자에게 가장 친숙한 방식이다. `@Controller`, `@RestController`, `@RequestMapping` 등의 어노테이션을 그대로 사용하되, 반환 타입이 `Mono`와 `Flux`로 바뀐다.

```java
@RestController
@RequestMapping("/api/products")
public class ProductController {

    private final ProductService productService;

    public ProductController(ProductService productService) {
        this.productService = productService;
    }

    /**
     * 단일 상품 조회
     */
    @GetMapping("/{id}")
    public Mono<ResponseEntity<Product>> getProduct(@PathVariable String id) {
        return productService.findById(id)
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * 전체 상품 목록 조회
     */
    @GetMapping
    public Flux<Product> getAllProducts(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        return productService.findAll(page, size);
    }

    /**
     * 상품 생성
     */
    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono<Product> createProduct(@Valid @RequestBody Product product) {
        return productService.save(product);
    }

    /**
     * 상품 수정
     */
    @PutMapping("/{id}")
    public Mono<ResponseEntity<Product>> updateProduct(
            @PathVariable String id,
            @Valid @RequestBody Product product) {
        return productService.update(id, product)
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    /**
     * 상품 삭제
     */
    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public Mono<Void> deleteProduct(@PathVariable String id) {
        return productService.deleteById(id);
    }

    /**
     * 카테고리별 상품 스트리밍 (SSE)
     */
    @GetMapping(value = "/stream/category/{category}",
                produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<Product> streamByCategory(@PathVariable String category) {
        return productService.findByCategoryStream(category);
    }
}
```

서비스 계층도 함께 살펴보자.

```java
@Service
public class ProductService {

    private final ProductRepository productRepository;

    public ProductService(ProductRepository productRepository) {
        this.productRepository = productRepository;
    }

    public Mono<Product> findById(String id) {
        return productRepository.findById(id);
    }

    public Flux<Product> findAll(int page, int size) {
        return productRepository.findAll()
                .skip((long) page * size)
                .take(size);
    }

    public Mono<Product> save(Product product) {
        product.setCreatedAt(LocalDateTime.now());
        return productRepository.save(product);
    }

    public Mono<Product> update(String id, Product product) {
        return productRepository.findById(id)
                .flatMap(existing -> {
                    existing.setName(product.getName());
                    existing.setPrice(product.getPrice());
                    existing.setUpdatedAt(LocalDateTime.now());
                    return productRepository.save(existing);
                });
    }

    public Mono<Void> deleteById(String id) {
        return productRepository.deleteById(id);
    }

    public Flux<Product> findByCategoryStream(String category) {
        return productRepository.findByCategory(category);
    }
}
```

### 2.5.2 함수형 엔드포인트 모델

함수형 모델은 라우팅과 핸들러를 프로그래밍 방식으로 정의한다. `RouterFunction`이 라우팅 규칙을 정의하고, `HandlerFunction`이 요청을 처리한다.

**핸들러(Handler):**

```java
@Component
public class ProductHandler {

    private final ProductService productService;

    public ProductHandler(ProductService productService) {
        this.productService = productService;
    }

    /**
     * 단일 상품 조회
     */
    public Mono<ServerResponse> getProduct(ServerRequest request) {
        String id = request.pathVariable("id");
        return productService.findById(id)
                .flatMap(product -> ServerResponse.ok()
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(product))
                .switchIfEmpty(ServerResponse.notFound().build());
    }

    /**
     * 전체 상품 목록 조회
     */
    public Mono<ServerResponse> getAllProducts(ServerRequest request) {
        int page = request.queryParam("page")
                .map(Integer::parseInt).orElse(0);
        int size = request.queryParam("size")
                .map(Integer::parseInt).orElse(20);

        Flux<Product> products = productService.findAll(page, size);
        return ServerResponse.ok()
                .contentType(MediaType.APPLICATION_JSON)
                .body(products, Product.class);
    }

    /**
     * 상품 생성
     */
    public Mono<ServerResponse> createProduct(ServerRequest request) {
        return request.bodyToMono(Product.class)
                .flatMap(productService::save)
                .flatMap(saved -> ServerResponse
                        .created(URI.create("/api/products/" + saved.getId()))
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(saved));
    }

    /**
     * 상품 수정
     */
    public Mono<ServerResponse> updateProduct(ServerRequest request) {
        String id = request.pathVariable("id");
        return request.bodyToMono(Product.class)
                .flatMap(product -> productService.update(id, product))
                .flatMap(updated -> ServerResponse.ok()
                        .contentType(MediaType.APPLICATION_JSON)
                        .bodyValue(updated))
                .switchIfEmpty(ServerResponse.notFound().build());
    }

    /**
     * 상품 삭제
     */
    public Mono<ServerResponse> deleteProduct(ServerRequest request) {
        String id = request.pathVariable("id");
        return productService.deleteById(id)
                .then(ServerResponse.noContent().build());
    }
}
```

**라우터(Router):**

```java
@Configuration
public class ProductRouter {

    @Bean
    public RouterFunction<ServerResponse> productRoutes(ProductHandler handler) {
        return RouterFunctions.route()
                .path("/api/products", builder -> builder
                        .GET("/{id}", handler::getProduct)
                        .GET("", handler::getAllProducts)
                        .POST("", handler::createProduct)
                        .PUT("/{id}", handler::updateProduct)
                        .DELETE("/{id}", handler::deleteProduct)
                )
                .build();
    }
}
```

여러 도메인의 라우터를 조합할 수도 있다.

```java
@Configuration
public class AppRouter {

    @Bean
    public RouterFunction<ServerResponse> allRoutes(
            ProductHandler productHandler,
            OrderHandler orderHandler,
            UserHandler userHandler) {

        return RouterFunctions.route()
                .path("/api/products", builder -> builder
                        .GET("/{id}", productHandler::getProduct)
                        .GET("", productHandler::getAllProducts)
                        .POST("", productHandler::createProduct)
                )
                .path("/api/orders", builder -> builder
                        .GET("/{id}", orderHandler::getOrder)
                        .GET("", orderHandler::getAllOrders)
                        .POST("", orderHandler::createOrder)
                )
                .path("/api/users", builder -> builder
                        .GET("/{id}", userHandler::getUser)
                        .POST("", userHandler::createUser)
                )
                .filter((request, next) -> {
                    // 공통 필터: 요청 로깅
                    System.out.println("Request: " + request.method()
                            + " " + request.path());
                    return next.handle(request);
                })
                .build();
    }
}
```

### 2.5.3 두 모델의 비교와 선택 기준

| 기준 | 어노테이션 기반 | 함수형 엔드포인트 |
|------|--------------|----------------|
| 학습 비용 | 낮음 (MVC 경험 활용) | 중간 (새로운 API 학습 필요) |
| 코드 스타일 | 선언적 (어노테이션) | 프로그래밍 방식 (코드로 라우팅) |
| 라우팅 유연성 | 제한적 | 매우 유연 (조건부 라우팅 등) |
| 테스트 | `@WebFluxTest` | 순수 단위 테스트 용이 |
| 검증 | `@Valid` 자동 적용 | 수동으로 검증 로직 작성 |
| IDE 지원 | 우수 (자동완성, 네비게이션) | 보통 |
| 한 파일 응집도 | 낮음 (라우팅이 분산) | 높음 (한 곳에서 라우팅 파악) |

**어노테이션 기반을 선택하는 경우:**

- 기존 Spring MVC 경험이 있는 팀
- 빠른 개발 속도가 중요한 프로젝트
- 표준적인 CRUD API를 구현하는 경우
- Bean Validation을 적극 활용하는 경우

**함수형 엔드포인트를 선택하는 경우:**

- 라우팅 규칙이 복잡하거나 동적인 경우
- 경량 마이크로서비스에서 최소한의 프레임워크 의존이 필요한 경우
- 함수형 프로그래밍 스타일을 선호하는 팀
- 테스트에서 스프링 컨텍스트 없이 핸들러를 단위 테스트하고 싶은 경우

실무에서는 어노테이션 기반 모델이 더 널리 사용된다. Spring MVC에서의 전환 비용이 낮고, 대부분의 팀이 이미 익숙하기 때문이다. 함수형 모델은 특수한 라우팅 요구사항이 있거나, 팀이 함수형 스타일에 익숙한 경우에 선택하면 좋다.

---

## 정리

이 장에서 다룬 핵심 내용을 요약하면 다음과 같다.

- **Spring MVC vs WebFlux**: MVC는 서블릿 기반 thread-per-request 모델이고, WebFlux는 이벤트 루프 기반 논블로킹 모델이다. WebFlux는 높은 동시성에서 적은 리소스로 안정적인 처리량을 유지한다.
- **Netty와 이벤트 루프**: WebFlux의 기본 런타임인 Netty는 이벤트 루프 모델을 통해 소수의 스레드로 수만 개의 동시 연결을 처리한다. 이벤트 루프 스레드를 블로킹하면 안 된다.
- **논블로킹 I/O**: Java NIO의 Selector를 활용하여 하나의 스레드가 여러 채널의 I/O를 효율적으로 관리한다. 데이터가 준비될 때만 처리하므로 스레드 낭비가 없다.
- **도입 판단 기준**: 높은 동시성, 리액티브 파이프라인, 팀 역량의 세 조건이 모두 충족될 때 WebFlux를 선택한다.
- **두 가지 프로그래밍 모델**: 어노테이션 기반은 MVC 경험을 활용할 수 있어 접근성이 높고, 함수형 모델은 라우팅의 유연성과 테스트 용이성에서 장점이 있다.

다음 장에서는 WebFlux의 핵심 기반인 **Project Reactor**를 깊이 있게 다룬다. `Mono`와 `Flux`의 동작 원리, 주요 연산자, 에러 처리 전략 등을 살펴볼 것이다.
