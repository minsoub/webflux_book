# Chapter 9. 데이터 검증과 예외 처리

Chapter 8에서 MongoDB 데이터 접근을 심화했다면, 이번 장에서는 클라이언트로부터 유입되는 데이터의 **검증**과 애플리케이션 전반의 **예외 처리**를 다룬다. 올바르지 않은 입력은 가능한 한 빨리 걸러내야 하며, 예외가 발생했을 때는 일관된 형식으로 클라이언트에 전달해야 한다. Bean Validation, 커스텀 Validator, `@ControllerAdvice`, `ErrorWebExceptionHandler`, 그리고 RFC 7807 기반 Problem Details까지 단계별로 살펴본다.

---

## 9.1 Bean Validation을 활용한 입력 검증

### 9.1.1 의존성 추가

Spring Boot에서 Bean Validation을 사용하려면 `spring-boot-starter-validation` 의존성이 필요하다.

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

이 스타터는 Hibernate Validator를 포함하며, Jakarta Bean Validation 3.0 API(`jakarta.validation` 패키지)를 제공한다.

### 9.1.2 주요 검증 어노테이션

자주 사용하는 Bean Validation 어노테이션을 정리한다.

| 어노테이션 | 설명 | 적용 대상 |
|-----------|------|----------|
| `@NotNull` | null이 아니어야 한다 | 모든 타입 |
| `@NotBlank` | null이 아니고, 공백을 제외한 길이가 1 이상 | `String` |
| `@NotEmpty` | null이 아니고, 비어 있지 않아야 한다 | `String`, `Collection`, `Map`, 배열 |
| `@Size(min, max)` | 길이 또는 크기가 범위 내 | `String`, `Collection`, `Map`, 배열 |
| `@Email` | 이메일 형식이어야 한다 | `String` |
| `@Pattern(regexp)` | 정규표현식에 매칭되어야 한다 | `String` |
| `@Min` / `@Max` | 지정 값 이상 / 이하 | 숫자 타입 |
| `@Positive` | 양수여야 한다 | 숫자 타입 |
| `@Past` / `@Future` | 과거 / 미래 날짜여야 한다 | 날짜, 시간 타입 |

### 9.1.3 DTO에 검증 어노테이션 적용

Chapter 6에서 사용한 사용자 등록 DTO에 검증 로직을 추가한다.

```java
package com.example.webfluxdemo.dto;

import jakarta.validation.constraints.*;
import lombok.*;

@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserCreateRequest {

    @NotBlank(message = "이름은 필수 입력 항목입니다")
    @Size(min = 2, max = 50, message = "이름은 2~50자 사이여야 합니다")
    private String name;

    @NotBlank(message = "이메일은 필수 입력 항목입니다")
    @Email(message = "올바른 이메일 형식이 아닙니다")
    private String email;

    @NotBlank(message = "비밀번호는 필수 입력 항목입니다")
    @Pattern(
        regexp = "^(?=.*[A-Za-z])(?=.*\\d)(?=.*[@$!%*#?&])[A-Za-z\\d@$!%*#?&]{8,20}$",
        message = "비밀번호는 8~20자이며, 영문, 숫자, 특수문자를 포함해야 합니다"
    )
    private String password;
}
```

상품 생성 DTO에도 동일하게 적용한다.

```java
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductCreateRequest {

    @NotBlank(message = "상품명은 필수 입력 항목입니다")
    @Size(max = 200, message = "상품명은 200자를 초과할 수 없습니다")
    private String name;

    @NotNull(message = "가격은 필수 입력 항목입니다")
    @Positive(message = "가격은 양수여야 합니다")
    private Integer price;

    @Size(max = 1000, message = "설명은 1000자를 초과할 수 없습니다")
    private String description;

    @NotBlank(message = "카테고리는 필수 입력 항목입니다")
    private String category;
}
```

### 9.1.4 컨트롤러에서 @Valid 적용

WebFlux 어노테이션 기반 컨트롤러에서는 `@Valid`를 `@RequestBody`와 함께 사용한다.

```java
@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono<UserResponse> createUser(
            @Valid @RequestBody UserCreateRequest request) {
        return userService.createUser(request);
    }

    @PutMapping("/{id}")
    public Mono<UserResponse> updateUser(
            @PathVariable String id,
            @Valid @RequestBody UserUpdateRequest request) {
        return userService.updateUser(id, request);
    }
}
```

`@Valid`가 선언된 파라미터에서 검증이 실패하면, Spring WebFlux는 `WebExchangeBindException`을 발생시킨다. 이 예외는 9.3절에서 글로벌 예외 처리기로 가공하여 클라이언트에 반환한다.

### 9.1.5 함수형 엔드포인트에서의 검증

함수형 엔드포인트에서는 `@Valid`를 직접 사용할 수 없다. `Validator`를 주입받아 수동으로 검증을 수행한다.

```java
@Component
@RequiredArgsConstructor
public class ProductHandler {

    private final ProductService productService;
    private final Validator validator;

    public Mono<ServerResponse> createProduct(ServerRequest request) {
        return request.bodyToMono(ProductCreateRequest.class)
            .doOnNext(this::validate)
            .flatMap(productService::createProduct)
            .flatMap(product -> ServerResponse
                .created(URI.create("/api/products/" + product.getId()))
                .bodyValue(product));
    }

    private <T> void validate(T body) {
        Set<ConstraintViolation<T>> violations = validator.validate(body);
        if (!violations.isEmpty()) {
            throw new ConstraintViolationException(violations);
        }
    }
}
```

`ConstraintViolation`이 발견되면 `ConstraintViolationException`을 던지며, 이 예외도 글로벌 예외 처리기에서 일괄 처리한다.

---

## 9.2 커스텀 Validator 구현

### 9.2.1 커스텀 어노테이션 정의

표준 어노테이션으로 표현하기 어려운 비즈니스 규칙은 커스텀 Validator로 구현한다. 허용된 카테고리 값만 받아들이는 검증기를 만들어 보자.

```java
@Documented
@Constraint(validatedBy = AllowedCategoryValidator.class)
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
public @interface AllowedCategory {
    String message() default "허용되지 않은 카테고리입니다";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
    String[] values() default {};
}
```

### 9.2.2 ConstraintValidator 구현

`ConstraintValidator<A, T>` 인터페이스를 구현한다. `A`는 어노테이션 타입, `T`는 검증 대상 필드 타입이다.

```java
public class AllowedCategoryValidator
        implements ConstraintValidator<AllowedCategory, String> {

    private Set<String> allowedValues;

    @Override
    public void initialize(AllowedCategory annotation) {
        this.allowedValues = Set.of(annotation.values());
    }

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null) {
            return true; // null 검사는 @NotBlank에 위임
        }
        return allowedValues.contains(value);
    }
}
```

DTO에 적용하면 다음과 같다.

```java
@AllowedCategory(
    values = {"ELECTRONICS", "BOOKS", "CLOTHING", "FOOD"},
    message = "카테고리는 ELECTRONICS, BOOKS, CLOTHING, FOOD 중 하나여야 합니다"
)
@NotBlank(message = "카테고리는 필수 입력 항목입니다")
private String category;
```

### 9.2.3 크로스 필드 검증 (클래스 레벨 Validator)

비밀번호와 비밀번호 확인이 일치하는지처럼, 두 개 이상의 필드를 함께 검증해야 하는 경우에는 **클래스 레벨 어노테이션**을 사용한다.

```java
@Documented
@Constraint(validatedBy = PasswordMatchValidator.class)
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface PasswordMatch {
    String message() default "비밀번호와 비밀번호 확인이 일치하지 않습니다";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}
```

검증 대상 DTO가 구현할 인터페이스를 먼저 정의한다.

```java
public interface PasswordConfirmable {
    String getPassword();
    String getPasswordConfirm();
}
```

```java
public class PasswordMatchValidator
        implements ConstraintValidator<PasswordMatch, PasswordConfirmable> {

    @Override
    public boolean isValid(PasswordConfirmable dto,
                           ConstraintValidatorContext context) {
        if (dto.getPassword() == null || dto.getPasswordConfirm() == null) {
            return true;
        }
        boolean matches = dto.getPassword().equals(dto.getPasswordConfirm());
        if (!matches) {
            context.disableDefaultConstraintViolation();
            context.buildConstraintViolationWithTemplate(
                    "비밀번호와 비밀번호 확인이 일치하지 않습니다")
                .addPropertyNode("passwordConfirm")
                .addConstraintViolation();
        }
        return matches;
    }
}
```

DTO 클래스에 `@PasswordMatch`를 선언하면 필드 레벨 검증과 크로스 필드 검증이 모두 수행된다.

```java
@PasswordMatch
@Getter @NoArgsConstructor @AllArgsConstructor @Builder
public class SignUpRequest implements PasswordConfirmable {

    @NotBlank(message = "이름은 필수 입력 항목입니다")
    private String name;

    @NotBlank @Email
    private String email;

    @NotBlank
    private String password;

    @NotBlank
    private String passwordConfirm;
}
```

---

## 9.3 글로벌 예외 처리 (@ControllerAdvice)

### 9.3.1 커스텀 예외 클래스 정의

비즈니스 로직에서 발생하는 예외를 명확하게 구분하기 위해 커스텀 예외 계층을 정의한다.

```java
package com.example.webfluxdemo.exception;

import lombok.Getter;

@Getter
public class BusinessException extends RuntimeException {

    private final ErrorCode errorCode;

    public BusinessException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.errorCode = errorCode;
    }

    public BusinessException(ErrorCode errorCode, String detail) {
        super(detail);
        this.errorCode = errorCode;
    }
}
```

```java
public class ResourceNotFoundException extends BusinessException {
    public ResourceNotFoundException(String resourceName, String id) {
        super(ErrorCode.RESOURCE_NOT_FOUND,
              resourceName + "을(를) 찾을 수 없습니다. ID: " + id);
    }
}

public class DuplicateResourceException extends BusinessException {
    public DuplicateResourceException(String resourceName, String field) {
        super(ErrorCode.DUPLICATE_RESOURCE,
              resourceName + "이(가) 이미 존재합니다. 필드: " + field);
    }
}
```

### 9.3.2 ErrorCode 열거형

에러 코드를 열거형으로 관리하면 에러 종류를 중앙에서 일관되게 유지할 수 있다.

```java
package com.example.webfluxdemo.exception;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;

@Getter
@RequiredArgsConstructor
public enum ErrorCode {

    // 공통
    INVALID_INPUT(HttpStatus.BAD_REQUEST, "C001", "잘못된 입력값입니다"),
    RESOURCE_NOT_FOUND(HttpStatus.NOT_FOUND, "C002", "리소스를 찾을 수 없습니다"),
    INTERNAL_ERROR(HttpStatus.INTERNAL_SERVER_ERROR, "C003", "서버 내부 오류"),
    DUPLICATE_RESOURCE(HttpStatus.CONFLICT, "C004", "중복된 리소스입니다"),

    // 사용자
    USER_NOT_FOUND(HttpStatus.NOT_FOUND, "U001", "사용자를 찾을 수 없습니다"),
    EMAIL_ALREADY_EXISTS(HttpStatus.CONFLICT, "U002", "이미 등록된 이메일입니다"),

    // 상품
    PRODUCT_NOT_FOUND(HttpStatus.NOT_FOUND, "P001", "상품을 찾을 수 없습니다"),
    INSUFFICIENT_STOCK(HttpStatus.BAD_REQUEST, "P002", "재고가 부족합니다");

    private final HttpStatus status;
    private final String code;
    private final String message;
}
```

### 9.3.3 ErrorResponse DTO

클라이언트에 반환할 에러 응답 형식을 정의한다.

```java
package com.example.webfluxdemo.exception;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.*;
import java.time.LocalDateTime;
import java.util.List;

@Getter
@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorResponse {

    private final String code;
    private final String message;
    private final int status;
    private final LocalDateTime timestamp;
    private final List<FieldError> errors;

    @Getter @Builder
    public static class FieldError {
        private final String field;
        private final String value;
        private final String reason;
    }

    public static ErrorResponse of(ErrorCode ec) {
        return of(ec, ec.getMessage(), null);
    }

    public static ErrorResponse of(ErrorCode ec, String message) {
        return of(ec, message, null);
    }

    public static ErrorResponse of(ErrorCode ec, List<FieldError> errors) {
        return of(ec, ec.getMessage(), errors);
    }

    private static ErrorResponse of(ErrorCode ec, String msg,
                                    List<FieldError> errors) {
        return ErrorResponse.builder()
            .code(ec.getCode()).message(msg)
            .status(ec.getStatus().value())
            .timestamp(LocalDateTime.now()).errors(errors)
            .build();
    }
}
```

### 9.3.4 @RestControllerAdvice 구현

`@RestControllerAdvice`는 `@ControllerAdvice`와 `@ResponseBody`의 조합이다. 모든 컨트롤러에서 발생하는 예외를 한 곳에서 처리한다.

```java
package com.example.webfluxdemo.exception;

import jakarta.validation.ConstraintViolationException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.*;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.bind.support.WebExchangeBindException;
import java.util.List;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(WebExchangeBindException.class)
    public ResponseEntity<ErrorResponse> handleValidation(
            WebExchangeBindException ex) {

        List<ErrorResponse.FieldError> fieldErrors = ex.getFieldErrors()
            .stream()
            .map(e -> ErrorResponse.FieldError.builder()
                .field(e.getField())
                .value(e.getRejectedValue() != null
                    ? e.getRejectedValue().toString() : "")
                .reason(e.getDefaultMessage())
                .build())
            .toList();

        log.warn("Validation failed: {}", fieldErrors);
        return ResponseEntity.badRequest()
            .body(ErrorResponse.of(ErrorCode.INVALID_INPUT, fieldErrors));
    }

    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity<ErrorResponse> handleConstraintViolation(
            ConstraintViolationException ex) {
        List<ErrorResponse.FieldError> fieldErrors = ex.getConstraintViolations()
            .stream()
            .map(v -> ErrorResponse.FieldError.builder()
                .field(v.getPropertyPath().toString())
                .reason(v.getMessage()).build())
            .toList();
        return ResponseEntity.badRequest()
            .body(ErrorResponse.of(ErrorCode.INVALID_INPUT, fieldErrors));
    }

    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusiness(
            BusinessException ex) {

        ErrorCode ec = ex.getErrorCode();
        log.warn("Business exception: [{}] {}", ec.getCode(), ex.getMessage());
        return ResponseEntity.status(ec.getStatus())
            .body(ErrorResponse.of(ec, ex.getMessage()));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(Exception ex) {

        log.error("Unhandled exception", ex);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(ErrorResponse.of(ErrorCode.INTERNAL_ERROR));
    }
}
```

### 9.3.5 서비스 계층에서 예외 발생

리액티브 파이프라인 안에서 `switchIfEmpty`와 `Mono.error`를 조합하여 예외를 전파한다.

```java
@Service
@RequiredArgsConstructor
public class UserService {

    private final UserRepository userRepository;

    public Mono<UserResponse> findById(String id) {
        return userRepository.findById(id)
            .map(UserResponse::from)
            .switchIfEmpty(Mono.error(
                new ResourceNotFoundException("사용자", id)));
    }

    public Mono<UserResponse> createUser(UserCreateRequest request) {
        return userRepository.findByEmail(request.getEmail())
            .flatMap(existing -> Mono.<User>error(
                new DuplicateResourceException("이메일", request.getEmail())))
            .switchIfEmpty(Mono.defer(() -> {
                User user = User.builder()
                    .name(request.getName())
                    .email(request.getEmail())
                    .password(request.getPassword())
                    .build();
                return userRepository.save(user);
            }))
            .map(UserResponse::from);
    }
}
```

전파된 예외는 `GlobalExceptionHandler`가 캐치하여 적절한 HTTP 응답으로 변환한다.

### 9.3.6 에러 응답 예시

검증 실패 시 클라이언트가 받는 응답은 다음과 같다.

```json
{
  "code": "C001",
  "message": "잘못된 입력값입니다",
  "status": 400,
  "timestamp": "2026-02-14T10:30:00",
  "errors": [
    { "field": "name", "value": "", "reason": "이름은 필수 입력 항목입니다" },
    { "field": "email", "value": "invalid", "reason": "올바른 이메일 형식이 아닙니다" }
  ]
}
```

리소스를 찾지 못한 경우는 다음과 같다.

```json
{
  "code": "C002",
  "message": "사용자을(를) 찾을 수 없습니다. ID: 64a1b2c3d4e5f6",
  "status": 404,
  "timestamp": "2026-02-14T10:31:00"
}
```

---

## 9.4 ErrorWebExceptionHandler를 활용한 함수형 예외 처리

### 9.4.1 @ControllerAdvice의 한계

`@RestControllerAdvice`는 어노테이션 기반 컨트롤러에서 잘 동작하지만, 함수형 엔드포인트(`RouterFunction`)에서 발생하는 예외는 처리하지 못하는 경우가 있다. 특히 라우팅 전에 발생하는 예외나 필터 단계의 예외는 `@ExceptionHandler`의 범위 밖이다. WebFlux에서 모든 예외를 통합 처리하려면 `ErrorWebExceptionHandler`를 사용한다.

### 9.4.2 AbstractErrorWebExceptionHandler 확장

Spring Boot의 `AbstractErrorWebExceptionHandler`를 확장하면 기본 에러 처리를 커스터마이징할 수 있다. 핵심은 `getRoutingFunction()`을 오버라이드하여 모든 에러 요청을 커스텀 렌더 메서드로 보내는 것이다.

```java
@Component
@Order(-2) // 기본 에러 핸들러(-1)보다 높은 우선순위
public class CustomErrorWebExceptionHandler
        extends AbstractErrorWebExceptionHandler {

    public CustomErrorWebExceptionHandler(
            ErrorAttributes errorAttributes, WebProperties webProperties,
            ApplicationContext ctx, ServerCodecConfigurer configurer) {
        super(errorAttributes, webProperties.getResources(), ctx);
        this.setMessageWriters(configurer.getWriters());
    }

    @Override
    protected RouterFunction<ServerResponse> getRoutingFunction(
            ErrorAttributes errorAttributes) {
        return RouterFunctions.route(
            RequestPredicates.all(), this::renderErrorResponse);
    }

    private Mono<ServerResponse> renderErrorResponse(ServerRequest request) {
        Throwable error = getError(request);
        HttpStatus status;
        String code, message;

        if (error instanceof BusinessException bex) {
            status = bex.getErrorCode().getStatus();
            code = bex.getErrorCode().getCode();
            message = bex.getMessage();
        } else if (error instanceof WebExchangeBindException) {
            status = HttpStatus.BAD_REQUEST;
            code = "C001"; message = "잘못된 입력값입니다";
        } else {
            status = HttpStatus.INTERNAL_SERVER_ERROR;
            code = "C003"; message = "서버 내부 오류가 발생했습니다";
        }

        Map<String, Object> body = Map.of(
            "code", code, "message", message,
            "status", status.value(),
            "timestamp", LocalDateTime.now().toString(),
            "path", request.path());

        return ServerResponse.status(status)
            .contentType(MediaType.APPLICATION_JSON)
            .body(BodyInserters.fromValue(body));
    }
}
```

### 9.4.3 @ControllerAdvice와의 공존

`@Order(-2)`를 설정한 이유는 기본 `DefaultErrorWebExceptionHandler`가 `@Order(-1)`이기 때문이다. 두 방식을 함께 사용할 수 있으며, 처리 순서는 다음과 같다.

| 단계 | 처리 주체 | 대상 |
|------|----------|------|
| 1 | `@ExceptionHandler` | 어노테이션 컨트롤러에서 발생한 예외 |
| 2 | `ErrorWebExceptionHandler` | 1단계에서 처리되지 않은 모든 예외 |

어노테이션 기반 API에서는 `@RestControllerAdvice`가 예외를 잡고, 함수형 엔드포인트나 필터에서 발생한 예외는 `ErrorWebExceptionHandler`가 처리하는 구조를 권장한다. 두 방식의 에러 응답 형식을 반드시 통일해야 한다.

---

## 9.5 에러 응답 표준화 (Problem Details)

### 9.5.1 RFC 7807이란?

RFC 7807(Problem Details for HTTP APIs)은 HTTP API에서 에러 응답의 표준 형식을 정의한 규격이다.

| 필드 | 설명 |
|------|------|
| `type` | 에러 유형을 식별하는 URI |
| `title` | 에러의 짧은 요약 |
| `status` | HTTP 상태 코드 |
| `detail` | 에러의 상세 설명 |
| `instance` | 에러가 발생한 구체적 URI |

Content-Type은 `application/problem+json`을 사용한다.

### 9.5.2 Spring Framework 6의 ProblemDetail

Spring Framework 6부터는 `ProblemDetail` 클래스를 기본 제공한다. `setProperty()`로 확장 필드를 추가할 수 있다.

```java
// ProblemDetail의 주요 구조
public class ProblemDetail {
    private URI type;
    private String title;
    private int status;
    private String detail;
    private URI instance;
    private Map<String, Object> properties; // 확장 필드
}
```

### 9.5.3 ProblemDetail 기반 글로벌 예외 처리

9.3절의 `GlobalExceptionHandler`를 `ProblemDetail`을 반환하도록 리팩터링한다. 반환 타입을 `ResponseEntity<ErrorResponse>` 대신 `ProblemDetail`로 변경하면 된다.

```java
package com.example.webfluxdemo.exception;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.*;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.bind.support.WebExchangeBindException;
import java.net.URI;
import java.time.Instant;
import java.util.*;

@Slf4j
@RestControllerAdvice
public class ProblemDetailExceptionHandler {

    private static final String BASE_TYPE = "https://api.example.com/errors/";

    @ExceptionHandler(WebExchangeBindException.class)
    public ProblemDetail handleValidation(WebExchangeBindException ex) {
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(
            HttpStatus.BAD_REQUEST, "입력값 검증에 실패했습니다");
        problem.setType(URI.create(BASE_TYPE + "validation-failed"));
        problem.setTitle("Validation Failed");
        problem.setProperty("errors", ex.getFieldErrors().stream()
            .map(fe -> Map.of("field", fe.getField(),
                "message", Objects.toString(fe.getDefaultMessage(), "")))
            .toList());
        problem.setProperty("timestamp", Instant.now());
        return problem;
    }

    @ExceptionHandler(BusinessException.class)
    public ProblemDetail handleBusiness(BusinessException ex) {
        ErrorCode ec = ex.getErrorCode();
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(
            ec.getStatus(), ex.getMessage());
        problem.setType(URI.create(BASE_TYPE + ec.getCode()));
        problem.setTitle(ec.getMessage());
        problem.setProperty("errorCode", ec.getCode());
        problem.setProperty("timestamp", Instant.now());
        return problem;
    }

    @ExceptionHandler(Exception.class)
    public ProblemDetail handleUnhandled(Exception ex) {
        log.error("Unhandled exception", ex);
        ProblemDetail problem = ProblemDetail.forStatusAndDetail(
            HttpStatus.INTERNAL_SERVER_ERROR, "서버 내부 오류가 발생했습니다");
        problem.setType(URI.create(BASE_TYPE + "internal-error"));
        problem.setTitle("Internal Server Error");
        problem.setProperty("timestamp", Instant.now());
        return problem;
    }
}
```

### 9.5.4 ProblemDetail 응답 예시

검증 실패 시 응답은 `application/problem+json` 타입으로 반환된다.

```json
{
  "type": "https://api.example.com/errors/validation-failed",
  "title": "Validation Failed",
  "status": 400,
  "detail": "입력값 검증에 실패했습니다",
  "errors": [
    { "field": "name", "message": "이름은 필수 입력 항목입니다" },
    { "field": "price", "message": "가격은 양수여야 합니다" }
  ],
  "timestamp": "2026-02-14T01:30:00Z"
}
```

비즈니스 예외 응답은 다음과 같다.

```json
{
  "type": "https://api.example.com/errors/U002",
  "title": "이미 등록된 이메일입니다",
  "status": 409,
  "detail": "이메일이(가) 이미 존재합니다. 필드: user@example.com",
  "errorCode": "U002",
  "timestamp": "2026-02-14T01:31:00Z"
}
```

### 9.5.5 ProblemDetail 활성화 설정

Spring Boot 3에서 `ProblemDetail`을 완전히 활성화하려면 `application.yml`에 다음 설정을 추가한다.

```yaml
spring:
  webflux:
    problemdetails:
      enabled: true
```

이 설정을 활성화하면 Spring이 기본으로 처리하는 예외(404 Not Found, 405 Method Not Allowed 등)도 `ProblemDetail` 형식으로 반환된다.

### 9.5.6 ErrorWebExceptionHandler에서 ProblemDetail 사용

9.4절의 `ErrorWebExceptionHandler`에서도 `ProblemDetail` 형식을 적용할 수 있다. `renderErrorResponse` 메서드에서 `Map` 대신 `ProblemDetail`을 생성하고, Content-Type을 `MediaType.APPLICATION_PROBLEM_JSON`으로 설정하면 된다.

```java
private Mono<ServerResponse> renderErrorResponse(ServerRequest request) {
    Throwable error = getError(request);
    HttpStatus status = (error instanceof BusinessException bex)
        ? bex.getErrorCode().getStatus()
        : HttpStatus.INTERNAL_SERVER_ERROR;

    ProblemDetail problem = ProblemDetail.forStatusAndDetail(
        status, error.getMessage());
    problem.setInstance(URI.create(request.path()));
    problem.setProperty("timestamp", Instant.now());

    return ServerResponse.status(status)
        .contentType(MediaType.APPLICATION_PROBLEM_JSON)
        .body(BodyInserters.fromValue(problem));
}
```

`APPLICATION_PROBLEM_JSON`을 사용하면 Content-Type이 `application/problem+json`으로 설정되어 RFC 7807 표준을 온전히 준수한다.

---

## 요약

이번 장에서 다룬 핵심 내용을 정리한다.

| 주제 | 핵심 내용 |
|------|----------|
| **Bean Validation** | `@NotBlank`, `@Email`, `@Pattern` 등으로 DTO 필드를 선언적으로 검증, 컨트롤러에서 `@Valid`로 활성화 |
| **커스텀 Validator** | `ConstraintValidator` 구현으로 비즈니스 규칙 검증, 클래스 레벨 어노테이션으로 크로스 필드 검증 |
| **@RestControllerAdvice** | `@ExceptionHandler`로 예외 유형별 처리, `ErrorResponse` DTO로 일관된 응답 반환 |
| **ErrorWebExceptionHandler** | `AbstractErrorWebExceptionHandler` 확장으로 함수형 엔드포인트 포함 모든 예외 통합 처리 |
| **Problem Details** | RFC 7807 기반 `ProblemDetail` 클래스로 에러 응답 표준화, `application/problem+json` 타입 사용 |

다음 장에서는 WebFlux 필터와 인터셉터를 다루며, `WebFilter`, `HandlerFilterFunction`을 활용한 요청/응답 로깅, CORS 설정, 요청 속도 제한 등을 살펴본다.
