# Chapter 5. 개발 환경 구성

Part 1에서 리액티브 프로그래밍, WebFlux, Reactor, MongoDB의 이론적 토대를 다졌다. 이제 실제 코드를 작성해 볼 차례인데, 먼저 개발 환경을 제대로 갖춰야 한다. JDK 설치부터 IDE 설정, Docker 기반 MongoDB 실행, 프로젝트 생성, 의존성 구성, 그리고 팀 협업에서도 유용한 프로젝트 구조까지 이 장 하나에서 한 번에 다룬다.

---

## 5.1 JDK, IDE, Docker 설치

### 5.1.1 JDK 17+ 설치 — SDKMAN 활용

Spring Boot 3.x는 Java 17 이상을 필요로 한다. 프로젝트마다 JDK 버전을 달리 사용해야 하는 경우가 많기 때문에, 이런 상황에서 **SDKMAN**이 유용하다.

**SDKMAN 설치 (macOS / Linux)**

```bash
# SDKMAN 설치
curl -s "https://get.sdkman.io" | bash
source "$HOME/.sdkman/bin/sdkman-init.sh"

# 설치 확인
sdk version
```

**JDK 설치 및 버전 관리**

```bash
sdk list java                          # 설치 가능한 JDK 목록
sdk install java 21.0.5-amzn           # Amazon Corretto 21 설치 (LTS)
sdk default java 21.0.5-amzn           # 기본 JDK 설정
java -version                          # 확인
```

> **Windows 사용자**: SDKMAN 대신 [scoop](https://scoop.sh)(`scoop install corretto21-jdk`)이나 직접 다운로드를 권장한다.

**프로젝트별 JDK 자동 전환** -- 프로젝트 루트에 `.sdkmanrc`를 만들어두면, 해당 디렉터리에 들어갈 때 자동으로 JDK 버전이 전환되는 기능이 있다.

```properties
# .sdkmanrc
java=21.0.5-amzn
```

### 5.1.2 IntelliJ IDEA 설정

**권장 에디션**: IntelliJ IDEA Ultimate가 Spring Boot 개발에 최적화되어 있다. Community Edition을 써도 되지만, Spring 관련 고급 기능 지원에서는 다소 제한이 있을 수 있다.

**필수 플러그인**

| 플러그인 | 용도 |
|---------|------|
| Lombok | `@Data`, `@Builder` 등 Lombok 어노테이션 지원 |
| Docker | IDE 내에서 Docker 컨테이너 관리 |
| MongoDB Plugin | MongoDB 쿼리 실행 및 데이터 브라우징 |
| Reactive Streams | Reactor 체인 디버깅 보조 |

**IDE 핵심 설정**

- `Annotation Processors` → Enable annotation processing 체크 (Lombok 필수)
- `Build Tools → Gradle` → Build and run using: **IntelliJ IDEA** (빌드 속도 향상)
- `File Encodings` → Project/Properties Encoding: **UTF-8**

### 5.1.3 Docker Desktop 설치

MongoDB를 로컬에서 실행하려면 Docker를 활용하는 것이 좋다. 설치와 제거가 간단해질 뿐 아니라 팀원들이 동일한 환경을 쉽게 구성할 수 있기 때문이다.

```bash
# macOS — Homebrew를 통한 설치
brew install --cask docker

# 설치 확인
docker --version
docker compose version
```

Docker Desktop을 실행한 후 **Resources** 설정에서 메모리를 최소 4GB 이상 할당해 두면 좋다. MongoDB와 애플리케이션을 함께 실행할 때 여유 있게 돌아가기 때문이다.

---

## 5.2 Spring Initializr로 프로젝트 생성

### 5.2.1 start.spring.io 사용법

[https://start.spring.io](https://start.spring.io)에 접속하면 직관적인 폼이 나온다. 다음 항목들을 설정하면 된다.

| 항목 | 설정값 |
|------|--------|
| Project | Gradle - Kotlin DSL |
| Language | Java |
| Spring Boot | 3.4.x (최신 안정 버전) |
| Group | `com.example` |
| Artifact | `webflux-mongo-demo` |
| Name | `webflux-mongo-demo` |
| Package name | `com.example.webfluxmongodemo` |
| Packaging | Jar |
| Java | 21 |

### 5.2.2 의존성 선택

이제 필요한 라이브러리들을 추가해야 한다.

| 의존성 | 설명 |
|--------|------|
| **Spring Reactive Web** | WebFlux 핵심 (Netty 내장) |
| **Spring Data Reactive MongoDB** | 리액티브 MongoDB 드라이버 + Repository |
| **Lombok** | 보일러플레이트 코드 제거 |
| **Spring Boot DevTools** | 핫 리로드, 자동 재시작 |
| **Validation** | Bean Validation (jakarta.validation) |
| **Spring Boot Actuator** | 헬스 체크, 메트릭 |

**GENERATE** 버튼을 누르면 ZIP 파일이 내려온다. 압축을 풀고 IntelliJ에서 프로젝트를 열면 된다.

> **팁**: IDE에서 직접 프로젝트를 만들 수도 있다. `File → New → Project → Spring Boot`를 선택하면 Initializr의 같은 기능을 IDE 내부에서 사용할 수 있다.

### 5.2.3 초기 프로젝트 구조

Initializr가 만들어주는 기본 구조는 `build.gradle.kts`, 메인 클래스, `application.properties`, 테스트 클래스 정도로 간단하다. 실제 개발할 때는 `application.properties` 대신 `application.yml`을 쓰는 것이 계층 구조를 표현하기에 더 낫다.

---

## 5.3 주요 의존성 설정 및 빌드 파일 구성

### 5.3.1 build.gradle.kts 전체 예시

```kotlin
plugins {
    java
    id("org.springframework.boot") version "3.4.1"
    id("io.spring.dependency-management") version "1.1.7"
}

group = "com.example"
version = "0.0.1-SNAPSHOT"

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

configurations {
    compileOnly {
        extendsFrom(configurations.annotationProcessor.get())
    }
}

repositories {
    mavenCentral()
}

dependencies {
    // Spring WebFlux (Netty 기반 논블로킹 웹 서버)
    implementation("org.springframework.boot:spring-boot-starter-webflux")
    // Spring Data Reactive MongoDB
    implementation("org.springframework.boot:spring-boot-starter-data-mongodb-reactive")
    // Validation (jakarta.validation)
    implementation("org.springframework.boot:spring-boot-starter-validation")
    // Actuator (헬스 체크, 메트릭)
    implementation("org.springframework.boot:spring-boot-starter-actuator")

    // Lombok
    compileOnly("org.projectlombok:lombok")
    annotationProcessor("org.projectlombok:lombok")
    // DevTools (개발 시 자동 재시작)
    developmentOnly("org.springframework.boot:spring-boot-devtools")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("io.projectreactor:reactor-test")
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")
}

tasks.withType<Test> {
    useJUnitPlatform()
}
```

### 5.3.2 의존성 상세 설명

| 스타터 | 포함 항목 |
|--------|-----------|
| `starter-webflux` | `spring-webflux` + `reactor-netty`(내장 서버) + Jackson JSON |
| `starter-data-mongodb-reactive` | `mongodb-driver-reactivestreams` + `spring-data-mongodb` + Reactor 어댑터 |
| `reactor-test` | `StepVerifier` 등 리액티브 스트림 테스트 유틸 (Ch.16에서 상세 설명) |

> **주의**: `spring-boot-starter-web`(Spring MVC)을 함께 추가하지 않도록 주의해야 한다. 만약 둘을 함께 설정하면 Spring이 MVC를 우선 적용하여 Netty 대신 Tomcat이 구동되기 때문이다.

### 5.3.3 Gradle Wrapper 버전 관리

```bash
./gradlew --version                        # 현재 버전 확인
./gradlew wrapper --gradle-version=8.12    # 업그레이드
```

---

## 5.4 application.yml 설정

기본으로 생성되는 `application.properties` 파일은 삭제하고 `application.yml`을 새로 만든다. YAML 형식이 설정 항목의 위계를 표현하는 데 훨씬 편하기 때문이다.

### 5.4.1 기본 설정 (application.yml)

```yaml
spring:
  application:
    name: webflux-mongo-demo
  data:
    mongodb:
      uri: mongodb://appuser:apppass@localhost:27017/webflux_demo?authSource=admin
  jackson:
    default-property-inclusion: non_null
    serialization:
      write-dates-as-timestamps: false
    deserialization:
      fail-on-unknown-properties: false

server:
  port: 8080
  netty:
    connection-timeout: 5000
    idle-timeout: 15000

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,env
  endpoint:
    health:
      show-details: when-authorized

logging:
  level:
    root: INFO
    com.example.webfluxmongodemo: DEBUG
    org.springframework.data.mongodb: DEBUG
    reactor.netty: INFO
  pattern:
    console: "%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
```

### 5.4.2 프로파일별 설정

Spring Boot에서는 `application-{profile}.yml` 형식으로 파일을 나누면, 환경에 따라 다른 설정을 쉽게 적용할 수 있다.

**application-local.yml (로컬 개발)**

```yaml
spring:
  data:
    mongodb:
      uri: mongodb://appuser:apppass@localhost:27017/webflux_demo?authSource=admin
  devtools:
    restart:
      enabled: true
      poll-interval: 2s
      quiet-period: 1s

logging:
  level:
    com.example.webfluxmongodemo: DEBUG
    org.springframework.data.mongodb.core.ReactiveMongoTemplate: DEBUG
```

**application-prod.yml (운영)**

```yaml
spring:
  data:
    mongodb:
      uri: ${MONGODB_URI}    # 환경 변수에서 주입

server:
  port: ${SERVER_PORT:8080}   # 환경 변수 없으면 8080 기본값

logging:
  level:
    root: WARN
    com.example.webfluxmongodemo: INFO
    org.springframework.data.mongodb: WARN
```

**프로파일 활성화 방법**

```bash
java -jar app.jar --spring.profiles.active=local      # JVM 옵션
export SPRING_PROFILES_ACTIVE=local                    # 환경 변수
```

### 5.4.3 MongoDB 연결 URI 상세

MongoDB 연결 문자열의 형식을 제대로 알아두면, 여러 환경에 유연하게 대응할 수 있다.

```
mongodb://[username:password@]host[:port]/database[?options]
```

| 옵션 | 설명 | 예시 |
|------|------|------|
| `authSource` | 인증 DB | `authSource=admin` |
| `replicaSet` | 복제 세트 이름 | `replicaSet=rs0` |
| `maxPoolSize` | 커넥션 풀 최대 크기 | `maxPoolSize=50` |
| `connectTimeoutMS` | 연결 타임아웃 | `connectTimeoutMS=5000` |
| `ssl` | SSL/TLS 사용 여부 | `ssl=true` |

**복제 세트 연결 예시**

```yaml
spring:
  data:
    mongodb:
      uri: mongodb://user:pass@host1:27017,host2:27017,host3:27017/mydb?replicaSet=rs0&readPreference=secondaryPreferred
```

---

## 5.5 MongoDB Docker 컨테이너 구성

### 5.5.1 docker-compose.yml 작성

이제 MongoDB를 Docker로 실행하기 위한 설정 파일을 만들어보자.

```yaml
version: "3.9"

services:
  # ──────────────────────────────────────────────
  # MongoDB
  # ──────────────────────────────────────────────
  mongodb:
    image: mongo:7.0
    container_name: webflux-mongo
    restart: unless-stopped
    ports:
      - "27017:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: admin1234
      MONGO_INITDB_DATABASE: webflux_demo
    volumes:
      - mongo-data:/data/db                  # 데이터 영속화
      - ./docker/mongo-init.js:/docker-entrypoint-initdb.d/init.js:ro  # 초기화 스크립트
    command: ["mongod", "--bind_ip_all"]
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

  # ──────────────────────────────────────────────
  # Mongo Express (선택 — 웹 기반 관리 도구)
  # ──────────────────────────────────────────────
  mongo-express:
    image: mongo-express:1.0
    container_name: webflux-mongo-express
    restart: unless-stopped
    ports:
      - "8081:8081"
    environment:
      ME_CONFIG_MONGODB_ADMINUSERNAME: admin
      ME_CONFIG_MONGODB_ADMINPASSWORD: admin1234
      ME_CONFIG_MONGODB_URL: mongodb://admin:admin1234@mongodb:27017/
      ME_CONFIG_BASICAUTH: "false"
    depends_on:
      mongodb:
        condition: service_healthy

volumes:
  mongo-data:
    driver: local
```

### 5.5.2 초기화 스크립트

MongoDB 컨테이너가 처음 시작될 때 자동으로 애플리케이션용 사용자와 데이터베이스를 만들어두면 편하다. `docker/mongo-init.js` 파일로 이를 구현한다.

```javascript
// docker/mongo-init.js
// MongoDB 컨테이너 최초 실행 시 1회 실행된다.

// 애플리케이션 전용 사용자 생성
db = db.getSiblingDB("webflux_demo");

db.createUser({
    user: "appuser",
    pwd: "apppass",
    roles: [
        { role: "readWrite", db: "webflux_demo" }
    ]
});

// 초기 컬렉션 생성 (선택)
db.createCollection("users");
db.createCollection("posts");

print("===== MongoDB 초기화 완료 =====");
```

### 5.5.3 Docker Compose 실행

```bash
docker compose up -d                    # 컨테이너 시작 (백그라운드)
docker compose logs -f mongodb          # 로그 확인
docker compose ps                       # 상태 확인
docker compose down                     # 중지
docker compose down -v                  # 중지 + 볼륨 삭제 (데이터 초기화)
```

**정상 동작 확인**

```bash
docker exec -it webflux-mongo mongosh -u appuser -p apppass \
  --authenticationDatabase admin webflux_demo

# 셸 내부에서
db.users.insertOne({ name: "테스트", email: "test@example.com" })
db.users.find()
```

### 5.5.4 .env 파일로 민감 정보 분리

docker-compose.yml에 비밀번호를 하드코딩하는 것은 좋지 않다. `.env` 파일로 분리하고 `.gitignore`에 추가하면 더 안전하다.

```properties
# .env (git에 포함시키지 않는다)
MONGO_ROOT_USERNAME=admin
MONGO_ROOT_PASSWORD=admin1234
```

```yaml
# docker-compose.yml에서 환경 변수 참조
environment:
  MONGO_INITDB_ROOT_USERNAME: ${MONGO_ROOT_USERNAME}
  MONGO_INITDB_ROOT_PASSWORD: ${MONGO_ROOT_PASSWORD}
```

---

## 5.6 프로젝트 구조 설계

프로젝트 규모가 커질수록 패키지 조직이 중요해진다. 코드를 찾기 쉽고 수정하기 좋으려면 초반부터 좋은 구조를 잡아야 한다. 널리 쓰이는 두 가지 접근법을 비교해보고, 이 책에서 권장하는 방식을 소개한다.

### 5.6.1 계층형 vs 도메인형 비교

| 구분 | 계층형 (Layer-based) | 도메인형 (Domain-based) |
|------|---------------------|------------------------|
| 패키지 분류 기준 | 기술적 역할 (`controller/`, `service/`, `repository/`) | 비즈니스 도메인 (`user/`, `post/`, `comment/`) |
| 장점 | 구조 단순, Spring 입문자에게 친숙 | 관련 코드가 한 곳에 모여 파악·수정 용이, MSA 분리에 유리 |
| 단점 | 프로젝트가 커지면 도메인 간 경계 불명확, 수정 시 패키지 넘나듦 | 초반에 과도한 분리처럼 느껴질 수 있음 |

### 5.6.2 본서의 권장 구조 — 도메인형 하이브리드

이 책에서는 도메인형 구조를 기본으로 삼으면서도, 설정이나 예외 처리처럼 여러 도메인에서 공통으로 쓰는 코드는 `global/` 패키지에 모아둔다. 이런 절충적인 방식이 실무에서 잘 먹혀간다.

```
webflux-mongo-demo/
├── build.gradle.kts
├── settings.gradle.kts
├── docker-compose.yml
├── docker/
│   └── mongo-init.js
├── .env
├── .gitignore
└── src/
    ├── main/
    │   ├── java/com/example/webfluxmongodemo/
    │   │   │
    │   │   ├── WebfluxMongoDemoApplication.java   ← 메인 클래스
    │   │   │
    │   │   ├── global/                            ← 전역 공통 모듈
    │   │   │   ├── config/
    │   │   │   │   ├── MongoConfig.java
    │   │   │   │   ├── WebFluxConfig.java
    │   │   │   │   └── SecurityConfig.java
    │   │   │   ├── exception/
    │   │   │   │   ├── GlobalExceptionHandler.java
    │   │   │   │   ├── ErrorResponse.java
    │   │   │   │   └── BusinessException.java
    │   │   │   └── util/
    │   │   │       └── DateUtils.java
    │   │   │
    │   │   ├── user/                              ← 사용자 도메인
    │   │   │   ├── domain/
    │   │   │   │   └── User.java
    │   │   │   ├── dto/
    │   │   │   │   ├── UserCreateRequest.java
    │   │   │   │   ├── UserUpdateRequest.java
    │   │   │   │   └── UserResponse.java
    │   │   │   ├── repository/
    │   │   │   │   └── UserRepository.java
    │   │   │   ├── service/
    │   │   │   │   └── UserService.java
    │   │   │   └── controller/
    │   │   │       └── UserController.java
    │   │   │
    │   │   └── post/                              ← 게시글 도메인
    │   │       ├── domain/
    │   │       │   └── Post.java
    │   │       ├── dto/
    │   │       │   ├── PostCreateRequest.java
    │   │       │   └── PostResponse.java
    │   │       ├── repository/
    │   │       │   └── PostRepository.java
    │   │       ├── service/
    │   │       │   └── PostService.java
    │   │       └── controller/
    │   │           └── PostController.java
    │   │
    │   └── resources/
    │       ├── application.yml
    │       ├── application-local.yml
    │       └── application-prod.yml
    │
    └── test/
        └── java/com/example/webfluxmongodemo/
            ├── user/
            │   ├── UserServiceTest.java
            │   └── UserControllerTest.java
            └── post/
                ├── PostServiceTest.java
                └── PostControllerTest.java
```

### 5.6.3 핵심 클래스 골격 코드

구조를 설정했으니 이제 각 계층의 기본 틀을 만들어 보자. 세부 로직은 다음 장에서 채워 넣을 것이다.

**메인 클래스**

```java
package com.example.webfluxmongodemo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class WebfluxMongoDemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(WebfluxMongoDemoApplication.class, args);
    }
}
```

**도메인 (Document)**

```java
package com.example.webfluxmongodemo.user.domain;

import lombok.*;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.index.Indexed;

import java.time.LocalDateTime;

@Document(collection = "users")     // MongoDB 컬렉션 매핑
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Builder
public class User {

    @Id
    private String id;              // MongoDB의 _id에 매핑

    @Indexed(unique = true)         // 고유 인덱스 자동 생성
    private String email;

    private String name;
    private String password;

    @CreatedDate
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;

    public void updateName(String name) {
        this.name = name;
    }
}
```

**리포지토리**

```java
package com.example.webfluxmongodemo.user.repository;

import com.example.webfluxmongodemo.user.domain.User;
import org.springframework.data.mongodb.repository.ReactiveMongoRepository;
import reactor.core.publisher.Mono;

public interface UserRepository extends ReactiveMongoRepository<User, String> {

    Mono<User> findByEmail(String email);

    Mono<Boolean> existsByEmail(String email);
}
```

> `ReactiveMongoRepository`는 `ReactiveCrudRepository`를 상속받으면서 메서드들이 모두 `Mono`나 `Flux`를 반환한다. 덕분에 어디서도 블로킹이 일어나지 않는다.

**서비스**

```java
package com.example.webfluxmongodemo.user.service;

import com.example.webfluxmongodemo.user.domain.User;
import com.example.webfluxmongodemo.user.dto.UserCreateRequest;
import com.example.webfluxmongodemo.user.dto.UserResponse;
import com.example.webfluxmongodemo.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Service
@RequiredArgsConstructor
public class UserService {

    private final UserRepository userRepository;

    public Mono<UserResponse> createUser(UserCreateRequest request) {
        User user = User.builder()
                .email(request.email())
                .name(request.name())
                .password(request.password())   // 실제로는 암호화 필수
                .build();

        return userRepository.save(user)
                .map(UserResponse::from);
    }

    public Mono<UserResponse> getUserById(String id) {
        return userRepository.findById(id)
                .map(UserResponse::from)
                .switchIfEmpty(Mono.error(
                    new IllegalArgumentException("사용자를 찾을 수 없습니다: " + id)
                ));
    }

    public Flux<UserResponse> getAllUsers() {
        return userRepository.findAll()
                .map(UserResponse::from);
    }

    public Mono<Void> deleteUser(String id) {
        return userRepository.deleteById(id);
    }
}
```

**DTO (Java Record 활용)**

```java
package com.example.webfluxmongodemo.user.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public record UserCreateRequest(
    @NotBlank(message = "이름은 필수입니다")
    String name,

    @NotBlank(message = "이메일은 필수입니다")
    @Email(message = "올바른 이메일 형식이 아닙니다")
    String email,

    @NotBlank(message = "비밀번호는 필수입니다")
    @Size(min = 8, message = "비밀번호는 8자 이상이어야 합니다")
    String password
) {}
```

```java
package com.example.webfluxmongodemo.user.dto;

import com.example.webfluxmongodemo.user.domain.User;
import java.time.LocalDateTime;

public record UserResponse(
    String id,
    String name,
    String email,
    LocalDateTime createdAt
) {
    public static UserResponse from(User user) {
        return new UserResponse(
            user.getId(),
            user.getName(),
            user.getEmail(),
            user.getCreatedAt()
        );
    }
}
```

**컨트롤러**

```java
package com.example.webfluxmongodemo.user.controller;

import com.example.webfluxmongodemo.user.dto.UserCreateRequest;
import com.example.webfluxmongodemo.user.dto.UserResponse;
import com.example.webfluxmongodemo.user.service.UserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono<UserResponse> createUser(@Valid @RequestBody UserCreateRequest request) {
        return userService.createUser(request);
    }

    @GetMapping("/{id}")
    public Mono<UserResponse> getUser(@PathVariable String id) {
        return userService.getUserById(id);
    }

    @GetMapping
    public Flux<UserResponse> getAllUsers() {
        return userService.getAllUsers();
    }

    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public Mono<Void> deleteUser(@PathVariable String id) {
        return userService.deleteUser(id);
    }
}
```

**MongoDB 설정 클래스**

```java
package com.example.webfluxmongodemo.global.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.mongodb.config.EnableReactiveMongoAuditing;
import org.springframework.data.mongodb.repository.config.EnableReactiveMongoRepositories;

@Configuration
@EnableReactiveMongoRepositories(
    basePackages = "com.example.webfluxmongodemo"
)
@EnableReactiveMongoAuditing   // @CreatedDate, @LastModifiedDate 활성화
public class MongoConfig {
    // ReactiveMongoClient는 Spring Boot가 자동 구성한다.
    // 커스텀 설정이 필요한 경우에만 Bean을 등록한다.
}
```

### 5.6.4 프로젝트 실행 및 검증

```bash
docker compose up -d                                          # MongoDB 시작
./gradlew bootRun --args='--spring.profiles.active=local'     # 애플리케이션 시작
```

정상적으로 구동되면 `Netty started on port 8080` 같은 로그가 나타날 것이다. 간단한 헬스 체크로 검증해 보자.

```bash
# 헬스 체크 — mongo 컴포넌트가 UP이면 성공
curl http://localhost:8080/actuator/health

# 사용자 생성
curl -X POST http://localhost:8080/api/users \
  -H "Content-Type: application/json" \
  -d '{"name":"홍길동","email":"hong@example.com","password":"password1234"}'

# 사용자 조회
curl http://localhost:8080/api/users
```

---

## 정리

이 장에서 다룬 개발 환경 구성을 한눈에 정리하면 이렇다.

| 항목 | 도구/설정 |
|------|-----------|
| JDK | 21 (SDKMAN으로 관리) |
| IDE | IntelliJ IDEA + Lombok, Docker 플러그인 |
| 빌드 도구 | Gradle 8.12 + Kotlin DSL |
| 웹 프레임워크 | Spring WebFlux (Netty) |
| 데이터베이스 | MongoDB 7.0 (Docker) |
| 데이터 접근 | Spring Data Reactive MongoDB |
| 설정 관리 | application.yml + 프로파일 분리 |
| 프로젝트 구조 | 도메인형 하이브리드 |

### 이 책에서 사용하는 주요 라이브러리 버전

이 책의 예제 코드에서 사용하는 주요 의존성 버전을 아래 표에 정리했다. Spring Boot의 의존성 관리(BOM)가 대부분 자동으로 처리해 주지만, 직접 명시해야 하는 라이브러리도 있으니 참고하기 바란다.

| 분류 | 라이브러리 | 버전 |
|------|-----------|------|
| **프레임워크** | Spring Boot | 3.5.11 |
| | io.spring.dependency-management (Gradle 플러그인) | 1.1.7 |
| **보안/인증** | jjwt (io.jsonwebtoken) | 0.13.0 |
| **API 문서** | SpringDoc OpenAPI (springdoc-openapi-starter-webflux-ui) | 2.8.4 |
| **복원력** | Resilience4j | 2.3.0 |
| **캐시** | Caffeine | 3.2.3 |
| **속도 제한** | Bucket4j (bucket4j-core) | 8.16.1 |
| **테스트** | Testcontainers | 1.20.4 |
| | Flapdoodle Embedded MongoDB (spring3x) | 4.23.0 |
| | OkHttp MockWebServer | 4.12.0 |
| | BlockHound | 1.0.15.RELEASE |
| **모니터링** | Logstash Logback Encoder | 9.0 |
| **성능 테스트** | JMH Gradle Plugin (me.champeau.jmh) | 0.7.3 |
| | Gatling Gradle Plugin | 3.14.9.8 |
| **배포** | Jib (com.google.cloud.tools.jib) | 3.5.3 |
| | GraalVM Native Build Tools | 0.11.4 |

> **참고**: Spring Boot BOM이 관리하는 의존성(Spring Security, Spring Data, Reactor, Netty 등)은 Spring Boot 버전에 맞는 호환 버전이 자동으로 적용되므로 별도로 명시하지 않아도 된다.

다음 장부터 이 환경 위에서 실제 REST API를 구현해 보자. 도메인 모델을 정의하고 Repository, Service, Controller의 구체적인 로직을 채워 넣은 뒤, API를 테스트해 보는 과정까지 다룰 것이다.
