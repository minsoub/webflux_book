# Chapter 3. Project Reactor 핵심

Project Reactor는 Spring WebFlux의 리액티브 프로그래밍을 뒷받침하는 핵심 라이브러리다. 이 장에서는 Reactor의 두 가지 핵심 타입인 `Mono`와 `Flux`부터 시작하여, 실전에서 자주 마주치는 연산자들, 에러 처리 전략, 스레드 제어를 위한 스케줄러, 그리고 디버깅 기법까지 차근차근 살펴보기로 한다.

---

## 3.1 Mono와 Flux 이해하기

### 3.1.1 Mono: 0..1개의 요소

`Mono<T>`는 **최대 1개의 요소**를 발행하는 Publisher다. 데이터베이스에서 단일 레코드를 조회하거나 HTTP 요청의 응답을 처리할 때 사용하게 되는 기본적인 타입이다.

```java
// 값이 있는 Mono
Mono<String> mono = Mono.just("Hello Reactor");

// 빈 Mono (값 없이 완료)
Mono<String> empty = Mono.empty();

// 에러를 발행하는 Mono
Mono<String> error = Mono.error(new RuntimeException("오류 발생"));
```

### 3.1.2 Flux: 0..N개의 요소

이제 `Flux<T>`는 **0개에서 N개까지의 요소**를 발행할 수 있는 Publisher다. 컬렉션의 데이터를 스트리밍하거나 실시간 이벤트를 계속 흘려 보내야 할 때 자연스럽게 선택하게 되는 타입이기도 하다.

```java
// 여러 값을 가진 Flux
Flux<String> flux = Flux.just("Spring", "WebFlux", "Reactor");

// 리스트에서 Flux 생성
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Flux<Integer> fromList = Flux.fromIterable(numbers);

// 범위로 생성
Flux<Integer> range = Flux.range(1, 10); // 1부터 10까지
```

### 3.1.3 다양한 생성 방법

실제로 Mono와 Flux를 만드는 방법은 상황에 따라 달라진다. 단순한 값부터 복잡한 비동기 작업까지, 다양한 시나리오에 맞게 여러 팩토리 메서드를 활용할 수 있다.

```java
// defer: 구독 시점에 Mono/Flux를 생성 (Lazy 평가)
Mono<Long> deferred = Mono.defer(() -> Mono.just(System.currentTimeMillis()));

// fromCallable: Callable로부터 Mono 생성
Mono<String> fromCallable = Mono.fromCallable(() -> {
    // 블로킹 작업도 래핑 가능
    return someBlockingMethod();
});

// create: 프로그래밍 방식으로 Flux 생성 (비동기 브릿지)
Flux<String> created = Flux.create(sink -> {
    sink.next("첫 번째");
    sink.next("두 번째");
    sink.next("세 번째");
    sink.complete();
});

// generate: 동기적으로 하나씩 값을 생성
Flux<Integer> generated = Flux.generate(
    () -> 0,                        // 초기 상태
    (state, sink) -> {
        sink.next(state);
        if (state == 9) sink.complete();
        return state + 1;           // 다음 상태
    }
);

// interval: 일정 간격으로 값 발행 (0부터 증가하는 Long)
Flux<Long> interval = Flux.interval(Duration.ofSeconds(1));
```

### 3.1.4 구독(subscribe)의 의미와 동작

Reactor를 다루면서 가장 먼저 깨닫게 되는 핵심 원칙이 있다. 바로 **"구독이 없으면 아무것도 실행되지 않는다"** 는 점이다. 아무리 화려한 `Mono`와 `Flux` 파이프라인을 구성했어도, `subscribe()`를 명시적으로 호출하기 전까지는 정말 아무 일도 벌어지지 않기 때문이다.

```java
Flux<Integer> pipeline = Flux.range(1, 5)
    .map(i -> i * 2)
    .filter(i -> i > 4);

// subscribe()를 호출하지 않으면 위 코드는 아무 것도 실행하지 않는다.

// 기본 구독
pipeline.subscribe();

// 값 소비자 지정
pipeline.subscribe(
    value -> System.out.println("값: " + value)
);

// 값, 에러, 완료 핸들러 지정
pipeline.subscribe(
    value -> System.out.println("값: " + value),
    error -> System.err.println("에러: " + error.getMessage()),
    () -> System.out.println("완료!")
);

```

> **주의**: Spring WebFlux에서는 프레임워크가 자동으로 구독을 처리한다. 컨트롤러에서 `Mono`나 `Flux`를 반환하면 WebFlux가 내부적으로 `subscribe()`를 호출하므로, 직접 `subscribe()`를 호출할 필요가 없다. 오히려 직접 호출하면 예기치 않은 동작이 발생할 수 있다.

---

## 3.2 Reactor의 주요 연산자

Reactor 개발에서 대부분의 시간을 쓰게 되는 부분이 바로 연산자 조합이다. 데이터를 변환하고, 필터링하고, 결합하는 다양한 연산자들을 어떻게 조합하느냐가 리액티브 코드의 질을 크게 좌우한다.

### 3.2.1 변환 연산자

#### map: 동기 변환

가장 기본적인 변환 연산자다. 각 요소를 동기적으로 1:1로 변환한다.

```java
Flux<String> upperCase = Flux.just("spring", "webflux", "reactor")
    .map(String::toUpperCase);
// 결과: "SPRING", "WEBFLUX", "REACTOR"
```

#### flatMap: 비동기 변환 (순서 보장 X)

필자의 경험상, 리액티브 코드에서 가장 자주 사용되는 연산자 중 하나가 바로 이것이다. 각 요소를 `Publisher`로 변환하고 결과들을 병합해주는데, **순서는 보장하지 않는 대신** 동시에 여러 내부 Publisher를 구독하기 때문에 처리량이 우수하다.

```java
Flux<User> users = Flux.just(1L, 2L, 3L)
    .flatMap(id -> userRepository.findById(id));
// 결과 순서: id=2 응답이 먼저 올 수 있음
```

#### flatMapSequential: 비동기 변환 (순서 보장)

`flatMap`과 동일하게 동시 실행하되, **원래 순서를 보장**한다.

```java
Flux<User> users = Flux.just(1L, 2L, 3L)
    .flatMapSequential(id -> userRepository.findById(id));
// 결과 순서: id=1, id=2, id=3 순서 보장
```

#### concatMap: 순차 비동기 변환

각 요소를 순차적으로 처리하기 때문에 **순서가 보장**된다는 점이 매력이다. 다만 이전 요소의 처리가 완료되어야 다음 요소를 처리할 수 있으므로, 처리량이 필요한 경우라면 `flatMapSequential`보다는 떨어질 수 밖에 없다.

```java
Flux<User> users = Flux.just(1L, 2L, 3L)
    .concatMap(id -> userRepository.findById(id));
// id=1 조회 완료 -> id=2 조회 시작 -> id=2 완료 -> id=3 조회 시작
```

#### flatMap vs flatMapSequential vs concatMap 비교

| 연산자 | 동시 실행 | 순서 보장 | 사용 시기 |
|--------|----------|----------|----------|
| `flatMap` | O | X | 순서 무관, 최대 처리량 필요 |
| `flatMapSequential` | O | O | 동시 실행 + 순서 보장 |
| `concatMap` | X | O | 순차 처리 필수 |

### 3.2.2 필터링 연산자

스트림에서 일부 요소를 걸러내거나, 특정 개수만 취하는 작업들은 매우 일반적이다. 이를 위한 필터링 연산자들을 살펴보자.

```java
Flux<Integer> numbers = Flux.range(1, 20);

// filter: 조건에 맞는 요소만 통과
Flux<Integer> evenNumbers = numbers.filter(n -> n % 2 == 0);
// 결과: 2, 4, 6, 8, 10, 12, 14, 16, 18, 20

// take: 처음 N개만 가져오기
Flux<Integer> firstThree = numbers.take(3);
// 결과: 1, 2, 3

// skip: 처음 N개 건너뛰기
Flux<Integer> skipped = numbers.skip(17);
// 결과: 18, 19, 20

// distinct: 중복 제거
Flux<String> unique = Flux.just("A", "B", "A", "C", "B")
    .distinct();
// 결과: "A", "B", "C"

// distinctUntilChanged: 연속 중복 제거
Flux<String> changed = Flux.just("A", "A", "B", "B", "A")
    .distinctUntilChanged();
// 결과: "A", "B", "A"
```

### 3.2.3 결합 연산자

여러 개의 Publisher를 하나로 조합해야 할 때가 있다. 상황에 따라 어떤 방식으로 결합할지 선택하는 것이 중요하다.

#### zip: 각 Publisher의 요소를 쌍으로 결합

```java
Mono<String> name = Mono.just("홍길동");
Mono<Integer> age = Mono.just(30);

Mono<String> combined = Mono.zip(name, age)
    .map(tuple -> tuple.getT1() + "님은 " + tuple.getT2() + "세입니다.");
// 결과: "홍길동님은 30세입니다."

// Flux에서의 zip
Flux<String> names = Flux.just("Alice", "Bob", "Charlie");
Flux<Integer> scores = Flux.just(95, 87, 92);

Flux<String> results = Flux.zip(names, scores)
    .map(tuple -> tuple.getT1() + ": " + tuple.getT2() + "점");
// 결과: "Alice: 95점", "Bob: 87점", "Charlie: 92점"
```

#### merge: 여러 Publisher를 인터리빙 방식으로 병합

여러 Publisher의 데이터가 뒤섞여서 흐르도록 만든다. 요소가 발행되는 즉시 하류로 전달되므로, 순서는 결국 도착 순이 된다.

```java
Flux<String> fast = Flux.interval(Duration.ofMillis(100))
    .map(i -> "FAST-" + i).take(3);
Flux<String> slow = Flux.interval(Duration.ofMillis(200))
    .map(i -> "SLOW-" + i).take(3);

Flux<String> merged = Flux.merge(fast, slow);
// 도착 순서대로 병합: FAST-0, FAST-1, SLOW-0, FAST-2, SLOW-1, SLOW-2
```

#### concat: 순서를 유지하며 병합

merge와 달리, concat은 엄격하게 순서를 유지한다. 첫 번째 Publisher가 완료될 때까지 두 번째 Publisher는 구독하지 않기 때문이다.

```java
Flux<String> first = Flux.just("1", "2", "3");
Flux<String> second = Flux.just("A", "B", "C");

Flux<String> concatenated = Flux.concat(first, second);
// 결과: "1", "2", "3", "A", "B", "C" (항상 이 순서)
```

#### combineLatest: 각 Publisher의 최신 값 결합

어느 한 Publisher에서 새로운 값이 나타나면, 다른 Publisher들의 최신 값과 함께 결합해서 내보낸다. 시시각각 변하는 여러 스트림을 조합해야 할 때 매우 유용하다.

```java
Flux<String> letters = Flux.just("A", "B", "C")
    .delayElements(Duration.ofMillis(100));
Flux<Integer> numbers = Flux.just(1, 2, 3)
    .delayElements(Duration.ofMillis(150));

Flux<String> combined = Flux.combineLatest(
    letters, numbers,
    (letter, number) -> letter + number
);
// 최신 값끼리 결합: A1, B1, B2, C2, C3 (타이밍에 따라 다를 수 있음)
```

### 3.2.4 집계 연산자

스트림의 모든 요소를 모아서 하나의 값으로 축약하거나, 컬렉션으로 수집해야 할 때가 있다. 이런 종료 연산자(terminal operator)들을 알아보자.

```java
Flux<Integer> numbers = Flux.just(3, 1, 4, 1, 5, 9, 2, 6);

// reduce: 모든 요소를 하나로 축약
Mono<Integer> sum = numbers.reduce(0, Integer::sum);
// 결과: 31

// count: 요소 개수
Mono<Long> count = numbers.count();
// 결과: 8

// collectList: 모든 요소를 List로 수집
Mono<List<Integer>> list = numbers.collectList();
// 결과: [3, 1, 4, 1, 5, 9, 2, 6]

// collectMap: 요소를 Map으로 수집
Flux<User> users = userRepository.findAll();
Mono<Map<String, User>> userMap = users
    .collectMap(User::getId, user -> user);

```

### 3.2.5 유용한 유틸리티 연산자

실제 개발에서 자주 만나는 상황들을 다루기 위한 편의 연산자들이 있다. 에러 처리와 부수 효과, 타임아웃 설정 등을 간편하게 처리할 수 있다.

```java
// switchIfEmpty: 빈 결과일 때 대체 Publisher 사용
Mono<User> user = userRepository.findById(id)
    .switchIfEmpty(Mono.error(
        new NotFoundException("사용자를 찾을 수 없습니다: " + id)
    ));

// defaultIfEmpty: 빈 결과일 때 기본값 사용
Mono<String> config = configRepository.findByKey("timeout")
    .defaultIfEmpty("30");

// doOnNext, doOnError, doOnComplete: 부수 효과 (사이드 이펙트)
Flux<User> usersWithLog = userRepository.findAll()
    .doOnNext(u -> log.info("조회된 사용자: {}", u.getName()))
    .doOnError(e -> log.error("조회 실패", e))
    .doOnComplete(() -> log.info("전체 사용자 조회 완료"));

// timeout: 지정 시간 내에 값이 없으면 에러
Mono<User> userWithTimeout = userRepository.findById(id)
    .timeout(Duration.ofSeconds(5));
```

---

## 3.3 에러 처리 전략

리액티브 스트림 세상에서는 에러 발생 시 즉시 스트림이 종료되어 버린다. 따라서 에러를 어떻게 다룰지를 미리 설계하는 것이 매우 중요하다. 다행히 Reactor는 다양한 전략을 구현할 수 있도록 풍부한 에러 처리 연산자들을 제공한다.

### 3.3.1 onErrorReturn: 기본값으로 대체

가장 간단한 에러 처리 방식이다. 에러가 터지면 그냥 정해진 기본값을 반환하고 스트림을 정상적으로 완료해버린다.

```java
Mono<String> result = externalApi.getData()
    .onErrorReturn("기본값");

// 특정 예외 타입에만 적용
Mono<String> result2 = externalApi.getData()
    .onErrorReturn(TimeoutException.class, "시간 초과 - 기본값 사용");
```

### 3.3.2 onErrorResume: 대체 Publisher로 전환

단순한 기본값이 아니라, 복잡한 폴백(fallback) 로직이 필요할 때 사용한다. 에러가 나면 다른 Publisher로 전환해서 재시도하는 식의 고급 처리가 가능하다.

```java
Mono<User> user = primaryDb.findById(id)
    .onErrorResume(e -> {
        log.warn("Primary DB 실패, Secondary DB로 전환", e);
        return secondaryDb.findById(id);
    });

// 에러 타입별 분기 처리
Mono<String> data = externalService.call()
    .onErrorResume(TimeoutException.class, e -> cachedService.getCached())
    .onErrorResume(ServiceUnavailableException.class, e -> Mono.just("서비스 점검 중"));
```

### 3.3.3 onErrorMap: 에러를 다른 에러로 변환

하위 계층에서 발생한 저수준의 예외를 비즈니스 계층에 맞는 고수준의 예외로 변환하는 데 쓰인다.

```java
Mono<User> user = userRepository.findById(id)
    .switchIfEmpty(Mono.error(new UserNotFoundException(id)))
    .onErrorMap(DataAccessException.class, e ->
        new ServiceException("데이터 접근 오류", e)
    );
```

### 3.3.4 doOnError: 에러 발생 시 부수 효과

스트림의 흐름 자체는 변경하지 않되, 에러가 발생했을 때 로깅이나 메트릭 수집 같은 부가 작업을 덧붙일 때 사용한다.

```java
Mono<User> user = userRepository.findById(id)
    .doOnError(e -> {
        log.error("사용자 조회 중 에러 발생. id={}", id, e);
        metrics.incrementErrorCount("user.findById");
    })
    .onErrorResume(e -> Mono.empty());
```

### 3.3.5 retry: 단순 재시도

에러가 나면 그냥 정해진 횟수만큼 다시 구독을 시도한다. 간단하지만, 많은 경우 이것만으로도 충분하다.

```java
Mono<String> result = externalApi.call()
    .retry(3); // 최대 3회 재시도
```

### 3.3.6 retryWhen: 고급 재시도 전략

단순 재시도로는 부족할 때, `Retry` 스펙을 활용하면 백오프(backoff) 전략이나 조건부 재시도 같은 정교한 정책을 구현할 수 있다.

```java
import reactor.util.retry.Retry;

Mono<String> result = externalApi.call()
    .retryWhen(Retry.backoff(3, Duration.ofSeconds(1))
        .maxBackoff(Duration.ofSeconds(10))
        .jitter(0.5)
        .filter(throwable -> throwable instanceof ServiceUnavailableException)
        .onRetryExhaustedThrow((retryBackoffSpec, retrySignal) ->
            new ServiceException(
                "재시도 횟수 초과. 마지막 에러: " + retrySignal.failure().getMessage(),
                retrySignal.failure()
            )
        )
    );
```

### 3.3.7 실전 에러 처리 패턴

이제까지 배운 기법들을 모두 조합하면, 실제 서비스 계층에서 견고한 에러 처리를 만들 수 있다. 다음 코드는 캐시 조회, DB 폴백, 타임아웃, 재시도를 모두 포함한 현실적인 예제다.

```java
@Service
@RequiredArgsConstructor
public class UserService {

    private final ReactiveMongoTemplate mongoTemplate;
    private final UserCacheService cacheService;
    private static final Logger log = LoggerFactory.getLogger(UserService.class);

    public Mono<User> findUserById(String id) {
        return cacheService.getCachedUser(id)            // 1. 캐시 조회
            .switchIfEmpty(
                mongoTemplate.findById(id, User.class)   // 2. DB 조회
                    .doOnNext(user ->
                        cacheService.cacheUser(user)      // 3. 캐시 저장 (fire-and-forget 패턴으로,
                            .subscribe()                  //    캐시 실패가 메인 흐름에 영향을 주지 않도록 의도적으로 사용)
                    )
            )
            .switchIfEmpty(
                Mono.error(new UserNotFoundException(id)) // 4. 없으면 예외
            )
            .timeout(Duration.ofSeconds(5))               // 5. 타임아웃
            .doOnError(TimeoutException.class, e ->
                log.warn("사용자 조회 타임아웃. id={}", id)
            )
            .onErrorMap(TimeoutException.class, e ->
                new ServiceException("사용자 조회 시간 초과", e)
            )
            .retryWhen(Retry.backoff(2, Duration.ofMillis(500))
                .filter(e -> e instanceof DataAccessException)
            );
    }

    public Flux<User> searchUsers(String keyword) {
        Query query = new Query(
            Criteria.where("name").regex(keyword, "i")
        );

        return mongoTemplate.find(query, User.class)
            .onErrorResume(e -> {
                log.error("사용자 검색 실패. keyword={}", keyword, e);
                return Flux.empty();
            });
    }
}
```

---

## 3.4 스케줄러(Scheduler)와 스레드 모델

기본적으로 Reactor는 **호출자 스레드**(caller's thread)에서 동작한다는 점을 먼저 이해해야 한다. 이를 원하지 않는다면, 스케줄러를 통해 작업을 다른 스레드로 옮길 수 있다.

### 3.4.1 주요 스케줄러 종류

| 스케줄러 | 설명 | 스레드 수 | 사용 시기 |
|---------|------|----------|----------|
| `Schedulers.parallel()` | CPU 집약적 작업 | CPU 코어 수 | 계산, 변환 작업 |
| `Schedulers.boundedElastic()` | 블로킹 I/O 래핑 | 최대 10 * CPU 코어 | 블로킹 코드 감싸기 |
| `Schedulers.single()` | 단일 재사용 스레드 | 1 | 순차 실행 보장 |
| `Schedulers.immediate()` | 현재 스레드 | - | 테스트, 디폴트 |
| `Schedulers.fromExecutorService()` | 커스텀 스레드 풀 | 사용자 지정 | 특수한 요구사항 |

### 3.4.2 publishOn vs subscribeOn

이 둘은 이름이 비슷해서 자주 헷갈리지만, 실제로는 전혀 다른 동작을 한다. 정확히 이해하는 것이 리액티브 프로그래밍의 핵심이다.

#### publishOn: 하류 연산자의 실행 스레드를 변경

`publishOn`을 삽입한 지점 이후의 연산자들이 지정한 스케줄러에서 실행되도록 만든다. 파이프라인 중간에 갑자기 스레드를 바꿔야 할 때 딱 맞다.

```java
Flux.range(1, 5)
    .map(i -> {
        log.info("[map1] {} - {}", i, Thread.currentThread().getName());
        return i * 10;
    })
    .publishOn(Schedulers.parallel())   // 여기서부터 parallel 스레드
    .map(i -> {
        log.info("[map2] {} - {}", i, Thread.currentThread().getName());
        return i + 1;
    })
    .subscribe(i ->
        log.info("[subscribe] {} - {}", i, Thread.currentThread().getName())
    );

// map1은 main 스레드, publishOn 이후 map2와 subscribe는 parallel-1 스레드에서 실행
```

#### subscribeOn: 전체 구독 체인의 실행 스레드를 변경

이것은 소스의 구독 시점부터 시작되는 스레드를 변경한다. 파이프라인의 어디에 놓든 **소스 발행 부분의 스레드에만 영향**을 미친다는 점이 핵심이다.

```java
Mono.fromCallable(() -> {
        log.info("[callable] {}", Thread.currentThread().getName());
        return blockingIoOperation();
    })
    .subscribeOn(Schedulers.boundedElastic())  // 소스가 boundedElastic에서 실행
    .map(result -> processResult(result))
    .subscribe();
// callable, map, subscribe 모두 boundedElastic-1 스레드에서 실행
```

#### publishOn과 subscribeOn 함께 사용

```java
Flux.range(1, 3)
    .subscribeOn(Schedulers.single())          // 소스: single 스레드
    .map(i -> {
        log.info("[map1] {}", Thread.currentThread().getName()); // single-1
        return "값-" + i;
    })
    .publishOn(Schedulers.parallel())          // 이후: parallel 스레드
    .map(s -> {
        log.info("[map2] {}", Thread.currentThread().getName()); // parallel-1
        return s.toUpperCase();
    })
    .subscribe();
```

### 3.4.3 블로킹 코드를 감싸는 방법

리액티브 파이프라인 안에서 블로킹 코드를 부주의하게 호출하면 시스템 전체의 처리량이 참담해진다. 이벤트 루프 스레드 자체가 블로킹되기 때문이다. 불가피하게 레거시 블로킹 코드를 다뤄야 한다면, 반드시 `boundedElastic` 스케줄러로 격리해서 실행해야 한다.

```java
@Service
public class LegacyIntegrationService {

    private final LegacyBlockingClient legacyClient;

    // 잘못된 방법 - 이벤트 루프 스레드를 블로킹
    public Mono<String> wrongWay() {
        return Mono.just(legacyClient.blockingCall()); // 절대 이렇게 하지 말 것!
    }

    // 올바른 방법 - boundedElastic에서 블로킹 실행
    public Mono<String> correctWay() {
        return Mono.fromCallable(() -> legacyClient.blockingCall())
            .subscribeOn(Schedulers.boundedElastic());
    }

    // 여러 블로킹 호출을 병렬로 실행
    public Mono<AggregatedResult> parallelBlockingCalls() {
        Mono<String> call1 = Mono.fromCallable(() -> legacyClient.callServiceA())
            .subscribeOn(Schedulers.boundedElastic());

        Mono<String> call2 = Mono.fromCallable(() -> legacyClient.callServiceB())
            .subscribeOn(Schedulers.boundedElastic());

        return Mono.zip(call1, call2)
            .map(tuple -> new AggregatedResult(tuple.getT1(), tuple.getT2()));
    }
}
```

> **Tip**: 프로젝트에 `BlockHound` 라이브러리를 추가하면 이벤트 루프 스레드에서 블로킹 호출이 발생할 때 즉시 탐지할 수 있다. 19장에서 자세히 다룬다.

---

## 3.5 Cold vs Hot Publisher

실무에서 자주 보는 패턴인데, Mono와 Flux가 모두 같은 식으로 동작하는 것은 아니다. 언제 데이터를 발행하기 시작하고, 구독자들이 어떻게 그 데이터를 받는지에 따라 두 가지로 나뉜다.

### 3.5.1 Cold Publisher

Cold Publisher는 **구독이 들어올 때마다 데이터를 처음부터 새로 발행**한다. 대부분의 Reactor 연산자가 기본적으로 이런 식으로 작동한다.

```java
Flux<Long> coldFlux = Flux.defer(() -> {
    log.info("새로운 데이터 소스 생성");
    return Flux.just(System.currentTimeMillis());
});

// 구독자 1: 자신만의 데이터를 받음
coldFlux.subscribe(v -> log.info("구독자1: {}", v));

Thread.sleep(100);

// 구독자 2: 별도의 새로운 데이터를 받음 (다른 타임스탬프)
coldFlux.subscribe(v -> log.info("구독자2: {}", v));

// 각 구독자가 서로 다른 타임스탬프를 받음 (매번 새로 생성)
```

### 3.5.2 Hot Publisher

Hot Publisher는 정반대다. **구독 여부와 상관없이 계속 데이터를 발행**하며, 구독자들은 자신이 구독한 시점 이후의 데이터만 수신한다.

```java
// ConnectableFlux로 Hot Publisher 만들기
Flux<Long> hotFlux = Flux.interval(Duration.ofSeconds(1))
    .publish()
    .autoConnect(2); // 2명이 구독하면 자동 시작

// 구독자 1
hotFlux.subscribe(v -> log.info("구독자1: {}", v));

Thread.sleep(1500);

// 구독자 2가 연결되면 발행 시작, 구독자2는 중간부터 수신
hotFlux.subscribe(v -> log.info("구독자2: {}", v));
```

### 3.5.3 Sinks를 활용한 Hot Publisher 생성

Hot Publisher를 명시적으로 만들기 위해서는 `Sinks`를 사용한다. Reactor 3.4부터 도입된 이것은 기존의 `Processor`를 현대적으로 개선한 버전으로, 스레드 안전성을 내장하고 있다.

```java
// Sinks.Many: 여러 값을 여러 구독자에게 발행
Sinks.Many<String> sink = Sinks.many().multicast().onBackpressureBuffer();

Flux<String> hotFlux = sink.asFlux();

// 구독자 등록
hotFlux.subscribe(v -> log.info("구독자1: {}", v));
hotFlux.subscribe(v -> log.info("구독자2: {}", v));

// 값 발행
sink.tryEmitNext("메시지 1");
sink.tryEmitNext("메시지 2");
sink.tryEmitComplete();

// 두 구독자 모두 "메시지 1", "메시지 2"를 수신
```

```java
// Sinks.Many의 다양한 스펙
Sinks.Many<String> unicast   = Sinks.many().unicast().onBackpressureBuffer();   // 구독자 1명
Sinks.Many<String> multicast = Sinks.many().multicast().onBackpressureBuffer(); // 여러 구독자
Sinks.Many<String> replay    = Sinks.many().replay().limit(5); // 최근 5개 재생
```

**실전 예제 - 이벤트 버스 구현**:

```java
@Component
public class EventBus {

    private final Sinks.Many<DomainEvent> sink =
        Sinks.many().multicast().onBackpressureBuffer();

    public void publish(DomainEvent event) {
        sink.tryEmitNext(event);
    }

    public Flux<DomainEvent> subscribe() {
        return sink.asFlux();
    }

    public <T extends DomainEvent> Flux<T> subscribe(Class<T> eventType) {
        return sink.asFlux()
            .filter(eventType::isInstance)
            .cast(eventType);
    }
}
```

### 3.5.4 share()와 cache()

Cold Publisher와 Hot Publisher의 특성을 상황에 맞게 조절할 수 있는 유틸리티 메서드들이 있다.

#### share(): Cold Publisher를 Hot Publisher로 변환

```java
Flux<Long> shared = Flux.interval(Duration.ofSeconds(1))
    .doOnSubscribe(s -> log.info("구독 시작"))
    .share(); // 첫 구독자가 구독할 때 시작, 모든 구독자가 해제되면 중지

shared.subscribe(v -> log.info("구독자1: {}", v));

Thread.sleep(2500);

// 구독자2는 중간부터 받음
shared.subscribe(v -> log.info("구독자2: {}", v));
```

#### cache(): 결과를 캐싱

한 번 실행된 결과를 메모리에 보관했다가 이후 구독자들에게 재사용시킬 수 있다.

```java
// 한 번 실행된 결과를 캐싱하여 이후 구독자에게 재사용
Mono<Config> config = loadConfigFromDb()
    .cache(Duration.ofMinutes(10)); // 10분간 캐시

// 첫 번째 호출: DB 조회 실행
config.subscribe(c -> log.info("설정1: {}", c));

// 두 번째 호출: 캐시된 값 반환 (DB 조회 없음)
config.subscribe(c -> log.info("설정2: {}", c));

// Flux에서도 사용 가능
Flux<Product> products = productRepository.findAll()
    .cache(Duration.ofMinutes(5)); // 전체 시퀀스를 캐시
```

---

## 3.6 Reactor 디버깅 기법

리액티브 코드를 디버깅하는 일은 명령형 코드보다 훨씬 까다롭다. 스택 트레이스가 비동기 실행 때문에 원래 코드의 위치를 정확히 가리키지 못하는 까닭이다. 다행히 Reactor가 이 문제를 푸는 여러 도구를 제공한다.

### 3.6.1 log(): 리액티브 신호 로깅

구독부터 완료까지, 리액티브 파이프라인을 흐르는 모든 신호를 로깅할 수 있다. `log()` 연산자를 체인에 끼워넣으면 그 지점의 모든 이벤트를 볼 수 있다.

```java
Flux.range(1, 5)
    .log("NumberFlux")    // 카테고리 이름 지정 가능
    .map(i -> i * 2)
    .log("DoubledFlux")
    .subscribe();

// 출력: onSubscribe, request, onNext, onComplete 등 모든 신호 로깅

// 특정 신호만 로깅
Flux.range(1, 5)
    .log("MyFlux", Level.INFO, SignalType.ON_NEXT, SignalType.ON_ERROR)
    .subscribe();
```

### 3.6.2 checkpoint(): 에러 추적 지점 설정

에러가 터졌을 때 정확히 어느 연산자에서 문제가 났는지 찾기는 어렵다. `checkpoint()`로 마킹해두면 에러 메시지에 그 정보를 포함시켜 추적을 한결 쉽게 만든다.

```java
Flux<Integer> flux = Flux.just(1, 2, 0, 4)
    .map(i -> 100 / i)
    .checkpoint("나눗셈 연산 후")        // 이 지점에 체크포인트 설정
    .map(i -> i + 10)
    .checkpoint("덧셈 연산 후");

flux.subscribe(
    v -> log.info("값: {}", v),
    e -> log.error("에러 발생", e)
);

// 에러 메시지에 체크포인트 정보 포함:
// Assembly trace from producer [reactor.core.publisher.FluxMap],
// described as [나눗셈 연산 후]
```

```java
// 상세 스택 트레이스 포함 (비용이 더 들지만 디버깅에 유용)
.checkpoint("상세 체크포인트", true)
```

### 3.6.3 Hooks.onOperatorDebug(): 글로벌 디버그 모드

모든 연산자에 대해 생성 시점의 스택 트레이스를 자동 캡처하는 강력한 도구다. 다만 **성능 오버헤드가 크기 때문에** 개발 환경에서만 켜야 한다.

```java
@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        // 개발 환경에서만 활성화
        if (isDevProfile()) {
            Hooks.onOperatorDebug();
        }
        SpringApplication.run(Application.class, args);
    }
}
```

활성화되면 에러 발생 시 스택 트레이스에 연산자가 정의된 정확한 소스 위치(클래스명, 줄 번호)를 포함시키므로, 원인 파악이 훨씬 빨라진다.

### 3.6.4 ReactorDebugAgent: 프로덕션 친화적 디버깅

`Hooks.onOperatorDebug()`의 성능 문제를 극복한 고급 옵션이다. Java Agent가 바이트코드 수준에서 변환을 하므로, 런타임 오버헤드 없이도 상세한 디버그 정보를 얻을 수 있다.

**의존성 추가**:

```xml
<dependency>
    <groupId>io.projectreactor</groupId>
    <artifactId>reactor-tools</artifactId>
</dependency>
```

**활성화**:

```java
@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        ReactorDebugAgent.init();               // JVM 시작 시 한 번 호출
        ReactorDebugAgent.processExistingClasses(); // 이미 로드된 클래스 처리
        SpringApplication.run(Application.class, args);
    }
}
```

### 3.6.5 디버깅 실전 전략 정리

| 방법 | 성능 영향 | 사용 환경 | 설명 |
|------|----------|----------|------|
| `log()` | 낮음 | 모든 환경 | 특정 지점의 신호 확인 |
| `checkpoint()` | 낮음 | 모든 환경 | 특정 지점에 디버그 마커 설정 |
| `Hooks.onOperatorDebug()` | **높음** | 개발 환경만 | 모든 연산자의 스택 트레이스 캡처 |
| `ReactorDebugAgent` | 낮음 | 모든 환경 | 바이트코드 변환 기반 디버깅 |

**권장 디버깅 워크플로우**:

차근차근 이 순서로 접근하면 대부분의 문제를 찾을 수 있다.

```java
// 1단계: log()로 신호 흐름 확인
userRepository.findById(id)
    .log("findById")
    .flatMap(user -> orderRepository.findByUserId(user.getId()))
    .log("findOrders")
    .subscribe();

// 2단계: 문제 지점에 checkpoint() 추가
userRepository.findById(id)
    .checkpoint("사용자 조회")
    .flatMap(user -> orderRepository.findByUserId(user.getId()))
    .checkpoint("주문 목록 조회")
    .subscribe();

// 3단계: 그래도 찾기 어려우면 ReactorDebugAgent 활성화
```

---

## 요약

이 장에서 배운 Project Reactor의 핵심 개념을 한번 정리해보자.

- **Mono와 Flux**는 리액티브 스트림의 두 기둥이다. 최대 1개의 값을 다루거나 여러 개의 값을 흐르게 해야 할 때, 어떤 것을 선택할지는 자연스럽게 결정된다.
- **연산자 체인**으로 선언적인 데이터 처리 파이프라인을 만든다. `map`, `flatMap`, `concatMap` 같은 각 연산자의 특성을 정확히 이해하는 것이 리액티브 코드의 품질을 결정한다.
- **에러 처리**는 단순한 기본값 반환부터 복잡한 재시도 전략까지, 상황에 맞는 도구를 선택할 수 있다. `retryWhen`과 `Retry.backoff()`를 조합하면 실제 서비스에 필요한 정교한 에러 대응을 구현할 수 있기 때문이다.
- **스케줄러**로 작업이 실행될 스레드를 제어한다. `publishOn`과 `subscribeOn`은 비슷하지만 전혀 다르다는 점을 잘 기억해야 하고, 레거시 블로킹 코드는 `boundedElastic`으로 반드시 격리해야 한다.
- **Cold와 Hot Publisher**의 차이를 이해하면, 데이터를 언제 생성하고 여러 구독자에게 어떻게 공유할지를 올바르게 설계할 수 있다. `Sinks`는 Hot Publisher를 직접 만드는 현대적인 방식이다.
- **디버깅**은 `log()`와 `checkpoint()`로 시작하여, 필요시 `ReactorDebugAgent`를 활용하면 복잡한 비동기 문제도 추적할 수 있다.

이제 Spring WebFlux와 Reactor를 이루는 기초를 다졌다. 다음 장에서는 MongoDB의 기본과 리액티브 드라이버를 자세히 살펴보기로 한다.
