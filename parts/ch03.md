# Chapter 3. Project Reactor 핵심

Project Reactor는 Spring WebFlux의 리액티브 프로그래밍 기반이다. 이 장에서는 Reactor의 두 가지 핵심 타입인 `Mono`와 `Flux`를 깊이 있게 다루고, 실전에서 빈번하게 사용하는 연산자, 에러 처리, 스케줄러, 그리고 디버깅 기법까지 체계적으로 살펴본다.

---

## 3.1 Mono와 Flux 이해하기

### 3.1.1 Mono: 0..1개의 요소

`Mono<T>`는 **최대 1개의 요소**를 발행하는 Publisher이다. 데이터베이스에서 단일 레코드를 조회하거나, HTTP 요청의 응답 하나를 반환할 때 주로 사용한다.

```java
// 값이 있는 Mono
Mono<String> mono = Mono.just("Hello Reactor");

// 빈 Mono (값 없이 완료)
Mono<String> empty = Mono.empty();

// 에러를 발행하는 Mono
Mono<String> error = Mono.error(new RuntimeException("오류 발생"));
```

### 3.1.2 Flux: 0..N개의 요소

`Flux<T>`는 **0개에서 N개까지의 요소**를 발행하는 Publisher이다. 컬렉션 데이터를 스트리밍하거나, 실시간 이벤트를 연속적으로 전달할 때 사용한다.

```java
// 여러 값을 가진 Flux
Flux<String> flux = Flux.just("Spring", "WebFlux", "Reactor");

// 리스트에서 Flux 생성
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Flux<Integer> fromList = Flux.fromIterable(numbers);

// 범위로 생성
Flux<Integer> range = Flux.range(1, 10); // 1부터 10까지
```

### 3.1.3 다양한 생성 방법

```java
// defer: 구독 시점에 Mono/Flux를 생성 (Lazy 평가)
Mono<Long> deferred = Mono.defer(() -> Mono.just(System.currentTimeMillis()));

// fromCallable: Callable로부터 Mono 생성
Mono<String> fromCallable = Mono.fromCallable(() -> {
    // 블로킹 작업도 래핑 가능
    return someBlockingMethod();
});

// create: 프로그래밍 방식으로 Flux 생성 (비동기 브릿지)
Flux<String> created = Flux.create(sink -> {
    sink.next("첫 번째");
    sink.next("두 번째");
    sink.next("세 번째");
    sink.complete();
});

// generate: 동기적으로 하나씩 값을 생성
Flux<Integer> generated = Flux.generate(
    () -> 0,                        // 초기 상태
    (state, sink) -> {
        sink.next(state);
        if (state == 9) sink.complete();
        return state + 1;           // 다음 상태
    }
);

// interval: 일정 간격으로 값 발행 (0부터 증가하는 Long)
Flux<Long> interval = Flux.interval(Duration.ofSeconds(1));
```

### 3.1.4 구독(subscribe)의 의미와 동작

Reactor에서 가장 핵심적인 개념은 **"아무것도 구독하지 않으면 아무 일도 일어나지 않는다"** 는 것이다. `Mono`와 `Flux`는 선언적 파이프라인일 뿐, `subscribe()`를 호출해야 실제 데이터 흐름이 시작된다.

```java
Flux<Integer> pipeline = Flux.range(1, 5)
    .map(i -> i * 2)
    .filter(i -> i > 4);

// subscribe()를 호출하지 않으면 위 코드는 아무 것도 실행하지 않는다.

// 기본 구독
pipeline.subscribe();

// 값 소비자 지정
pipeline.subscribe(
    value -> System.out.println("값: " + value)
);

// 값, 에러, 완료 핸들러 지정
pipeline.subscribe(
    value -> System.out.println("값: " + value),
    error -> System.err.println("에러: " + error.getMessage()),
    () -> System.out.println("완료!")
);

```

> **주의**: Spring WebFlux에서는 프레임워크가 자동으로 구독을 처리한다. 컨트롤러에서 `Mono`나 `Flux`를 반환하면 WebFlux가 내부적으로 `subscribe()`를 호출하므로, 직접 `subscribe()`를 호출할 필요가 없다. 오히려 직접 호출하면 예기치 않은 동작이 발생할 수 있다.

---

## 3.2 Reactor의 주요 연산자

### 3.2.1 변환 연산자

#### map: 동기 변환

각 요소를 동기적으로 1:1 변환한다.

```java
Flux<String> upperCase = Flux.just("spring", "webflux", "reactor")
    .map(String::toUpperCase);
// 결과: "SPRING", "WEBFLUX", "REACTOR"
```

#### flatMap: 비동기 변환 (순서 보장 X)

각 요소를 `Publisher`로 변환하고 결과를 병합한다. **순서가 보장되지 않으며**, 동시에 여러 내부 Publisher를 구독한다.

```java
Flux<User> users = Flux.just(1L, 2L, 3L)
    .flatMap(id -> userRepository.findById(id));
// 결과 순서: id=2 응답이 먼저 올 수 있음
```

#### flatMapSequential: 비동기 변환 (순서 보장)

`flatMap`과 동일하게 동시 실행하되, **원래 순서를 보장**한다.

```java
Flux<User> users = Flux.just(1L, 2L, 3L)
    .flatMapSequential(id -> userRepository.findById(id));
// 결과 순서: id=1, id=2, id=3 순서 보장
```

#### concatMap: 순차 비동기 변환

각 요소를 순차적으로 처리한다. 이전 요소의 처리가 완료된 후 다음 요소를 처리하므로 **순서가 보장**되지만, `flatMapSequential`보다 느리다.

```java
Flux<User> users = Flux.just(1L, 2L, 3L)
    .concatMap(id -> userRepository.findById(id));
// id=1 조회 완료 -> id=2 조회 시작 -> id=2 완료 -> id=3 조회 시작
```

#### flatMap vs flatMapSequential vs concatMap 비교

| 연산자 | 동시 실행 | 순서 보장 | 사용 시기 |
|--------|----------|----------|----------|
| `flatMap` | O | X | 순서 무관, 최대 처리량 필요 |
| `flatMapSequential` | O | O | 동시 실행 + 순서 보장 |
| `concatMap` | X | O | 순차 처리 필수 |

### 3.2.2 필터링 연산자

```java
Flux<Integer> numbers = Flux.range(1, 20);

// filter: 조건에 맞는 요소만 통과
Flux<Integer> evenNumbers = numbers.filter(n -> n % 2 == 0);
// 결과: 2, 4, 6, 8, 10, 12, 14, 16, 18, 20

// take: 처음 N개만 가져오기
Flux<Integer> firstThree = numbers.take(3);
// 결과: 1, 2, 3

// skip: 처음 N개 건너뛰기
Flux<Integer> skipped = numbers.skip(17);
// 결과: 18, 19, 20

// distinct: 중복 제거
Flux<String> unique = Flux.just("A", "B", "A", "C", "B")
    .distinct();
// 결과: "A", "B", "C"

// distinctUntilChanged: 연속 중복 제거
Flux<String> changed = Flux.just("A", "A", "B", "B", "A")
    .distinctUntilChanged();
// 결과: "A", "B", "A"
```

### 3.2.3 결합 연산자

#### zip: 각 Publisher의 요소를 쌍으로 결합

```java
Mono<String> name = Mono.just("홍길동");
Mono<Integer> age = Mono.just(30);

Mono<String> combined = Mono.zip(name, age)
    .map(tuple -> tuple.getT1() + "님은 " + tuple.getT2() + "세입니다.");
// 결과: "홍길동님은 30세입니다."

// Flux에서의 zip
Flux<String> names = Flux.just("Alice", "Bob", "Charlie");
Flux<Integer> scores = Flux.just(95, 87, 92);

Flux<String> results = Flux.zip(names, scores)
    .map(tuple -> tuple.getT1() + ": " + tuple.getT2() + "점");
// 결과: "Alice: 95점", "Bob: 87점", "Charlie: 92점"
```

#### merge: 여러 Publisher를 인터리빙 방식으로 병합

요소가 발행되는 즉시 하류로 전달한다. 순서는 도착 순이다.

```java
Flux<String> fast = Flux.interval(Duration.ofMillis(100))
    .map(i -> "FAST-" + i).take(3);
Flux<String> slow = Flux.interval(Duration.ofMillis(200))
    .map(i -> "SLOW-" + i).take(3);

Flux<String> merged = Flux.merge(fast, slow);
// 도착 순서대로 병합: FAST-0, FAST-1, SLOW-0, FAST-2, SLOW-1, SLOW-2
```

#### concat: 순서를 유지하며 병합

첫 번째 Publisher가 완료된 후 두 번째 Publisher를 구독한다.

```java
Flux<String> first = Flux.just("1", "2", "3");
Flux<String> second = Flux.just("A", "B", "C");

Flux<String> concatenated = Flux.concat(first, second);
// 결과: "1", "2", "3", "A", "B", "C" (항상 이 순서)
```

#### combineLatest: 각 Publisher의 최신 값 결합

어느 한 Publisher에서 새 값이 발행되면, 다른 Publisher의 최신 값과 결합한다.

```java
Flux<String> letters = Flux.just("A", "B", "C")
    .delayElements(Duration.ofMillis(100));
Flux<Integer> numbers = Flux.just(1, 2, 3)
    .delayElements(Duration.ofMillis(150));

Flux<String> combined = Flux.combineLatest(
    letters, numbers,
    (letter, number) -> letter + number
);
// 최신 값끼리 결합: A1, B1, B2, C2, C3 (타이밍에 따라 다를 수 있음)
```

### 3.2.4 집계 연산자

```java
Flux<Integer> numbers = Flux.just(3, 1, 4, 1, 5, 9, 2, 6);

// reduce: 모든 요소를 하나로 축약
Mono<Integer> sum = numbers.reduce(0, Integer::sum);
// 결과: 31

// count: 요소 개수
Mono<Long> count = numbers.count();
// 결과: 8

// collectList: 모든 요소를 List로 수집
Mono<List<Integer>> list = numbers.collectList();
// 결과: [3, 1, 4, 1, 5, 9, 2, 6]

// collectMap: 요소를 Map으로 수집
Flux<User> users = userRepository.findAll();
Mono<Map<String, User>> userMap = users
    .collectMap(User::getId, user -> user);

```

### 3.2.5 유용한 유틸리티 연산자

```java
// switchIfEmpty: 빈 결과일 때 대체 Publisher 사용
Mono<User> user = userRepository.findById(id)
    .switchIfEmpty(Mono.error(
        new NotFoundException("사용자를 찾을 수 없습니다: " + id)
    ));

// defaultIfEmpty: 빈 결과일 때 기본값 사용
Mono<String> config = configRepository.findByKey("timeout")
    .defaultIfEmpty("30");

// doOnNext, doOnError, doOnComplete: 부수 효과 (사이드 이펙트)
Flux<User> usersWithLog = userRepository.findAll()
    .doOnNext(u -> log.info("조회된 사용자: {}", u.getName()))
    .doOnError(e -> log.error("조회 실패", e))
    .doOnComplete(() -> log.info("전체 사용자 조회 완료"));

// timeout: 지정 시간 내에 값이 없으면 에러
Mono<User> userWithTimeout = userRepository.findById(id)
    .timeout(Duration.ofSeconds(5));
```

---

## 3.3 에러 처리 전략

리액티브 스트림에서 에러가 발생하면 스트림이 종료된다. Reactor는 다양한 에러 처리 연산자를 제공하여 우아한 에러 복구를 가능하게 한다.

### 3.3.1 onErrorReturn: 기본값으로 대체

에러 발생 시 지정한 기본값을 반환하고 스트림을 정상 완료한다.

```java
Mono<String> result = externalApi.getData()
    .onErrorReturn("기본값");

// 특정 예외 타입에만 적용
Mono<String> result2 = externalApi.getData()
    .onErrorReturn(TimeoutException.class, "시간 초과 - 기본값 사용");
```

### 3.3.2 onErrorResume: 대체 Publisher로 전환

에러 발생 시 다른 Publisher로 전환한다. 폴백(fallback) 로직을 구현할 때 유용하다.

```java
Mono<User> user = primaryDb.findById(id)
    .onErrorResume(e -> {
        log.warn("Primary DB 실패, Secondary DB로 전환", e);
        return secondaryDb.findById(id);
    });

// 에러 타입별 분기 처리
Mono<String> data = externalService.call()
    .onErrorResume(TimeoutException.class, e -> cachedService.getCached())
    .onErrorResume(ServiceUnavailableException.class, e -> Mono.just("서비스 점검 중"));
```

### 3.3.3 onErrorMap: 에러를 다른 에러로 변환

예외를 도메인에 맞는 다른 예외로 변환한다.

```java
Mono<User> user = userRepository.findById(id)
    .switchIfEmpty(Mono.error(new UserNotFoundException(id)))
    .onErrorMap(DataAccessException.class, e ->
        new ServiceException("데이터 접근 오류", e)
    );
```

### 3.3.4 doOnError: 에러 발생 시 부수 효과

스트림 자체를 변경하지 않고 로깅 등의 부수 효과를 실행한다.

```java
Mono<User> user = userRepository.findById(id)
    .doOnError(e -> {
        log.error("사용자 조회 중 에러 발생. id={}", id, e);
        metrics.incrementErrorCount("user.findById");
    })
    .onErrorResume(e -> Mono.empty());
```

### 3.3.5 retry: 단순 재시도

에러 발생 시 지정한 횟수만큼 재구독한다.

```java
Mono<String> result = externalApi.call()
    .retry(3); // 최대 3회 재시도
```

### 3.3.6 retryWhen: 고급 재시도 전략

`Retry` 스펙을 사용하여 세밀한 재시도 정책을 구현한다.

```java
import reactor.util.retry.Retry;

Mono<String> result = externalApi.call()
    .retryWhen(Retry.backoff(3, Duration.ofSeconds(1))
        .maxBackoff(Duration.ofSeconds(10))
        .jitter(0.5)
        .filter(throwable -> throwable instanceof ServiceUnavailableException)
        .onRetryExhaustedThrow((retryBackoffSpec, retrySignal) ->
            new ServiceException(
                "재시도 횟수 초과. 마지막 에러: " + retrySignal.failure().getMessage(),
                retrySignal.failure()
            )
        )
    );
```

### 3.3.7 실전 에러 처리 패턴

다음은 실제 서비스 계층에서 사용하는 종합 에러 처리 패턴이다.

```java
@Service
@RequiredArgsConstructor
public class UserService {

    private final ReactiveMongoTemplate mongoTemplate;
    private final UserCacheService cacheService;
    private static final Logger log = LoggerFactory.getLogger(UserService.class);

    public Mono<User> findUserById(String id) {
        return cacheService.getCachedUser(id)            // 1. 캐시 조회
            .switchIfEmpty(
                mongoTemplate.findById(id, User.class)   // 2. DB 조회
                    .doOnNext(user ->
                        cacheService.cacheUser(user)      // 3. 캐시 저장
                            .subscribe()
                    )
            )
            .switchIfEmpty(
                Mono.error(new UserNotFoundException(id)) // 4. 없으면 예외
            )
            .timeout(Duration.ofSeconds(5))               // 5. 타임아웃
            .doOnError(TimeoutException.class, e ->
                log.warn("사용자 조회 타임아웃. id={}", id)
            )
            .onErrorMap(TimeoutException.class, e ->
                new ServiceException("사용자 조회 시간 초과", e)
            )
            .retryWhen(Retry.backoff(2, Duration.ofMillis(500))
                .filter(e -> e instanceof DataAccessException)
            );
    }

    public Flux<User> searchUsers(String keyword) {
        Query query = new Query(
            Criteria.where("name").regex(keyword, "i")
        );

        return mongoTemplate.find(query, User.class)
            .onErrorResume(e -> {
                log.error("사용자 검색 실패. keyword={}", keyword, e);
                return Flux.empty();
            });
    }
}
```

---

## 3.4 스케줄러(Scheduler)와 스레드 모델

Reactor는 기본적으로 **호출자 스레드**에서 동작한다. 스케줄러를 사용하면 작업을 실행할 스레드를 제어할 수 있다.

### 3.4.1 주요 스케줄러 종류

| 스케줄러 | 설명 | 스레드 수 | 사용 시기 |
|---------|------|----------|----------|
| `Schedulers.parallel()` | CPU 집약적 작업 | CPU 코어 수 | 계산, 변환 작업 |
| `Schedulers.boundedElastic()` | 블로킹 I/O 래핑 | 최대 10 * CPU 코어 | 블로킹 코드 감싸기 |
| `Schedulers.single()` | 단일 재사용 스레드 | 1 | 순차 실행 보장 |
| `Schedulers.immediate()` | 현재 스레드 | - | 테스트, 디폴트 |
| `Schedulers.fromExecutorService()` | 커스텀 스레드 풀 | 사용자 지정 | 특수한 요구사항 |

### 3.4.2 publishOn vs subscribeOn

두 연산자는 이름이 비슷하지만 동작 방식이 완전히 다르다.

#### publishOn: 하류 연산자의 실행 스레드를 변경

`publishOn` 이후의 연산자들이 지정한 스케줄러에서 실행된다. 파이프라인 중간에 스레드를 전환할 때 사용한다.

```java
Flux.range(1, 5)
    .map(i -> {
        log.info("[map1] {} - {}", i, Thread.currentThread().getName());
        return i * 10;
    })
    .publishOn(Schedulers.parallel())   // 여기서부터 parallel 스레드
    .map(i -> {
        log.info("[map2] {} - {}", i, Thread.currentThread().getName());
        return i + 1;
    })
    .subscribe(i ->
        log.info("[subscribe] {} - {}", i, Thread.currentThread().getName())
    );

// map1은 main 스레드, publishOn 이후 map2와 subscribe는 parallel-1 스레드에서 실행
```

#### subscribeOn: 전체 구독 체인의 실행 스레드를 변경

소스의 구독(데이터 발행) 시점부터의 스레드를 변경한다. **위치에 관계없이** 소스 발행 스레드에 영향을 미친다.

```java
Mono.fromCallable(() -> {
        log.info("[callable] {}", Thread.currentThread().getName());
        return blockingIoOperation();
    })
    .subscribeOn(Schedulers.boundedElastic())  // 소스가 boundedElastic에서 실행
    .map(result -> processResult(result))
    .subscribe();
// callable, map, subscribe 모두 boundedElastic-1 스레드에서 실행
```

#### publishOn과 subscribeOn 함께 사용

```java
Flux.range(1, 3)
    .subscribeOn(Schedulers.single())          // 소스: single 스레드
    .map(i -> {
        log.info("[map1] {}", Thread.currentThread().getName()); // single-1
        return "값-" + i;
    })
    .publishOn(Schedulers.parallel())          // 이후: parallel 스레드
    .map(s -> {
        log.info("[map2] {}", Thread.currentThread().getName()); // parallel-1
        return s.toUpperCase();
    })
    .subscribe();
```

### 3.4.3 블로킹 코드를 감싸는 방법

리액티브 파이프라인 안에서 블로킹 코드를 직접 호출하면 이벤트 루프 스레드를 점유하여 전체 시스템 처리량이 급격히 떨어진다. 불가피하게 블로킹 코드를 사용해야 할 때는 반드시 `boundedElastic` 스케줄러로 격리해야 한다.

```java
@Service
public class LegacyIntegrationService {

    private final LegacyBlockingClient legacyClient;

    // 잘못된 방법 - 이벤트 루프 스레드를 블로킹
    public Mono<String> wrongWay() {
        return Mono.just(legacyClient.blockingCall()); // 절대 이렇게 하지 말 것!
    }

    // 올바른 방법 - boundedElastic에서 블로킹 실행
    public Mono<String> correctWay() {
        return Mono.fromCallable(() -> legacyClient.blockingCall())
            .subscribeOn(Schedulers.boundedElastic());
    }

    // 여러 블로킹 호출을 병렬로 실행
    public Mono<AggregatedResult> parallelBlockingCalls() {
        Mono<String> call1 = Mono.fromCallable(() -> legacyClient.callServiceA())
            .subscribeOn(Schedulers.boundedElastic());

        Mono<String> call2 = Mono.fromCallable(() -> legacyClient.callServiceB())
            .subscribeOn(Schedulers.boundedElastic());

        return Mono.zip(call1, call2)
            .map(tuple -> new AggregatedResult(tuple.getT1(), tuple.getT2()));
    }
}
```

> **Tip**: 프로젝트에 `BlockHound` 라이브러리를 추가하면 이벤트 루프 스레드에서 블로킹 호출이 발생할 때 즉시 탐지할 수 있다. 19장에서 자세히 다룬다.

---

## 3.5 Cold vs Hot Publisher

### 3.5.1 Cold Publisher

Cold Publisher는 **구독할 때마다 데이터를 처음부터 새로 발행**한다. 대부분의 Reactor 연산자는 Cold Publisher를 생성한다.

```java
Flux<Long> coldFlux = Flux.defer(() -> {
    log.info("새로운 데이터 소스 생성");
    return Flux.just(System.currentTimeMillis());
});

// 구독자 1: 자신만의 데이터를 받음
coldFlux.subscribe(v -> log.info("구독자1: {}", v));

Thread.sleep(100);

// 구독자 2: 별도의 새로운 데이터를 받음 (다른 타임스탬프)
coldFlux.subscribe(v -> log.info("구독자2: {}", v));

// 각 구독자가 서로 다른 타임스탬프를 받음 (매번 새로 생성)
```

### 3.5.2 Hot Publisher

Hot Publisher는 **구독 여부와 관계없이 데이터를 발행**하며, 구독자들은 구독 이후의 데이터만 받는다.

```java
// ConnectableFlux로 Hot Publisher 만들기
Flux<Long> hotFlux = Flux.interval(Duration.ofSeconds(1))
    .publish()
    .autoConnect(2); // 2명이 구독하면 자동 시작

// 구독자 1
hotFlux.subscribe(v -> log.info("구독자1: {}", v));

Thread.sleep(1500);

// 구독자 2가 연결되면 발행 시작, 구독자2는 중간부터 수신
hotFlux.subscribe(v -> log.info("구독자2: {}", v));
```

### 3.5.3 Sinks를 활용한 Hot Publisher 생성

`Sinks`는 Reactor 3.4부터 도입된 프로그래밍 방식의 신호 발행 도구이다. 기존의 `Processor` 를 대체하며 스레드 안전성을 보장한다.

```java
// Sinks.Many: 여러 값을 여러 구독자에게 발행
Sinks.Many<String> sink = Sinks.many().multicast().onBackpressureBuffer();

Flux<String> hotFlux = sink.asFlux();

// 구독자 등록
hotFlux.subscribe(v -> log.info("구독자1: {}", v));
hotFlux.subscribe(v -> log.info("구독자2: {}", v));

// 값 발행
sink.tryEmitNext("메시지 1");
sink.tryEmitNext("메시지 2");
sink.tryEmitComplete();

// 두 구독자 모두 "메시지 1", "메시지 2"를 수신
```

```java
// Sinks.Many의 다양한 스펙
Sinks.Many<String> unicast   = Sinks.many().unicast().onBackpressureBuffer();   // 구독자 1명
Sinks.Many<String> multicast = Sinks.many().multicast().onBackpressureBuffer(); // 여러 구독자
Sinks.Many<String> replay    = Sinks.many().replay().limit(5); // 최근 5개 재생
```

**실전 예제 - 이벤트 버스 구현**:

```java
@Component
public class EventBus {

    private final Sinks.Many<DomainEvent> sink =
        Sinks.many().multicast().onBackpressureBuffer();

    public void publish(DomainEvent event) {
        sink.tryEmitNext(event);
    }

    public Flux<DomainEvent> subscribe() {
        return sink.asFlux();
    }

    public <T extends DomainEvent> Flux<T> subscribe(Class<T> eventType) {
        return sink.asFlux()
            .filter(eventType::isInstance)
            .cast(eventType);
    }
}
```

### 3.5.4 share()와 cache()

#### share(): Cold Publisher를 Hot Publisher로 변환

```java
Flux<Long> shared = Flux.interval(Duration.ofSeconds(1))
    .doOnSubscribe(s -> log.info("구독 시작"))
    .share(); // 첫 구독자가 구독할 때 시작, 모든 구독자가 해제되면 중지

shared.subscribe(v -> log.info("구독자1: {}", v));

Thread.sleep(2500);

// 구독자2는 중간부터 받음
shared.subscribe(v -> log.info("구독자2: {}", v));
```

#### cache(): 결과를 캐싱

```java
// 한 번 실행된 결과를 캐싱하여 이후 구독자에게 재사용
Mono<Config> config = loadConfigFromDb()
    .cache(Duration.ofMinutes(10)); // 10분간 캐시

// 첫 번째 호출: DB 조회 실행
config.subscribe(c -> log.info("설정1: {}", c));

// 두 번째 호출: 캐시된 값 반환 (DB 조회 없음)
config.subscribe(c -> log.info("설정2: {}", c));

// Flux에서도 사용 가능
Flux<Product> products = productRepository.findAll()
    .cache(Duration.ofMinutes(5)); // 전체 시퀀스를 캐시
```

---

## 3.6 Reactor 디버깅 기법

리액티브 코드의 디버깅은 명령형 코드보다 까다롭다. 비동기 스택 트레이스가 연산자 체인의 원래 위치를 보여주지 않기 때문이다. Reactor는 이를 돕는 도구를 제공한다.

### 3.6.1 log(): 리액티브 신호 로깅

`log()` 연산자는 구독, 요청, 발행, 완료, 에러 등 모든 리액티브 신호를 로깅한다.

```java
Flux.range(1, 5)
    .log("NumberFlux")    // 카테고리 이름 지정 가능
    .map(i -> i * 2)
    .log("DoubledFlux")
    .subscribe();

// 출력: onSubscribe, request, onNext, onComplete 등 모든 신호 로깅

// 특정 신호만 로깅
Flux.range(1, 5)
    .log("MyFlux", Level.INFO, SignalType.ON_NEXT, SignalType.ON_ERROR)
    .subscribe();
```

### 3.6.2 checkpoint(): 에러 추적 지점 설정

`checkpoint()`는 에러 발생 시 연산자 체인의 어느 지점에서 문제가 발생했는지 추적할 수 있게 한다.

```java
Flux<Integer> flux = Flux.just(1, 2, 0, 4)
    .map(i -> 100 / i)
    .checkpoint("나눗셈 연산 후")        // 이 지점에 체크포인트 설정
    .map(i -> i + 10)
    .checkpoint("덧셈 연산 후");

flux.subscribe(
    v -> log.info("값: {}", v),
    e -> log.error("에러 발생", e)
);

// 에러 메시지에 체크포인트 정보 포함:
// Assembly trace from producer [reactor.core.publisher.FluxMap],
// described as [나눗셈 연산 후]
```

```java
// 상세 스택 트레이스 포함 (비용이 더 들지만 디버깅에 유용)
.checkpoint("상세 체크포인트", true)
```

### 3.6.3 Hooks.onOperatorDebug(): 글로벌 디버그 모드

모든 연산자에 대해 어셈블리(조립) 시점의 스택 트레이스를 자동 캡처한다. **성능 오버헤드가 크므로 개발 환경에서만 사용**해야 한다.

```java
@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        // 개발 환경에서만 활성화
        if (isDevProfile()) {
            Hooks.onOperatorDebug();
        }
        SpringApplication.run(Application.class, args);
    }
}
```

활성화하면 에러 발생 시 연산자가 조립된 소스 코드 위치(클래스명, 줄 번호)를 스택 트레이스에 포함시켜 준다.

### 3.6.4 ReactorDebugAgent: 프로덕션 친화적 디버깅

`Hooks.onOperatorDebug()`의 성능 문제를 해결한 대안이다. Java Agent 방식으로 바이트코드를 변환하여, 런타임 오버헤드 없이 디버그 정보를 제공한다.

**의존성 추가**:

```xml
<dependency>
    <groupId>io.projectreactor</groupId>
    <artifactId>reactor-tools</artifactId>
</dependency>
```

**활성화**:

```java
@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        ReactorDebugAgent.init();               // JVM 시작 시 한 번 호출
        ReactorDebugAgent.processExistingClasses(); // 이미 로드된 클래스 처리
        SpringApplication.run(Application.class, args);
    }
}
```

### 3.6.5 디버깅 실전 전략 정리

| 방법 | 성능 영향 | 사용 환경 | 설명 |
|------|----------|----------|------|
| `log()` | 낮음 | 모든 환경 | 특정 지점의 신호 확인 |
| `checkpoint()` | 낮음 | 모든 환경 | 특정 지점에 디버그 마커 설정 |
| `Hooks.onOperatorDebug()` | **높음** | 개발 환경만 | 모든 연산자의 스택 트레이스 캡처 |
| `ReactorDebugAgent` | 낮음 | 모든 환경 | 바이트코드 변환 기반 디버깅 |

**권장 디버깅 워크플로우**:

```java
// 1단계: log()로 신호 흐름 확인
userRepository.findById(id)
    .log("findById")
    .flatMap(user -> orderRepository.findByUserId(user.getId()))
    .log("findOrders")
    .subscribe();

// 2단계: 문제 지점에 checkpoint() 추가
userRepository.findById(id)
    .checkpoint("사용자 조회")
    .flatMap(user -> orderRepository.findByUserId(user.getId()))
    .checkpoint("주문 목록 조회")
    .subscribe();

// 3단계: 그래도 찾기 어려우면 ReactorDebugAgent 활성화
```

---

## 요약

이 장에서 다룬 Project Reactor의 핵심 개념을 정리하면 다음과 같다.

- **Mono와 Flux**는 리액티브 스트림의 기본 구성 요소다. Mono는 0..1개, Flux는 0..N개의 요소를 비동기적으로 발행한다.
- **연산자**를 조합하여 선언적으로 데이터 처리 파이프라인을 구성한다. `flatMap`과 `concatMap`의 차이처럼, 각 연산자의 동작 특성을 이해하는 것이 중요하다.
- **에러 처리**는 `onErrorReturn`, `onErrorResume`, `retry` 등을 활용하여 우아하게 복구할 수 있다. 특히 `retryWhen`과 `Retry.backoff()`를 조합하면 실전에서 필요한 재시도 전략을 구현할 수 있다.
- **스케줄러**를 통해 작업의 실행 스레드를 제어한다. `publishOn`은 하류의 스레드를 전환하고, `subscribeOn`은 소스의 스레드를 전환한다. 블로킹 코드는 반드시 `boundedElastic`으로 격리해야 한다.
- **Cold vs Hot Publisher** 개념을 이해하면 데이터 공유와 멀티캐스트 시나리오를 올바르게 구현할 수 있다. `Sinks`는 프로그래밍 방식으로 Hot Publisher를 생성하는 현대적 도구이다.
- **디버깅**은 `log()`, `checkpoint()`로 시작하고, 필요 시 `ReactorDebugAgent`를 활용한다.

다음 장에서는 MongoDB의 기본 개념과 리액티브 드라이버에 대해 알아본다.
