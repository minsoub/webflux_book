# Chapter 10. WebFlux 필터와 인터셉터

Chapter 9에서 데이터 검증과 예외 처리를 다루었다. 이번 장에서는 요청과 응답의 **횡단 관심사(cross-cutting concerns)**를 처리하는 필터와 인터셉터를 살펴본다. Spring MVC의 `Filter`와 `HandlerInterceptor`에 대응하는 WebFlux의 `WebFilter`와 `HandlerFilterFunction`을 구현하고, 로깅, CORS, 속도 제한까지 실전에서 자주 사용하는 패턴을 모두 다룬다.

---

## 10.1 WebFilter 구현

### 10.1.1 WebFilter 인터페이스 이해

`WebFilter`는 Spring WebFlux에서 모든 HTTP 요청에 대해 공통 로직을 실행할 수 있는 서블릿 필터 대응 인터페이스다. 어노테이션 기반 컨트롤러와 함수형 엔드포인트 모두에 적용된다.

```java
public interface WebFilter {
    Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain);
}
```

| 파라미터 | 설명 |
|---------|------|
| `ServerWebExchange` | HTTP 요청(`ServerHttpRequest`)과 응답(`ServerHttpResponse`)을 모두 담고 있는 컨텍스트 객체 |
| `WebFilterChain` | 다음 필터 또는 핸들러로 요청을 전달하는 체인 |

핵심 원리는 **필터 체인** 패턴이다. 각 필터는 `chain.filter(exchange)`를 호출하여 다음 단계로 요청을 넘기고, 반환값인 `Mono<Void>`에 연산자를 체이닝하여 응답 후처리를 수행한다.

```
[클라이언트] → [WebFilter 1] → [WebFilter 2] → ... → [핸들러]
                                                         ↓
[클라이언트] ← [WebFilter 1] ← [WebFilter 2] ← ... ← [응답]
```

### 10.1.2 요청 전후 처리 필터

`@Component`로 등록하면 스프링이 자동으로 필터 체인에 추가한다. `chain.filter()` 호출 전후로 코드를 배치하여 요청과 응답 양쪽을 처리할 수 있다.

```java
@Slf4j
@Component
public class RequestTimingFilter implements WebFilter {

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        // === 전처리 ===
        long startTime = System.currentTimeMillis();
        String method = exchange.getRequest().getMethod().name();
        String path = exchange.getRequest().getURI().getPath();

        log.info(">>> 요청 시작: {} {}", method, path);

        return chain.filter(exchange)
            // === 후처리 ===
            .doFinally(signalType -> {
                long duration = System.currentTimeMillis() - startTime;
                log.info("<<< 요청 완료: {} {} - {}ms [{}]",
                    method, path, duration, signalType);
            });
    }
}
```

> **주의**: `then(Mono.fromRunnable(...))`은 정상 완료 시에만 실행된다. 에러를 포함한 모든 경우를 처리하려면 위 예시처럼 `doFinally`를 사용해야 한다.

### 10.1.3 @Order로 필터 실행 순서 지정

여러 WebFilter가 등록된 경우 `@Order` 어노테이션으로 실행 순서를 제어한다. 값이 작을수록 먼저 실행된다.

```java
@Component
@Order(1)
public class SecurityCheckFilter implements WebFilter { /* 보안 검사 */ }

@Component
@Order(2)
public class LoggingFilter implements WebFilter { /* 로깅 */ }

@Component
@Order(3)
public class MetricsFilter implements WebFilter { /* 메트릭 수집 */ }
```

`Ordered` 인터페이스를 구현하는 방법도 있다.

```java
@Component
public class HighPriorityFilter implements WebFilter, Ordered {
    @Override
    public int getOrder() { return Ordered.HIGHEST_PRECEDENCE; }

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        return chain.filter(exchange);
    }
}
```

### 10.1.4 조건부 필터 적용과 요청 차단

WebFilter는 기본적으로 **모든 요청**에 적용된다. 특정 경로에만 필터를 적용하려면 내부에서 경로를 확인하고, 요청을 차단하려면 `chain.filter()`를 호출하지 않고 응답을 즉시 완료한다.

```java
@Slf4j
@Component
@Order(1)
public class ApiKeyFilter implements WebFilter {

    private static final String API_KEY_HEADER = "X-API-Key";
    private static final String VALID_API_KEY = "my-secret-api-key";

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        String path = exchange.getRequest().getURI().getPath();

        // /api/** 경로에만 필터 적용
        if (!path.startsWith("/api/")) {
            return chain.filter(exchange);
        }

        String apiKey = exchange.getRequest().getHeaders().getFirst(API_KEY_HEADER);
        if (VALID_API_KEY.equals(apiKey)) {
            return chain.filter(exchange);
        }

        // 요청 차단: chain.filter()를 호출하지 않고 응답 완료
        log.warn("유효하지 않은 API Key 요청: {}", path);
        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
        return exchange.getResponse().setComplete();
    }
}
```

### 10.1.5 요청 속성(Attribute) 전달

필터에서 설정한 데이터를 다운스트림 핸들러로 전달할 때 `ServerWebExchange`의 속성을 활용한다.

```java
@Component
@Order(0)
public class RequestContextFilter implements WebFilter {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        String requestId = UUID.randomUUID().toString().substring(0, 8);
        exchange.getAttributes().put("requestId", requestId);
        exchange.getResponse().getHeaders().add("X-Request-Id", requestId);
        return chain.filter(exchange);
    }
}

// 컨트롤러에서 속성 사용
@GetMapping("/api/products")
public Mono<ResponseEntity<List<Product>>> getProducts(ServerWebExchange exchange) {
    String requestId = exchange.getAttribute("requestId");
    log.info("[{}] 상품 목록 조회 요청", requestId);
    // ...
}
```

---

## 10.2 HandlerFilterFunction 활용

### 10.2.1 WebFilter와 HandlerFilterFunction 비교

`HandlerFilterFunction`은 **함수형 엔드포인트(RouterFunction)** 전용 필터다.

```java
@FunctionalInterface
public interface HandlerFilterFunction<T extends ServerResponse, R extends ServerResponse> {
    Mono<R> filter(ServerRequest request, HandlerFunction<T> next);
}
```

| 항목 | WebFilter | HandlerFilterFunction |
|------|-----------|----------------------|
| 적용 대상 | 모든 요청 (어노테이션 + 함수형) | 함수형 엔드포인트만 |
| 적용 범위 | 글로벌 | 특정 RouterFunction |
| 접근 객체 | `ServerWebExchange` | `ServerRequest` / `ServerResponse` |
| 등록 방법 | `@Component` 자동 등록 | `RouterFunction.filter()` |

### 10.2.2 기본 사용법

`RouterFunction`의 `filter()` 메서드에 람다로 필터를 전달한다.

```java
@Configuration
public class ProductRouter {
    @Bean
    public RouterFunction<ServerResponse> productRoutes(ProductHandler handler) {
        return nest(path("/api/products"),
            route(GET(""), handler::getAll)
            .andRoute(POST(""), handler::create)
            .andRoute(PUT("/{id}"), handler::update)
            .andRoute(DELETE("/{id}"), handler::delete)
        )
        .filter((request, next) -> {
            log.info("Product API 요청: {} {}", request.method(), request.path());
            return next.handle(request);
        });
    }
}
```

### 10.2.3 인증 필터 구현

실제 프로젝트에서 자주 사용하는 인증 필터를 `HandlerFilterFunction`으로 구현한다.

```java
public class AuthFilterFunction
        implements HandlerFilterFunction<ServerResponse, ServerResponse> {

    private final TokenValidator tokenValidator;

    public AuthFilterFunction(TokenValidator tokenValidator) {
        this.tokenValidator = tokenValidator;
    }

    @Override
    public Mono<ServerResponse> filter(ServerRequest request,
                                       HandlerFunction<ServerResponse> next) {
        String authHeader = request.headers().firstHeader("Authorization");

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            return ServerResponse.status(HttpStatus.UNAUTHORIZED)
                .bodyValue(Map.of("error", "Authorization 헤더가 필요합니다."));
        }

        String token = authHeader.substring(7);

        return tokenValidator.validate(token)
            .flatMap(userId -> {
                ServerRequest modifiedRequest = ServerRequest.from(request)
                    .attribute("userId", userId)
                    .build();
                return next.handle(modifiedRequest);
            })
            .onErrorResume(InvalidTokenException.class, e ->
                ServerResponse.status(HttpStatus.UNAUTHORIZED)
                    .bodyValue(Map.of("error", e.getMessage()))
            );
    }
}
```

라우터에서 공개 API와 보호된 API를 분리하여 인증 필터를 선택적으로 적용한다.

```java
@Configuration
public class AppRouter {

    private final TokenValidator tokenValidator;

    public AppRouter(TokenValidator tokenValidator) {
        this.tokenValidator = tokenValidator;
    }

    @Bean
    public RouterFunction<ServerResponse> routes(
            ProductHandler productHandler, AuthHandler authHandler) {

        // 인증 불필요: 공개 API
        RouterFunction<ServerResponse> publicRoutes = route(
            POST("/api/auth/login"), authHandler::login
        ).andRoute(
            POST("/api/auth/register"), authHandler::register
        );

        // 인증 필요: 보호된 API
        RouterFunction<ServerResponse> protectedRoutes = nest(path("/api/products"),
            route(GET(""), productHandler::getAll)
            .andRoute(POST(""), productHandler::create)
            .andRoute(DELETE("/{id}"), productHandler::delete)
        ).filter(new AuthFilterFunction(tokenValidator));

        return publicRoutes.and(protectedRoutes);
    }
}
```

### 10.2.4 역할 기반 접근 제어 필터

인증 필터를 확장하여 역할(Role) 기반 인가 필터도 구현할 수 있다. 여러 필터를 체이닝하면 인증 -> 인가 순서로 적용된다.

```java
public class RoleFilterFunction
        implements HandlerFilterFunction<ServerResponse, ServerResponse> {

    private final Set<String> allowedRoles;

    public RoleFilterFunction(String... roles) {
        this.allowedRoles = Set.of(roles);
    }

    @Override
    public Mono<ServerResponse> filter(ServerRequest request,
                                       HandlerFunction<ServerResponse> next) {
        String userRole = request.attribute("userRole")
            .map(Object::toString).orElse("");

        if (allowedRoles.contains(userRole)) {
            return next.handle(request);
        }
        return ServerResponse.status(HttpStatus.FORBIDDEN)
            .bodyValue(Map.of("error", "접근 권한이 없습니다."));
    }
}

// 관리자 전용 API에 인증 + 역할 필터 체이닝
RouterFunction<ServerResponse> adminRoutes = nest(path("/api/admin"),
    route(GET("/users"), adminHandler::getAllUsers)
    .andRoute(DELETE("/users/{id}"), adminHandler::deleteUser)
)
.filter(new AuthFilterFunction(tokenValidator))
.filter(new RoleFilterFunction("ADMIN"));
```

---

## 10.3 요청/응답 로깅

### 10.3.1 요청 로깅 필터

운영 환경에서 요청 정보를 체계적으로 기록하는 로깅 필터를 구현한다.

```java
@Slf4j
@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
public class RequestLoggingFilter implements WebFilter {

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String requestId = UUID.randomUUID().toString().substring(0, 8);
        String method = request.getMethod().name();
        String path = request.getURI().getPath();
        String clientIp = extractClientIp(request);

        log.info("[{}] >>> {} {} ip={}", requestId, method, path, clientIp);

        long startTime = System.nanoTime();
        exchange.getResponse().getHeaders().add("X-Request-Id", requestId);
        exchange.getAttributes().put("requestId", requestId);

        return chain.filter(exchange)
            .doFinally(signalType -> {
                long durationMs = (System.nanoTime() - startTime) / 1_000_000;
                HttpStatusCode status = exchange.getResponse().getStatusCode();
                log.info("[{}] <<< {} {} -> {} ({}ms)",
                    requestId, method, path, status, durationMs);
            });
    }

    private String extractClientIp(ServerHttpRequest request) {
        String xff = request.getHeaders().getFirst("X-Forwarded-For");
        if (xff != null && !xff.isEmpty()) {
            return xff.split(",")[0].trim();
        }
        return Optional.ofNullable(request.getRemoteAddress())
            .map(addr -> addr.getAddress().getHostAddress())
            .orElse("unknown");
    }
}
```

### 10.3.2 응답 바디 로깅 (ServerHttpResponseDecorator)

응답 바디는 스트림 형태이므로 직접 읽을 수 없다. `ServerHttpResponseDecorator`로 `writeWith`를 오버라이드하여 쓰기 시점에 바이트를 가로채 기록한다.

```java
@Slf4j
@Component
@Order(Ordered.HIGHEST_PRECEDENCE + 1)
public class ResponseBodyLoggingFilter implements WebFilter {

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        if (!log.isDebugEnabled()) return chain.filter(exchange);

        String requestId = exchange.getAttribute("requestId");
        ServerHttpResponse original = exchange.getResponse();

        ServerHttpResponseDecorator decorated = new ServerHttpResponseDecorator(original) {
            @Override
            public Mono<Void> writeWith(Publisher<? extends DataBuffer> body) {
                if (body instanceof Flux<? extends DataBuffer> fluxBody) {
                    return super.writeWith(fluxBody.buffer().map(dataBuffers -> {
                        DataBuffer joined = original.bufferFactory().join(dataBuffers);
                        byte[] content = new byte[joined.readableByteCount()];
                        joined.read(content);
                        DataBufferUtils.release(joined);
                        log.debug("[{}] 응답 바디: {}", requestId,
                            new String(content, StandardCharsets.UTF_8));
                        return original.bufferFactory().wrap(content);
                    }));
                }
                return super.writeWith(body);
            }
        };
        return chain.filter(exchange.mutate().response(decorated).build());
    }
}
```

> **주의**: 응답 바디 로깅은 메모리와 성능에 영향을 미친다. 반드시 디버그 레벨에서만 활성화하고, 대용량 응답에서는 크기 제한 로직을 추가해야 한다.

### 10.3.3 요청 추적 ID와 Reactor Context

리액티브 환경에서는 스레드가 수시로 전환되므로 기존 `MDC`가 정상 작동하지 않는다. Reactor의 **Context**를 활용하여 추적 ID를 전파한다.

```java
@Slf4j
@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
public class TraceIdFilter implements WebFilter {

    private static final String TRACE_ID_KEY = "traceId";

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        String traceId = Optional.ofNullable(
                exchange.getRequest().getHeaders().getFirst("X-Trace-Id")
            ).orElse(UUID.randomUUID().toString());

        exchange.getResponse().getHeaders().add("X-Trace-Id", traceId);

        return chain.filter(exchange)
            .contextWrite(Context.of(TRACE_ID_KEY, traceId));
    }
}
```

서비스 계층에서 Context의 추적 ID를 활용한다.

```java
@Service
@Slf4j
public class ProductService {
    public Mono<Product> findById(String id) {
        return Mono.deferContextual(ctx -> {
            String traceId = ctx.getOrDefault("traceId", "N/A");
            log.info("[{}] 상품 조회: id={}", traceId, id);
            return productRepository.findById(id);
        });
    }
}
```

Spring Boot 3.x에서는 Micrometer **Context Propagation**을 사용하면 MDC 자동 전파를 구성할 수 있다.

```yaml
spring:
  reactor:
    context-propagation: auto
```

---

## 10.4 CORS 설정

### 10.4.1 CORS 개요

브라우저는 **동일 출처 정책(Same-Origin Policy)**을 적용한다. 프런트엔드(`http://localhost:3000`)에서 백엔드(`http://localhost:8080`)를 호출하면 출처가 다르므로 CORS 에러가 발생한다. 서버에서 적절한 CORS 헤더를 응답에 포함해야 한다.

| CORS 헤더 | 설명 |
|-----------|------|
| `Access-Control-Allow-Origin` | 허용할 출처 |
| `Access-Control-Allow-Methods` | 허용할 HTTP 메서드 |
| `Access-Control-Allow-Headers` | 허용할 요청 헤더 |
| `Access-Control-Allow-Credentials` | 쿠키/인증 정보 포함 허용 여부 |
| `Access-Control-Max-Age` | Preflight 요청 캐시 시간(초) |

### 10.4.2 WebFluxConfigurer를 이용한 글로벌 설정

가장 권장되는 방법으로, 모든 엔드포인트에 일괄 적용된다.

```java
@Configuration
public class CorsConfig implements WebFluxConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
            .allowedOrigins("http://localhost:3000", "https://myapp.example.com")
            .allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS")
            .allowedHeaders("*")
            .exposedHeaders("X-Request-Id", "X-Trace-Id")
            .allowCredentials(true)
            .maxAge(3600);
    }
}
```

### 10.4.3 @CrossOrigin 어노테이션

컨트롤러 또는 개별 메서드 레벨에서 세밀하게 CORS를 설정할 수 있다. 클래스 레벨과 메서드 레벨 설정이 동시에 존재하면 **병합**된다.

```java
@RestController
@RequestMapping("/api/products")
@CrossOrigin(origins = "http://localhost:3000", maxAge = 3600)
public class ProductController {

    @CrossOrigin(origins = "https://partner.example.com")
    @GetMapping("/{id}")
    public Mono<Product> getById(@PathVariable String id) {
        return productService.findById(id);
    }
}
```

### 10.4.4 CorsWebFilter (프로그래밍 방식)

함수형 엔드포인트에는 `@CrossOrigin`을 사용할 수 없다. `CorsWebFilter`를 빈으로 등록하면 어노테이션 기반과 함수형 모두에 적용된다.

```java
@Configuration
public class CorsFilterConfig {

    @Bean
    public CorsWebFilter corsWebFilter() {
        CorsConfiguration config = new CorsConfiguration();
        config.addAllowedOrigin("http://localhost:3000");
        config.addAllowedOrigin("https://myapp.example.com");
        config.addAllowedMethod("*");
        config.addAllowedHeader("*");
        config.addExposedHeader("X-Request-Id");
        config.setAllowCredentials(true);
        config.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/api/**", config);
        return new CorsWebFilter(source);
    }
}
```

### 10.4.5 환경별 CORS 설정

개발과 운영 환경마다 허용 출처가 다른 경우 `application.yml` 프로파일과 `@Value`를 조합한다.

```yaml
# application.yml             → app.cors.allowed-origins: "http://localhost:3000"
# application-prod.yml        → app.cors.allowed-origins: "https://myapp.example.com"
```

```java
@Configuration
public class CorsConfig implements WebFluxConfigurer {

    @Value("${app.cors.allowed-origins}")
    private String[] allowedOrigins;

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
            .allowedOrigins(allowedOrigins)
            .allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH")
            .allowedHeaders("*")
            .allowCredentials(true)
            .maxAge(3600);
    }
}
```

---

## 10.5 요청 속도 제한(Rate Limiting)

### 10.5.1 토큰 버킷 알고리즘

가장 널리 사용되는 속도 제한 알고리즘이다.

1. **버킷**에 토큰이 일정 속도로 채워진다.
2. 요청이 들어오면 버킷에서 토큰 1개를 소비한다.
3. 토큰이 없으면 요청을 거부한다(429 Too Many Requests).
4. 버킷 크기가 고정되어 순간적인 버스트(burst)를 일정 수준까지 허용한다.

```
[토큰 생성기] ---(초당 10개)---> [버킷 (최대 20개)]
                                       ↓
                                 요청 -> 토큰 1개 소비
                                 토큰 부족 -> 429 응답
```

### 10.5.2 Bucket4j 의존성

**Bucket4j**는 토큰 버킷 알고리즘의 Java 구현체로, 스레드 안전하며 성능이 뛰어나다. `build.gradle.kts`에 의존성을 추가한다: `implementation("com.bucket4j:bucket4j-core:8.10.1")`

### 10.5.3 IP 기반 속도 제한 필터

클라이언트 IP별로 독립적인 버킷을 관리하는 필터를 구현한다.

```java
@Slf4j
@Component
public class RateLimitFilter implements WebFilter {

    private final Map<String, Bucket> bucketCache = new ConcurrentHashMap<>();

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        String path = exchange.getRequest().getURI().getPath();
        if (!path.startsWith("/api/")) {
            return chain.filter(exchange);
        }

        String clientIp = extractClientIp(exchange);
        Bucket bucket = bucketCache.computeIfAbsent(clientIp, this::createBucket);
        ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);

        if (probe.isConsumed()) {
            exchange.getResponse().getHeaders()
                .add("X-RateLimit-Remaining",
                    String.valueOf(probe.getRemainingTokens()));
            return chain.filter(exchange);
        }

        // 속도 제한 초과 -> 429 응답
        long waitSeconds = probe.getNanosToWaitForRefill() / 1_000_000_000;
        log.warn("속도 제한 초과: IP={}, 재시도까지 {}초", clientIp, waitSeconds);

        exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
        exchange.getResponse().getHeaders().setContentType(MediaType.APPLICATION_JSON);
        exchange.getResponse().getHeaders().add("Retry-After", String.valueOf(waitSeconds));

        String errorBody = """
            {
              "error": "TOO_MANY_REQUESTS",
              "message": "요청 속도 제한을 초과했습니다.",
              "retryAfterSeconds": %d
            }
            """.formatted(waitSeconds);

        return exchange.getResponse().writeWith(
            Mono.just(exchange.getResponse().bufferFactory()
                .wrap(errorBody.getBytes()))
        );
    }

    private Bucket createBucket(String key) {
        Bandwidth limit = Bandwidth.classic(
            10,                                      // 버킷 용량 (버스트)
            Refill.greedy(60, Duration.ofMinutes(1)) // 분당 60개 보충
        );
        return Bucket.builder().addLimit(limit).build();
    }

    private String extractClientIp(ServerWebExchange exchange) {
        String xff = exchange.getRequest().getHeaders().getFirst("X-Forwarded-For");
        if (xff != null && !xff.isEmpty()) return xff.split(",")[0].trim();
        return Optional.ofNullable(exchange.getRequest().getRemoteAddress())
            .map(addr -> addr.getAddress().getHostAddress()).orElse("unknown");
    }
}
```

### 10.5.4 사용자 등급별 차등 속도 제한

인증된 사용자별로 등급(plan)에 따라 다른 제한을 적용한다. 핵심은 `Plan` enum으로 등급별 정책을 정의하고, 사용자 ID와 등급을 조합한 키로 버킷을 관리하는 것이다.

```java
@Slf4j
@Component
@Order(10)  // 인증 필터 이후에 실행
public class UserRateLimitFilter implements WebFilter {

    private final Map<String, Bucket> bucketCache = new ConcurrentHashMap<>();

    enum Plan {
        FREE(20, Duration.ofMinutes(1)),       // 무료: 분당 20건
        BASIC(100, Duration.ofMinutes(1)),      // 기본: 분당 100건
        PREMIUM(1000, Duration.ofMinutes(1));   // 프리미엄: 분당 1000건

        final int capacity;
        final Duration period;
        Plan(int capacity, Duration period) {
            this.capacity = capacity;
            this.period = period;
        }
    }

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        String userId = exchange.getAttribute("userId");
        if (userId == null || !exchange.getRequest().getURI()
                .getPath().startsWith("/api/")) {
            return chain.filter(exchange);
        }

        String userPlan = exchange.getAttribute("userPlan");
        Plan plan = resolvePlan(userPlan);
        Bucket bucket = bucketCache.computeIfAbsent(
            userId + ":" + plan.name(), k -> createBucket(plan));

        ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);

        // 남은 호출 횟수를 헤더로 전달
        exchange.getResponse().getHeaders()
            .add("X-RateLimit-Limit", String.valueOf(plan.capacity));
        exchange.getResponse().getHeaders()
            .add("X-RateLimit-Remaining", String.valueOf(probe.getRemainingTokens()));

        if (probe.isConsumed()) return chain.filter(exchange);

        // 429 응답 (IP 기반 필터와 동일한 패턴)
        exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
        String body = """
            {"error":"TOO_MANY_REQUESTS","plan":"%s","limit":%d}
            """.formatted(plan.name(), plan.capacity);
        return exchange.getResponse().writeWith(
            Mono.just(exchange.getResponse().bufferFactory().wrap(body.getBytes())));
    }

    private Plan resolvePlan(String planStr) {
        try { return Plan.valueOf(planStr.toUpperCase()); }
        catch (Exception e) { return Plan.FREE; }
    }

    private Bucket createBucket(Plan plan) {
        return Bucket.builder().addLimit(Bandwidth.classic(
            plan.capacity, Refill.greedy(plan.capacity, plan.period))).build();
    }
}
```

### 10.5.5 엔드포인트별 차등 속도 제한

로그인 API처럼 브루트포스 공격에 취약한 엔드포인트에는 `HandlerFilterFunction`으로 더 엄격한 제한을 적용한다.

```java
@Configuration
public class RateLimitConfig {

    @Bean
    public RouterFunction<ServerResponse> rateLimitedAuthRoutes(AuthHandler handler) {
        return route(POST("/api/auth/login"), handler::login)
            .filter(createRateLimitFilter(5, Duration.ofMinutes(1)))   // 분당 5회
            .andRoute(POST("/api/auth/register"), handler::register)
            .filter(createRateLimitFilter(3, Duration.ofHours(1)));    // 시간당 3회
    }

    private HandlerFilterFunction<ServerResponse, ServerResponse>
            createRateLimitFilter(int capacity, Duration period) {
        Map<String, Bucket> buckets = new ConcurrentHashMap<>();
        return (request, next) -> {
            String ip = request.remoteAddress()
                .map(a -> a.getAddress().getHostAddress()).orElse("unknown");
            Bucket bucket = buckets.computeIfAbsent(ip, k ->
                Bucket.builder().addLimit(
                    Bandwidth.classic(capacity, Refill.greedy(capacity, period))
                ).build());

            if (bucket.tryConsume(1)) return next.handle(request);

            return ServerResponse.status(HttpStatus.TOO_MANY_REQUESTS)
                .bodyValue(Map.of("error", "요청이 너무 많습니다."));
        };
    }
}
```

### 10.5.6 버킷 캐시 메모리 관리

`ConcurrentHashMap`에 IP별 버킷이 무한히 쌓이면 메모리 누수가 발생한다. Caffeine 캐시를 사용하면 자동 만료를 쉽게 구현할 수 있다.

```kotlin
dependencies {
    implementation("com.github.ben-manes.caffeine:caffeine:3.1.8")
}
```

```java
private final Cache<String, Bucket> bucketCache = Caffeine.newBuilder()
    .maximumSize(100_000)
    .expireAfterAccess(Duration.ofMinutes(10))
    .build();

// 사용: bucketCache.get(clientIp, this::createBucket)
```

---

## 10.6 정리

| 주제 | 핵심 기술 | 적용 범위 |
|------|----------|----------|
| WebFilter | `WebFilter` 인터페이스, `@Order` | 모든 요청 (글로벌) |
| HandlerFilterFunction | `RouterFunction.filter()` | 함수형 엔드포인트 (선택적) |
| 요청/응답 로깅 | `ServerHttpResponseDecorator`, Reactor Context | 전역 로깅, 추적 ID |
| CORS | `WebFluxConfigurer`, `@CrossOrigin`, `CorsWebFilter` | API 전체 또는 개별 엔드포인트 |
| 속도 제한 | Bucket4j, 토큰 버킷 알고리즘 | IP별, 사용자별, 엔드포인트별 |

**설계 원칙**:
- **글로벌 관심사**(로깅, 추적 ID, CORS)에는 `WebFilter`를 사용한다.
- **특정 API 그룹에만 적용할 로직**(인증, 인가, 속도 제한)에는 `HandlerFilterFunction`을 사용한다.
- 필터 순서(`@Order`)는 명시적으로 관리하여 의도하지 않은 동작을 방지한다.
- 응답 바디 로깅처럼 성능에 영향을 주는 필터는 조건부로 활성화한다.

다음 Chapter 11에서는 **Spring Security WebFlux**를 활용하여 본격적인 인증과 인가를 구현한다. 이번 장에서 직접 구현한 인증 필터가 Spring Security의 `SecurityWebFilterChain`으로 어떻게 대체되고 확장되는지 비교해 볼 것이다.
