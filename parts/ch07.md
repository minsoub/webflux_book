# Chapter 7. 함수형 엔드포인트 (Router Functions)

Chapter 6에서는 `@RestController`와 어노테이션 기반 방식으로 REST API를 구현했는데, Spring WebFlux는 이와는 다른 접근 방식을 하나 더 제공한다. 바로 **함수형 엔드포인트(Functional Endpoints)**라는 프로그래밍 모델이다. 이번 장에서는 `RouterFunction`과 `HandlerFunction`을 활용해 동일한 API를 함수형 방식으로 구현해보고, 두 방식 사이의 장단점을 실제로 비교해볼 것이다.

---

## 7.1 HandlerFunction과 RouterFunction 이해

### 7.1.1 함수형 엔드포인트의 핵심 구성 요소

함수형 엔드포인트는 사실 그리 복잡하지 않다. 두 가지 핵심 인터페이스만 이해하면 충분하다.

| 구성 요소 | 역할 | 대응하는 어노테이션 방식 |
|-----------|------|------------------------|
| `HandlerFunction` | 요청을 받아 응답을 생성하는 함수 | `@RequestMapping` 메서드 본문 |
| `RouterFunction` | 요청을 적절한 HandlerFunction으로 라우팅 | `@RequestMapping`, `@GetMapping` 등 |
| `ServerRequest` | 불변(immutable) HTTP 요청 객체 | 메서드 파라미터 (`@RequestBody`, `@PathVariable` 등) |
| `ServerResponse` | HTTP 응답을 빌더 패턴으로 생성 | 컨트롤러 반환값 |

### 7.1.2 HandlerFunction 인터페이스

`HandlerFunction<T extends ServerResponse>`를 먼저 살펴보자. 이것은 `ServerRequest`를 받아 `Mono<T>`를 반환하는 함수형 인터페이스이기 때문에

```java
@FunctionalInterface
public interface HandlerFunction<T extends ServerResponse> {
    Mono<T> handle(ServerRequest request);
}
```

개념상으로는 `Function<ServerRequest, Mono<ServerResponse>>`와 다를 바 없다. 그래서 이 단순한 시그니처 덕분에 람다로 아주 간결하게 핸들러를 작성할 수 있는 장점이 생기는 거다.

```java
// 람다로 작성한 간단한 핸들러
HandlerFunction<ServerResponse> helloHandler = request ->
    ServerResponse.ok()
        .contentType(MediaType.TEXT_PLAIN)
        .bodyValue("Hello, WebFlux!");
```

### 7.1.3 RouterFunction 인터페이스

한편 `RouterFunction<T extends ServerResponse>`는 들어오는 요청을 분석해서 적절한 `HandlerFunction`으로 보내주는 역할을 담당한다.

```java
@FunctionalInterface
public interface RouterFunction<T extends ServerResponse> {
    Mono<HandlerFunction<T>> route(ServerRequest request);
}
```

물론 직접 구현할 수도 있지만, 보통은 `RouterFunctions.route()` 같은 헬퍼 메서드를 사용해서 선언적으로 라우팅을 정의하는 방식을 선호한다.

### 7.1.4 ServerRequest와 ServerResponse

**ServerRequest**는 불변 객체인데, HTTP 메서드, URI, 헤더, 쿼리 파라미터, 요청 바디 등 필요한 모든 정보에 접근할 수 있는 메서드들을 제공한다.

```java
// ServerRequest 주요 메서드
request.method();                          // HTTP 메서드
request.uri();                             // 전체 URI
request.path();                            // 경로
request.pathVariable("id");               // 경로 변수
request.queryParam("name");               // 쿼리 파라미터 (Optional)
request.headers();                         // 헤더 접근
request.bodyToMono(Product.class);        // 바디를 Mono로 변환
request.bodyToFlux(Product.class);        // 바디를 Flux로 변환
```

한편 **ServerResponse**는 빌더 패턴을 사용해서 HTTP 응답을 유연하게 구성할 수 있도록 해준다.

```java
// 200 OK + JSON 바디
ServerResponse.ok()
    .contentType(MediaType.APPLICATION_JSON)
    .bodyValue(product);

// 201 Created + Location 헤더
ServerResponse.created(URI.create("/api/products/" + id))
    .bodyValue(savedProduct);

// 204 No Content
ServerResponse.noContent().build();

// 404 Not Found
ServerResponse.notFound().build();

// Mono/Flux를 바디로 설정
ServerResponse.ok().body(productMono, Product.class);
ServerResponse.ok().body(productFlux, Product.class);
```

---

## 7.2 RouterFunction으로 라우팅 정의하기

### 7.2.1 기본 라우팅 정의

실제로 라우팅을 정의할 때는 `RouterFunctions.route()`와 `RequestPredicates`를 조합해서 사용한다. 어렵지 않으니 바로 코드로 살펴보자.

```java
import static org.springframework.web.reactive.function.server.RouterFunctions.route;
import static org.springframework.web.reactive.function.server.RequestPredicates.*;

@Configuration
public class ProductRouter {

    @Bean
    public RouterFunction<ServerResponse> productRoutes(ProductHandler handler) {
        return route(GET("/api/products"), handler::getAll)
            .andRoute(GET("/api/products/{id}"), handler::getById)
            .andRoute(POST("/api/products"), handler::create)
            .andRoute(PUT("/api/products/{id}"), handler::update)
            .andRoute(DELETE("/api/products/{id}"), handler::delete);
    }
}
```

`RequestPredicates`는 요청 조건을 표현하는 유틸리티 클래스다. HTTP 메서드, 경로, 콘텐츠 타입 등 다양한 조건을 조합할 수 있다.

```java
// 메서드 + 경로
GET("/api/products")
POST("/api/products")

// 경로만
path("/api/products")

// 콘텐츠 타입 조건 추가
POST("/api/products").and(contentType(MediaType.APPLICATION_JSON))

// Accept 헤더 조건
GET("/api/products").and(accept(MediaType.APPLICATION_JSON))

// 조건 결합
method(HttpMethod.GET).and(path("/api/products")).and(accept(MediaType.APPLICATION_JSON))
```

### 7.2.2 nest()로 라우팅 그룹화

같은 경로 접두사를 쓰는 라우트들이 많을 때는 `nest()`를 사용해서 그룹화하면 중복 코드를 줄일 수 있다. 또한 코드도 훨씬 읽기 쉬워진다.

```java
@Configuration
public class ProductRouter {

    @Bean
    public RouterFunction<ServerResponse> productRoutes(ProductHandler handler) {
        return nest(path("/api/products"),
            route(GET(""), handler::getAll)
            .andRoute(GET("/{id}"), handler::getById)
            .andRoute(POST("").and(contentType(MediaType.APPLICATION_JSON)), handler::create)
            .andRoute(PUT("/{id}").and(contentType(MediaType.APPLICATION_JSON)), handler::update)
            .andRoute(DELETE("/{id}"), handler::delete)
        );
    }
}
```

당연히 여러 리소스를 함께 관리하는 것도 가능하다. 한 설정 클래스에서 `products`, `categories`, `orders` 같은 여러 엔드포인트를 한 번에 정의할 수 있다.

```java
@Configuration
public class AppRouter {

    @Bean
    public RouterFunction<ServerResponse> routes(
            ProductHandler productHandler,
            CategoryHandler categoryHandler,
            OrderHandler orderHandler) {

        return nest(path("/api"),
            nest(path("/products"),
                route(GET(""), productHandler::getAll)
                .andRoute(GET("/{id}"), productHandler::getById)
                .andRoute(POST(""), productHandler::create)
                .andRoute(PUT("/{id}"), productHandler::update)
                .andRoute(DELETE("/{id}"), productHandler::delete)
            )
            .andNest(path("/categories"),
                route(GET(""), categoryHandler::getAll)
                .andRoute(GET("/{id}"), categoryHandler::getById)
                .andRoute(POST(""), categoryHandler::create)
            )
            .andNest(path("/orders"),
                route(GET(""), orderHandler::getAll)
                .andRoute(POST(""), orderHandler::create)
            )
        );
    }
}
```

### 7.2.3 필터 적용

`RouterFunction`에 `filter()`를 적용해서 요청과 응답을 가로채고 공통 로직을 추가할 수 있다. 어노테이션 방식의 `WebFilter`나 `HandlerInterceptor`와 비슷한 역할을 한다고 생각하면 된다.

```java
@Bean
public RouterFunction<ServerResponse> productRoutes(ProductHandler handler) {
    return nest(path("/api/products"),
        route(GET(""), handler::getAll)
        .andRoute(GET("/{id}"), handler::getById)
        .andRoute(POST(""), handler::create)
    )
    .filter((request, next) -> {
        long startTime = System.currentTimeMillis();
        log.info("Request: {} {}", request.method(), request.path());

        return next.handle(request)
            .doOnSuccess(response -> {
                long duration = System.currentTimeMillis() - startTime;
                log.info("Response: {} ({}ms)", response.statusCode(), duration);
            });
    });
}
```

### 7.2.4 before()와 after()

만약 요청 전/후 처리를 좀 더 깔끔하게 분리하고 싶다면, `filter()` 대신 `before()`와 `after()`를 사용할 수 있다.

```java
@Bean
public RouterFunction<ServerResponse> productRoutes(ProductHandler handler) {
    return route(GET("/api/products"), handler::getAll)
        .andRoute(POST("/api/products"), handler::create)
        .before(request -> {
            log.info("[Before] {} {}", request.method(), request.path());
            return request;
        })
        .after((request, response) -> {
            log.info("[After] {} -> {}", request.path(), response.statusCode());
            return response;
        });
}
```

---

## 7.3 HandlerFunction 구현

### 7.3.1 Handler 클래스 구조

실제 프로젝트에서는 핸들러를 별도의 클래스로 빼서 관리한다. 어노테이션 방식의 컨트롤러처럼 생각하면 된다.

```java
@Component
@RequiredArgsConstructor
public class ProductHandler {

    private final ProductService productService;

    /**
     * 전체 상품 조회
     */
    public Mono<ServerResponse> getAll(ServerRequest request) {
        Flux<Product> products = productService.findAll();
        return ServerResponse.ok()
            .contentType(MediaType.APPLICATION_JSON)
            .body(products, Product.class);
    }

    /**
     * 단일 상품 조회
     */
    public Mono<ServerResponse> getById(ServerRequest request) {
        String id = request.pathVariable("id");
        return productService.findById(id)
            .flatMap(product -> ServerResponse.ok()
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(product))
            .switchIfEmpty(ServerResponse.notFound().build());
    }

    /**
     * 상품 생성
     */
    public Mono<ServerResponse> create(ServerRequest request) {
        return request.bodyToMono(Product.class)
            .flatMap(productService::save)
            .flatMap(saved -> ServerResponse
                .created(URI.create("/api/products/" + saved.getId()))
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(saved));
    }

    /**
     * 상품 수정
     */
    public Mono<ServerResponse> update(ServerRequest request) {
        String id = request.pathVariable("id");
        return request.bodyToMono(Product.class)
            .flatMap(product -> productService.update(id, product))
            .flatMap(updated -> ServerResponse.ok()
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(updated))
            .switchIfEmpty(ServerResponse.notFound().build());
    }

    /**
     * 상품 삭제
     */
    public Mono<ServerResponse> delete(ServerRequest request) {
        String id = request.pathVariable("id");
        return productService.deleteById(id)
            .then(ServerResponse.noContent().build());
    }
}
```

### 7.3.2 도메인 모델과 서비스 계층

핸들러를 위한 도메인 모델과 서비스 계층은 어노테이션 방식과 완전히 같은 방식으로 작성할 수 있다. 결국 비즈니스 로직은 바뀌지 않으니까.

```java
@Document(collection = "products")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Product {

    @Id
    private String id;
    private String name;
    private String description;
    private BigDecimal price;
    private String category;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```

```java
public interface ProductRepository extends ReactiveMongoRepository<Product, String> {
}
```

```java
@Service
@RequiredArgsConstructor
public class ProductService {

    private final ProductRepository productRepository;

    public Flux<Product> findAll() { return productRepository.findAll(); }
    public Mono<Product> findById(String id) { return productRepository.findById(id); }

    public Mono<Product> save(Product product) {
        product.setCreatedAt(LocalDateTime.now());
        product.setUpdatedAt(LocalDateTime.now());
        return productRepository.save(product);
    }

    public Mono<Product> update(String id, Product product) {
        return productRepository.findById(id)
            .map(existing -> {
                existing.setName(product.getName());
                existing.setPrice(product.getPrice());
                existing.setCategory(product.getCategory());
                existing.setUpdatedAt(LocalDateTime.now());
                return existing;
            })
            .flatMap(productRepository::save);
    }

    public Mono<Void> deleteById(String id) { return productRepository.deleteById(id); }
}
```

### 7.3.3 에러 처리가 포함된 핸들러

실무에서는 입력값 검증, 리소스 없음 등 여러 가지 에러 상황을 처리해야 한다. 함수형 방식에서는 이를 어떻게 다룰까.

```java
@Component
@RequiredArgsConstructor
public class ProductHandler {

    private final ProductService productService;
    private final Validator validator;

    public Mono<ServerResponse> create(ServerRequest request) {
        return request.bodyToMono(Product.class)
            .doOnNext(this::validate)
            .flatMap(productService::save)
            .flatMap(saved -> ServerResponse
                .created(URI.create("/api/products/" + saved.getId()))
                .bodyValue(saved))
            .onErrorResume(ValidationException.class, e ->
                ServerResponse.badRequest()
                    .bodyValue(new ErrorResponse("VALIDATION_ERROR", e.getMessage())))
            .onErrorResume(e ->
                ServerResponse.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .bodyValue(new ErrorResponse("INTERNAL_ERROR", "서버 내부 오류가 발생했습니다.")));
    }

    private void validate(Product product) {
        Errors errors = new BeanPropertyBindingResult(product, "product");
        validator.validate(product, errors);
        if (errors.hasErrors()) {
            String message = errors.getFieldErrors().stream()
                .map(e -> e.getField() + ": " + e.getDefaultMessage())
                .collect(Collectors.joining(", "));
            throw new ValidationException(message);
        }
    }
}
```

```java
@Data
@AllArgsConstructor
public class ErrorResponse {
    private String code;
    private String message;
}
```

---

## 7.4 요청 파라미터 및 바디 처리

### 7.4.1 경로 변수 (Path Variable)

경로에서 값을 추출하려면 `{변수명}` 형태로 선언해야 하고, 핸들러에서 `ServerRequest.pathVariable()`로 꺼내면 된다.

```java
// Router 정의
route(GET("/api/products/{id}"), handler::getById)

// Handler에서 추출
public Mono<ServerResponse> getById(ServerRequest request) {
    String id = request.pathVariable("id");
    return productService.findById(id)
        .flatMap(product -> ServerResponse.ok().bodyValue(product))
        .switchIfEmpty(ServerResponse.notFound().build());
}
```

경로 변수가 여러 개인 경우도 마찬가지다. 각각 `pathVariable()`로 꺼내면 된다.

```java
// 중첩 리소스 라우팅
route(GET("/api/categories/{categoryId}/products/{productId}"), handler::getProductInCategory)

// Handler
public Mono<ServerResponse> getProductInCategory(ServerRequest request) {
    String categoryId = request.pathVariable("categoryId");
    String productId = request.pathVariable("productId");
    return productService.findByCategoryAndId(categoryId, productId)
        .flatMap(product -> ServerResponse.ok().bodyValue(product))
        .switchIfEmpty(ServerResponse.notFound().build());
}
```

### 7.4.2 쿼리 파라미터 (Query Parameter)

쿼리 파라미터는 `ServerRequest.queryParam()`으로 꺼내는데, 이 메서드는 `Optional<String>`을 반환한다기 때문에 존재 여부 확인을 명시적으로 해야 한다. 필요하면 `queryParams()`로 전체 파라미터 맵을 받을 수도 있다.

```java
// GET /api/products?category=electronics&minPrice=10000&page=0&size=20
public Mono<ServerResponse> search(ServerRequest request) {
    Optional<String> category = request.queryParam("category");
    Optional<String> minPrice = request.queryParam("minPrice");
    int page = request.queryParam("page")
        .map(Integer::parseInt)
        .orElse(0);
    int size = request.queryParam("size")
        .map(Integer::parseInt)
        .orElse(20);

    Flux<Product> results = productService.search(
        category.orElse(null),
        minPrice.map(BigDecimal::new).orElse(null),
        PageRequest.of(page, size)
    );

    return ServerResponse.ok()
        .contentType(MediaType.APPLICATION_JSON)
        .body(results, Product.class);
}
```

### 7.4.3 요청 바디 처리: bodyToMono / bodyToFlux

요청 바디는 포함된 데이터의 특성에 따라 다르게 처리하면 된다. 단일 객체면 `bodyToMono()`, 여러 개의 스트리밍 데이터면 `bodyToFlux()`를 쓰자.

```java
// 단일 객체 수신
public Mono<ServerResponse> create(ServerRequest request) {
    return request.bodyToMono(Product.class)
        .flatMap(productService::save)
        .flatMap(saved -> ServerResponse.created(
            URI.create("/api/products/" + saved.getId()))
            .bodyValue(saved));
}

// 여러 객체 일괄 수신
public Mono<ServerResponse> createBatch(ServerRequest request) {
    Flux<Product> products = request.bodyToFlux(Product.class);
    return productService.saveAll(products)
        .collectList()
        .flatMap(savedList -> ServerResponse.ok()
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(savedList));
}
```

### 7.4.4 ParameterizedTypeReference 활용

복잡한 제네릭 타입이 포함된 데이터를 역직렬화해야 할 때가 있다. 이 경우 `ParameterizedTypeReference`를 사용해야 하기 때문에 알아두면 유용하다.

```java
// Map<String, Object> 형태의 바디 수신
public Mono<ServerResponse> handleDynamic(ServerRequest request) {
    return request.bodyToMono(new ParameterizedTypeReference<Map<String, Object>>() {})
        .flatMap(body -> {
            String name = (String) body.get("name");
            // 동적 처리
            return ServerResponse.ok().bodyValue(Map.of("received", name));
        });
}
```

### 7.4.5 헤더 및 쿠키 접근

요청에 포함된 헤더와 쿠키도 당연히 접근할 수 있다. 다음과 같이 처리한다.

```java
public Mono<ServerResponse> withHeaders(ServerRequest request) {
    // 헤더 접근
    ServerRequest.Headers headers = request.headers();
    List<MediaType> acceptTypes = headers.accept();
    Optional<String> authHeader = headers.firstHeader("Authorization");
    OptionalLong contentLength = headers.contentLength();

    // 쿠키 접근
    MultiValueMap<String, HttpCookie> cookies = request.cookies();
    HttpCookie sessionCookie = cookies.getFirst("SESSION_ID");

    return ServerResponse.ok()
        .bodyValue(Map.of(
            "accept", acceptTypes.toString(),
            "hasAuth", authHeader.isPresent()
        ));
}
```

### 7.4.6 멀티파트 파일 업로드

파일 업로드 같은 멀티파트 요청도 함수형 방식에서 충분히 처리할 수 있다. 어렵지도 않다.

```java
// Router 정의
route(POST("/api/products/{id}/image")
    .and(contentType(MediaType.MULTIPART_FORM_DATA)), handler::uploadImage)
```

```java
// Handler 구현
public Mono<ServerResponse> uploadImage(ServerRequest request) {
    String productId = request.pathVariable("id");

    return request.multipartData()
        .flatMap(parts -> {
            Part filePart = parts.getFirst("file");
            if (filePart instanceof FilePart fp) {
                String filename = fp.filename();
                Path destination = Path.of("/uploads", productId + "_" + filename);
                return fp.transferTo(destination)
                    .then(productService.updateImagePath(productId, destination.toString()))
                    .flatMap(updated -> ServerResponse.ok().bodyValue(updated));
            }
            return ServerResponse.badRequest()
                .bodyValue(new ErrorResponse("INVALID_FILE", "파일이 전송되지 않았습니다."));
        });
}
```

만약 여러 파트를 세분화해서 처리해야 하면 `BodyExtractors.toMultipartData()`를 쓰면 텍스트 필드(`FormFieldPart`)와 파일(`FilePart`)을 구분해서 다룰 수 있다.

---

## 7.5 어노테이션 방식과 함수형 방식 비교

### 7.5.1 같은 API를 두 방식으로 구현

이제 실제로 같은 기능을 하는 API를 어노테이션 방식과 함수형 방식으로 각각 만들어보고, 어떤 차이가 있는지 살펴보자. 상품 CRUD API를 예로 든다.

**어노테이션 방식 (@RestController)**

```java
@RestController
@RequestMapping("/api/products")
@RequiredArgsConstructor
public class ProductController {

    private final ProductService productService;

    @GetMapping
    public Flux<Product> getAll() {
        return productService.findAll();
    }

    @GetMapping("/{id}")
    public Mono<ResponseEntity<Product>> getById(@PathVariable String id) {
        return productService.findById(id)
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono<Product> create(@Valid @RequestBody Product product) {
        return productService.save(product);
    }

    @PutMapping("/{id}")
    public Mono<ResponseEntity<Product>> update(
            @PathVariable String id,
            @Valid @RequestBody Product product) {
        return productService.update(id, product)
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public Mono<Void> delete(@PathVariable String id) {
        return productService.deleteById(id);
    }
}
```

**함수형 방식 (RouterFunction + HandlerFunction)**

```java
// Router
@Configuration
public class ProductRouter {

    @Bean
    public RouterFunction<ServerResponse> productRoutes(ProductHandler handler) {
        return nest(path("/api/products"),
            route(GET(""), handler::getAll)
            .andRoute(GET("/{id}"), handler::getById)
            .andRoute(POST("").and(contentType(MediaType.APPLICATION_JSON)),
                      handler::create)
            .andRoute(PUT("/{id}").and(contentType(MediaType.APPLICATION_JSON)),
                      handler::update)
            .andRoute(DELETE("/{id}"), handler::delete)
        );
    }
}

// Handler
@Component
@RequiredArgsConstructor
public class ProductHandler {

    private final ProductService productService;

    public Mono<ServerResponse> getAll(ServerRequest request) {
        return ServerResponse.ok()
            .contentType(MediaType.APPLICATION_JSON)
            .body(productService.findAll(), Product.class);
    }

    public Mono<ServerResponse> getById(ServerRequest request) {
        String id = request.pathVariable("id");
        return productService.findById(id)
            .flatMap(product -> ServerResponse.ok()
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(product))
            .switchIfEmpty(ServerResponse.notFound().build());
    }

    public Mono<ServerResponse> create(ServerRequest request) {
        return request.bodyToMono(Product.class)
            .flatMap(productService::save)
            .flatMap(saved -> ServerResponse
                .created(URI.create("/api/products/" + saved.getId()))
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(saved));
    }

    public Mono<ServerResponse> update(ServerRequest request) {
        String id = request.pathVariable("id");
        return request.bodyToMono(Product.class)
            .flatMap(product -> productService.update(id, product))
            .flatMap(updated -> ServerResponse.ok()
                .contentType(MediaType.APPLICATION_JSON)
                .bodyValue(updated))
            .switchIfEmpty(ServerResponse.notFound().build());
    }

    public Mono<ServerResponse> delete(ServerRequest request) {
        String id = request.pathVariable("id");
        return productService.deleteById(id)
            .then(ServerResponse.noContent().build());
    }
}
```

### 7.5.2 핵심 차이점 분석

두 방식을 찬찬히 비교해보면 여러 차이점이 눈에 띈다.

**라우팅 정의**: 어노테이션 방식에서는 라우팅 정보(`@GetMapping`)와 비즈니스 로직이 같은 클래스, 같은 메서드에 있다. 함수형 방식은 Router에서 라우팅을 정의하고, Handler에서 로직을 구현하기 때문에 역할이 명확히 분리된다는 게 큰 특징이다.

**파라미터 바인딩**: 어노테이션 방식이 `@PathVariable`, `@RequestBody` 같은 어노테이션으로 자동으로 바인딩해주는 반면, 함수형 방식에서는 `ServerRequest.pathVariable()`, `bodyToMono()` 같은 메서드를 직접 호출해야 한다. 더 명시적이라고 볼 수 있다.

**검증 처리**: 어노테이션 방식은 `@Valid` 어노테이션 하나로 자동 검증이 되는데, 함수형 방식에서는 `Validator`를 직접 주입받아서 수동으로 호출해야 한다.

### 7.5.3 장단점 비교표

| 비교 항목 | 어노테이션 방식 | 함수형 방식 |
|-----------|----------------|------------|
| **진입 장벽** | 낮음 (Spring MVC 경험 활용) | 중간 (함수형 개념 필요) |
| **코드 간결성** | 간결 (어노테이션이 많은 것을 대행) | 상대적으로 장황 |
| **라우팅-로직 분리** | 같은 클래스에 혼재 | 명확히 분리 |
| **파라미터 바인딩** | 자동 (`@PathVariable`, `@RequestBody`) | 수동 (`pathVariable()`, `bodyToMono()`) |
| **검증 통합** | `@Valid` 자동 적용 | `Validator` 수동 호출 |
| **테스트 용이성** | `@WebFluxTest` 슬라이스 테스트 | 순수 함수 단위 테스트 용이 |
| **타입 안전성** | 런타임 리플렉션 의존 | 컴파일 타임 검증 |
| **라우팅 유연성** | 고정된 어노테이션 규칙 | 프로그래밍 방식으로 동적 라우팅 가능 |
| **필터 적용** | `WebFilter` (전역) | `filter()` 메서드로 라우트별 적용 가능 |
| **OpenAPI 문서화** | SpringDoc 자동 감지 | 추가 설정 필요 |

### 7.5.4 실무 선택 기준

흥미로운 점은 두 방식을 같은 애플리케이션에 섞어서 쓸 수 있다는 것이다. 둘 다 결국 같은 `DispatcherHandler`에서 처리되기 때문이다. 따라서 팀의 상황과 필요에 맞춰 선택하면 된다.

**어노테이션 방식이 적합한 경우**

- 팀 내에 Spring MVC를 이미 경험한 개발자가 많다면 학습 곡선이 낮은 편이다.
- 대부분이 CRUD 중심의 표준적인 REST API라면 어노테이션으로 충분하다.
- Spring의 자동 검증(`@Valid`)이나 전역 예외 처리(`@ControllerAdvice`) 같은 기능을 활용하고 싶을 때.
- Swagger/OpenAPI 문서를 자동으로 생성하는 것이 중요한 프로젝트.

**함수형 방식이 적합한 경우**

- 라우팅이 동적으로 변해야 하는 경우가 있다면 프로그래밍 방식의 유연성이 빛난다.
- 라우팅과 로직을 명확히 분리해야 한다는 설계 원칙이 있을 때.
- 특정 엔드포인트 그룹에만 필터를 적용하고 싶을 때 함수형 방식이 더 수월하다.
- 경량 마이크로서비스에서 리플렉션 기반의 어노테이션 처리 오버헤드를 줄이고 싶을 때.
- 팀이 함수형 프로그래밍 스타일을 좋아하거나 이미 익숙한 경우.

**혼합 사용 예시**

필자의 경험상, 실제 프로젝트에서는 두 방식을 함께 쓰는 게 가장 실용적이다. 예를 들어, 표준 CRUD는 어노테이션으로 빠르게 구현하고, 복잡한 라우팅이 필요한 부분만 함수형으로 구현하는 식이다.

```java
// 어노테이션 방식 — 일반 CRUD API
@RestController
@RequestMapping("/api/users")
public class UserController {
    // 표준적인 CRUD 엔드포인트
}

// 함수형 방식 — 동적 라우팅이 필요한 특수 API
@Configuration
public class WebhookRouter {

    @Bean
    public RouterFunction<ServerResponse> webhookRoutes(WebhookHandler handler) {
        return nest(path("/api/webhooks"),
            route(POST("/{provider}"), handler::handle)
            .filter((request, next) -> {
                // 웹훅 제공자별 서명 검증
                String provider = request.pathVariable("provider");
                return verifySignature(request, provider)
                    .flatMap(valid -> valid
                        ? next.handle(request)
                        : ServerResponse.status(HttpStatus.UNAUTHORIZED).build());
            })
        );
    }
}
```

### 7.5.5 함수형 엔드포인트에서 OpenAPI 문서화

함수형 방식의 유일한 단점을 꼽으라면, SpringDoc 라이브러리가 라우팅을 자동으로 감지하지 못한다는 것이다. OpenAPI 문서를 원하면 `@RouterOperation`으로 수동 추가해야 한다.

```java
@Bean
@RouterOperations({
    @RouterOperation(path = "/api/products", method = RequestMethod.GET,
        beanClass = ProductHandler.class, beanMethod = "getAll",
        operation = @Operation(operationId = "getAllProducts",
            summary = "전체 상품 조회")),
    @RouterOperation(path = "/api/products/{id}", method = RequestMethod.GET,
        beanClass = ProductHandler.class, beanMethod = "getById",
        operation = @Operation(operationId = "getProductById",
            summary = "상품 단건 조회",
            parameters = @Parameter(name = "id", in = ParameterIn.PATH, required = true)))
})
public RouterFunction<ServerResponse> productRoutes(ProductHandler handler) {
    return nest(path("/api/products"),
        route(GET(""), handler::getAll)
        .andRoute(GET("/{id}"), handler::getById)
    );
}
```

---

## 요약

이번 장에서 배운 핵심 내용을 간단히 정리해보자.

| 주제 | 핵심 내용 |
|------|----------|
| **HandlerFunction** | `ServerRequest -> Mono<ServerResponse>` 시그니처의 함수형 인터페이스 |
| **RouterFunction** | `route()`, `nest()`로 선언적 라우팅 정의, `filter()`로 공통 로직 적용 |
| **ServerRequest** | 불변 요청 객체, `pathVariable()`, `queryParam()`, `bodyToMono()` 등으로 데이터 추출 |
| **ServerResponse** | 빌더 패턴으로 상태 코드, 헤더, 바디를 설정하여 응답 생성 |
| **멀티파트 처리** | `multipartData()`, `BodyExtractors.toMultipartData()`로 파일 업로드 처리 |
| **어노테이션 vs 함수형** | 같은 애플리케이션에 공존 가능, 상황에 따라 적합한 방식 선택 |

다음 장에서는 MongoDB와의 반응형 데이터 접근을 좀 더 깊이 있게 다룬다. `ReactiveMongoTemplate`, 커스텀 쿼리, Aggregation Pipeline, 변경 스트림(Change Stream) 같은 고급 기능들을 살펴보게 될 것이다.
