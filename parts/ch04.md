# Chapter 4. MongoDB 소개

앞선 장에서 리액티브 프로그래밍의 개념과 Project Reactor의 핵심을 다뤘다. 이번 장에서는 리액티브 스택과 궁합이 뛰어난 데이터베이스인 MongoDB를 살펴본다. MongoDB가 왜 리액티브 애플리케이션에 적합한지, 도큐먼트 모델의 특성은 무엇인지, 그리고 실제 설치부터 CRUD 조작까지 실습한다.

---

## 4.1 NoSQL과 MongoDB의 특징

### 4.1.1 RDBMS vs NoSQL 비교

전통적인 관계형 데이터베이스(RDBMS)는 정규화된 테이블, SQL 쿼리, ACID 트랜잭션을 기반으로 한다. 반면 NoSQL은 특정 사용 사례에 최적화된 다양한 데이터 모델을 제공한다.

| 구분 | RDBMS | NoSQL (MongoDB) |
|------|-------|-----------------|
| 데이터 모델 | 테이블, 행, 열 | 도큐먼트 (JSON/BSON) |
| 스키마 | 고정 스키마 (DDL 필수) | 유연한 스키마 (스키마리스) |
| 확장 방식 | 주로 수직 확장 (Scale-up) | 수평 확장 (Scale-out, 샤딩) |
| 트랜잭션 | 강력한 ACID 지원 | 단일 도큐먼트 ACID, 멀티 도큐먼트 트랜잭션 지원 |
| 조인 | JOIN 연산 기본 지원 | 일반적으로 비정규화, `$lookup`으로 제한적 지원 |
| 쿼리 언어 | SQL | MQL (MongoDB Query Language) |
| 적합한 사용 사례 | 복잡한 관계, 정합성 중시 | 빠른 반복 개발, 대규모 읽기/쓰기, 유연한 구조 |

### 4.1.2 MongoDB 핵심 특징

**스키마 유연성**

MongoDB는 같은 컬렉션 안에 서로 다른 구조의 도큐먼트를 저장할 수 있다. 애플리케이션 요구사항이 빠르게 변화하는 환경에서 스키마 마이그레이션 부담을 크게 줄여준다.

```javascript
// 같은 컬렉션에 서로 다른 구조의 도큐먼트가 공존 가능
{ name: "Alice", email: "alice@example.com" }
{ name: "Bob", email: "bob@example.com", phone: "010-1234-5678", address: { city: "Seoul" } }
```

**수평 확장 (Sharding)**

데이터가 증가하면 샤드를 추가하여 여러 서버에 데이터를 분산 저장한다. 애플리케이션 코드 변경 없이 처리 용량을 늘릴 수 있다.

**높은 가용성 (Replica Set)**

복제 세트(Replica Set)를 통해 데이터의 복제본을 여러 노드에 유지한다. 프라이머리 노드가 장애를 겪으면 자동으로 세컨더리 노드가 프라이머리로 승격된다.

### 4.1.3 CAP 정리에서의 MongoDB 위치

분산 시스템에서는 일관성(Consistency), 가용성(Availability), 분단 내성(Partition Tolerance) 세 가지를 동시에 모두 만족할 수 없다는 것이 CAP 정리다.

- **C (Consistency)**: 모든 노드가 같은 시점에 같은 데이터를 반환한다.
- **A (Availability)**: 모든 요청에 대해 응답을 반환한다.
- **P (Partition Tolerance)**: 네트워크 분단이 발생해도 시스템이 동작한다.

MongoDB는 기본적으로 **CP 시스템**으로 분류된다. 프라이머리 노드에 쓰기를 집중하여 일관성을 보장하고, 네트워크 분단 시 가용성보다 일관성을 우선한다. 단, `readPreference`와 `writeConcern` 설정을 조정하면 가용성과 일관성 사이의 균형을 유연하게 조절할 수 있다.

```javascript
// writeConcern 설정 예시
db.orders.insertOne(
  { item: "laptop", qty: 1 },
  { writeConcern: { w: "majority", wtimeout: 5000 } }
)
```

- `w: "majority"` — 과반수 노드에 쓰기가 확인되어야 성공으로 간주
- `w: 1` — 프라이머리에만 쓰기 확인 (기본값, 더 빠르지만 덜 안전)

---

## 4.2 도큐먼트 모델과 컬렉션

### 4.2.1 BSON 형식과 도큐먼트 구조

MongoDB는 내부적으로 **BSON**(Binary JSON) 형식으로 데이터를 저장한다. BSON은 JSON의 확장으로, JSON이 지원하지 않는 추가 데이터 타입을 포함한다.

| BSON 타입 | 설명 | 예시 |
|-----------|------|------|
| String | UTF-8 문자열 | `"Hello"` |
| Int32 / Int64 | 정수형 | `42`, `NumberLong(123456789)` |
| Double | 부동소수점 | `3.14` |
| Boolean | 논리값 | `true`, `false` |
| Date | 날짜/시간 | `ISODate("2025-01-01T00:00:00Z")` |
| ObjectId | 12바이트 고유 식별자 | `ObjectId("507f1f77bcf86cd799439011")` |
| Array | 배열 | `[1, 2, 3]` |
| Object | 내장 도큐먼트 | `{ city: "Seoul" }` |
| Decimal128 | 고정밀 소수점 | `NumberDecimal("19.99")` |
| Binary | 바이너리 데이터 | — |

도큐먼트의 기본 구조는 다음과 같다.

```javascript
{
  _id: ObjectId("65a1b2c3d4e5f6a7b8c9d0e1"),  // 자동 생성되는 고유 식별자
  title: "Spring WebFlux 입문",
  author: {                                     // 내장 도큐먼트
    name: "홍길동",
    email: "hong@example.com"
  },
  tags: ["spring", "webflux", "reactive"],      // 배열
  price: NumberDecimal("35000"),
  publishedAt: ISODate("2025-03-15T09:00:00Z"),
  inStock: true
}
```

`_id` 필드는 컬렉션 내에서 도큐먼트를 고유하게 식별하는 기본 키다. 명시적으로 지정하지 않으면 MongoDB가 `ObjectId`를 자동으로 생성한다.

### 4.2.2 컬렉션 개념

컬렉션(Collection)은 RDBMS의 테이블에 대응하는 개념이다. 그러나 테이블과 달리 컬렉션에 저장되는 도큐먼트들이 반드시 같은 스키마를 가질 필요는 없다.

```javascript
// 컬렉션 생성 (명시적)
db.createCollection("books")

// 또는 첫 번째 도큐먼트 삽입 시 자동 생성
db.books.insertOne({ title: "MongoDB in Action" })
```

필요한 경우 **Schema Validation**을 적용하여 도큐먼트 구조를 강제할 수 있다.

```javascript
db.createCollection("books", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["title", "author", "price"],
      properties: {
        title:  { bsonType: "string", description: "제목은 필수 문자열" },
        author: { bsonType: "string", description: "저자는 필수 문자열" },
        price:  { bsonType: "number", minimum: 0, description: "가격은 0 이상" }
      }
    }
  }
})
```

### 4.2.3 내장 도큐먼트(Embedded) vs 참조(Reference)

MongoDB 스키마 설계에서 가장 중요한 결정 중 하나는 **데이터를 내장할 것인가, 참조할 것인가**이다.

**내장 도큐먼트 방식**

관련 데이터를 하나의 도큐먼트 안에 중첩하여 저장한다.

```javascript
// 주문 도큐먼트에 배송 주소를 내장
{
  _id: ObjectId("..."),
  orderNumber: "ORD-2025-001",
  customer: "김철수",
  items: [
    { productName: "키보드", quantity: 1, price: 89000 },
    { productName: "마우스", quantity: 2, price: 45000 }
  ],
  shippingAddress: {
    zipCode: "06234",
    city: "서울",
    detail: "강남구 테헤란로 123"
  }
}
```

**참조 방식**

별도의 컬렉션에 데이터를 저장하고 `_id`로 연결한다.

```javascript
// users 컬렉션
{ _id: ObjectId("user001"), name: "김철수", email: "kim@example.com" }

// orders 컬렉션 - userId로 참조
{
  _id: ObjectId("order001"),
  userId: ObjectId("user001"),   // 참조
  orderNumber: "ORD-2025-001",
  items: [...]
}
```

**선택 기준**

| 기준 | 내장 (Embedded) | 참조 (Reference) |
|------|----------------|-----------------|
| 관계 유형 | 1:1, 1:N (소량) | 1:N (대량), N:M |
| 읽기 패턴 | 함께 조회하는 경우 | 독립적으로 조회하는 경우 |
| 데이터 크기 | 내장 데이터가 작을 때 | 내장 시 도큐먼트가 16MB 제한에 근접할 때 |
| 갱신 빈도 | 드물게 변경 | 자주 독립적으로 변경 |

### 4.2.4 스키마 설계 패턴

MongoDB에서 자주 사용되는 설계 패턴 몇 가지를 소개한다.

**버킷 패턴 (Bucket Pattern)**: 시계열 데이터처럼 연속적인 데이터를 일정 단위(시간, 개수)로 묶어 하나의 도큐먼트에 저장한다.

```javascript
{
  sensorId: "sensor-001",
  date: ISODate("2025-01-15"),
  readings: [
    { time: ISODate("2025-01-15T00:00:00Z"), value: 23.5 },
    { time: ISODate("2025-01-15T00:05:00Z"), value: 23.7 },
    // ... 하루치 데이터를 하나의 도큐먼트에 저장
  ],
  count: 288,
  avg: 24.1
}
```

**다형성 패턴 (Polymorphic Pattern)**: 유사하지만 구조가 약간 다른 데이터를 같은 컬렉션에 저장한다. `type` 필드로 구분한다.

```javascript
// products 컬렉션
{ type: "book", title: "MongoDB 가이드", author: "홍길동", pages: 500 }
{ type: "electronics", title: "무선 마우스", brand: "Logitech", weight: 85 }
```

---

## 4.3 MongoDB 설치 및 기본 CRUD

### 4.3.1 Docker를 통한 설치

개발 환경에서는 Docker를 사용하면 가장 간편하게 MongoDB를 실행할 수 있다.

```bash
# MongoDB 최신 버전 실행
docker run -d \
  --name mongodb \
  -p 27017:27017 \
  -e MONGO_INITDB_ROOT_USERNAME=admin \
  -e MONGO_INITDB_ROOT_PASSWORD=secret1234 \
  -v mongodb_data:/data/db \
  mongo:7

# 컨테이너 상태 확인
docker ps

# 로그 확인
docker logs mongodb
```

`docker-compose.yml`로 관리하면 더 편리하다.

```yaml
version: "3.8"

services:
  mongodb:
    image: mongo:7
    container_name: mongodb
    ports:
      - "27017:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: secret1234
      MONGO_INITDB_DATABASE: webflux_demo
    volumes:
      - mongodb_data:/data/db

volumes:
  mongodb_data:
```

```bash
# 실행
docker compose up -d

# 종료
docker compose down
```

### 4.3.2 mongosh 사용법

`mongosh`는 MongoDB의 공식 셸 클라이언트다. Docker 컨테이너 안에서 바로 실행할 수 있다.

```bash
# mongosh 접속
docker exec -it mongodb mongosh -u admin -p secret1234

# 데이터베이스 목록 조회
show dbs

# 데이터베이스 선택 (없으면 첫 도큐먼트 삽입 시 자동 생성)
use webflux_demo

# 컬렉션 목록 조회
show collections

# 현재 데이터베이스 확인
db.getName()
```

### 4.3.3 insertOne / insertMany

```javascript
// 단일 도큐먼트 삽입
db.books.insertOne({
  title: "Spring WebFlux 완벽 가이드",
  author: "홍길동",
  price: 35000,
  tags: ["spring", "webflux", "reactive"],
  publishedAt: new Date("2025-03-15")
})

// 다수 도큐먼트 삽입
db.books.insertMany([
  {
    title: "MongoDB 실전 활용",
    author: "김영희",
    price: 32000,
    tags: ["mongodb", "nosql"],
    publishedAt: new Date("2025-01-10")
  },
  {
    title: "리액티브 프로그래밍 입문",
    author: "이철수",
    price: 28000,
    tags: ["reactive", "java"],
    publishedAt: new Date("2024-11-20")
  },
  {
    title: "Kotlin과 WebFlux",
    author: "박민수",
    price: 38000,
    tags: ["kotlin", "webflux", "spring"],
    publishedAt: new Date("2025-06-01")
  }
])
```

### 4.3.4 find / findOne

```javascript
// 전체 조회
db.books.find()

// 보기 좋게 출력
db.books.find().pretty()

// 조건 조회: 가격이 30000 이상인 책
db.books.find({ price: { $gte: 30000 } })

// 특정 필드만 조회 (프로젝션)
db.books.find(
  { price: { $gte: 30000 } },
  { title: 1, price: 1, _id: 0 }
)
// 결과:
// { title: "Spring WebFlux 완벽 가이드", price: 35000 }
// { title: "MongoDB 실전 활용", price: 32000 }
// { title: "Kotlin과 WebFlux", price: 38000 }

// 단일 도큐먼트 조회
db.books.findOne({ author: "홍길동" })

// 배열 필드 조건: tags에 "webflux"가 포함된 책
db.books.find({ tags: "webflux" })

// 논리 연산자 조합
db.books.find({
  $or: [
    { price: { $lt: 30000 } },
    { author: "홍길동" }
  ]
})

// 정렬, 스킵, 제한
db.books.find().sort({ price: -1 }).skip(0).limit(2)
```

### 4.3.5 update

```javascript
// 단일 도큐먼트 수정
db.books.updateOne(
  { title: "MongoDB 실전 활용" },
  { $set: { price: 34000, updatedAt: new Date() } }
)

// 다수 도큐먼트 수정: 모든 책의 가격을 10% 인상
db.books.updateMany(
  {},
  { $mul: { price: 1.1 } }
)

// 배열에 요소 추가
db.books.updateOne(
  { title: "Spring WebFlux 완벽 가이드" },
  { $push: { tags: "java" } }
)

// 필드 제거
db.books.updateOne(
  { title: "Spring WebFlux 완벽 가이드" },
  { $unset: { updatedAt: "" } }
)

// upsert: 있으면 수정, 없으면 삽입
db.books.updateOne(
  { title: "새로운 책" },
  { $set: { author: "신규 저자", price: 25000 } },
  { upsert: true }
)
```

주요 업데이트 연산자 정리:

| 연산자 | 설명 | 예시 |
|--------|------|------|
| `$set` | 필드 값 설정 | `{ $set: { price: 30000 } }` |
| `$unset` | 필드 제거 | `{ $unset: { field: "" } }` |
| `$inc` | 숫자 증감 | `{ $inc: { stock: -1 } }` |
| `$mul` | 숫자 곱셈 | `{ $mul: { price: 1.1 } }` |
| `$push` | 배열에 요소 추가 | `{ $push: { tags: "new" } }` |
| `$pull` | 배열에서 요소 제거 | `{ $pull: { tags: "old" } }` |
| `$addToSet` | 배열에 중복 없이 추가 | `{ $addToSet: { tags: "new" } }` |

### 4.3.6 delete

```javascript
// 단일 도큐먼트 삭제
db.books.deleteOne({ title: "새로운 책" })

// 조건에 맞는 다수 도큐먼트 삭제
db.books.deleteMany({ price: { $lt: 30000 } })

// 컬렉션의 모든 도큐먼트 삭제
db.books.deleteMany({})

// 컬렉션 자체 삭제
db.books.drop()
```

### 4.3.7 MongoDB Compass

MongoDB Compass는 공식 GUI 클라이언트로, 다음과 같은 기능을 제공한다.

- **연결**: `mongodb://admin:secret1234@localhost:27017` 형식의 URI로 접속
- **도큐먼트 탐색**: 시각적으로 데이터를 조회, 편집, 삭제
- **쿼리 작성**: 필터, 프로젝션, 정렬을 GUI에서 구성
- **Aggregation Pipeline 빌더**: 파이프라인 스테이지를 시각적으로 조합
- **인덱스 관리**: 인덱스 생성, 삭제, 성능 분석
- **스키마 분석**: 컬렉션 내 도큐먼트 구조를 시각적으로 파악

> **Tip**: 개발 단계에서 복잡한 쿼리를 작성할 때 Compass의 Aggregation Pipeline 빌더로 먼저 검증한 뒤, 코드로 옮기는 방법을 추천한다.

---

## 4.4 인덱싱과 쿼리 최적화 기초

### 4.4.1 인덱스 종류

인덱스가 없으면 MongoDB는 컬렉션 전체를 스캔(COLLSCAN)해야 한다. 적절한 인덱스를 생성하면 쿼리 성능을 크게 향상시킬 수 있다.

**단일 필드 인덱스**

```javascript
// author 필드에 오름차순 인덱스 생성
db.books.createIndex({ author: 1 })

// price 필드에 내림차순 인덱스 생성
db.books.createIndex({ price: -1 })
```

**복합 인덱스 (Compound Index)**

여러 필드를 조합한 인덱스다. 필드 순서가 중요하다. **ESR 규칙**(Equality, Sort, Range)에 따라 동등 조건 필드를 앞에, 정렬 필드를 중간에, 범위 조건 필드를 뒤에 배치하면 효율적이다.

```javascript
// author(동등) + publishedAt(정렬/범위)에 복합 인덱스
db.books.createIndex({ author: 1, publishedAt: -1 })

// 활용 쿼리: 특정 저자의 책을 최신순으로 조회
db.books.find({ author: "홍길동" }).sort({ publishedAt: -1 })
```

**멀티키 인덱스 (Multikey Index)**

배열 필드에 인덱스를 생성하면 자동으로 멀티키 인덱스가 된다. 배열의 각 요소에 대해 인덱스 항목이 생성된다.

```javascript
// tags 배열 필드에 인덱스
db.books.createIndex({ tags: 1 })

// 활용: tags에 "webflux"가 포함된 도큐먼트 조회
db.books.find({ tags: "webflux" })
```

**텍스트 인덱스 (Text Index)**

전문 검색(Full-Text Search)을 위한 인덱스다.

```javascript
// title과 author에 텍스트 인덱스 생성
db.books.createIndex({ title: "text", author: "text" })

// 텍스트 검색
db.books.find({ $text: { $search: "WebFlux 가이드" } })

// 관련도 점수와 함께 조회
db.books.find(
  { $text: { $search: "WebFlux 가이드" } },
  { score: { $meta: "textScore" } }
).sort({ score: { $meta: "textScore" } })
```

**고유 인덱스 (Unique Index)**

```javascript
// email 필드에 고유 인덱스 생성
db.users.createIndex({ email: 1 }, { unique: true })
```

**TTL 인덱스**

일정 시간이 지난 도큐먼트를 자동으로 삭제한다. 세션, 로그 등 만료가 필요한 데이터에 유용하다.

```javascript
// createdAt 기준으로 24시간(86400초) 후 자동 삭제
db.sessions.createIndex({ createdAt: 1 }, { expireAfterSeconds: 86400 })
```

### 4.4.2 인덱스 생성과 관리

```javascript
// 현재 컬렉션의 모든 인덱스 조회
db.books.getIndexes()

// 인덱스 삭제
db.books.dropIndex("author_1")

// 모든 인덱스 삭제 (_id 인덱스 제외)
db.books.dropIndexes()

// 인덱스 크기 확인
db.books.stats().indexSizes
```

> **주의**: 인덱스는 읽기 성능을 향상시키지만 쓰기 시 인덱스 갱신 비용이 발생한다. 불필요한 인덱스는 오히려 성능을 저하시킨다. 실제 쿼리 패턴을 분석하여 필요한 인덱스만 생성하자.

### 4.4.3 explain()으로 쿼리 실행 계획 분석

`explain()` 메서드를 사용하면 쿼리가 어떻게 실행되는지 확인할 수 있다.

```javascript
// 실행 계획 확인
db.books.find({ author: "홍길동" }).explain("executionStats")
```

주요 확인 항목:

```javascript
{
  "executionStats": {
    "executionSuccess": true,
    "nReturned": 1,              // 반환된 도큐먼트 수
    "executionTimeMillis": 0,     // 실행 시간 (ms)
    "totalKeysExamined": 1,       // 검사한 인덱스 키 수
    "totalDocsExamined": 1,       // 검사한 도큐먼트 수
    "executionStages": {
      "stage": "FETCH",           // 실행 스테이지
      "inputStage": {
        "stage": "IXSCAN",        // 인덱스 스캔 사용
        "indexName": "author_1"
      }
    }
  }
}
```

핵심 지표 해석:

| 지표 | 좋은 상태 | 나쁜 상태 |
|------|-----------|-----------|
| `stage` | `IXSCAN` (인덱스 스캔) | `COLLSCAN` (컬렉션 풀 스캔) |
| `totalDocsExamined` / `nReturned` | 비율이 1에 가까움 | 비율이 매우 큼 (불필요한 스캔) |
| `executionTimeMillis` | 짧음 | 길면 최적화 필요 |

**COLLSCAN이 나타나면** 해당 쿼리 조건에 맞는 인덱스 생성을 검토해야 한다.

```javascript
// 인덱스 없이 조회 (COLLSCAN)
db.books.find({ price: { $gte: 30000 } }).explain("executionStats")
// => stage: "COLLSCAN", totalDocsExamined: 전체 도큐먼트 수

// 인덱스 생성 후 조회 (IXSCAN)
db.books.createIndex({ price: 1 })
db.books.find({ price: { $gte: 30000 } }).explain("executionStats")
// => stage: "IXSCAN", totalDocsExamined ≈ nReturned
```

---

## 4.5 MongoDB와 리액티브 드라이버

### 4.5.1 MongoDB Reactive Streams Driver

MongoDB는 공식적으로 **Reactive Streams** 사양을 구현한 Java 드라이버를 제공한다. 이 드라이버는 논블로킹 I/O를 기반으로 동작하며, Netty를 내부 네트워크 레이어로 사용한다.

```xml
<!-- pom.xml -->
<dependency>
    <groupId>org.mongodb</groupId>
    <artifactId>mongodb-driver-reactivestreams</artifactId>
    <version>5.3.0</version>
</dependency>
```

Reactive Streams Driver를 직접 사용하는 예시:

```java
import com.mongodb.reactivestreams.client.MongoClients;
import com.mongodb.reactivestreams.client.MongoClient;
import com.mongodb.reactivestreams.client.MongoDatabase;
import com.mongodb.reactivestreams.client.MongoCollection;
import org.bson.Document;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

// 클라이언트 생성
MongoClient mongoClient = MongoClients.create("mongodb://admin:secret1234@localhost:27017");
MongoDatabase database = mongoClient.getDatabase("webflux_demo");
MongoCollection<Document> collection = database.getCollection("books");

// 도큐먼트 삽입 (Publisher를 Reactor의 Mono로 래핑)
Document book = new Document("title", "Reactive MongoDB")
    .append("author", "Jane Doe")
    .append("price", 42000);

Mono.from(collection.insertOne(book))
    .subscribe(result ->
        System.out.println("Inserted ID: " + result.getInsertedId()));

// 도큐먼트 조회 (Publisher를 Reactor의 Flux로 래핑)
Flux.from(collection.find())
    .doOnNext(doc -> System.out.println(doc.toJson()))
    .subscribe();
```

### 4.5.2 동기 vs 리액티브 드라이버 비교

| 구분 | 동기 드라이버 | 리액티브 드라이버 |
|------|-------------|-----------------|
| 아티팩트 | `mongodb-driver-sync` | `mongodb-driver-reactivestreams` |
| I/O 모델 | 블로킹 | 논블로킹 |
| 반환 타입 | `List<T>`, `T` | `Publisher<T>` |
| 스레드 모델 | 요청당 스레드 점유 | 이벤트 루프 기반, 스레드 공유 |
| 배압 지원 | 없음 | Reactive Streams 배압 지원 |
| 적합한 프레임워크 | Spring MVC | Spring WebFlux |

동기 드라이버에서 `find()`를 호출하면 결과가 모두 반환될 때까지 호출 스레드가 블로킹된다. 리액티브 드라이버에서는 `Publisher`를 반환하고 구독 시점에 비동기로 데이터를 스트리밍한다.

```java
// 동기 드라이버 — 스레드가 결과 반환까지 대기
List<Document> books = syncCollection.find().into(new ArrayList<>());

// 리액티브 드라이버 — 논블로킹, 데이터가 준비되면 콜백
Flux.from(reactiveCollection.find())
    .collectList()
    .subscribe(books -> { /* 결과 처리 */ });
```

### 4.5.3 Spring Data MongoDB Reactive 모듈 소개

실무에서 Reactive Streams Driver를 직접 사용하는 일은 드물다. **Spring Data MongoDB Reactive** 모듈이 드라이버를 추상화하여 훨씬 편리한 프로그래밍 모델을 제공한다.

**의존성 추가**

```xml
<!-- pom.xml -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-mongodb-reactive</artifactId>
</dependency>
```

```groovy
// build.gradle (Kotlin DSL)
implementation("org.springframework.boot:spring-boot-starter-data-mongodb-reactive")
```

**도메인 모델 정의**

```java
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@Document(collection = "books")   // MongoDB 컬렉션 매핑
public class Book {

    @Id
    private String id;            // MongoDB의 _id에 매핑
    private String title;
    private String author;
    private BigDecimal price;
    private List<String> tags;
    private LocalDateTime publishedAt;

    // 생성자, getter, setter 생략
}
```

**ReactiveMongoRepository 정의**

```java
import org.springframework.data.mongodb.repository.ReactiveMongoRepository;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

public interface BookRepository extends ReactiveMongoRepository<Book, String> {

    // 메서드 이름 기반 쿼리 자동 생성
    Flux<Book> findByAuthor(String author);

    Flux<Book> findByPriceGreaterThanEqual(BigDecimal price);

    Flux<Book> findByTagsContaining(String tag);

    Mono<Book> findByTitle(String title);
}
```

**서비스 및 컨트롤러 예시**

```java
@Service
@RequiredArgsConstructor
public class BookService {

    private final BookRepository bookRepository;

    public Flux<Book> findAll() {
        return bookRepository.findAll();
    }

    public Mono<Book> findById(String id) {
        return bookRepository.findById(id)
            .switchIfEmpty(Mono.error(
                new RuntimeException("Book not found: " + id)));
    }

    public Mono<Book> create(Book book) {
        return bookRepository.save(book);
    }

    public Mono<Void> delete(String id) {
        return bookRepository.deleteById(id);
    }
}

@RestController
@RequestMapping("/api/books")
@RequiredArgsConstructor
public class BookController {

    private final BookService bookService;

    @GetMapping
    public Flux<Book> getAll() {
        return bookService.findAll();
    }

    @GetMapping("/{id}")
    public Mono<Book> getById(@PathVariable String id) {
        return bookService.findById(id);
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono<Book> create(@RequestBody Book book) {
        return bookService.create(book);
    }

    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public Mono<Void> delete(@PathVariable String id) {
        return bookService.delete(id);
    }
}
```

위 코드에서 중요한 점은 **반환 타입이 모두 `Mono` 또는 `Flux`라는 것**이다. 컨트롤러에서 `Mono`나 `Flux`를 반환하면 WebFlux가 구독을 관리하고, 데이터가 준비되는 대로 논블로킹 방식으로 HTTP 응답을 스트리밍한다. 데이터베이스 쿼리부터 HTTP 응답까지 전체 흐름에서 스레드가 블로킹되지 않는다.

**application.yml 설정**

```yaml
spring:
  data:
    mongodb:
      uri: mongodb://admin:secret1234@localhost:27017/webflux_demo?authSource=admin
```

> **Spring Data MongoDB Reactive의 핵심 구성 요소**는 Chapter 5에서 프로젝트를 직접 구성하면서 상세하게 다루고, Chapter 6에서 실제 REST API를 구현하며 실습한다. Chapter 8에서는 `ReactiveMongoTemplate`, Aggregation, Change Streams 등 심화 기능을 다룬다.

---

## 4장 정리

이번 장에서 다룬 핵심 내용을 정리한다.

| 주제 | 핵심 요약 |
|------|----------|
| NoSQL vs RDBMS | MongoDB는 유연한 스키마, 수평 확장, 높은 가용성을 제공하는 도큐먼트 DB |
| CAP 정리 | MongoDB는 CP 시스템. `writeConcern`, `readPreference`로 균형 조절 가능 |
| 도큐먼트 모델 | BSON 형식, 내장 vs 참조 설계 결정이 핵심 |
| 기본 CRUD | `insertOne/Many`, `find`, `updateOne/Many`, `deleteOne/Many` |
| 인덱스 | 단일, 복합, 멀티키, 텍스트, TTL. `explain()`으로 실행 계획 분석 |
| 리액티브 드라이버 | 논블로킹 I/O, `Publisher<T>` 반환, Spring Data MongoDB Reactive로 추상화 |

다음 Chapter 5에서는 실제 개발 환경을 구성하고, Spring Boot + WebFlux + MongoDB Reactive 프로젝트를 처음부터 세팅한다.
