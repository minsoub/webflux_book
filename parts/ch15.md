# Chapter 15. R2DBC와의 통합 (보너스)

지금까지 MongoDB를 중심으로 리액티브 데이터 접근을 살펴봤지만, 현실 프로젝트를 보면 관계형 데이터베이스(RDBMS)와 함께 사용해야 할 때가 매우 많습니다. 예를 들어 사용자 인증과 결제 정보는 강한 일관성이 필요하니 PostgreSQL에 저장하고, 상품 카탈로그와 리뷰는 높은 쓰기 처리량이 필요하니 MongoDB에 저장하는 식으로 말이죠. 이런 **하이브리드 아키텍처**를 설계할 때 핵심 도구가 **R2DBC(Reactive Relational Database Connectivity)**입니다. 이번 장에서는 R2DBC가 무엇인지, 그리고 MongoDB와 함께 사용할 때 어떤 패턴과 주의사항이 있는지 실전 예제로 함께 살펴보겠습니다.

---

## 15.1 R2DBC란?

### 15.1.1 R2DBC 소개

R2DBC는 **Reactive Relational Database Connectivity**의 약자로, 관계형 데이터베이스에 접근하는 비동기/논블로킹 방식의 SPI(Service Provider Interface) 명세입니다. 기존 JDBC는 블로킹 I/O 기반으로 설계되었지만, R2DBC는 처음부터 Reactive Streams 표준을 염두에 두고 논블로킹으로 만들어졌다는 점이 가장 큰 차이입니다.

| 원칙 | 설명 |
|------|------|
| **완전한 논블로킹** | 데이터베이스 연결, 쿼리 실행, 결과 처리 모든 과정이 논블로킹 |
| **Reactive Streams 기반** | `Publisher`, `Subscriber` 패턴을 사용하여 배압(Backpressure) 지원 |
| **SPI 명세** | 드라이버 제공자가 구현하는 인터페이스 규격 |
| **SQL 중심** | ORM이 아닌 SQL 기반 접근 (Spring Data R2DBC가 리포지토리 추상화 제공) |

### 15.1.2 JDBC vs R2DBC

| 구분 | JDBC | R2DBC |
|------|------|-------|
| **I/O 모델** | 블로킹 | 논블로킹 |
| **스레드 모델** | 요청당 스레드 점유 | 이벤트 루프 기반 |
| **반환 타입** | `ResultSet`, `List<T>` | `Mono<T>`, `Flux<T>` |
| **배압 지원** | 없음 | Reactive Streams 기반 지원 |
| **트랜잭션** | `ThreadLocal` 기반 | Reactor Context 기반 |
| **커넥션 풀** | HikariCP 등 | `r2dbc-pool` |
| **Spring 통합** | Spring Data JPA | Spring Data R2DBC |

필자의 경험상, JDBC 기반의 `JdbcTemplate`이나 JPA를 WebFlux와 함께 사용하면 곧바로 성능 문제가 나타납니다. 이벤트 루프 스레드가 데이터베이스 I/O를 기다리면서 블로킹되기 때문인데, 그러면 한 번에 처리할 수 있는 요청의 개수가 급격히 떨어지게 됩니다. R2DBC는 이 문제의 근본적인 해결책입니다.

```
[JDBC + WebFlux]
이벤트 루프 스레드 → DB 쿼리 실행(블로킹) → 스레드 대기 → 처리량 저하

[R2DBC + WebFlux]
이벤트 루프 스레드 → DB 쿼리 요청(논블로킹) → 다른 요청 처리 → 결과 도착 시 콜백
```

### 15.1.3 지원 데이터베이스와 의존성 설정

R2DBC는 SPI 명세이기 때문에 각 데이터베이스 벤더나 커뮤니티에서 드라이버를 구현합니다. 주요 데이터베이스의 상황은 다음과 같습니다.

| 데이터베이스 | Maven/Gradle Artifact |
|-------------|----------------------|
| **PostgreSQL** | `org.postgresql:r2dbc-postgresql` |
| **MySQL** | `io.asyncer:r2dbc-mysql` |
| **MariaDB** | `org.mariadb:r2dbc-mariadb` |
| **H2** | `io.r2dbc:r2dbc-h2` |
| **Oracle** | `com.oracle.database.r2dbc:oracle-r2dbc` |

이 장에서는 가장 널리 사용되는 **PostgreSQL**을 기준으로 진행하겠습니다. 먼저 `build.gradle`에 R2DBC 관련 의존성을 추가해야 합니다.

```groovy
dependencies {
    // 기존 의존성
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    implementation 'org.springframework.boot:spring-boot-starter-data-mongodb-reactive'

    // R2DBC 의존성 추가
    implementation 'org.springframework.boot:spring-boot-starter-data-r2dbc'
    implementation 'org.postgresql:r2dbc-postgresql'

    // Flyway (스키마 마이그레이션) - R2DBC에서는 JDBC 드라이버도 필요
    implementation 'org.flywaydb:flyway-core'
    implementation 'org.flywaydb:flyway-database-postgresql'
    runtimeOnly 'org.postgresql:postgresql'

    testImplementation 'io.r2dbc:r2dbc-h2'
}
```

> **참고**: Flyway 같은 스키마 마이그레이션 도구는 아직 R2DBC를 직접 지원하지 않으므로, 마이그레이션 실행 시에만 JDBC 드라이버가 필요하다. Spring Boot는 시작 시 JDBC 드라이버로 마이그레이션을 수행한 후, 런타임에는 R2DBC 드라이버를 사용한다.

### 15.1.4 Spring Data R2DBC의 핵심 구성 요소

Spring Data R2DBC의 API는 MongoDB와 상당히 유사합니다. 다음 표를 보면 어떤 요소들이 있는지 이해할 수 있습니다.

| 구성 요소 | 설명 |
|----------|------|
| `ReactiveCrudRepository` | 기본 CRUD 연산을 제공하는 리포지토리 인터페이스 |
| `R2dbcEntityTemplate` | `ReactiveMongoTemplate`에 대응하는 저수준 템플릿 |
| `@Table`, `@Id`, `@Column` | 엔티티 매핑 어노테이션 (`@Entity`는 사용하지 않음) |
| `DatabaseClient` | SQL을 직접 작성하여 실행하는 저수준 클라이언트 |
| `R2dbcTransactionManager` | 리액티브 트랜잭션 관리자 |

MongoDB에서 `ReactiveMongoRepository`를 써본 개발자라면 R2DBC의 리포지토리도 거의 같은 방식으로 사용할 수 있습니다.

```java
// MongoDB 리포지토리 (이미 익숙한 패턴)
public interface ProductRepository
        extends ReactiveMongoRepository<Product, String> {
    Flux<Product> findByCategory(String category);
}

// R2DBC 리포지토리 (거의 동일한 패턴)
public interface PaymentRepository
        extends ReactiveCrudRepository<Payment, Long> {
    Flux<Payment> findByUserId(Long userId);
}
```

---

## 15.2 MongoDB + R2DBC(관계형 DB) 멀티 데이터소스 구성

### 15.2.1 아키텍처 설계

멀티 데이터소스 환경에서 성공의 핵심은 각 데이터베이스의 역할을 처음부터 명확히 정의하는 것입니다. 아래는 전형적인 전자상거래 플랫폼의 아키텍처입니다.

```
┌─────────────────────────────────────────────────┐
│                   Spring WebFlux                 │
│                                                  │
│  ┌──────────────┐         ┌──────────────────┐  │
│  │  R2DBC Layer │         │  MongoDB Layer   │  │
│  │ - 사용자     │         │ - 상품 카탈로그  │  │
│  │ - 주문/결제  │         │ - 상품 리뷰      │  │
│  │ - 재고       │         │ - 활동 로그      │  │
│  └──────┬───────┘         └────────┬─────────┘  │
└─────────┼──────────────────────────┼─────────────┘
          │                          │
    ┌─────▼─────┐             ┌──────▼──────┐
    │ PostgreSQL │             │   MongoDB   │
    └───────────┘             └─────────────┘
```

| PostgreSQL (R2DBC) | MongoDB |
|---------------------|---------|
| 강한 일관성, ACID 트랜잭션 필수 | 유연한 스키마, 비정형 데이터 |
| 복잡한 조인이 필요한 데이터 | 높은 쓰기 처리량이 필요한 데이터 |
| 예: 사용자, 주문, 결제, 재고 | 예: 상품 카탈로그, 리뷰, 로그 |

### 15.2.2 application.yml에 두 데이터소스 설정

설정 파일에서 MongoDB와 PostgreSQL의 접속 정보를 분리하여 정의합니다.

```yaml
spring:
  # MongoDB 설정
  data:
    mongodb:
      uri: mongodb://localhost:27017/shopdb
      auto-index-creation: true

  # R2DBC (PostgreSQL) 설정
  r2dbc:
    url: r2dbc:postgresql://localhost:5432/shopdb
    username: shopuser
    password: ${DB_PASSWORD:shoppass}
    pool:
      initial-size: 5
      max-size: 20
      max-idle-time: 30m

  # Flyway (JDBC 기반 마이그레이션)
  flyway:
    enabled: true
    url: jdbc:postgresql://localhost:5432/shopdb
    user: shopuser
    password: ${DB_PASSWORD:shoppass}
    locations: classpath:db/migration
```

### 15.2.3 Flyway 스키마 마이그레이션

관계형 데이터베이스를 사용하려면 테이블 스키마를 미리 정의해야 합니다. Flyway를 이용해 `src/main/resources/db/migration/V1__init.sql` 파일을 작성하겠습니다.

```sql
CREATE TABLE users (
    id          BIGSERIAL PRIMARY KEY,
    username    VARCHAR(50)  NOT NULL UNIQUE,
    email       VARCHAR(100) NOT NULL UNIQUE,
    password    VARCHAR(255) NOT NULL,
    role        VARCHAR(20)  NOT NULL DEFAULT 'USER',
    created_at  TIMESTAMP    NOT NULL DEFAULT NOW()
);

CREATE TABLE orders (
    id              BIGSERIAL PRIMARY KEY,
    user_id         BIGINT       NOT NULL REFERENCES users(id),
    order_number    VARCHAR(30)  NOT NULL UNIQUE,
    status          VARCHAR(20)  NOT NULL DEFAULT 'PENDING',
    total_amount    DECIMAL(12,2) NOT NULL,
    shipping_address TEXT,
    created_at      TIMESTAMP    NOT NULL DEFAULT NOW()
);

CREATE TABLE order_items (
    id          BIGSERIAL PRIMARY KEY,
    order_id    BIGINT       NOT NULL REFERENCES orders(id),
    product_id  VARCHAR(50)  NOT NULL,  -- MongoDB ObjectId 참조
    product_name VARCHAR(200) NOT NULL,
    quantity    INT          NOT NULL,
    unit_price  DECIMAL(10,2) NOT NULL,
    subtotal    DECIMAL(12,2) NOT NULL
);

CREATE TABLE payments (
    id              BIGSERIAL PRIMARY KEY,
    order_id        BIGINT       NOT NULL REFERENCES orders(id),
    payment_method  VARCHAR(30)  NOT NULL,
    amount          DECIMAL(12,2) NOT NULL,
    status          VARCHAR(20)  NOT NULL DEFAULT 'PENDING',
    transaction_id  VARCHAR(100),
    created_at      TIMESTAMP    NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_order_items_order_id ON order_items(order_id);
```

### 15.2.4 MongoDB/R2DBC 설정 클래스

두 데이터소스를 독립적으로 관리하려면 각각의 설정 클래스가 필요합니다. 리포지토리 스캔 경로를 분리하는 것이 핵심입니다.

```java
@Configuration
@EnableR2dbcRepositories(basePackages = "com.example.shop.repository.r2dbc")
public class R2dbcConfig extends AbstractR2dbcConfiguration {

    @Value("${spring.r2dbc.url}")
    private String url;

    @Value("${spring.r2dbc.username}")
    private String username;

    @Value("${spring.r2dbc.password}")
    private String password;

    @Override
    @Bean
    public ConnectionFactory connectionFactory() {
        return ConnectionFactories.get(ConnectionFactoryOptions.builder()
            .from(ConnectionFactoryOptions.parse(url))
            .option(ConnectionFactoryOptions.USER, username)
            .option(ConnectionFactoryOptions.PASSWORD, password)
            .build());
    }

    @Bean
    public ReactiveTransactionManager transactionManager(
            ConnectionFactory connectionFactory) {
        return new R2dbcTransactionManager(connectionFactory);
    }
}
```

```java
@Configuration
@EnableReactiveMongoRepositories(
    basePackages = "com.example.shop.repository.mongo"
)
public class MongoConfig extends AbstractReactiveMongoConfiguration {

    @Value("${spring.data.mongodb.uri}")
    private String mongoUri;

    @Override
    protected String getDatabaseName() {
        return "shopdb";
    }

    @Override
    @Bean
    public MongoClient reactiveMongoClient() {
        return MongoClients.create(mongoUri);
    }

    @Bean
    public ReactiveMongoTransactionManager mongoTransactionManager(
            ReactiveMongoDatabaseFactory dbFactory) {
        return new ReactiveMongoTransactionManager(dbFactory);
    }
}
```

### 15.2.5 패키지 구조

멀티 데이터소스 환경에서 패키지를 분리하면 나중에 코드를 유지보수할 때 훨씬 수월합니다.

```
com.example.shop
├── config
│   ├── R2dbcConfig.java
│   └── MongoConfig.java
├── domain
│   ├── rdb                         # R2DBC 엔티티
│   │   ├── UserEntity.java
│   │   ├── OrderEntity.java
│   │   └── OrderItemEntity.java
│   └── mongo                       # MongoDB 도큐먼트
│       ├── Product.java
│       └── Review.java
├── repository
│   ├── r2dbc                       # R2DBC 리포지토리
│   │   ├── UserRepository.java
│   │   └── OrderRepository.java
│   └── mongo                       # MongoDB 리포지토리
│       ├── ProductRepository.java
│       └── ReviewRepository.java
├── service
└── controller
```

### 15.2.6 엔티티와 도큐먼트 정의

R2DBC 엔티티는 MongoDB와 다르게 `@Table`, `@Id`, `@Column` 어노테이션을 사용합니다. 다음은 주문 테이블을 매핑한 예제입니다.

```java
@Table("orders")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OrderEntity {

    @Id
    private Long id;

    @Column("user_id")
    private Long userId;

    @Column("order_number")
    private String orderNumber;

    private String status;

    @Column("total_amount")
    private BigDecimal totalAmount;

    @Column("shipping_address")
    private String shippingAddress;

    @Column("created_at")
    private LocalDateTime createdAt;
}
```

한편 MongoDB 도큐먼트는 유연한 스키마의 장점을 충분히 활용합니다. 상품 정보처럼 다양한 속성이 필요한 경우가 좋은 예입니다.

```java
@Document(collection = "products")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Product {

    @Id
    private String id;
    private String name;
    private String description;
    private String category;
    private BigDecimal price;
    private int stockQuantity;
    private List<String> tags;
    private Map<String, String> attributes;  // 유연한 속성
    private LocalDateTime createdAt;
}
```

### 15.2.7 각 리포지토리

두 데이터소스의 리포지토리를 패키지별로 명확히 분리하여 정의합니다.

```java
// R2DBC 리포지토리 (com.example.shop.repository.r2dbc)
public interface OrderRepository extends ReactiveCrudRepository<OrderEntity, Long> {
    Flux<OrderEntity> findByUserIdOrderByCreatedAtDesc(Long userId);
    Mono<OrderEntity> findByOrderNumber(String orderNumber);
}

public interface OrderItemRepository
        extends ReactiveCrudRepository<OrderItemEntity, Long> {
    Flux<OrderItemEntity> findByOrderId(Long orderId);
}
```

```java
// MongoDB 리포지토리 (com.example.shop.repository.mongo)
public interface ProductRepository
        extends ReactiveMongoRepository<Product, String> {
    Flux<Product> findByCategory(String category);

    @Query("{ 'price': { '$gte': ?0, '$lte': ?1 } }")
    Flux<Product> findByPriceRange(BigDecimal minPrice, BigDecimal maxPrice);
}

public interface ReviewRepository
        extends ReactiveMongoRepository<Review, String> {
    Flux<Review> findByProductIdOrderByCreatedAtDesc(String productId);
    Mono<Long> countByProductId(String productId);
}
```

---

## 15.3 리액티브 환경에서 여러 데이터소스 조합하기

### 15.3.1 데이터 조합 패턴

멀티 데이터소스 환경에서 실제 가치를 발휘하려면 두 데이터베이스의 결과를 효과적으로 조합해야 합니다. Reactor의 연산자들이 이 부분에서 핵심 역할을 합니다.

**패턴 1: 순차 조합 (flatMap)** -- 한쪽 결과를 기반으로 다른 데이터소스를 조회한다.

```java
@Service
@RequiredArgsConstructor
public class OrderQueryService {

    private final OrderRepository orderRepository;         // R2DBC
    private final OrderItemRepository orderItemRepository; // R2DBC
    private final ProductRepository productRepository;     // MongoDB

    public Mono<OrderDetailResponse> getOrderDetail(Long orderId) {
        return orderRepository.findById(orderId)
            .switchIfEmpty(Mono.error(
                new NotFoundException("주문을 찾을 수 없습니다: " + orderId)))
            .flatMap(order -> orderItemRepository.findByOrderId(orderId)
                .flatMap(item -> productRepository.findById(item.getProductId())
                    .map(product -> OrderItemDetail.builder()
                        .productName(product.getName())
                        .category(product.getCategory())
                        .quantity(item.getQuantity())
                        .unitPrice(item.getUnitPrice())
                        .build()))
                .collectList()
                .map(items -> OrderDetailResponse.builder()
                    .orderId(order.getId())
                    .orderNumber(order.getOrderNumber())
                    .status(order.getStatus())
                    .totalAmount(order.getTotalAmount())
                    .items(items)
                    .createdAt(order.getCreatedAt())
                    .build()));
    }
}
```

**패턴 2: 병렬 조합 (zip)** -- 서로 독립적인 데이터를 병렬로 조회하여 조합한다.

```java
public Mono<ProductPageResponse> getProductPage(String productId) {
    Mono<Product> productMono = productRepository.findById(productId)
        .switchIfEmpty(Mono.error(
            new NotFoundException("상품을 찾을 수 없습니다: " + productId)));

    Mono<List<Review>> reviewsMono = reviewRepository
        .findByProductIdOrderByCreatedAtDesc(productId)
        .collectList();

    Mono<Long> reviewCountMono = reviewRepository.countByProductId(productId);

    return Mono.zip(productMono, reviewsMono, reviewCountMono)
        .map(tuple -> ProductPageResponse.builder()
            .product(tuple.getT1())
            .reviews(tuple.getT2())
            .totalReviews(tuple.getT3())
            .build());
}
```

### 15.3.2 트랜잭션 주의사항

멀티 데이터소스 환경에서 트랜잭션은 가장 까다로운 부분입니다. 필자의 경험상 여기서 실수하면 데이터 불일치 문제가 프로덕션까지 고스란히 들어갑니다.

**원칙 1: 각 데이터소스의 트랜잭션은 독립적이다**

```java
// 이 코드는 PostgreSQL 트랜잭션만 보장한다.
// MongoDB 저장이 실패해도 PostgreSQL 변경은 롤백되지 않는다!
@Transactional  // R2dbcTransactionManager가 기본으로 동작
public Mono<Order> createOrder(OrderRequest request) {
    return orderRepository.save(orderEntity)           // PostgreSQL - 트랜잭션 O
        .flatMap(order ->
            productRepository.save(updatedProduct)     // MongoDB - 트랜잭션 X
                .thenReturn(order));
}
```

**원칙 2: 트랜잭션 매니저를 명시적으로 지정한다**

```java
// PostgreSQL 트랜잭션 사용
@Transactional("transactionManager")
public Mono<OrderEntity> saveOrder(OrderEntity order) {
    return orderRepository.save(order);
}

// MongoDB 트랜잭션 사용
@Transactional("mongoTransactionManager")
public Mono<Product> updateProduct(Product product) {
    return productRepository.save(product);
}
```

**원칙 3: 보상 트랜잭션(Saga) 패턴을 활용한다**

분산 환경에서 일관성을 보장하는 가장 실용적인 방법은 Saga 패턴입니다. 한쪽이 실패하면 이미 성공한 다른 쪽의 변경을 의도적으로 되돌리는 방식인데, 이를 보상(compensation)이라고 부릅니다.

### 15.3.3 실전 예제: 주문 시스템 (Saga 패턴)

이제 실제 온라인 쇼핑 플랫폼에서 사용할 수 있는 주문 서비스를 구현해봅시다. 재고 차감(MongoDB) -> 주문 생성(PostgreSQL) -> 결제 처리(PostgreSQL) 순서로 진행하는데, 각 단계가 실패하면 이전 단계들을 순차적으로 보상합니다.

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class OrderSagaService {

    private final OrderRepository orderRepository;
    private final OrderItemRepository orderItemRepository;
    private final ProductRepository productRepository;
    private final PaymentRepository paymentRepository;

    /**
     * 보상 트랜잭션 패턴:
     * 1. 재고 차감 (MongoDB) -> 실패 시 즉시 에러
     * 2. 주문 생성 (PostgreSQL) -> 실패 시 재고 복원
     * 3. 결제 처리 (PostgreSQL) -> 실패 시 주문 취소 + 재고 복원
     */
    public Mono<OrderResult> placeOrder(Long userId, OrderRequest request) {
        return decreaseStock(request.getItems())
            .then(createOrderInDb(userId, request))
            .flatMap(order -> processPayment(order, request)
                .thenReturn(order)
                .onErrorResume(paymentError -> {
                    log.error("결제 실패, 보상 시작", paymentError);
                    return cancelOrder(order)
                        .then(restoreStock(request.getItems()))
                        .then(Mono.error(new PaymentException(
                            "결제 처리에 실패했습니다.", paymentError)));
                }))
            .onErrorResume(orderError -> {
                if (!(orderError instanceof PaymentException)) {
                    log.error("주문 생성 실패, 재고 복원", orderError);
                    return restoreStock(request.getItems())
                        .then(Mono.error(new OrderException(
                            "주문 생성에 실패했습니다.", orderError)));
                }
                return Mono.error(orderError);
            })
            .map(order -> OrderResult.builder()
                .orderId(order.getId())
                .orderNumber(order.getOrderNumber())
                .status("COMPLETED")
                .build());
    }

    private Mono<Void> decreaseStock(List<OrderItemRequest> items) {
        return Flux.fromIterable(items)
            .flatMap(item -> productRepository.findById(item.getProductId())
                .switchIfEmpty(Mono.error(new NotFoundException(
                    "상품을 찾을 수 없습니다: " + item.getProductId())))
                .flatMap(product -> {
                    if (product.getStockQuantity() < item.getQuantity()) {
                        return Mono.error(new InsufficientStockException(
                            product.getName() + " 재고가 부족합니다."));
                    }
                    product.setStockQuantity(
                        product.getStockQuantity() - item.getQuantity());
                    return productRepository.save(product);
                }))
            .then();
    }

    private Mono<Void> restoreStock(List<OrderItemRequest> items) {
        return Flux.fromIterable(items)
            .flatMap(item -> productRepository.findById(item.getProductId())
                .flatMap(product -> {
                    product.setStockQuantity(
                        product.getStockQuantity() + item.getQuantity());
                    return productRepository.save(product);
                }))
            .then();
    }

    private Mono<OrderEntity> createOrderInDb(Long userId, OrderRequest request) {
        OrderEntity order = OrderEntity.builder()
            .userId(userId)
            .orderNumber("ORD-" + System.currentTimeMillis())
            .status("PENDING")
            .totalAmount(request.calculateTotalAmount())
            .shippingAddress(request.getShippingAddress())
            .createdAt(LocalDateTime.now())
            .build();

        return orderRepository.save(order)
            .flatMap(savedOrder -> {
                List<OrderItemEntity> orderItems = request.getItems().stream()
                    .map(item -> OrderItemEntity.builder()
                        .orderId(savedOrder.getId())
                        .productId(item.getProductId())
                        .productName(item.getProductName())
                        .quantity(item.getQuantity())
                        .unitPrice(item.getUnitPrice())
                        .subtotal(item.getUnitPrice()
                            .multiply(BigDecimal.valueOf(item.getQuantity())))
                        .build())
                    .toList();
                return orderItemRepository.saveAll(orderItems)
                    .then(Mono.just(savedOrder));
            });
    }

    private Mono<Void> processPayment(OrderEntity order, OrderRequest request) {
        PaymentEntity payment = PaymentEntity.builder()
            .orderId(order.getId())
            .paymentMethod(request.getPaymentMethod())
            .amount(order.getTotalAmount())
            .status("COMPLETED")
            .transactionId("TXN-" + UUID.randomUUID())
            .createdAt(LocalDateTime.now())
            .build();
        return paymentRepository.save(payment).then();
    }

    private Mono<Void> cancelOrder(OrderEntity order) {
        order.setStatus("CANCELLED");
        return orderRepository.save(order).then();
    }
}
```

### 15.3.4 컨트롤러 구현

이제 클라이언트 요청을 받아서 주문 서비스와 조회 서비스를 호출하는 컨트롤러를 만듭니다.

```java
@RestController
@RequestMapping("/api/orders")
@RequiredArgsConstructor
public class OrderController {

    private final OrderSagaService orderSagaService;
    private final OrderQueryService orderQueryService;

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono<OrderResult> placeOrder(
            @AuthenticationPrincipal Mono<UserDetails> principal,
            @Valid @RequestBody OrderRequest request) {
        return principal.flatMap(user -> {
            Long userId = Long.parseLong(user.getUsername());
            return orderSagaService.placeOrder(userId, request);
        });
    }

    @GetMapping("/{orderId}")
    public Mono<OrderDetailResponse> getOrderDetail(@PathVariable Long orderId) {
        return orderQueryService.getOrderDetail(orderId);
    }

    @GetMapping("/my")
    public Flux<OrderSummaryResponse> getMyOrders(
            @AuthenticationPrincipal Mono<UserDetails> principal) {
        return principal.flatMapMany(user -> {
            Long userId = Long.parseLong(user.getUsername());
            return orderQueryService.getUserOrders(userId);
        });
    }
}
```

### 15.3.5 DatabaseClient를 활용한 복잡한 쿼리

Spring Data R2DBC의 자동 쿼리 생성만으로는 부족한 경우도 있습니다. 그럴 때는 `DatabaseClient`를 사용해 SQL을 직접 작성할 수 있습니다. 예를 들어 판매 통계 같은 복잡한 집계 쿼리를 실행할 때 유용합니다.

```java
@Repository
@RequiredArgsConstructor
public class OrderCustomRepository {

    private final DatabaseClient databaseClient;

    public Flux<SalesStatistics> getSalesStatistics(
            LocalDateTime from, LocalDateTime to) {
        String sql = """
            SELECT DATE(o.created_at) AS sale_date,
                   COUNT(o.id) AS order_count,
                   SUM(o.total_amount) AS total_sales
            FROM orders o
            WHERE o.status = 'COMPLETED'
              AND o.created_at BETWEEN :from AND :to
            GROUP BY DATE(o.created_at)
            ORDER BY sale_date DESC
            """;

        return databaseClient.sql(sql)
            .bind("from", from)
            .bind("to", to)
            .map((row, metadata) -> SalesStatistics.builder()
                .saleDate(row.get("sale_date", LocalDate.class))
                .orderCount(row.get("order_count", Long.class))
                .totalSales(row.get("total_sales", BigDecimal.class))
                .build())
            .all();
    }
}
```

### 15.3.6 두 데이터소스 통계 조합

이제 실무에서 자주 만나는 시나리오를 다루겠습니다. PostgreSQL의 주문 집계 데이터와 MongoDB의 상품 상세 정보, 리뷰 정보를 조합해 대시보드를 구성하는 예제입니다.

```java
@Service
@RequiredArgsConstructor
public class DashboardService {

    private final OrderCustomRepository orderCustomRepository;
    private final ProductRepository productRepository;
    private final ReviewRepository reviewRepository;

    public Flux<PopularProductDashboard> getPopularProductDashboard(int limit) {
        return orderCustomRepository.getPopularProducts(limit)
            .flatMap(stats -> {
                Mono<Product> productMono = productRepository
                    .findById(stats.getProductId())
                    .defaultIfEmpty(Product.builder()
                        .id(stats.getProductId())
                        .name(stats.getProductName())
                        .category("UNKNOWN").build());

                Mono<Double> avgRatingMono = reviewRepository
                    .findByProductIdOrderByCreatedAtDesc(stats.getProductId())
                    .map(Review::getRating)
                    .collectList()
                    .map(ratings -> ratings.stream()
                        .mapToInt(Integer::intValue).average().orElse(0.0));

                return Mono.zip(productMono, avgRatingMono)
                    .map(tuple -> PopularProductDashboard.builder()
                        .productId(stats.getProductId())
                        .productName(stats.getProductName())
                        .category(tuple.getT1().getCategory())
                        .totalQuantitySold(stats.getTotalQuantity())
                        .averageRating(tuple.getT2())
                        .build());
            });
    }
}
```

### 15.3.7 멀티 데이터소스 환경의 베스트 프랙티스

멀티 데이터소스를 성공적으로 운영하려면 몇 가지 중요한 원칙들이 있습니다. 필자가 실제 프로젝트에서 배운 내용을 정리해봤습니다.

**1. 데이터 비정규화로 정합성 관리**

```java
// 올바른 패턴: 주문 시점의 상품 정보를 비정규화하여 저장
@Table("order_items")
public class OrderItemEntity {
    private String productId;     // MongoDB ObjectId 참조
    private String productName;   // 비정규화 (주문 시점 상품명)
    private BigDecimal unitPrice; // 비정규화 (주문 시점 가격)
}
```

**2. 에러 처리 통합**

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(DataIntegrityViolationException.class)
    @ResponseStatus(HttpStatus.CONFLICT)
    public Mono<ErrorResponse> handleDataIntegrity(
            DataIntegrityViolationException ex) {
        return Mono.just(ErrorResponse.of("DATA_CONFLICT",
            "데이터 무결성 위반이 발생했습니다."));
    }

    @ExceptionHandler(DuplicateKeyException.class)
    @ResponseStatus(HttpStatus.CONFLICT)
    public Mono<ErrorResponse> handleDuplicateKey(DuplicateKeyException ex) {
        return Mono.just(ErrorResponse.of("DUPLICATE_KEY",
            "중복된 데이터가 존재합니다."));
    }
}
```

**3. 헬스 체크 통합**

```java
@Component
@RequiredArgsConstructor
public class MultiDataSourceHealthIndicator
        implements ReactiveHealthIndicator {

    private final ConnectionFactory connectionFactory;
    private final ReactiveMongoTemplate mongoTemplate;

    @Override
    public Mono<Health> health() {
        Mono<String> r2dbcHealth = Mono.from(connectionFactory.create())
            .flatMap(conn -> Mono.from(conn.createStatement("SELECT 1")
                .execute())
                .flatMap(result -> Mono.from(result.map((row, meta) -> "UP")))
                .doFinally(signal -> conn.close()))
            .onErrorReturn("DOWN");

        Mono<String> mongoHealth = mongoTemplate.executeCommand("{ ping: 1 }")
            .map(doc -> "UP")
            .onErrorReturn("DOWN");

        return Mono.zip(r2dbcHealth, mongoHealth)
            .map(tuple -> {
                boolean allUp = "UP".equals(tuple.getT1())
                             && "UP".equals(tuple.getT2());
                return (allUp ? Health.up() : Health.down())
                    .withDetail("postgresql", tuple.getT1())
                    .withDetail("mongodb", tuple.getT2())
                    .build();
            });
    }
}
```

### 15.3.8 주의사항 정리

마지막으로 멀티 데이터소스 환경에서 흔히 빠지는 함정들과 대응 방법을 정리했습니다. 이 부분을 꼼꼼히 읽어두면 나중에 많은 디버깅 시간을 절약할 수 있습니다.

| 함정 | 대응 방법 |
|------|----------|
| **분산 트랜잭션 불가**: `@Transactional` 하나로 두 DB를 묶을 수 없음 | Saga 패턴, 보상 트랜잭션 |
| **참조 무결성 부재**: 두 DB 간 외래 키 제약 없음 | 비정규화, 방어적 코딩, 정기 정합성 검증 배치 |
| **트랜잭션 매니저 충돌**: 기본 `@Transactional`이 어느 매니저를 쓸지 모호 | `@Transactional("매니저명")` 명시 |
| **N+1 쿼리**: 두 데이터소스 조합 시 반복 조회 발생 | `collectList()` 후 일괄 조회, 캐싱 |
| **에러 타입 혼재**: R2DBC와 MongoDB가 다른 예외 체계 사용 | 통합 예외 핸들러, 비즈니스 예외로 래핑 |
| **스키마 관리**: R2DBC는 DDL 자동 생성 미지원 | Flyway 또는 Liquibase 사용 |

---

## 요약

이번 장에서는 리액티브 환경에서 관계형 데이터베이스를 다루는 R2DBC를 살펴봤고, MongoDB와 함께 사용하는 멀티 데이터소스 아키텍처를 실전 예제로 학습했습니다.

| 주제 | 핵심 내용 |
|------|----------|
| **R2DBC 소개** | JDBC의 리액티브 대안, Reactive Streams 기반 논블로킹 DB 접근 |
| **JDBC vs R2DBC** | 블로킹 vs 논블로킹, ThreadLocal vs Reactor Context 기반 트랜잭션 |
| **멀티 데이터소스 구성** | 패키지 분리, 설정 클래스 분리, 리포지토리 스캔 경로 분리 |
| **데이터 조합** | `flatMap`(순차), `zip`(병렬)을 활용한 조합 패턴 |
| **트랜잭션 관리** | 분산 트랜잭션 불가, Saga 패턴과 보상 트랜잭션으로 대응 |
| **실전 예제** | 주문 시스템 -- 재고 차감(MongoDB) + 주문 생성(PostgreSQL) + 결제 처리 |

요약하면, R2DBC는 WebFlux 기반 애플리케이션에서 관계형 데이터베이스를 사용할 때 현재 유일한 리액티브 선택지입니다. MongoDB와 함께 사용하면 각 데이터베이스의 강점을 충분히 활용할 수 있지만, 분산 환경의 트랜잭션과 데이터 정합성 문제에 대한 신중한 설계가 필수적입니다. 이 장에서 다룬 Saga 패턴과 보상 트랜잭션 개념을 잘 이해하고 있다면, 복잡한 멀티 데이터소스 시스템도 자신감 있게 설계할 수 있을 겁니다.

다음 장에서는 리액티브 애플리케이션을 체계적으로 테스트하는 전략을 다룹니다. StepVerifier와 WebTestClient를 활용해 리액티브 코드를 효과적으로 검증하는 방법을 살펴보겠습니다.
