# Chapter 14. WebClient: 리액티브 HTTP 클라이언트

Spring WebFlux를 사용하면서 외부 서비스와 통신해야 한다면, `RestTemplate` 같은 구식 도구보다 `WebClient`를 써야 한다. Spring 5에서 도입된 `WebClient`는 **논블로킹 리액티브 HTTP 클라이언트**로, 필자의 경험상 대규모 시스템에서 효율성 면에서 압도적으로 우수하다. 이 장에서는 실전에서 꼭 필요한 설정부터 기본 사용법, 에러 핸들링, 재시도 전략, 타임아웃 관리, 여러 API 동시 호출, 필터 구현까지 모두 살펴보겠다.

---

## 14.1 WebClient 설정과 기본 사용법

### 14.1.1 WebClient란?

`WebClient`는 Spring WebFlux에 포함된 논블로킹 HTTP 클라이언트이고, 내부에서 Reactor Netty의 `HttpClient`를 사용하고 있다. 리액티브 스트림 방식으로 요청과 응답을 다루는 것이 특징이다. 다음 표를 보면 기존 `RestTemplate`과 어떤 점이 다른지 한눈에 파악할 수 있다.

| 특성 | RestTemplate | WebClient |
|------|-------------|-----------|
| **블로킹 여부** | 블로킹 | 논블로킹 |
| **반환 타입** | 직접 객체 반환 | `Mono<T>`, `Flux<T>` |
| **스트리밍** | 미지원 | SSE, 스트리밍 응답 지원 |
| **유지 상태** | Spring 6에서 deprecated | 현재 권장 방식 |

### 14.1.2 WebClient 생성과 빈 설정

`WebClient`를 생성하는 방법은 몇 가지가 있다. `create()`, `create(baseUrl)`, `builder()`인데, 필자의 경험상 실전에서는 `builder()`로 설정하고 빈으로 등록하는 것이 가장 깔끔하다. 여러 외부 서비스를 호출해야 한다면, 각 서비스마다 별도 빈을 만드는 게 나중에 유지보수하기 좋다.

```java
@Configuration
public class WebClientConfig {

    @Bean("userServiceClient")
    public WebClient userServiceClient() {
        return WebClient.builder()
            .baseUrl("https://user-service.example.com")
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .build();
    }

    @Bean("orderServiceClient")
    public WebClient orderServiceClient() {
        return WebClient.builder()
            .baseUrl("https://order-service.example.com")
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .build();
    }
}
```

### 14.1.3 커넥션 풀 설정

운영 환경이라면 Reactor Netty 커넥션 풀을 꼭 설정해줘야 한다. 기본값으로 두면 의외로 성능이 떨어질 수 있다.

```java
@Bean
public WebClient webClient() {
    ConnectionProvider provider = ConnectionProvider.builder("custom-pool")
        .maxConnections(500)                           // 최대 커넥션 수
        .maxIdleTime(Duration.ofSeconds(20))            // 유휴 커넥션 유지 시간
        .maxLifeTime(Duration.ofSeconds(60))            // 커넥션 최대 수명
        .pendingAcquireTimeout(Duration.ofSeconds(60))  // 커넥션 대기 타임아웃
        .evictInBackground(Duration.ofSeconds(120))     // 백그라운드 정리 주기
        .build();

    HttpClient httpClient = HttpClient.create(provider)
        .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)
        .compress(true);

    return WebClient.builder()
        .baseUrl("https://api.example.com")
        .clientConnector(new ReactorClientHttpConnector(httpClient))
        .build();
}
```

### 14.1.4 코덱(Codec) 설정

대용량 응답을 다루거나 커스텀 직렬화가 필요하면 코덱을 설정해야 한다. `maxInMemorySize`는 응답 본문을 메모리에 버퍼링할 때 최대 크기인데, 기본값이 256KB이다. 실무에서 큰 JSON 파일을 받다 보면 `DataBufferLimitException`이 터질 수 있으니, 그럴 땐 이 값을 올려야 한다.

```java
@Bean
public WebClient webClient() {
    return WebClient.builder()
        .codecs(configurer -> {
            configurer.defaultCodecs().maxInMemorySize(10 * 1024 * 1024); // 10MB

            ObjectMapper mapper = new ObjectMapper();
            mapper.registerModule(new JavaTimeModule());
            mapper.setPropertyNamingStrategy(PropertyNamingStrategies.SNAKE_CASE);
            configurer.defaultCodecs().jackson2JsonEncoder(
                new Jackson2JsonEncoder(mapper, MediaType.APPLICATION_JSON));
            configurer.defaultCodecs().jackson2JsonDecoder(
                new Jackson2JsonDecoder(mapper, MediaType.APPLICATION_JSON));
        })
        .build();
}
```

---

## 14.2 요청/응답 처리 (GET, POST, PUT, DELETE)

GET, POST, PUT, DELETE 각각을 어떻게 처리하는지 하나씩 살펴보자.

### 14.2.1 GET 요청

```java
@Service
@RequiredArgsConstructor
public class ProductClientService {

    private final WebClient webClient;

    // 단일 객체 조회
    public Mono<Product> getProduct(String id) {
        return webClient.get()
            .uri("/api/products/{id}", id)
            .retrieve()
            .bodyToMono(Product.class);
    }

    // 목록 조회
    public Flux<Product> getAllProducts() {
        return webClient.get()
            .uri("/api/products")
            .retrieve()
            .bodyToFlux(Product.class);
    }

    // 쿼리 파라미터 사용
    public Flux<Product> searchProducts(String keyword, int page, int size) {
        return webClient.get()
            .uri(uriBuilder -> uriBuilder
                .path("/api/products/search")
                .queryParam("keyword", keyword)
                .queryParam("page", page)
                .queryParam("size", size)
                .build())
            .retrieve()
            .bodyToFlux(Product.class);
    }
}
```

### 14.2.2 POST 요청

```java
// JSON 본문 전송 (bodyValue: 준비된 객체)
public Mono<Product> createProduct(ProductRequest request) {
    return webClient.post().uri("/api/products")
        .bodyValue(request).retrieve().bodyToMono(Product.class);
}

// Mono 본문 전송 (body: Publisher 타입)
public Mono<Product> createProductReactive(Mono<ProductRequest> request) {
    return webClient.post().uri("/api/products")
        .body(request, ProductRequest.class).retrieve().bodyToMono(Product.class);
}

// 폼 데이터 전송
public Mono<String> submitForm(String username, String password) {
    return webClient.post().uri("/api/auth/login")
        .contentType(MediaType.APPLICATION_FORM_URLENCODED)
        .body(BodyInserters.fromFormData("username", username)
            .with("password", password))
        .retrieve().bodyToMono(String.class);
}
```

### 14.2.3 PUT과 DELETE 요청

```java
public Mono<Product> updateProduct(String id, ProductRequest request) {
    return webClient.put()
        .uri("/api/products/{id}", id)
        .bodyValue(request)
        .retrieve()
        .bodyToMono(Product.class);
}

public Mono<Void> deleteProduct(String id) {
    return webClient.delete()
        .uri("/api/products/{id}", id)
        .retrieve()
        .bodyToMono(Void.class);
}
```

### 14.2.4 retrieve() vs exchangeToMono()

두 가지 방식이 있고 상황에 따라 쓰임이 다르다. `retrieve()`는 응답 본문만 간단하게 뽑아내주고 4xx/5xx 에러는 자동으로 예외를 던진다. 반면 `exchangeToMono()`를 쓰면 상태 코드나 헤더 같은 전체 응답 정보에 접근할 수 있어서 더 세밀한 제어가 가능하다.

```java
public Mono<Product> getProductWithStatus(String id) {
    return webClient.get()
        .uri("/api/products/{id}", id)
        .exchangeToMono(response -> {
            if (response.statusCode().is2xxSuccessful()) {
                return response.bodyToMono(Product.class);
            } else if (response.statusCode() == HttpStatus.NOT_FOUND) {
                return Mono.empty();
            } else {
                return response.createError();
            }
        });
}
```

> **주의**: 이전 버전의 `exchange()` 메서드는 deprecated되었다. 리소스 누수 위험이 있으므로, 반드시 `exchangeToMono()` 또는 `exchangeToFlux()`를 사용한다.

응답 헤더와 상태 코드가 모두 필요하면 `toEntity()`를 사용한다.

```java
public Mono<ResponseEntity<Product>> getProductWithHeaders(String id) {
    return webClient.get()
        .uri("/api/products/{id}", id)
        .retrieve()
        .toEntity(Product.class);
}
```

### 14.2.5 스트리밍 응답 처리

음, SSE나 NDJSON 같은 스트리밍 응답도 당연히 처리할 수 있다.

```java
// SSE 스트림
public Flux<ServerSentEvent<String>> subscribeToEvents() {
    return webClient.get().uri("/api/events/stream")
        .accept(MediaType.TEXT_EVENT_STREAM).retrieve()
        .bodyToFlux(new ParameterizedTypeReference<ServerSentEvent<String>>() {});
}

// NDJSON 스트림
public Flux<Product> streamProducts() {
    return webClient.get().uri("/api/products/stream")
        .accept(MediaType.APPLICATION_NDJSON).retrieve()
        .bodyToFlux(Product.class);
}
```

---

## 14.3 에러 핸들링과 재시도 전략

외부 API를 호출하면 당연히 에러가 날 수 있다. 네트워크 문제, 서버 다운, 타임아웃... 이런 것들을 어떻게 처리할지가 중요하다.

### 14.3.1 onStatus()를 활용한 상태 코드별 처리

`retrieve()`는 기본적으로 4xx/5xx 응답에 `WebClientResponseException`을 자동으로 던진다. 하지만 `onStatus()`를 사용하면 각 상태 코드별로 맞춤 처리를 정의할 수 있다.

```java
public Mono<Product> getProduct(String id) {
    return webClient.get()
        .uri("/api/products/{id}", id)
        .retrieve()
        .onStatus(HttpStatusCode::is4xxClientError, response -> {
            if (response.statusCode() == HttpStatus.NOT_FOUND) {
                return Mono.error(
                    new ProductNotFoundException("상품을 찾을 수 없습니다: " + id));
            }
            return response.bodyToMono(ErrorResponse.class)
                .flatMap(error -> Mono.error(
                    new InvalidRequestException(error.getMessage())));
        })
        .onStatus(HttpStatusCode::is5xxServerError, response ->
            response.bodyToMono(String.class)
                .flatMap(body -> Mono.error(
                    new ExternalServiceException("서버 에러: " + body)))
        )
        .bodyToMono(Product.class);
}
```

### 14.3.2 retryWhen()과 Retry.backoff()

단순 `retry(n)`은 실패하면 바로 재시도하는데, 이건 외부 서비스에 부하를 받게 만들 수 있다. 운영 환경에서는 반드시 `Retry.backoff()`로 지수 백오프(exponential backoff)를 적용해야 한다. 처음엔 짧게 기다렸다가 점점 더 길게 기다리는 방식이다.

```java
public Mono<Product> getProductWithBackoff(String id) {
    return webClient.get()
        .uri("/api/products/{id}", id)
        .retrieve()
        .bodyToMono(Product.class)
        .retryWhen(Retry.backoff(3, Duration.ofSeconds(1))
            .maxBackoff(Duration.ofSeconds(10))
            .jitter(0.5)
            .filter(ex -> ex instanceof WebClientResponseException.ServiceUnavailable
                       || ex instanceof ConnectException)
            .doBeforeRetry(signal -> log.warn(
                "재시도 #{} - 원인: {}",
                signal.totalRetries() + 1,
                signal.failure().getMessage()))
            .onRetryExhaustedThrow((spec, signal) ->
                new ExternalServiceException(
                    "재시도 횟수 초과: " + signal.failure().getMessage(),
                    signal.failure()))
        );
}
```

| 재시도 횟수 | 최소 대기 시간 | jitter=0.5 적용 시 범위 |
|-----------|-------------|---------------------|
| 1회차 | 1초 | 0.5초 ~ 1.5초 |
| 2회차 | 2초 | 1초 ~ 3초 |
| 3회차 | 4초 | 2초 ~ 6초 |

`jitter`는 여러 클라이언트가 동시에 재시도하여 부하가 집중되는 "thundering herd" 문제를 방지한다.

### 14.3.3 서킷 브레이커 패턴

외부 서비스가 계속 장애 상태라면 재시도만 해서는 소용없다. 이럴 땐 요청 자체를 차단하고 빨리 실패하는 게 낫다. Resilience4j라는 라이브러리로 서킷 브레이커 패턴을 구현하면 된다.

```groovy
dependencies {
    implementation 'io.github.resilience4j:resilience4j-spring-boot3:2.2.0'
    implementation 'io.github.resilience4j:resilience4j-reactor:2.2.0'
}
```

```yaml
resilience4j:
  circuitbreaker:
    instances:
      productService:
        sliding-window-size: 10
        failure-rate-threshold: 50
        wait-duration-in-open-state: 30s
        permitted-number-of-calls-in-half-open-state: 3
```

```java
@Service
@RequiredArgsConstructor
public class ProductClientService {

    private final WebClient webClient;
    private final CircuitBreakerRegistry circuitBreakerRegistry;

    public Mono<Product> getProduct(String id) {
        CircuitBreaker cb = circuitBreakerRegistry.circuitBreaker("productService");

        return webClient.get()
            .uri("/api/products/{id}", id)
            .retrieve()
            .bodyToMono(Product.class)
            .transformDeferred(CircuitBreakerOperator.of(cb))
            .onErrorResume(CallNotPermittedException.class, ex -> {
                log.warn("서킷 브레이커 OPEN - 폴백 실행");
                return Mono.just(Product.fallback(id));
            })
            .retryWhen(Retry.backoff(2, Duration.ofMillis(500))
                .filter(ex -> !(ex instanceof CallNotPermittedException)));
    }
}
```

| 상태 | 동작 |
|------|------|
| **CLOSED** | 정상 상태. 모든 요청 전달, 실패율 모니터링 |
| **OPEN** | 차단 상태. 즉시 폴백 실행. 대기 시간 후 HALF_OPEN 전환 |
| **HALF_OPEN** | 일부 요청만 허용하여 복구 확인. 성공하면 CLOSED, 실패하면 OPEN |

---

## 14.4 타임아웃 설정

타임아웃은 정말 중요하다. 만약 타임아웃이 없다면 외부 서비스의 장애가 자신의 서버까지 파급되어 버린다. 클라이언트가 계속 응답을 기다리다 보니 스레드 또는 리소스가 고갈되는 거다.

### 14.4.1 계층별 타임아웃

네트워크 요청은 여러 단계로 이루어져 있는데, 각 단계마다 타임아웃을 설정할 수 있다.

```java
HttpClient httpClient = HttpClient.create()
    // 1. 커넥션 타임아웃: TCP 연결 수립
    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 3000)
    // 2. 응답 타임아웃: 첫 응답 바이트 수신까지
    .responseTimeout(Duration.ofSeconds(5))
    // 3. 읽기/쓰기 타임아웃: 데이터 전송 중 무응답
    .doOnConnected(conn -> conn
        .addHandlerLast(new ReadTimeoutHandler(10, TimeUnit.SECONDS))
        .addHandlerLast(new WriteTimeoutHandler(10, TimeUnit.SECONDS)));

WebClient webClient = WebClient.builder()
    .clientConnector(new ReactorClientHttpConnector(httpClient))
    .build();
```

### 14.4.2 Reactor timeout() 연산자

Reactor 레벨에서 제공하는 `timeout()` 연산자로 전체 리액티브 체인, 재시도를 포함한 최종 시간을 제한할 수 있다.

```java
public Mono<Product> getProduct(String id) {
    return webClient.get()
        .uri("/api/products/{id}", id)
        .retrieve()
        .bodyToMono(Product.class)
        .retryWhen(Retry.backoff(3, Duration.ofSeconds(1)))
        .timeout(Duration.ofSeconds(15))
        .onErrorResume(TimeoutException.class, ex ->
            Mono.error(new ExternalServiceException("응답 시간 초과")));
}
```

### 14.4.3 타임아웃 종합 정리

| 타임아웃 | 적용 계층 | 대상 |
|---------|----------|------|
| **커넥션 타임아웃** | TCP | 서버와 TCP 연결 수립 |
| **응답 타임아웃** | HTTP | 첫 응답 바이트 수신까지 |
| **읽기 타임아웃** | TCP | 데이터 읽기 중 무응답 |
| **쓰기 타임아웃** | TCP | 데이터 쓰기 중 무응답 |
| **Reactor timeout()** | 리액티브 | 전체 리액티브 체인 완료 |

---

## 14.5 외부 API 연동 실전 예제

지금까지 배운 기법들을 실제 프로젝트에서 어떻게 조합해서 쓰는지 보자.

### 14.5.1 REST API 호출 서비스

외부 날씨 API를 호출하는 예제를 만들어 보자. 에러 처리, 재시도, 타임아웃까지 모두 함께 적용해야 한다.

```java
@Slf4j
@Service
public class WeatherClientService {

    private final WebClient webClient;

    public WeatherClientService(WebClient.Builder builder,
                                @Value("${weather.api.key}") String apiKey) {
        this.webClient = builder
            .baseUrl("https://api.openweathermap.org/data/2.5")
            .build();
    }

    public Mono<WeatherResponse> getCurrentWeather(String city) {
        return webClient.get()
            .uri(uriBuilder -> uriBuilder.path("/weather")
                .queryParam("q", city).queryParam("appid", apiKey)
                .queryParam("units", "metric").build())
            .retrieve()
            .onStatus(HttpStatusCode::is4xxClientError, response ->
                response.statusCode() == HttpStatus.NOT_FOUND
                    ? Mono.error(new CityNotFoundException("도시를 찾을 수 없습니다: " + city))
                    : response.createException())
            .bodyToMono(WeatherResponse.class)
            .retryWhen(Retry.backoff(2, Duration.ofSeconds(1))
                .filter(ex -> ex instanceof WebClientResponseException.ServiceUnavailable))
            .timeout(Duration.ofSeconds(10));
    }
}
```

### 14.5.2 여러 API 동시 호출 (zip)

대시보드처럼 여러 소스의 데이터가 필요한 경우, `Mono.zip()`으로 독립적인 API 호출들을 병렬로 실행하고 결과를 한데 모을 수 있다.

```java
@Service
@RequiredArgsConstructor
public class DashboardService {

    private final UserClientService userClient;
    private final OrderClientService orderClient;
    private final WeatherClientService weatherClient;

    public Mono<DashboardResponse> getDashboard(String userId) {
        Mono<UserProfile> userMono = userClient.getProfile(userId);
        Mono<List<Order>> ordersMono = orderClient.getRecentOrders(userId).collectList();
        Mono<WeatherResponse> weatherMono = weatherClient.getCurrentWeather("Seoul");

        return Mono.zip(userMono, ordersMono, weatherMono)
            .map(tuple -> DashboardResponse.builder()
                .user(tuple.getT1())
                .recentOrders(tuple.getT2())
                .weather(tuple.getT3())
                .build());
    }
}
```

포인트는 세 API 호출이 **동시에** 실행된다는 것이다. 따라서 가장 느린 호출 기준으로만 대기하면 된다. 각각을 순차로 호출하는 것보다 훨씬 빠르다.

### 14.5.3 여러 API 결과 병합 (merge)

반면 `Flux.merge()`는 여러 소스의 결과를 도착 순서대로 그냥 합친다. 상대적으로 단순한 조합이지만, 스트리밍 데이터를 다룰 때는 이게 더 편할 수 있다.

```java
public Flux<PriceQuote> getPriceQuotes(String productId) {
    Flux<PriceQuote> a = webClient.get()
        .uri("https://supplier-a.com/api/price/{id}", productId)
        .retrieve().bodyToMono(PriceQuote.class).flux();
    Flux<PriceQuote> b = webClient.get()
        .uri("https://supplier-b.com/api/price/{id}", productId)
        .retrieve().bodyToMono(PriceQuote.class).flux();

    return Flux.merge(a, b)
        .timeout(Duration.ofSeconds(5))
        .onErrorResume(ex -> Flux.empty());
}
```

### 14.5.4 순차 API 호출 (flatMap 체이닝)

반대로 첫 번째 API의 결과가 두 번째 API 호출에 필요한 경우도 있다. 이럴 땐 `flatMap`으로 체이닝해서 순차적으로 실행한다.

```java
// 1. 사용자 조회 → 2. 주문 생성 → 3. 결제 처리
public Mono<PaymentResult> processOrder(String userId, OrderRequest orderRequest) {
    return webClient.get()
        .uri("/api/users/{id}", userId)
        .retrieve()
        .bodyToMono(UserProfile.class)
        .flatMap(user -> {
            orderRequest.setShippingAddress(user.getAddress());
            return webClient.post()
                .uri("/api/orders")
                .bodyValue(orderRequest)
                .retrieve()
                .bodyToMono(OrderResponse.class);
        })
        .flatMap(order -> webClient.post()
            .uri("/api/payments")
            .bodyValue(new PaymentRequest(order.getId(), order.getTotalAmount()))
            .retrieve()
            .bodyToMono(PaymentResult.class));
}
```

### 14.5.5 폴백(Fallback) 패턴

외부 API가 실패해도 서비스는 계속 돌아야 할 수 있다. 이럴 때는 캐시나 기본값 같은 대체 데이터로 폴백하는 방식이 있다.

```java
@Slf4j
@Service
@RequiredArgsConstructor
public class ProductService {

    private final WebClient webClient;
    private final ProductRepository productRepository;

    public Mono<Product> getProduct(String id) {
        return webClient.get()
            .uri("/api/products/{id}", id)
            .retrieve().bodyToMono(Product.class)
            .timeout(Duration.ofSeconds(3))
            .onErrorResume(ex -> {
                log.warn("외부 API 실패, 로컬 DB 폴백: {}", ex.getMessage());
                return productRepository.findById(id);
            });
    }

    // 다단계 폴백: 캐시 → 외부 API → 기본값
    public Mono<ExchangeRate> getExchangeRate(String currency) {
        return getFromCache(currency)
            .switchIfEmpty(getFromExternalApi(currency)
                .doOnNext(rate -> saveToCache(currency, rate)))
            .switchIfEmpty(Mono.just(ExchangeRate.defaultRate(currency)))
            .onErrorReturn(ExchangeRate.defaultRate(currency));
    }
}
```

### 14.5.6 페이지네이션 API 전체 조회

API가 페이지네이션으로 데이터를 제공하면, `expand()` 연산자로 다음 페이지를 자동으로 호출할 수 있다. 더 이상 다음 페이지가 없으면 `Mono.empty()`를 반환해서 재귀를 멈춘다.

```java
public Flux<Product> getAllProductsPaginated() {
    return fetchPage(0)
        .expand(page -> page.hasNext() ? fetchPage(page.getPage() + 1) : Mono.empty())
        .flatMapIterable(PageResponse::getContent);
}

private Mono<PageResponse<Product>> fetchPage(int page) {
    return webClient.get()
        .uri(uriBuilder -> uriBuilder.path("/api/products")
            .queryParam("page", page).queryParam("size", 100).build())
        .retrieve()
        .bodyToMono(new ParameterizedTypeReference<PageResponse<Product>>() {});
}
```

---

## 14.6 WebClient 필터와 인터셉터

대규모 애플리케이션에서는 로깅, 인증, 에러 처리 같은 공통 로직을 모든 API 호출에 적용해야 하는데, 매번 반복하는 건 비효율적이다. `ExchangeFilterFunction`으로 이런 횡단 관심사(cross-cutting concern)를 깔끔하게 처리할 수 있다.

### 14.6.1 ExchangeFilterFunction과 로깅 필터

`ExchangeFilterFunction`은 `WebClient`의 요청/응답 파이프라인에 끼워넣는 필터다. `WebClient.builder().filter()`로 등록하고, 여러 개를 등록하면 등록한 순서 그대로 체이닝된다.

```java
@Slf4j
public class WebClientFilters {

    public static ExchangeFilterFunction logRequestResponse() {
        return (request, next) -> {
            long startTime = System.currentTimeMillis();
            log.info(">>> {} {}", request.method(), request.url());

            return next.exchange(request)
                .doOnNext(response -> {
                    long duration = System.currentTimeMillis() - startTime;
                    log.info("<<< {} {} - {}ms",
                        response.statusCode(), request.url(), duration);
                });
        };
    }
}
```

### 14.6.2 인증 필터

외부 API 호출할 때는 당연히 인증이 필요하다. 간단한 API 키부터 복잡한 OAuth 토큰까지 여러 방식이 있다. 필터로 이걸 깔끔하게 처리해 보자.

```java
public static ExchangeFilterFunction apiKeyAuth(String apiKey) {
    return (request, next) -> {
        ClientRequest filtered = ClientRequest.from(request)
            .header("X-API-Key", apiKey).build();
        return next.exchange(filtered);
    };
}
```

```java
@Component
@RequiredArgsConstructor
public class DynamicAuthFilter {

    private final TokenService tokenService;

    public ExchangeFilterFunction authFilter() {
        return (request, next) ->
            tokenService.getValidToken()
                .flatMap(token -> {
                    ClientRequest filtered = ClientRequest.from(request)
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + token)
                        .build();
                    return next.exchange(filtered);
                });
    }
}
```

```java
@Service
public class TokenService {

    private final WebClient authClient;
    private final AtomicReference<TokenInfo> cachedToken = new AtomicReference<>();

    public TokenService(WebClient.Builder builder) {
        this.authClient = builder.baseUrl("https://auth.example.com").build();
    }

    public Mono<String> getValidToken() {
        TokenInfo current = cachedToken.get();
        if (current != null && !current.isExpired()) {
            return Mono.just(current.getAccessToken());
        }
        return authClient.post().uri("/oauth/token")
            .contentType(MediaType.APPLICATION_FORM_URLENCODED)
            .body(BodyInserters.fromFormData("grant_type", "client_credentials")
                .with("client_id", "my-client").with("client_secret", "my-secret"))
            .retrieve().bodyToMono(TokenInfo.class)
            .doOnNext(cachedToken::set).map(TokenInfo::getAccessToken);
    }
}
```

### 14.6.3 에러 처리 필터와 요청 ID 전파 필터

기타 유용한 필터들도 몇 가지 있다.

```java
public static ExchangeFilterFunction errorHandlingFilter() {
    return (request, next) -> next.exchange(request)
        .flatMap(response -> {
            if (response.statusCode().is5xxServerError()) {
                return response.bodyToMono(String.class)
                    .flatMap(body -> Mono.error(new ExternalServiceException(
                        "서버 에러 [" + request.method() + " " + request.url() + "]: " + body)));
            }
            return Mono.just(response);
        });
}

public static ExchangeFilterFunction traceIdFilter() {
    return (request, next) -> {
        String traceId = Optional.ofNullable(MDC.get("traceId"))
            .orElse(UUID.randomUUID().toString().substring(0, 8));
        ClientRequest filtered = ClientRequest.from(request)
            .header("X-Trace-Id", traceId).build();
        return next.exchange(filtered);
    };
}
```

### 14.6.4 필터 조합과 적용

이제 여러 필터를 조합해서 실제로 WebClient 빈을 만드는 방법을 보자.

```java
@Configuration
@RequiredArgsConstructor
public class WebClientConfig {

    private final DynamicAuthFilter dynamicAuthFilter;
    @Value("${external.api.base-url}") private String baseUrl;

    @Bean
    public WebClient webClient() {
        HttpClient httpClient = HttpClient.create()
            .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)
            .responseTimeout(Duration.ofSeconds(10))
            .doOnConnected(conn -> conn
                .addHandlerLast(new ReadTimeoutHandler(10, TimeUnit.SECONDS))
                .addHandlerLast(new WriteTimeoutHandler(10, TimeUnit.SECONDS)));

        return WebClient.builder()
            .baseUrl(baseUrl)
            .clientConnector(new ReactorClientHttpConnector(httpClient))
            .codecs(c -> c.defaultCodecs().maxInMemorySize(5 * 1024 * 1024))
            .filter(WebClientFilters.traceIdFilter())       // 1. 추적
            .filter(dynamicAuthFilter.authFilter())          // 2. 인증
            .filter(WebClientFilters.logRequestResponse())   // 3. 로깅
            .filter(WebClientFilters.errorHandlingFilter())  // 4. 에러 처리
            .build();
    }
}
```

필터는 등록 순서대로 체이닝되므로 순서가 중요하다. 필자의 경험상 추적 -> 인증 -> 로깅 -> 에러 처리 이 순서가 가장 깔끔하다.

### 14.6.5 테스트에서의 WebClient 모킹

`WebClient`를 사용하는 코드를 테스트할 때는 실제 외부 API를 호출할 수 없다. `MockWebServer`라는 도구로 가짜 API를 만들어서 테스트한다.

```groovy
testImplementation 'com.squareup.okhttp3:mockwebserver:4.12.0'
```

```java
class ProductClientServiceTest {

    private MockWebServer mockWebServer;
    private ProductClientService service;

    @BeforeEach
    void setUp() throws IOException {
        mockWebServer = new MockWebServer();
        mockWebServer.start();
        service = new ProductClientService(
            WebClient.builder().baseUrl(mockWebServer.url("/").toString()).build());
    }

    @AfterEach
    void tearDown() throws IOException { mockWebServer.shutdown(); }

    @Test
    void getProduct_성공() {
        mockWebServer.enqueue(new MockResponse()
            .setBody("{\"id\":\"123\",\"name\":\"테스트 상품\",\"price\":10000}")
            .addHeader("Content-Type", "application/json"));

        StepVerifier.create(service.getProduct("123"))
            .assertNext(p -> assertThat(p.getName()).isEqualTo("테스트 상품"))
            .verifyComplete();
    }

    @Test
    void getProduct_재시도_후_성공() {
        // 처음 두 번은 503, 세 번째는 성공
        mockWebServer.enqueue(new MockResponse().setResponseCode(503));
        mockWebServer.enqueue(new MockResponse().setResponseCode(503));
        mockWebServer.enqueue(new MockResponse()
            .setBody("{\"id\":\"123\",\"name\":\"상품\",\"price\":5000}")
            .addHeader("Content-Type", "application/json"));

        StepVerifier.create(service.getProductWithBackoff("123"))
            .assertNext(p -> assertThat(p.getId()).isEqualTo("123"))
            .verifyComplete();
        assertThat(mockWebServer.getRequestCount()).isEqualTo(3);
    }
}
```

---

## 요약

| 주제 | 핵심 내용 |
|------|----------|
| **WebClient 설정** | `WebClient.builder()`로 빈 생성, 커넥션 풀(`ConnectionProvider`), 코덱(`maxInMemorySize`, Jackson) 설정 |
| **요청/응답 처리** | GET/POST/PUT/DELETE, `retrieve()` vs `exchangeToMono()`, `bodyToMono`/`bodyToFlux`, 스트리밍 |
| **에러 핸들링** | `onStatus()`로 상태 코드별 처리, `onErrorResume()`으로 폴백, 서킷 브레이커로 장애 전파 차단 |
| **재시도 전략** | `Retry.backoff()`로 지수 백오프, `jitter`로 부하 분산, `filter()`로 재시도 대상 예외 선별 |
| **타임아웃** | 커넥션/읽기/쓰기/응답 타임아웃 계층별 설정, Reactor `timeout()`으로 전체 체인 시간 제한 |
| **외부 API 연동** | `Mono.zip()`으로 병렬 호출, `Flux.merge()`로 결과 병합, 폴백 패턴, 페이지네이션 순회 |
| **필터** | `ExchangeFilterFunction`으로 로깅/인증/에러 처리/추적 필터 구현, 필터 체이닝 순서 |

다음 장에서는 R2DBC를 활용하여 관계형 데이터베이스를 리액티브 방식으로 접근하는 방법과, MongoDB를 함께 사용하는 멀티 데이터소스 구성을 다룬다.
