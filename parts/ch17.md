# Chapter 17. 문서화와 API 관리

API를 잘 만드는 것 못지않게 중요한 것이 **잘 문서화하는 것**이다. 아무리 훌륭한 리액티브 API를 설계하더라도, 소비자(프론트엔드 개발자, 외부 파트너, 내부 팀)가 그 사용법을 쉽게 파악할 수 없다면 실용적 가치가 반감된다. 이번 장에서는 Spring WebFlux 환경에서 SpringDoc OpenAPI(Swagger)를 활용한 API 문서 자동 생성, `Mono`/`Flux` 반환 타입과 `RouterFunction`의 문서화, 그리고 API 버전 관리 전략까지 실전에서 필요한 내용을 다룬다.

---

## 17.1 SpringDoc OpenAPI(Swagger) 연동

### 17.1.1 SpringDoc OpenAPI란?

SpringDoc OpenAPI는 Spring Boot 애플리케이션에서 **OpenAPI 3.0/3.1 명세**를 자동으로 생성해주는 라이브러리다. 과거에는 Springfox(Swagger 2)가 널리 사용되었지만, Spring Boot 3.x 이후로는 SpringDoc이 사실상 표준으로 자리잡았다.

| 구분 | Springfox | SpringDoc |
|------|-----------|-----------|
| **OpenAPI 버전** | Swagger 2.0 | OpenAPI 3.0/3.1 |
| **Spring Boot 3 지원** | 미지원 | 지원 |
| **WebFlux 지원** | 제한적 | 네이티브 지원 |
| **유지보수 상태** | 사실상 중단 | 활발히 유지보수 |
| **RouterFunction 지원** | 미지원 | 지원 |

### 17.1.2 의존성 설정

WebFlux 환경에서는 `springdoc-openapi-starter-webflux-ui` 의존성을 추가한다. 일반 MVC용인 `springdoc-openapi-starter-webmvc-ui`와 혼동하지 않도록 주의한다.

```groovy
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    implementation 'org.springframework.boot:spring-boot-starter-data-mongodb-reactive'

    // SpringDoc OpenAPI - WebFlux 전용
    implementation 'org.springdoc:springdoc-openapi-starter-webflux-ui:2.8.4'
}
```

의존성을 추가하는 것만으로 다음 두 엔드포인트가 자동으로 활성화된다.

| 엔드포인트 | 설명 |
|-----------|------|
| `/v3/api-docs` | OpenAPI 3.0 JSON 명세 |
| `/swagger-ui.html` | Swagger UI 웹 인터페이스 |

### 17.1.3 기본 설정

`application.yml`에서 SpringDoc의 동작을 세밀하게 제어할 수 있다.

```yaml
springdoc:
  api-docs:
    path: /v3/api-docs
    enabled: true
  swagger-ui:
    path: /swagger-ui.html
    enabled: true
    operations-sorter: method
    tags-sorter: alpha
    display-request-duration: true
  default-produces-media-type: application/json
  default-consumes-media-type: application/json
  show-actuator: false
```

운영 환경에서는 보안상 Swagger UI를 비활성화하는 것이 일반적이다.

```yaml
# application-prod.yml
springdoc:
  api-docs:
    enabled: false
  swagger-ui:
    enabled: false
```

### 17.1.4 OpenAPI 전역 설정 빈

API 문서의 제목, 설명, 버전 등 전역 정보를 `OpenAPI` 빈으로 정의한다.

```java
@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
            .info(new Info()
                .title("상품 관리 API")
                .description("Spring WebFlux + MongoDB 기반 리액티브 상품 관리 시스템")
                .version("1.0.0")
                .contact(new Contact()
                    .name("개발팀")
                    .email("dev@example.com"))
                .license(new License()
                    .name("Apache 2.0")
                    .url("https://www.apache.org/licenses/LICENSE-2.0")))
            .externalDocs(new ExternalDocumentation()
                .description("프로젝트 위키")
                .url("https://wiki.example.com/product-api"));
    }
}
```

### 17.1.5 @Operation과 @ApiResponse

컨트롤러 메서드에 `@Operation`을 붙여 개별 API의 설명을 추가하고, `@ApiResponse`로 응답 코드별 설명을 명시한다.

```java
@RestController
@RequestMapping("/api/v1/products")
@Tag(name = "상품", description = "상품 CRUD API")
public class ProductController {

    private final ProductService productService;

    public ProductController(ProductService productService) {
        this.productService = productService;
    }

    @Operation(summary = "상품 목록 조회",
               description = "등록된 모든 상품을 페이징하여 조회한다.")
    @ApiResponses({
        @ApiResponse(responseCode = "200", description = "조회 성공",
            content = @Content(mediaType = "application/json",
                array = @ArraySchema(schema = @Schema(implementation = ProductResponse.class))))
    })
    @GetMapping
    public Flux<ProductResponse> getAllProducts(
            @Parameter(description = "페이지 번호 (0부터 시작)", example = "0")
            @RequestParam(defaultValue = "0") int page,
            @Parameter(description = "페이지 크기", example = "20")
            @RequestParam(defaultValue = "20") int size) {
        return productService.findAll(page, size);
    }

    @Operation(summary = "상품 단건 조회",
               description = "상품 ID로 단건 조회한다. 존재하지 않으면 404를 반환한다.")
    @ApiResponses({
        @ApiResponse(responseCode = "200", description = "조회 성공"),
        @ApiResponse(responseCode = "404", description = "상품을 찾을 수 없음",
            content = @Content(schema = @Schema(implementation = ErrorResponse.class)))
    })
    @GetMapping("/{id}")
    public Mono<ProductResponse> getProduct(
            @Parameter(description = "상품 ID", required = true,
                       example = "665a1b2c3d4e5f6a7b8c9d0e")
            @PathVariable String id) {
        return productService.findById(id);
    }

    @Operation(summary = "상품 등록")
    @ApiResponses({
        @ApiResponse(responseCode = "201", description = "등록 성공"),
        @ApiResponse(responseCode = "400", description = "유효성 검증 실패")
    })
    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Mono<ProductResponse> createProduct(
            @Valid @RequestBody ProductCreateRequest request) {
        return productService.create(request);
    }
}
```

### 17.1.6 @Schema를 활용한 모델 문서화

요청/응답 DTO에 `@Schema`를 적용하면 Swagger UI에서 각 필드의 의미, 필수 여부, 예시 값을 확인할 수 있다.

```java
@Schema(description = "상품 등록 요청")
public record ProductCreateRequest(

    @Schema(description = "상품명", example = "무선 키보드",
            requiredMode = RequiredMode.REQUIRED)
    @NotBlank(message = "상품명은 필수입니다")
    String name,

    @Schema(description = "가격 (원)", example = "45000", minimum = "0")
    @NotNull @Positive
    Integer price,

    @Schema(description = "카테고리", example = "ELECTRONICS",
            allowableValues = {"ELECTRONICS", "CLOTHING", "FOOD", "BOOKS"})
    @NotNull
    Category category,

    @Schema(description = "태그 목록", example = "[\"bluetooth\", \"keyboard\"]")
    List<String> tags
) {}
```

```java
@Schema(description = "상품 응답")
public record ProductResponse(

    @Schema(description = "상품 ID", example = "665a1b2c3d4e5f6a7b8c9d0e")
    String id,

    @Schema(description = "상품명", example = "무선 키보드")
    String name,

    @Schema(description = "가격 (원)", example = "45000")
    Integer price,

    @Schema(description = "카테고리")
    Category category,

    @Schema(description = "등록일시", example = "2025-01-15T10:30:00")
    LocalDateTime createdAt
) {}
```

---

## 17.2 리액티브 API 문서 자동 생성

### 17.2.1 Mono/Flux 반환 타입 처리

SpringDoc은 리액티브 타입을 자동으로 인식하여, 래핑된 내부 타입을 기준으로 스키마를 생성한다.

| 메서드 반환 타입 | OpenAPI 스키마 |
|----------------|---------------|
| `Mono<Product>` | `Product` (단일 객체) |
| `Flux<Product>` | `Product[]` (배열) |
| `Mono<Void>` | 응답 본문 없음 |
| `Mono<ResponseEntity<Product>>` | `Product` + 상태 코드 |
| `Flux<ServerSentEvent<Product>>` | SSE 스트림으로 표현 |

**스트리밍 응답**의 경우 `produces` 미디어 타입을 명시하는 것이 좋다.

```java
@Operation(summary = "상품 실시간 스트림")
@GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux<ProductResponse> streamProducts() {
    return productService.streamAll();
}
```

### 17.2.2 RouterFunction 문서화

함수형 라우터(`RouterFunction`)는 리플렉션으로 메타데이터를 추출할 수 없다. SpringDoc은 `@RouterOperation` 어노테이션과 `OpenApiCustomizer` 두 가지 방식을 제공한다.

**방법 1: @RouterOperation 어노테이션**

```java
@Configuration
public class ProductRouter {

    @RouterOperations({
        @RouterOperation(
            path = "/api/v1/products", method = RequestMethod.GET,
            beanClass = ProductHandler.class, beanMethod = "getAllProducts",
            operation = @Operation(
                operationId = "getAllProducts", summary = "상품 목록 조회",
                tags = {"상품"},
                responses = @ApiResponse(responseCode = "200",
                    description = "조회 성공",
                    content = @Content(array = @ArraySchema(
                        schema = @Schema(implementation = ProductResponse.class)))))),
        @RouterOperation(
            path = "/api/v1/products/{id}", method = RequestMethod.GET,
            beanClass = ProductHandler.class, beanMethod = "getProduct",
            operation = @Operation(
                operationId = "getProduct", summary = "상품 단건 조회",
                tags = {"상품"},
                parameters = @Parameter(in = ParameterIn.PATH, name = "id",
                    description = "상품 ID", required = true),
                responses = {
                    @ApiResponse(responseCode = "200", description = "조회 성공"),
                    @ApiResponse(responseCode = "404", description = "상품을 찾을 수 없음")}))
    })
    @Bean
    public RouterFunction<ServerResponse> productRoutes(ProductHandler handler) {
        return RouterFunctions.route()
            .path("/api/v1/products", builder -> builder
                .GET("", handler::getAllProducts)
                .GET("/{id}", handler::getProduct))
            .build();
    }
}
```

**방법 2: OpenApiCustomizer 프로그래밍 방식**

라우트가 많거나, 문서 정보를 코드로 관리하고 싶을 때는 `OpenApiCustomizer` 빈에서 `openApi.getPaths().addPathItem()`을 호출하여 경로와 오퍼레이션을 프로그래밍 방식으로 등록한다.

### 17.2.3 SecurityScheme 설정

JWT 인증을 사용하는 API의 경우, Swagger UI에서 토큰을 입력하여 인증된 요청을 테스트할 수 있도록 `SecurityScheme`을 설정한다.

```java
@Bean
public OpenAPI customOpenAPI() {
    final String securitySchemeName = "bearerAuth";

    return new OpenAPI()
        .info(new Info().title("상품 관리 API").version("1.0.0"))
        .addSecurityItem(new SecurityRequirement().addList(securitySchemeName))
        .components(new Components()
            .addSecuritySchemes(securitySchemeName,
                new SecurityScheme()
                    .name(securitySchemeName)
                    .type(SecurityScheme.Type.HTTP)
                    .scheme("bearer")
                    .bearerFormat("JWT")
                    .description("JWT 토큰을 입력하세요.")));
}
```

특정 엔드포인트에만 보안을 적용하거나 제외하려면 `@SecurityRequirement`를 메서드 레벨에서 사용한다.

```java
// 인증이 필요한 엔드포인트
@Operation(summary = "상품 등록",
           security = @SecurityRequirement(name = "bearerAuth"))
@PostMapping
public Mono<ProductResponse> createProduct(@Valid @RequestBody ProductCreateRequest req) {
    return productService.create(req);
}

// 인증이 필요 없는 엔드포인트 (전역 보안 설정 무시)
@Operation(summary = "상품 목록 조회", security = {})
@GetMapping
public Flux<ProductResponse> getAllProducts() {
    return productService.findAll();
}
```

### 17.2.4 그룹(Group)별 문서 분리

대규모 프로젝트에서는 API를 도메인별로 그룹화하여 별도의 문서로 분리한다.

```java
@Configuration
public class OpenApiGroupConfig {

    @Bean
    public GroupedOpenApi productApi() {
        return GroupedOpenApi.builder()
            .group("product-api").displayName("상품 API")
            .pathsToMatch("/api/v1/products/**")
            .build();
    }

    @Bean
    public GroupedOpenApi orderApi() {
        return GroupedOpenApi.builder()
            .group("order-api").displayName("주문 API")
            .pathsToMatch("/api/v1/orders/**")
            .build();
    }
}
```

Swagger UI 상단의 드롭다운에서 그룹을 선택하면 해당 그룹의 API만 표시된다.

---

## 17.3 API 버전 관리 전략

### 17.3.1 왜 API 버전 관리가 필요한가?

API는 한번 공개되면 소비자가 존재한다. 기존 소비자의 코드를 깨뜨리지 않으면서 새로운 기능을 추가하거나 구조를 변경해야 하는 상황이 반드시 발생한다. 체계적인 버전 관리 전략이 없으면 기존 클라이언트가 예기치 않게 동작을 멈추고, 어떤 필드가 언제 변경되었는지 추적이 불가능해진다.

### 17.3.2 URL 경로 기반 버전 관리

가장 직관적이고 널리 사용되는 방식이다. URL 경로에 버전 번호를 포함한다.

```java
@RestController
@RequestMapping("/api/v1/products")
@Tag(name = "상품 V1")
public class ProductV1Controller {

    private final ProductService productService;

    public ProductV1Controller(ProductService productService) {
        this.productService = productService;
    }

    @GetMapping("/{id}")
    public Mono<ProductV1Response> getProduct(@PathVariable String id) {
        return productService.findById(id).map(ProductV1Response::from);
    }
}

@RestController
@RequestMapping("/api/v2/products")
@Tag(name = "상품 V2", description = "카테고리 구조 변경")
public class ProductV2Controller {

    private final ProductService productService;

    public ProductV2Controller(ProductService productService) {
        this.productService = productService;
    }

    @GetMapping("/{id}")
    public Mono<ProductV2Response> getProduct(@PathVariable String id) {
        return productService.findById(id).map(ProductV2Response::from);
    }
}
```

버전별 응답 DTO를 분리하여 관리한다.

```java
// V1: 카테고리를 단일 문자열로 표현
public record ProductV1Response(String id, String name, int price, String category) {
    public static ProductV1Response from(Product p) {
        return new ProductV1Response(p.getId(), p.getName(), p.getPrice(),
            p.getCategory().name());
    }
}

// V2: 카테고리를 계층 구조 객체로 표현
public record ProductV2Response(String id, String name, int price,
                                CategoryInfo category, List<String> tags) {
    public record CategoryInfo(String code, String displayName, String parentCode) {}

    public static ProductV2Response from(Product p) {
        return new ProductV2Response(p.getId(), p.getName(), p.getPrice(),
            new CategoryInfo(p.getCategory().name(),
                p.getCategory().getDisplayName(),
                p.getCategory().getParentCode()),
            p.getTags());
    }
}
```

| 장점 | 단점 |
|------|------|
| 직관적이고 이해하기 쉬움 | 컨트롤러가 버전만큼 증가 |
| URL만 보면 버전 파악 가능 | 공통 로직 중복 가능성 |
| 캐싱, 라우팅, 로깅에서 구분 용이 | URL이 길어짐 |

### 17.3.3 헤더 기반 버전 관리

URL을 깨끗하게 유지하면서 커스텀 헤더로 버전을 지정하는 방식이다.

```
GET /api/products
X-API-Version: 2
```

```java
@RestController
@RequestMapping("/api/products")
public class ProductController {

    private final ProductService productService;

    public ProductController(ProductService productService) {
        this.productService = productService;
    }

    @Operation(summary = "상품 조회",
        parameters = @Parameter(name = "X-API-Version", in = ParameterIn.HEADER,
            description = "API 버전", required = false,
            schema = @Schema(type = "integer", defaultValue = "1")))
    @GetMapping("/{id}")
    public Mono<?> getProduct(
            @PathVariable String id,
            @RequestHeader(value = "X-API-Version", defaultValue = "1") int version) {
        return productService.findById(id)
            .map(product -> switch (version) {
                case 2 -> ProductV2Response.from(product);
                default -> ProductV1Response.from(product);
            });
    }
}
```

| 장점 | 단점 |
|------|------|
| URL이 깔끔하게 유지됨 | 브라우저에서 직접 테스트 어려움 |
| 동일 리소스에 대한 단일 URL | 캐싱 설정 복잡 (Vary 헤더 필요) |
| 컨트롤러 중복 감소 | 문서화 시 헤더 명시 필요 |

### 17.3.4 미디어 타입(Content Negotiation) 기반 버전 관리

`Accept` 헤더에 버전 정보를 포함하는 방식이다. GitHub API가 대표적으로 이 방식을 사용한다.

```java
@RestController
@RequestMapping("/api/products")
public class ProductController {

    private final ProductService productService;

    public ProductController(ProductService productService) {
        this.productService = productService;
    }

    @GetMapping(value = "/{id}", produces = "application/vnd.example.v1+json")
    @Operation(summary = "상품 조회 (V1)")
    public Mono<ProductV1Response> getProductV1(@PathVariable String id) {
        return productService.findById(id).map(ProductV1Response::from);
    }

    @GetMapping(value = "/{id}", produces = "application/vnd.example.v2+json")
    @Operation(summary = "상품 조회 (V2)")
    public Mono<ProductV2Response> getProductV2(@PathVariable String id) {
        return productService.findById(id).map(ProductV2Response::from);
    }
}
```

커스텀 미디어 타입을 Spring이 JSON으로 처리하도록 `WebFluxConfigurer`의 `configureHttpMessageCodecs`에서 `Jackson2JsonEncoder`와 `Jackson2JsonDecoder`에 해당 미디어 타입을 등록해야 한다.

| 장점 | 단점 |
|------|------|
| RESTful 원칙에 가장 부합 | 구현 복잡도 높음 |
| URL과 헤더 모두 깨끗 | 클라이언트가 Accept 헤더를 올바르게 설정해야 함 |
| HTTP 콘텐츠 협상 표준 활용 | 코덱 설정 필요 |

### 17.3.5 하위 호환성 유지 전략

버전 관리 방식과 관계없이, **하위 호환성(Backward Compatibility)**을 최대한 유지하는 것이 가장 좋은 전략이다. 새 버전을 만드는 것은 최후의 수단으로 남겨두어야 한다.

**하위 호환이 유지되는 변경 (Non-Breaking)**

| 변경 유형 | 예시 |
|----------|------|
| 응답 필드 추가 | `tags` 필드 추가 (기존 클라이언트는 무시) |
| 선택적 요청 파라미터 추가 | `?sortBy=name` (기존 요청에 영향 없음) |
| 새 엔드포인트 추가 | `POST /api/v1/products/bulk` |

**하위 호환이 깨지는 변경 (Breaking)**

| 변경 유형 | 예시 |
|----------|------|
| 응답 필드 제거/타입 변경 | `price: int` -> `price: object` |
| 필수 파라미터 추가 | `?category` 필수로 변경 |
| URL 구조 변경 | `/products/{id}` -> `/items/{id}` |

**Deprecation 정책 구현**

API 필드나 엔드포인트를 제거할 때는 충분한 유예 기간을 두고 사전 고지한다.

```java
@GetMapping("/{id}")
public Mono<ResponseEntity<ProductV1Response>> getProductV1(@PathVariable String id) {
    return productService.findById(id)
        .map(ProductV1Response::from)
        .map(response -> ResponseEntity.ok()
            .header("Deprecation", "true")
            .header("Sunset", "2026-06-01T00:00:00Z")
            .header("Link", "</api/v2/products>; rel=\"successor-version\"")
            .body(response));
}
```

### 17.3.6 버전 관리 전략 비교 및 권장사항

| 기준 | URL 경로 | 헤더 | 미디어 타입 |
|------|---------|------|-----------|
| **구현 난이도** | 쉬움 | 보통 | 어려움 |
| **직관성** | 높음 | 낮음 | 낮음 |
| **RESTful 준수** | 보통 | 보통 | 높음 |
| **캐싱 용이성** | 높음 | 낮음 | 보통 |
| **대표 사용 사례** | Stripe, Twitter | Azure | GitHub |

**실전 권장 가이드라인**

1. **URL 경로 기반을 기본으로 사용한다.** 가장 직관적이고, 디버깅과 모니터링이 쉽다.
2. **하위 호환 변경은 버전을 올리지 않는다.** 필드 추가, 선택 파라미터 추가 등은 기존 버전에 적용한다.
3. **Breaking Change가 불가피할 때만 새 버전을 생성한다.**
4. **이전 버전은 최소 6개월 이상 유지한다.** Sunset 헤더로 종료 일자를 사전 고지한다.
5. **동시에 유지하는 버전은 최대 2개로 제한한다.** 3개 이상은 유지보수 비용이 기하급수적으로 증가한다.

---

## 17.4 정리

이번 장에서 다룬 핵심 내용을 요약한다.

| 주제 | 핵심 내용 |
|------|----------|
| **SpringDoc 연동** | `springdoc-openapi-starter-webflux-ui` 의존성 추가만으로 자동 문서 생성 |
| **어노테이션 활용** | `@Operation`, `@Parameter`, `@ApiResponse`, `@Schema`로 상세 문서화 |
| **리액티브 타입** | `Mono`/`Flux`를 자동 인식하여 내부 타입 기준으로 스키마 생성 |
| **RouterFunction** | `@RouterOperation` 또는 `OpenApiCustomizer`로 문서화 |
| **SecurityScheme** | JWT Bearer 인증을 Swagger UI에서 테스트 가능하도록 설정 |
| **버전 관리** | URL 경로 기반이 가장 실용적, 하위 호환성 유지가 최우선 |

API 문서화와 버전 관리는 기술적 완성도보다 **개발 조직의 규율과 일관성**이 더 중요한 영역이다. 도구가 아무리 좋아도 팀 전체가 문서화 원칙을 지키지 않으면 무용지물이다. 다음 장에서는 프로덕션 환경에서 애플리케이션의 상태를 모니터링하고 관찰하기 위한 **Observability** 전략을 다룬다.
