# Chapter 11. 리액티브 보안 (Spring Security WebFlux)

Spring WebFlux로 API 서버를 구축할 때 보안 구현 방식은 기존 서블릿 기반 Spring Security와 상당히 다르다. ThreadLocal이 작동하지 않고, 비동기 논블로킹 특성을 고려해야 하기 때문이다. 이 장에서는 WebFlux 환경에 맞춘 Spring Security 설정부터 시작해서 인증/인가, JWT 토큰 기반 인증, SecurityContext 다루기, 그리고 OAuth2 통합까지 단계적으로 살펴볼 것이다.

---

## 11.1 Spring Security Reactive 설정

### 11.1.1 의존성 추가

먼저 `build.gradle`에 필요한 Spring Security 의존성들을 넣어야 한다.

```groovy
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-data-mongodb-reactive'

    // JWT (11.4절), OAuth2 (11.6절)
    implementation 'io.jsonwebtoken:jjwt-api:0.12.6'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.12.6'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.12.6'
    implementation 'org.springframework.boot:spring-boot-starter-oauth2-client'
    implementation 'org.springframework.boot:spring-boot-starter-oauth2-resource-server'

    testImplementation 'org.springframework.security:spring-security-test'
}
```

재미있는 점은 이 의존성들을 추가하는 것만으로 자동으로 Spring Security가 활성화된다는 것이다. 모든 엔드포인트가 기본 인증으로 보호되기 시작한다.

### 11.1.2 서블릿 기반과의 차이

| 구분 | Servlet (Spring MVC) | Reactive (Spring WebFlux) |
|------|---------------------|--------------------------|
| **필터 체인** | `SecurityFilterChain` | `SecurityWebFilterChain` (`WebFilter`) |
| **설정 빌더** | `HttpSecurity` | `ServerHttpSecurity` |
| **인증 저장소** | `SecurityContextHolder` (ThreadLocal) | `ReactiveSecurityContextHolder` (Reactor Context) |
| **UserDetailsService** | `UserDetailsService` | `ReactiveUserDetailsService` |
| **인증 매니저** | `AuthenticationManager` | `ReactiveAuthenticationManager` |
| **메서드 보안** | `@EnableMethodSecurity` | `@EnableReactiveMethodSecurity` |

가장 크리티컬한 차이는 **인증 정보를 어디에 저장하는가** 하는 문제다. 전통적인 서블릿 환경에서는 `ThreadLocal`을 이용하는데, 리액티브는 한 요청이 여러 스레드를 타고 처리되므로 이 방식이 작동하지 않는다. 대신 **Reactor의 Context** 메커니즘을 활용해야 한다.

### 11.1.3 기본 보안 설정 클래스

이제 실제로 보안을 구성해 보자. `@EnableWebFluxSecurity` 어노테이션으로 리액티브 보안을 켜고 `SecurityWebFilterChain` 빈을 정의하면 된다.

```java
@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        return http
            .authorizeExchange(exchanges -> exchanges
                .anyExchange().authenticated()
            )
            .httpBasic(Customizer.withDefaults())
            .formLogin(Customizer.withDefaults())
            .build();
    }
}
```

`Customizer.withDefaults()`는 Spring Security 6.1 이상에서 권장되는 설정 패턴이다.

---

## 11.2 SecurityWebFilterChain 구성

### 11.2.1 ServerHttpSecurity 주요 설정

`ServerHttpSecurity`라는 빌더를 통해 리액티브 보안을 상세하게 설정한다. 어떤 경로를 누구에게 열어줄지, CORS는 어떻게 할지 등을 여기서 결정한다.

```java
@Bean
public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
    return http
        .authorizeExchange(exchanges -> exchanges
            .pathMatchers(HttpMethod.GET, "/api/products/**").permitAll()
            .pathMatchers(HttpMethod.POST, "/api/products/**").hasRole("ADMIN")
            .pathMatchers("/api/admin/**").hasRole("ADMIN")
            .pathMatchers("/api/users/signup", "/api/users/login").permitAll()
            .anyExchange().authenticated()
        )
        .httpBasic(Customizer.withDefaults())
        .csrf(csrf -> csrf.disable())
        .cors(cors -> cors.configurationSource(corsConfigurationSource()))
        .formLogin(formLogin -> formLogin.disable())
        .build();
}
```

### 11.2.2 authorizeExchange 상세 설정

`authorizeExchange` 내에서 쓸 수 있는 여러 매처와 권한 검증 규칙들을 정리해 보면 다음과 같다.

```java
.authorizeExchange(exchanges -> exchanges
    // HTTP 메서드 + 경로 조합
    .pathMatchers(HttpMethod.GET, "/api/products/**").permitAll()
    .pathMatchers(HttpMethod.DELETE, "/api/**").hasRole("ADMIN")

    // 역할/권한 기반 인가
    .pathMatchers("/api/manager/**").hasAnyRole("ADMIN", "MANAGER")
    .pathMatchers("/api/reports/**").hasAuthority("REPORT_READ")

    // 커스텀 인가 로직
    .pathMatchers("/api/users/{userId}/**")
        .access((authentication, context) -> {
            String userId = context.getVariables().get("userId");
            return authentication
                .map(auth -> auth.getName().equals(userId))
                .map(AuthorizationDecision::new);
        })

    .anyExchange().authenticated()
)
```

### 11.2.3 CSRF와 CORS 설정

API 서버를 만들 때는 보통 CSRF를 꺼둔다. 쿠키 기반 토큰이 필요하지 않기 때문이다. 다만 SPA 같은 브라우저 기반 애플리케이션이라면 쿠키에 저장된 CSRF 토큰을 검증해야 한다.

```java
// REST API: CSRF 비활성화
.csrf(csrf -> csrf.disable())

// 브라우저 기반: 쿠키 CSRF 토큰
.csrf(csrf -> csrf
    .csrfTokenRepository(CookieServerCsrfTokenRepository.withHttpOnlyFalse()))
```

CORS 정책은 `CorsConfigurationSource` 빈을 통해 설정하는 것이 일반적이다.

```java
@Bean
public CorsConfigurationSource corsConfigurationSource() {
    CorsConfiguration config = new CorsConfiguration();
    config.setAllowedOrigins(List.of("http://localhost:3000"));
    config.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
    config.setAllowedHeaders(List.of("*"));
    config.setAllowCredentials(true);

    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/api/**", config);
    return source;
}
```

---

## 11.3 인증과 인가 구현

### 11.3.1 ReactiveUserDetailsService

리액티브 환경에서는 당연히 `ReactiveUserDetailsService`를 사용해야 한다. 비동기로 사용자 정보를 조회해서 `Mono<UserDetails>`로 반환하는 방식이다. 먼저 사용자 도메인과 MongoDB 리포지토리를 먼저 만들어 보자.

```java
@Document(collection = "users")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User {
    @Id
    private String id;
    private String username;
    private String password;
    private String email;
    private List<String> roles;
    private boolean enabled;
    private LocalDateTime createdAt;
}
```

```java
public interface UserRepository extends ReactiveMongoRepository<User, String> {
    Mono<User> findByUsername(String username);
    Mono<Boolean> existsByUsername(String username);
}
```

이제 MongoDB에서 사용자를 조회하는 `ReactiveUserDetailsService`를 구현해 보자.

```java
@Service
@RequiredArgsConstructor
public class MongoUserDetailsService implements ReactiveUserDetailsService {

    private final UserRepository userRepository;

    @Override
    public Mono<UserDetails> findByUsername(String username) {
        return userRepository.findByUsername(username)
            .map(user -> org.springframework.security.core.userdetails.User.builder()
                .username(user.getUsername())
                .password(user.getPassword())
                .roles(user.getRoles().toArray(new String[0]))
                .disabled(!user.isEnabled())
                .build()
            )
            .switchIfEmpty(Mono.error(
                new UsernameNotFoundException("사용자를 찾을 수 없습니다: " + username)
            ));
    }
}
```

### 11.3.2 PasswordEncoder와 회원가입

비밀번호는 절대 평문으로 저장하면 안 되고, BCrypt 같은 해시 알고리즘으로 암호화해서 저장해야 한다.

```java
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}
```

```java
@Service
@RequiredArgsConstructor
public class UserService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    public Mono<User> signup(SignupRequest request) {
        return userRepository.existsByUsername(request.getUsername())
            .flatMap(exists -> {
                if (exists) {
                    return Mono.error(new DuplicateException("이미 사용 중인 사용자명입니다."));
                }
                User user = User.builder()
                    .username(request.getUsername())
                    .password(passwordEncoder.encode(request.getPassword()))
                    .email(request.getEmail())
                    .roles(List.of("USER"))
                    .enabled(true)
                    .createdAt(LocalDateTime.now())
                    .build();
                return userRepository.save(user);
            });
    }
}
```

### 11.3.3 @PreAuthorize 메서드 보안

`@EnableReactiveMethodSecurity`를 켜면 서비스 메서드 단위에서 세분화된 권한 검증을 할 수 있다. 이건 정말 유용한 기능이다.

```java
@Configuration
@EnableWebFluxSecurity
@EnableReactiveMethodSecurity
public class SecurityConfig {
    // SecurityWebFilterChain 빈 정의
}
```

```java
@Service
@RequiredArgsConstructor
public class ProductService {

    private final ProductRepository productRepository;

    @PreAuthorize("hasRole('ADMIN')")
    public Mono<Product> create(Product product) {
        product.setCreatedAt(LocalDateTime.now());
        return productRepository.save(product);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
    public Mono<Product> update(String id, Product product) {
        return productRepository.findById(id)
            .map(existing -> {
                existing.setName(product.getName());
                existing.setPrice(product.getPrice());
                existing.setUpdatedAt(LocalDateTime.now());
                return existing;
            })
            .flatMap(productRepository::save);
    }

    // 현재 사용자 본인의 데이터만 조회 허용
    @PreAuthorize("#username == authentication.name or hasRole('ADMIN')")
    public Mono<User> findByUsername(String username) {
        return userRepository.findByUsername(username);
    }
}
```

필자의 경험상 리액티브 환경에서도 `@PreAuthorize`는 `Mono`/`Flux` 반환 타입을 문제없이 처리한다. 권한이 없으면 `AccessDeniedException`이 던져지는데, 이를 적절히 핸들링해야 한다.

---

## 11.4 JWT 기반 인증 구현

요즘 REST API 서버에서는 세션을 쓰지 않고 JWT(JSON Web Token)로 무상태 인증을 한다. JWT는 Header(헤더-알고리즘/타입), Payload(페이로드-클레임), Signature(서명) 이렇게 세 부분으로 나뉜다. 이 방식은 확장성이 좋고, 마이크로서비스 환경에 잘 맞는다.

### 11.4.1 JWT 유틸리티 클래스

jjwt 라이브러리는 JWT를 쉽게 다루기 위한 라이브러리인데, 이걸 활용해서 토큰을 생성하고 검증하고 파싱하는 유틸리티를 만들어 보자.

```java
@Component
public class JwtTokenProvider {

    @Value("${jwt.secret}")
    private String secretKey;

    @Value("${jwt.access-token-expiration}")
    private long accessTokenExpiration;

    @Value("${jwt.refresh-token-expiration}")
    private long refreshTokenExpiration;

    private SecretKey key;

    @PostConstruct
    public void init() {
        this.key = Keys.hmacShaKeyFor(Decoders.BASE64.decode(secretKey));
    }

    public String generateAccessToken(UserDetails userDetails) {
        Map<String, Object> claims = Map.of("roles",
            userDetails.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority).toList());
        return createToken(claims, userDetails.getUsername(), accessTokenExpiration);
    }

    public String generateRefreshToken(UserDetails userDetails) {
        return createToken(Map.of(), userDetails.getUsername(), refreshTokenExpiration);
    }

    private String createToken(Map<String, Object> claims, String subject,
                               long expiration) {
        Date now = new Date();
        return Jwts.builder()
            .claims(claims).subject(subject).issuedAt(now)
            .expiration(new Date(now.getTime() + expiration))
            .signWith(key).compact();
    }

    public String getUsernameFromToken(String token) {
        return getClaims(token).getSubject();
    }

    @SuppressWarnings("unchecked")
    public List<String> getRolesFromToken(String token) {
        return getClaims(token).get("roles", List.class);
    }

    public boolean validateToken(String token) {
        try { getClaims(token); return true; }
        catch (JwtException | IllegalArgumentException e) { return false; }
    }

    private Claims getClaims(String token) {
        return Jwts.parser().verifyWith(key).build()
            .parseSignedClaims(token).getPayload();
    }
}
```

`application.yml` 설정을 추가한다.

```yaml
jwt:
  secret: "dGhpcyBpcyBhIHZlcnkgbG9uZyBzZWNyZXQga2V5IGZvciBIUzI1NiBhbGdvcml0aG0="
  access-token-expiration: 3600000     # 1시간
  refresh-token-expiration: 604800000  # 7일
```

### 11.4.2 JWT 인증 필터

Authorization 헤더에서 JWT를 추출해서 검증하고 `Authentication` 객체로 변환하는 컨버터와 매니저를 만들어야 한다.

```java
@Component
@RequiredArgsConstructor
public class JwtAuthenticationConverter implements ServerAuthenticationConverter {

    private final JwtTokenProvider jwtTokenProvider;

    @Override
    public Mono<Authentication> convert(ServerWebExchange exchange) {
        return Mono.justOrEmpty(
                exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION))
            .filter(header -> header.startsWith("Bearer "))
            .map(header -> header.substring(7))
            .filter(jwtTokenProvider::validateToken)
            .map(token -> {
                String username = jwtTokenProvider.getUsernameFromToken(token);
                List<GrantedAuthority> authorities = jwtTokenProvider
                    .getRolesFromToken(token).stream()
                    .map(SimpleGrantedAuthority::new)
                    .collect(Collectors.toList());
                return new UsernamePasswordAuthenticationToken(
                    username, null, authorities);
            });
    }
}
```

```java
@Component
@RequiredArgsConstructor
public class JwtReactiveAuthenticationManager implements ReactiveAuthenticationManager {

    private final ReactiveUserDetailsService userDetailsService;

    @Override
    public Mono<Authentication> authenticate(Authentication authentication) {
        return userDetailsService.findByUsername(authentication.getName())
            .map(userDetails -> new UsernamePasswordAuthenticationToken(
                userDetails, null, authentication.getAuthorities()));
    }
}
```

### 11.4.3 JWT SecurityWebFilterChain 구성

위에서 만든 컨버터와 매니저를 사용해서 JWT 기반의 완전한 보안 설정을 구성해 보자.

```java
@Configuration
@EnableWebFluxSecurity
@EnableReactiveMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtReactiveAuthenticationManager authenticationManager;
    private final JwtAuthenticationConverter authenticationConverter;

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        AuthenticationWebFilter jwtFilter =
            new AuthenticationWebFilter(authenticationManager);
        jwtFilter.setServerAuthenticationConverter(authenticationConverter);

        return http
            .authorizeExchange(exchanges -> exchanges
                .pathMatchers("/api/auth/**").permitAll()
                .pathMatchers(HttpMethod.GET, "/api/products/**").permitAll()
                .pathMatchers("/api/admin/**").hasRole("ADMIN")
                .anyExchange().authenticated()
            )
            .addFilterAt(jwtFilter, SecurityWebFiltersOrder.AUTHENTICATION)
            .httpBasic(httpBasic -> httpBasic.disable())
            .formLogin(formLogin -> formLogin.disable())
            .csrf(csrf -> csrf.disable())
            .exceptionHandling(ex -> ex
                .authenticationEntryPoint((exchange, e) -> Mono.fromRunnable(
                    () -> exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED)))
                .accessDeniedHandler((exchange, denied) -> Mono.fromRunnable(
                    () -> exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN)))
            )
            .securityContextRepository(NoOpServerSecurityContextRepository.getInstance())
            .build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

`NoOpServerSecurityContextRepository`를 설정하면 서버에서 세션을 전혀 생성하지 않는 완전한 stateless 구조가 완성된다.

### 11.4.4 인증 컨트롤러

이제 클라이언트가 회원가입하고 로그인하고 토큰을 갱신할 수 있도록 엔드포인트들을 만들어 보자.

```java
@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {

    private final UserService userService;
    private final ReactiveUserDetailsService userDetailsService;
    private final PasswordEncoder passwordEncoder;
    private final JwtTokenProvider jwtTokenProvider;

    @PostMapping("/signup")
    @ResponseStatus(HttpStatus.CREATED)
    public Mono<UserResponse> signup(@Valid @RequestBody SignupRequest request) {
        return userService.signup(request).map(UserResponse::from);
    }

    @PostMapping("/login")
    public Mono<TokenResponse> login(@Valid @RequestBody LoginRequest request) {
        return userDetailsService.findByUsername(request.getUsername())
            .filter(ud -> passwordEncoder.matches(
                request.getPassword(), ud.getPassword()))
            .map(ud -> new TokenResponse(
                jwtTokenProvider.generateAccessToken(ud),
                jwtTokenProvider.generateRefreshToken(ud)))
            .switchIfEmpty(Mono.error(
                new BadCredentialsException("잘못된 사용자명 또는 비밀번호입니다.")));
    }

    @PostMapping("/refresh")
    public Mono<TokenResponse> refresh(@RequestBody RefreshTokenRequest request) {
        String refreshToken = request.getRefreshToken();
        if (!jwtTokenProvider.validateToken(refreshToken)) {
            return Mono.error(
                new BadCredentialsException("유효하지 않은 리프레시 토큰입니다."));
        }
        String username = jwtTokenProvider.getUsernameFromToken(refreshToken);
        return userDetailsService.findByUsername(username)
            .map(ud -> new TokenResponse(
                jwtTokenProvider.generateAccessToken(ud), refreshToken));
    }
}
```

컨트롤러에서 사용할 요청/응답 DTO도 정의해야 한다.

```java
@Data
public class LoginRequest {
    @NotBlank private String username;
    @NotBlank private String password;
}

@Data
public class RefreshTokenRequest {
    @NotBlank private String refreshToken;
}

@Data
@AllArgsConstructor
public class TokenResponse {
    private String accessToken;
    private String refreshToken;
}
```

### 11.4.5 전체 인증 흐름

JWT 기반 인증이 어떻게 흘러가는지 정리하면 다음과 같다.

1. **회원가입**: `POST /api/auth/signup` — 입력받은 비밀번호를 BCrypt로 인코딩해서 MongoDB에 저장
2. **로그인**: `POST /api/auth/login` — 사용자명과 비밀번호를 검증하면 Access Token과 Refresh Token을 발급
3. **인증된 API 호출**: `Authorization: Bearer <accessToken>` 헤더를 붙여서 요청 — `JwtAuthenticationConverter`가 토큰을 추출하고 검증한 뒤 `Authentication` 객체 생성
4. **토큰 갱신**: `POST /api/auth/refresh` — Refresh Token이 유효하면 새로운 Access Token을 발급

---

## 11.5 리액티브 환경에서의 SecurityContext 관리

### 11.5.1 ReactiveSecurityContextHolder

서블릿 환경의 `SecurityContextHolder.getContext()`는 ThreadLocal 기반인데, 리액티브 환경에서는 이걸 쓰면 안 된다.

```java
// 리액티브 환경에서의 올바른 방식
Mono<String> username = ReactiveSecurityContextHolder.getContext()
    .map(SecurityContext::getAuthentication)
    .map(Authentication::getName);
```

### 11.5.2 현재 사용자 정보 가져오기

서비스 계층에서 현재 로그인한 사용자 정보를 어떻게 가져오는지 살펴보자.

```java
@Service
@RequiredArgsConstructor
public class OrderService {

    private final OrderRepository orderRepository;

    public Flux<Order> getMyOrders() {
        return ReactiveSecurityContextHolder.getContext()
            .map(ctx -> ctx.getAuthentication().getName())
            .flatMapMany(orderRepository::findByUsername);
    }

    public Mono<Order> createOrder(OrderRequest request) {
        return ReactiveSecurityContextHolder.getContext()
            .map(ctx -> ctx.getAuthentication().getName())
            .flatMap(username -> {
                Order order = Order.builder()
                    .username(username)
                    .items(request.getItems())
                    .totalAmount(request.getTotalAmount())
                    .createdAt(LocalDateTime.now())
                    .build();
                return orderRepository.save(order);
            });
    }
}
```

### 11.5.3 컨트롤러에서 인증 정보 접근

컨트롤러의 핸들러 메서드에서는 `@AuthenticationPrincipal`이나 `Mono<Principal>`을 주입받는 방식이 더 편하다.

```java
@GetMapping("/me")
public Mono<UserResponse> getMyProfile(
        @AuthenticationPrincipal Mono<UserDetails> principal) {
    return principal
        .flatMap(user -> userService.findByUsername(user.getUsername()))
        .map(UserResponse::from);
}

@GetMapping("/me/orders")
public Flux<Order> getMyOrders(Mono<Principal> principal) {
    return principal.map(Principal::getName)
        .flatMapMany(orderService::findByUsername);
}
```

### 11.5.4 SecurityContext 주의사항

`ReactiveSecurityContextHolder.getContext()`의 반환값은 반드시 리액티브 체인 내부에서 `map`/`flatMap`으로 계속 연결해야 한다. Reactor의 Context는 구독할 때 전파되는데, 체인이 끊기면 SecurityContext를 더 이상 읽을 수 없기 때문이다. 필자의 경험상 이것 때문에 생기는 버그가 많다.

```java
// 잘못된 사용: context를 구독하지 않으므로 SecurityContext 접근 불가
Mono<SecurityContext> context = ReactiveSecurityContextHolder.getContext();
return orderRepository.save(order);

// 올바른 사용: 체인 내부에서 연결
return ReactiveSecurityContextHolder.getContext()
    .map(ctx -> ctx.getAuthentication().getName())
    .flatMap(username -> orderRepository.save(buildOrder(request, username)));
```

---

## 11.6 OAuth2 / OpenID Connect 연동

### 11.6.1 OAuth2 Login 설정

구글이나 깃허브 같은 소셜 로그인을 지원하려면 `application.yml`에 OAuth2 클라이언트 정보를 등록해야 한다.

```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: ${GOOGLE_CLIENT_ID}
            client-secret: ${GOOGLE_CLIENT_SECRET}
            scope: openid, profile, email
          github:
            client-id: ${GITHUB_CLIENT_ID}
            client-secret: ${GITHUB_CLIENT_SECRET}
            scope: read:user, user:email
        provider:
          github:
            user-name-attribute: login
```

구글은 OpenID Connect를 지원해서 provider 설정이 자동으로 적용되지만, 깃허브는 `user-name-attribute`를 직접 지정해 줘야 한다.

### 11.6.2 OAuth2 SecurityWebFilterChain 설정

OAuth2 로그인을 활성화하는 보안 설정은 매우 간단하다.

```java
@Configuration
@EnableWebFluxSecurity
public class OAuth2SecurityConfig {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        return http
            .authorizeExchange(exchanges -> exchanges
                .pathMatchers("/", "/login/**", "/oauth2/**").permitAll()
                .anyExchange().authenticated()
            )
            .oauth2Login(Customizer.withDefaults())
            .csrf(csrf -> csrf.disable())
            .build();
    }
}
```

`oauth2Login(Customizer.withDefaults())`라는 한 줄의 설정만으로 `/oauth2/authorization/{registrationId}` 엔드포인트와 리다이렉트 콜백이 자동으로 준비된다. 정말 편하다.

### 11.6.3 OAuth2 사용자 정보 커스터마이징

소셜 로그인이 성공한 후에 사용자 정보를 우리 MongoDB에 저장하고 싶다면 `ReactiveOAuth2UserService`를 커스터마이징해야 한다.

```java
@Service
@RequiredArgsConstructor
public class CustomOAuth2UserService
        implements ReactiveOAuth2UserService<OidcUserRequest, OidcUser> {

    private final UserRepository userRepository;
    private final ReactiveOidcUserService delegate = new ReactiveOidcUserService();

    @Override
    public Mono<OidcUser> loadUser(OidcUserRequest userRequest) {
        return delegate.loadUser(userRequest)
            .flatMap(oidcUser -> {
                String email = oidcUser.getEmail();
                String provider = userRequest.getClientRegistration()
                    .getRegistrationId();
                return userRepository.findByEmail(email)
                    .switchIfEmpty(createOAuth2User(email, oidcUser.getFullName(),
                                                     provider))
                    .thenReturn(oidcUser);
            });
    }

    private Mono<User> createOAuth2User(String email, String name, String provider) {
        User user = User.builder()
            .username(email).email(email).password("")
            .roles(List.of("USER")).enabled(true)
            .createdAt(LocalDateTime.now()).build();
        return userRepository.save(user);
    }
}
```

### 11.6.4 Resource Server 설정

Keycloak이나 Auth0 같은 외부 인증 서버에서 발급받은 JWT를 검증해야 하는 경우가 있다. 이 경우 우리 애플리케이션은 Resource Server가 되는데, 그 설정 방법을 살펴보자.

```yaml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://auth.example.com/realms/my-realm
```

```java
@Configuration
@EnableWebFluxSecurity
public class ResourceServerConfig {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        return http
            .authorizeExchange(exchanges -> exchanges
                .pathMatchers(HttpMethod.GET, "/api/products/**").permitAll()
                .pathMatchers("/api/admin/**").hasAuthority("SCOPE_admin")
                .anyExchange().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2.jwt(Customizer.withDefaults()))
            .csrf(csrf -> csrf.disable())
            .build();
    }

    @Bean
    public ReactiveJwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter =
            new JwtGrantedAuthoritiesConverter();
        grantedAuthoritiesConverter.setAuthorityPrefix("ROLE_");
        grantedAuthoritiesConverter.setAuthoritiesClaimName("roles");

        ReactiveJwtAuthenticationConverter converter =
            new ReactiveJwtAuthenticationConverter();
        converter.setJwtGrantedAuthoritiesConverter(
            new ReactiveJwtGrantedAuthoritiesConverterAdapter(
                grantedAuthoritiesConverter));
        return converter;
    }
}
```

### 11.6.5 JWT와 OAuth2의 선택 기준

| 시나리오 | 권장 방식 |
|----------|----------|
| 단순한 단일 애플리케이션, 자체 인증 처리 | JWT 자체 발급 (11.4절) |
| 마이크로서비스 아키텍처, 중앙 인증 서버 | OAuth2 Resource Server |
| 구글/깃허브 같은 소셜 로그인 필요 | OAuth2 Login |
| SPA와 API 서버 분리 | JWT 자체 발급 또는 OAuth2 + PKCE |

---

## 요약

이 장에서 배운 내용의 핵심을 정리하면 다음과 같다.

| 주제 | 핵심 내용 |
|------|----------|
| **리액티브 보안 설정** | `@EnableWebFluxSecurity`와 `SecurityWebFilterChain`으로 WebFlux 보안 활성화, ThreadLocal 대신 Reactor Context 사용 |
| **경로별 인가 설정** | `ServerHttpSecurity`의 `authorizeExchange`로 세분화된 접근 제어, CSRF/CORS 설정 |
| **인증과 인가** | `ReactiveUserDetailsService` 구현, BCrypt 해싱, `@PreAuthorize` 메서드 보안 |
| **JWT 기반 인증** | `JwtTokenProvider`로 토큰 생성/검증, `AuthenticationWebFilter` 통합, 완전한 stateless 구조 |
| **현재 사용자 정보** | `ReactiveSecurityContextHolder`로 인증 정보 조회, 리액티브 체인 내부에서 map/flatMap 연결 필수 |
| **OAuth2 지원** | OAuth2 Login으로 소셜 로그인, Resource Server로 외부 JWT 검증, 사용자 정보 자동 저장 |

다음 장에서는 Server-Sent Events(SSE)를 활용해서 클라이언트에게 실시간으로 데이터를 스트리밍하는 방법을 다룬다.
